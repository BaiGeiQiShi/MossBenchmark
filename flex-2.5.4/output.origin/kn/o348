skel
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext
	yyleng = (int) (yy_cp - yy_bp); \
#define YY_NUM_RULES 9
#define YY_END_OF_BUFFER 10
static yyconst short int yy_accept[45] =
    {   0,
        1,    1,   10,    8,    7,    7,    5,    1,    4,    4,
        4,    4,    4,    4,    4,    8,    7,    2,    1,    4,
        4,    4,    4,    3,    4,    4,    0,    6,    2,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    1,    6,    7,    8,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,   10,   11,   12,   13,

       14,   15,   16,   17,   18,   10,   10,   10,   10,   19,
       20,   21,   10,   22,   10,   23,   24,   10,   10,   10,
       10,   10,   25,    1,   26,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[27] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    1,    1
    } ;

static yyconst short int yy_base[47] =
    {   0,
        0,    0,   69,   70,   25,   27,   70,   24,    0,   54,
       48,   42,   50,   42,   46,   36,   32,   52,   29,    0,
       44,   46,   39,    0,   37,   42,   29,   70,   45,   35,
       40,   39,   31,   30,   25,   33,   28,   32,   24,   19,
       23,   18,   23,   70,   29,   38
    } ;

static yyconst short int yy_def[47] =
    {   0,
       44,    1,   44,   44,   44,   44,   44,   44,   45,   45,
       45,   45,   45,   45,   45,   46,   44,   44,   44,   45,
       45,   45,   45,   45,   45,   45,   46,   44,   44,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,    0,   44,   44
    } ;

static yyconst short int yy_nxt[97] =
    {   0,
        4,    5,    6,    7,    7,    7,    4,    7,    8,    9,
       10,    9,    9,   11,   12,    9,    9,   13,    9,    9,
       14,    9,   15,    9,   16,    4,   17,   17,   17,   17,
       18,   20,   19,   17,   17,   18,   24,   19,   27,   43,
       27,   24,   42,   41,   40,   39,   38,   37,   24,   24,
       36,   35,   34,   29,   28,   33,   32,   31,   24,   30,
       29,   28,   26,   25,   24,   23,   22,   21,   44,    3,
       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
       44,   44,   44,   44,   44,   44

    } ;

static yyconst short int yy_chk[97] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    5,    5,    6,    6,
        8,   45,    8,   17,   17,   19,   43,   19,   46,   42,
       46,   41,   40,   39,   38,   37,   36,   35,   34,   33,
       32,   31,   30,   29,   27,   26,   25,   23,   22,   21,
       18,   16,   15,   14,   13,   12,   11,   10,    3,   44,
       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
       44,   44,   44,   44,   44,   44

    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
#define INITIAL 0
/* scanner for a toy Pascal-like language */
#line 4 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
/* need this for the call to atof() below */
#include <math.h>
#line 124 "lex.yy.c"
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#define YY_RULE_SETUP \
	YY_USER_ACTION
#line 11 "/moss-script/moss/flex-2.5.4/inputfile/in.0"


#line 145 "lex.yy.c"
		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 45 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 70 );
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 13 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
{
		printf("An integer: %s (%d)\n", yytext, atoi(yytext));
		}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 17 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
{
		printf("A float: %s (%g)\n", yytext, atof(yytext));
		}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 21 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
{
		printf("A keyword: %s\n", yytext);
		}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 25 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
printf("An identifier: %s\n", yytext);
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 27 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
printf("An operator: %s\n", yytext);
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 29 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
/* eat up one-line comments */
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 31 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
/* eat up whitespace */
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 33 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
printf("Unrecognized character: %s\n", yytext);
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 35 "/moss-script/moss/flex-2.5.4/inputfile/in.0"
ECHO;
	YY_BREAK
#line 231 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();
				yy_cp = yy_c_buf_p;
	yy_current_state = yy_start;
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 45 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 45 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 44);
#line 35 "/moss-script/moss/flex-2.5.4/inputfile/in.0"


main(argc, argv)
int argc;
char **argv;
	{
	++argv, --argc;	/* skip over program name */
	if(argc > 0)
		yyin = fopen(argv[0], "r");
	else
		yyin = stdin;

	yylex();
	} 
