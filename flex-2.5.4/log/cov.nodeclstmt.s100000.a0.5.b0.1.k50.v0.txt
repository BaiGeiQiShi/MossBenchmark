Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 70107)
Iteration 2 (Word: 67767)
Iteration 3 (Word: 67716)
Iteration 1 (Word: 67716)
Oracle: ./test.sh
Input: flex-2.5.4.c
Output Directory: /moss-script/moss/flex-2.5.4/debop-out.cov.nodeclstmt.s100000.a0.5.b0.1.k50.v0
Reduce File: flex-2.5.4.c
Start reduction
Max Samples: 100000
Max Iterations: 100000000
Alpha Value: 0.500000
Beta Value: 0.100000
K Value: 50.000000
Generality Factor: 1.000000
Element Select Probability: -1.000000
Block: 0
ProgElement 0: make_tables();
ProgElement 1: flexend(0);
ProgElement 2: return (0);
Block: 1
ProgElement 3: line_warning((char *)"-s option given but default rule can be matched", *(rule_linenum + default_rule));
Block: 2
ProgElement 4: i___0 ++;
Block: 3
ProgElement 5: line_warning((char *)"rule cannot be matched", *(rule_linenum + i___0));
Block: 4
ProgElement 6: flexinit(argc, argv);
ProgElement 7: readin();
ProgElement 8: ntod();
ProgElement 9: i___0 = 1;
Block: 5
ProgElement 10: argv ++;
ProgElement 11: err = fopen((char const   * __restrict  )*argv, (char const   * __restrict  )"w");
ProgElement 12: argv --;
ProgElement 13: argc ++;
Block: 6
ProgElement 14: argc --;
Block: 7
ProgElement 15: skelout();
ProgElement 16: return;
Block: 8
ProgElement 17: line_directive_out(stdout, 0);
Block: 9
ProgElement 18: outn("");
Block: 10
ProgElement 19: out_str3("#define yy%s %s%s\n", "wrap", (char const   *)prefix, "wrap");
Block: 11
ProgElement 20: out_str3("#define yy%s %s%s\n", "_create_buffer", (char const   *)prefix, "_create_buffer");
ProgElement 21: out_str3("#define yy%s %s%s\n", "_delete_buffer", (char const   *)prefix, "_delete_buffer");
ProgElement 22: out_str3("#define yy%s %s%s\n", "_scan_buffer", (char const   *)prefix, "_scan_buffer");
ProgElement 23: out_str3("#define yy%s %s%s\n", "_scan_string", (char const   *)prefix, "_scan_string");
ProgElement 24: out_str3("#define yy%s %s%s\n", "_scan_bytes", (char const   *)prefix, "_scan_bytes");
ProgElement 25: out_str3("#define yy%s %s%s\n", "_flex_debug", (char const   *)prefix, "_flex_debug");
ProgElement 26: out_str3("#define yy%s %s%s\n", "_init_buffer", (char const   *)prefix, "_init_buffer");
ProgElement 27: out_str3("#define yy%s %s%s\n", "_flush_buffer", (char const   *)prefix, "_flush_buffer");
ProgElement 28: out_str3("#define yy%s %s%s\n", "_load_buffer_state", (char const   *)prefix,
               "_load_buffer_state");
ProgElement 29: out_str3("#define yy%s %s%s\n", "_switch_to_buffer", (char const   *)prefix,
               "_switch_to_buffer");
ProgElement 30: out_str3("#define yy%s %s%s\n", "in", (char const   *)prefix, "in");
ProgElement 31: out_str3("#define yy%s %s%s\n", "leng", (char const   *)prefix, "leng");
ProgElement 32: out_str3("#define yy%s %s%s\n", "lex", (char const   *)prefix, "lex");
ProgElement 33: out_str3("#define yy%s %s%s\n", "out", (char const   *)prefix, "out");
ProgElement 34: out_str3("#define yy%s %s%s\n", "restart", (char const   *)prefix, "restart");
ProgElement 35: out_str3("#define yy%s %s%s\n", "text", (char const   *)prefix, "text");
Block: 12
ProgElement 36: tmp = strcmp((char const   *)prefix, "yy");
Block: 13
ProgElement 37: lerrsf("can\'t open skeleton file %s", (char const   *)skelname);
Block: 14
ProgElement 38: skelfile = fopen((char const   * __restrict  )skelname, (char const   * __restrict  )"r");
Block: 15
ProgElement 39: outfile_created = 1;
Block: 16
ProgElement 40: prev_stdout = freopen((char const   * __restrict  )outfilename, (char const   * __restrict  )"w",
                          (FILE * __restrict  )stdout);
Block: 17
ProgElement 41: sprintf((char * __restrict  )(outfile_path), (char const   * __restrict  )outfile_template,
              prefix, suffix);
ProgElement 42: outfilename = outfile_path;
Block: 18
ProgElement 43: suffix = (char *)"c";
Block: 19
ProgElement 44: ecgroup[i___0] = i___0;
ProgElement 45: nextecm[i___0] = -32767;
ProgElement 46: i___0 ++;
Block: 20
ProgElement 47: i___0 = 1;
Block: 21
ProgElement 48: nextecm[csize] = 0;
Block: 22
ProgElement 49: ecgroup[i___0] = i___0 - 1;
ProgElement 50: nextecm[i___0 - 1] = i___0;
ProgElement 51: i___0 ++;
Block: 23
ProgElement 52: ecgroup[1] = 0;
ProgElement 53: i___0 = 2;
Block: 24
ProgElement 54: flexerror("-Cf and -CF are mutually exclusive");
Block: 25
ProgElement 55: flexerror("-Cf/-CF and -I are incompatible");
Block: 26
ProgElement 56: flexerror("-Cf/-CF and -Cm don\'t make sense together");
Block: 27
ProgElement 57: interactive = 1;
Block: 28
ProgElement 58: interactive = 0;
Block: 29
ProgElement 59: interactive = 0;
Block: 30
ProgElement 60: csize = 256;
Block: 31
ProgElement 61: csize = 256;
Block: 32
ProgElement 62: csize = 128;
Block: 33
ProgElement 63: reject_really_used = 1;
Block: 34
ProgElement 64: reject_really_used = 1;
ProgElement 65: yymore_really_used = reject_really_used;
ProgElement 66: yytext_is_array = 1;
ProgElement 67: do_yylineno = 1;
ProgElement 68: use_read = 0;
Block: 35
ProgElement 69: flexerror("Can\'t use -f or -F with -l option");
Block: 36
ProgElement 70: exit(exit_status);
Block: 37
ProgElement 71: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d (%d saved) hash collisions, %d DFAs equal\n",
            hshcol, hshsave, dfaeql);
ProgElement 72: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d sets of reallocations needed\n",
            num_reallocs);
ProgElement 73: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d total table entries needed\n",
            tblsiz);
Block: 38
ProgElement 74: tblsiz += numecs;
ProgElement 75: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d meta-equivalence classes created\n",
              nummecs, csize);
Block: 39
ProgElement 76: tblsiz += csize;
ProgElement 77: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d equivalence classes created\n",
              numecs, csize);
Block: 40
ProgElement 78: tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
ProgElement 79: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d base-def entries created\n",
              lastdfa + numtemps, current_max_dfas);
ProgElement 80: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d (peak %d) nxt-chk entries created\n",
              tblend, current_max_xpairs, peakpairs);
ProgElement 81: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d (peak %d) template nxt-chk entries created\n",
              numtemps * nummecs, current_max_template_xpairs, numtemps * numecs);
ProgElement 82: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d empty table entries\n",
              nummt);
ProgElement 83: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d protos created\n",
              numprots);
ProgElement 84: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d templates created, %d uses\n",
              numtemps, tmpuses);
Block: 41
ProgElement 85: tblsiz = lastdfa * numecs;
ProgElement 86: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d table entries\n",
              tblsiz);
Block: 42
ProgElement 87: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d state/nextstate pairs created\n",
            numsnpairs);
ProgElement 88: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d unique/duplicate transitions\n",
            numuniq, numdup);
Block: 43
ProgElement 89: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d character classes needed %d/%d words of storage, %d reused\n",
              lastccl, current_maxccls, *(cclmap + lastccl) + *(ccllen + lastccl),
              current_max_ccl_tbl_size, cclreuse);
Block: 44
ProgElement 90: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  no character classes\n");
Block: 45
ProgElement 91: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d start conditions\n",
            lastsc, current_max_scs);
ProgElement 92: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d epsilon states, %d double epsilon states\n",
            numeps, eps2);
Block: 46
ProgElement 93: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  Compressed tables always back-up\n");
Block: 47
ProgElement 94: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  No backing up\n");
Block: 48
ProgElement 95: _IO_putc('\n', err);
ProgElement 96: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d NFA states\n",
            lastnfa, current_mns);
ProgElement 97: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d/%d DFA states (%d words)\n",
            lastdfa, current_max_dfas, totnst);
ProgElement 98: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  %d rules\n",
            (num_rules + num_eof_rules) - 1);
Block: 49
ProgElement 99: tmp___6 = strcmp((char const   *)prefix, "yy");
Block: 50
ProgElement 100: fprintf((FILE * __restrict  )err, (char const   * __restrict  )" -S%s", skelname);
Block: 51
ProgElement 101: _IO_putc('r', err);
Block: 52
ProgElement 102: _IO_putc('m', err);
Block: 53
ProgElement 103: _IO_putc('e', err);
Block: 54
ProgElement 104: _IO_putc('F', err);
Block: 55
ProgElement 105: _IO_putc('f', err);
Block: 56
ProgElement 106: _IO_putc('a', err);
Block: 57
ProgElement 107: fprintf((FILE * __restrict  )err, (char const   * __restrict  )" -C");
Block: 58
ProgElement 108: _IO_putc('8', err);
Block: 59
ProgElement 109: _IO_putc('7', err);
Block: 60
ProgElement 110: _IO_putc('T', err);
Block: 61
ProgElement 111: _IO_putc('L', err);
Block: 62
ProgElement 112: _IO_putc('I', err);
Block: 63
ProgElement 113: _IO_putc('B', err);
Block: 64
ProgElement 114: _IO_putc('w', err);
Block: 65
ProgElement 115: _IO_putc('v', err);
Block: 66
ProgElement 116: _IO_putc('t', err);
Block: 67
ProgElement 117: _IO_putc('s', err);
Block: 68
ProgElement 118: _IO_putc('p', err);
Block: 69
ProgElement 119: _IO_putc('l', err);
Block: 70
ProgElement 120: _IO_putc('i', err);
Block: 71
ProgElement 121: _IO_putc('d', err);
Block: 72
ProgElement 122: _IO_putc('b', err);
Block: 73
ProgElement 123: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%s version %s usage statistics:\n",
            program_name, flex_version);
ProgElement 124: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  scanner options: -");
Block: 74
ProgElement 125: tmp___4 = fclose(backing_up_file);
Block: 75
ProgElement 126: tmp___5 = ferror(backing_up_file);
Block: 76
ProgElement 127: fprintf((FILE * __restrict  )backing_up_file, (char const   * __restrict  )"Compressed tables always back up.\n");
Block: 77
ProgElement 128: tmp___1 = unlink(outfilename);
Block: 78
ProgElement 129: tmp___2 = fclose(stdout);
Block: 79
ProgElement 130: tmp___3 = ferror(stdout);
Block: 80
ProgElement 131: tmp = fclose(skelfile);
Block: 81
ProgElement 132: tmp___0 = ferror(skelfile);
Block: 82
ProgElement 133: set_input_file(tmp___4);
ProgElement 134: lastnfa = 0;
ProgElement 135: lastdfa = lastnfa;
ProgElement 136: lastsc = lastdfa;
ProgElement 137: lastccl = lastsc;
ProgElement 138: default_rule = 0;
ProgElement 139: num_eof_rules = default_rule;
ProgElement 140: num_rules = num_eof_rules;
ProgElement 141: tmpuses = 0;
ProgElement 142: numsnpairs = tmpuses;
ProgElement 143: numas = numsnpairs;
ProgElement 144: totnst = 0;
ProgElement 145: dfaeql = totnst;
ProgElement 146: hshcol = dfaeql;
ProgElement 147: num_reallocs = hshcol;
ProgElement 148: eps2 = num_reallocs;
ProgElement 149: numeps = eps2;
ProgElement 150: numecs = numeps;
ProgElement 151: dataline = 0;
ProgElement 152: datapos = dataline;
ProgElement 153: eofseen = datapos;
ProgElement 154: hshsave = eofseen;
ProgElement 155: numdup = hshsave;
ProgElement 156: numuniq = numdup;
ProgElement 157: numprots = 0;
ProgElement 158: onesp = numprots;
ProgElement 159: num_backing_up = onesp;
ProgElement 160: bol_needed = 0;
ProgElement 161: variable_trailing_context_rules = bol_needed;
ProgElement 162: sectnum = 1;
ProgElement 163: linenum = sectnum;
ProgElement 164: out_linenum = linenum;
ProgElement 165: firstprot = 0;
ProgElement 166: lastprot = 1;
ProgElement 167: set_up_initial_allocations();
ProgElement 168: return;
Block: 83
ProgElement 169: tmp___4 = *(input_files + 0);
Block: 84
ProgElement 170: num_input_files = argc;
ProgElement 171: input_files = argv;
Block: 85
ProgElement 172: argc --;
ProgElement 173: argv ++;
Block: 86
ProgElement 174: i___0 ++;
Block: 87
ProgElement 175: csize = 256;
ProgElement 176: goto switch_break;
Block: 88
ProgElement 177: csize = 128;
ProgElement 178: goto switch_break;
Block: 89
ProgElement 179: nowarn = 1;
ProgElement 180: goto switch_break;
Block: 90
ProgElement 181: printf((char const   * __restrict  )"%s version %s\n", program_name, flex_version);
ProgElement 182: exit(0);
Block: 91
ProgElement 183: printstats = 1;
ProgElement 184: goto switch_break;
Block: 92
ProgElement 185: trace = 1;
ProgElement 186: goto switch_break;
Block: 93
ProgElement 187: use_stdout = 1;
ProgElement 188: goto switch_break;
Block: 94
ProgElement 189: spprdflt = 1;
ProgElement 190: goto switch_break;
Block: 95
ProgElement 191: skelname = (arg + i___0) + 1;
ProgElement 192: goto get_next_arg;
Block: 96
ProgElement 193: flexerror("-S flag must be given separately");
Block: 97
ProgElement 194: performance_report ++;
ProgElement 195: goto switch_break;
Block: 98
ProgElement 196: prefix = (arg + i___0) + 1;
ProgElement 197: goto get_next_arg;
Block: 99
ProgElement 198: flexerror("-P flag must be given separately");
Block: 100
ProgElement 199: outfilename = (arg + i___0) + 1;
ProgElement 200: did_outfilename = 1;
ProgElement 201: goto get_next_arg;
Block: 101
ProgElement 202: gen_line_dirs = 0;
ProgElement 203: goto switch_break;
Block: 102
ProgElement 204: lex_compat = 1;
ProgElement 205: goto switch_break;
Block: 103
ProgElement 206: caseins = 1;
ProgElement 207: goto switch_break;
Block: 104
ProgElement 208: interactive = 1;
ProgElement 209: goto switch_break;
Block: 105
ProgElement 210: usage();
ProgElement 211: exit(0);
Block: 106
ProgElement 212: usemecs = 0;
ProgElement 213: useecs = usemecs;
ProgElement 214: fullspd = 1;
ProgElement 215: use_read = fullspd;
ProgElement 216: goto switch_break;
Block: 107
ProgElement 217: usemecs = 0;
ProgElement 218: useecs = usemecs;
ProgElement 219: fulltbl = 1;
ProgElement 220: use_read = fulltbl;
ProgElement 221: goto switch_break;
Block: 108
ProgElement 222: ddebug = 1;
ProgElement 223: goto switch_break;
Block: 109
ProgElement 224: i___0 ++;
Block: 110
ProgElement 225: lerrif("unknown -C option \'%c\'", (int )*(arg + i___0));
ProgElement 226: goto switch_break___0;
Block: 111
ProgElement 227: use_read = 1;
ProgElement 228: goto switch_break___0;
Block: 112
ProgElement 229: usemecs = 1;
ProgElement 230: goto switch_break___0;
Block: 113
ProgElement 231: fulltbl = 1;
ProgElement 232: goto switch_break___0;
Block: 114
ProgElement 233: fullspd = 1;
ProgElement 234: goto switch_break___0;
Block: 115
ProgElement 235: useecs = 1;
ProgElement 236: goto switch_break___0;
Block: 116
ProgElement 237: long_align = 1;
ProgElement 238: goto switch_break___0;
Block: 117
ProgElement 239: i___0 ++;
Block: 118
ProgElement 240: useecs = 0;
ProgElement 241: usemecs = 0;
ProgElement 242: fulltbl = 0;
ProgElement 243: sawcmpflag = 1;
Block: 119
ProgElement 244: flexerror("-C flag must be given separately");
Block: 120
ProgElement 245: backing_up_report = 1;
ProgElement 246: goto switch_break;
Block: 121
ProgElement 247: interactive = 0;
ProgElement 248: goto switch_break;
Block: 122
ProgElement 249: i___0 = 1;
Block: 123
ProgElement 250: arg = *(argv + 0);
Block: 124
ProgElement 251: argv ++;
ProgElement 252: argc --;
ProgElement 253: argc --;
ProgElement 254: argv ++;
Block: 125
ProgElement 255: tmp___0 = strlen((char const   *)program_name);
Block: 126
ProgElement 256: caseins = 0;
ProgElement 257: spprdflt = caseins;
ProgElement 258: trace = spprdflt;
ProgElement 259: syntaxerror = trace;
ProgElement 260: printstats = syntaxerror;
ProgElement 261: fulltbl = 0;
ProgElement 262: ddebug = fulltbl;
ProgElement 263: backing_up_report = ddebug;
ProgElement 264: C_plus_plus = backing_up_report;
ProgElement 265: lex_compat = C_plus_plus;
ProgElement 266: continued_action = 0;
ProgElement 267: yymore_used = continued_action;
ProgElement 268: nowarn = yymore_used;
ProgElement 269: long_align = nowarn;
ProgElement 270: fullspd = long_align;
ProgElement 271: do_stdinit = 0;
ProgElement 272: reject = do_stdinit;
ProgElement 273: in_rule = reject;
ProgElement 274: yytext_is_array = in_rule;
ProgElement 275: do_yylineno = yytext_is_array;
ProgElement 276: reject_really_used = -1;
ProgElement 277: yymore_really_used = reject_really_used;
ProgElement 278: csize = -1;
ProgElement 279: interactive = csize;
ProgElement 280: useecs = 1;
ProgElement 281: usemecs = useecs;
ProgElement 282: gen_line_dirs = usemecs;
ProgElement 283: do_yywrap = gen_line_dirs;
ProgElement 284: performance_report = 0;
ProgElement 285: did_outfilename = 0;
ProgElement 286: prefix = (char *)"yy";
ProgElement 287: yyclass = (char *)0;
ProgElement 288: use_stdout = 0;
ProgElement 289: use_read = use_stdout;
ProgElement 290: sawcmpflag = 0;
ProgElement 291: action_size = 2048;
ProgElement 292: tmp = allocate_array(action_size, sizeof(char ));
ProgElement 293: action_array = (char *)tmp;
ProgElement 294: action_index = 0;
ProgElement 295: action_offset = action_index;
ProgElement 296: prolog_offset = action_offset;
ProgElement 297: defs1_offset = prolog_offset;
ProgElement 298: *(action_array + 0) = (char )'\000';
ProgElement 299: program_name = (char *)"Executable";
Block: 127
ProgElement 300: return;
Block: 128
ProgElement 301: ccl2ecl();
Block: 129
ProgElement 302: NUL_ec = ecgroup[0];
Block: 130
ProgElement 303: NUL_ec = - ecgroup[0];
Block: 131
ProgElement 304: ecgroup[0] = ecgroup[csize];
Block: 132
ProgElement 305: numecs = csize;
Block: 133
ProgElement 306: numecs = cre8ecs(nextecm, ecgroup, csize);
Block: 134
ProgElement 307: outn("extern char *yytext;");
ProgElement 308: outn("#define yytext_ptr yytext");
Block: 135
ProgElement 309: outn("extern char yytext[];\n");
Block: 136
ProgElement 310: outn("extern int yylineno;");
ProgElement 311: outn("int yylineno = 1;");
Block: 137
ProgElement 312: outn("#define YY_FLEX_LEX_COMPAT");
Block: 138
ProgElement 313: outn("\n#define FLEX_DEBUG");
Block: 139
ProgElement 314: outn("typedef int yy_state_type;");
Block: 140
ProgElement 315: outn("typedef yyconst struct yy_trans_info *yy_state_type;");
Block: 141
ProgElement 316: outn((char const   *)(yy_nostdinit));
Block: 142
ProgElement 317: outn("typedef char YY_CHAR;");
Block: 143
ProgElement 318: outn("typedef unsigned char YY_CHAR;");
Block: 144
ProgElement 319: outn("\n#define FLEX_DEBUG");
Block: 145
ProgElement 320: outn("\n#define YY_USES_REJECT");
Block: 146
ProgElement 321: flexerror("REJECT cannot be used with -f or -F");
Block: 147
ProgElement 322: reject = 1;
Block: 148
ProgElement 323: real_reject = 1;
Block: 149
ProgElement 324: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"Variable trailing context rules entail a large performance penalty\n");
Block: 150
ProgElement 325: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"REJECT entails a large performance penalty\n");
Block: 151
ProgElement 326: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"-I (interactive) entails a minor performance penalty\n");
Block: 152
ProgElement 327: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"-l AT&T lex compatibility option entails a large performance penalty\n");
ProgElement 328: fprintf((FILE * __restrict  )err, (char const   * __restrict  )" and may be the actual source of other reported performance penalties\n");
Block: 153
ProgElement 329: reject = 1;
Block: 154
ProgElement 330: yymore_used = 1;
Block: 155
ProgElement 331: backing_up_file = (FILE *)((void *)0);
Block: 156
ProgElement 332: backing_up_file = fopen((char const   * __restrict  )backing_name, (char const   * __restrict  )"w");
Block: 157
ProgElement 333: flexend(1);
Block: 158
ProgElement 334: pinpoint_message((char *)"fatal parse error");
ProgElement 335: flexend(1);
Block: 159
ProgElement 336: line_directive_out((FILE *)0, 1);
ProgElement 337: tmp = yyparse();
Block: 160
ProgElement 338: current_mns = 2000;
ProgElement 339: tmp = allocate_array(current_mns, sizeof(int ));
ProgElement 340: firstst = (int *)tmp;
ProgElement 341: tmp___0 = allocate_array(current_mns, sizeof(int ));
ProgElement 342: lastst = (int *)tmp___0;
ProgElement 343: tmp___1 = allocate_array(current_mns, sizeof(int ));
ProgElement 344: finalst = (int *)tmp___1;
ProgElement 345: tmp___2 = allocate_array(current_mns, sizeof(int ));
ProgElement 346: transchar = (int *)tmp___2;
ProgElement 347: tmp___3 = allocate_array(current_mns, sizeof(int ));
ProgElement 348: trans1 = (int *)tmp___3;
ProgElement 349: tmp___4 = allocate_array(current_mns, sizeof(int ));
ProgElement 350: trans2 = (int *)tmp___4;
ProgElement 351: tmp___5 = allocate_array(current_mns, sizeof(int ));
ProgElement 352: accptnum = (int *)tmp___5;
ProgElement 353: tmp___6 = allocate_array(current_mns, sizeof(int ));
ProgElement 354: assoc_rule = (int *)tmp___6;
ProgElement 355: tmp___7 = allocate_array(current_mns, sizeof(int ));
ProgElement 356: state_type = (int *)tmp___7;
ProgElement 357: current_max_rules = 100;
ProgElement 358: tmp___8 = allocate_array(current_max_rules, sizeof(int ));
ProgElement 359: rule_type = (int *)tmp___8;
ProgElement 360: tmp___9 = allocate_array(current_max_rules, sizeof(int ));
ProgElement 361: rule_linenum = (int *)tmp___9;
ProgElement 362: tmp___10 = allocate_array(current_max_rules, sizeof(int ));
ProgElement 363: rule_useful = (int *)tmp___10;
ProgElement 364: current_max_scs = 40;
ProgElement 365: tmp___11 = allocate_array(current_max_scs, sizeof(int ));
ProgElement 366: scset = (int *)tmp___11;
ProgElement 367: tmp___12 = allocate_array(current_max_scs, sizeof(int ));
ProgElement 368: scbol = (int *)tmp___12;
ProgElement 369: tmp___13 = allocate_array(current_max_scs, sizeof(int ));
ProgElement 370: scxclu = (int *)tmp___13;
ProgElement 371: tmp___14 = allocate_array(current_max_scs, sizeof(int ));
ProgElement 372: sceof = (int *)tmp___14;
ProgElement 373: tmp___15 = allocate_array(current_max_scs, sizeof(char *));
ProgElement 374: scname = (char **)tmp___15;
ProgElement 375: current_maxccls = 100;
ProgElement 376: tmp___16 = allocate_array(current_maxccls, sizeof(int ));
ProgElement 377: cclmap = (int *)tmp___16;
ProgElement 378: tmp___17 = allocate_array(current_maxccls, sizeof(int ));
ProgElement 379: ccllen = (int *)tmp___17;
ProgElement 380: tmp___18 = allocate_array(current_maxccls, sizeof(int ));
ProgElement 381: cclng = (int *)tmp___18;
ProgElement 382: current_max_ccl_tbl_size = 500;
ProgElement 383: tmp___19 = allocate_array(current_max_ccl_tbl_size, sizeof(unsigned char ));
ProgElement 384: ccltbl = (unsigned char *)tmp___19;
ProgElement 385: current_max_dfa_size = 750;
ProgElement 386: current_max_xpairs = 2000;
ProgElement 387: tmp___20 = allocate_array(current_max_xpairs, sizeof(int ));
ProgElement 388: nxt = (int *)tmp___20;
ProgElement 389: tmp___21 = allocate_array(current_max_xpairs, sizeof(int ));
ProgElement 390: chk = (int *)tmp___21;
ProgElement 391: current_max_template_xpairs = 2500;
ProgElement 392: tmp___22 = allocate_array(current_max_template_xpairs, sizeof(int ));
ProgElement 393: tnxt = (int *)tmp___22;
ProgElement 394: current_max_dfas = 1000;
ProgElement 395: tmp___23 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 396: base = (int *)tmp___23;
ProgElement 397: tmp___24 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 398: def = (int *)tmp___24;
ProgElement 399: tmp___25 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 400: dfasiz = (int *)tmp___25;
ProgElement 401: tmp___26 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 402: accsiz = (int *)tmp___26;
ProgElement 403: tmp___27 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 404: dhash = (int *)tmp___27;
ProgElement 405: tmp___28 = allocate_array(current_max_dfas, sizeof(int *));
ProgElement 406: dss = (int **)tmp___28;
ProgElement 407: tmp___29 = allocate_array(current_max_dfas, sizeof(union dfaacc_union ));
ProgElement 408: dfaacc = (union dfaacc_union *)tmp___29;
ProgElement 409: nultrans = (int *)0;
ProgElement 410: return;
Block: 161
ProgElement 411: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-t  write generated scanner on stdout instead of %s\n",
          outfilename);
ProgElement 412: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-v  write summary of scanner statistics to f\n");
ProgElement 413: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-w  do not generate warnings\n");
ProgElement 414: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-B  generate batch scanner (opposite of -I)\n");
ProgElement 415: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-F  use alternative fast scanner representation\n");
ProgElement 416: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-I  generate interactive scanner (opposite of -B)\n");
ProgElement 417: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-L  suppress #line directives in scanner\n");
ProgElement 418: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-T  %s should run in trace mode\n",
          program_name);
ProgElement 419: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-V  report %s version\n",
          program_name);
ProgElement 420: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-7  generate 7-bit scanner\n");
ProgElement 421: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-8  generate 8-bit scanner\n");
ProgElement 422: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-+  generate C++ scanner class\n");
ProgElement 423: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-?  produce this help message\n");
ProgElement 424: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-C  specify degree of table compression (default is -Cem):\n");
ProgElement 425: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-Ca  trade off larger tables for better memory alignment\n");
ProgElement 426: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-Ce  construct equivalence classes\n");
ProgElement 427: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-Cf  do not compress scanner tables; use -f representation\n");
ProgElement 428: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-CF  do not compress scanner tables; use -F representation\n");
ProgElement 429: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-Cm  construct meta-equivalence classes\n");
ProgElement 430: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t\t-Cr  use read() instead of stdio for scanner input\n");
ProgElement 431: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-o  specify output filename\n");
ProgElement 432: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-P  specify scanner prefix other than \"yy\"\n");
ProgElement 433: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-S  specify skeleton file\n");
ProgElement 434: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t--help     produce this help message\n");
ProgElement 435: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t--version  report %s version\n",
          program_name);
ProgElement 436: return;
Block: 162
ProgElement 437: sprintf((char * __restrict  )(outfile_path), (char const   * __restrict  )outfile_template,
            prefix, tmp);
ProgElement 438: outfilename = outfile_path;
Block: 163
ProgElement 439: tmp = "c";
Block: 164
ProgElement 440: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n",
          program_name);
ProgElement 441: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t[--help --version] [file ...]\n");
ProgElement 442: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-b  generate backing-up information to %s\n",
          backing_name);
ProgElement 443: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-c  do-nothing POSIX option\n");
ProgElement 444: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-d  turn on debug mode in generated scanner\n");
ProgElement 445: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-f  generate fast, large scanner\n");
ProgElement 446: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-h  produce this help message\n");
ProgElement 447: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-i  generate case-insensitive scanner\n");
ProgElement 448: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-l  maximal compatibility with original lex\n");
ProgElement 449: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-n  do-nothing POSIX option\n");
ProgElement 450: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-p  generate performance report to err\n");
ProgElement 451: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t-s  suppress default rule to ECHO unmatched text\n");
Block: 165
ProgElement 452: *(ccllen + cclp) = len + 1;
ProgElement 453: *(ccltbl + newpos) = (unsigned char )ch;
ProgElement 454: return;
Block: 166
ProgElement 455: current_max_ccl_tbl_size += 250;
ProgElement 456: num_reallocs ++;
ProgElement 457: tmp = reallocate_array((void *)ccltbl, current_max_ccl_tbl_size, sizeof(unsigned char ));
ProgElement 458: ccltbl = (unsigned char *)tmp;
Block: 167
ProgElement 459: newpos = ind + len;
Block: 168
ProgElement 460: i___0 ++;
Block: 169
ProgElement 461: return;
Block: 170
ProgElement 462: check_char(ch);
ProgElement 463: len = *(ccllen + cclp);
ProgElement 464: ind = *(cclmap + cclp);
ProgElement 465: i___0 = 0;
Block: 171
ProgElement 466: *(ccllen + lastccl) = 0;
ProgElement 467: *(cclng + lastccl) = 0;
ProgElement 468: return (lastccl);
Block: 172
ProgElement 469: *(cclmap + lastccl) = *(cclmap + (lastccl - 1)) + *(ccllen + (lastccl - 1));
Block: 173
ProgElement 470: *(cclmap + lastccl) = 0;
Block: 174
ProgElement 471: current_maxccls += 100;
ProgElement 472: num_reallocs ++;
ProgElement 473: tmp = reallocate_array((void *)cclmap, current_maxccls, sizeof(int ));
ProgElement 474: cclmap = (int *)tmp;
ProgElement 475: tmp___0 = reallocate_array((void *)ccllen, current_maxccls, sizeof(int ));
ProgElement 476: ccllen = (int *)tmp___0;
ProgElement 477: tmp___1 = reallocate_array((void *)cclng, current_maxccls, sizeof(int ));
ProgElement 478: cclng = (int *)tmp___1;
Block: 175
ProgElement 479: lastccl ++;
Block: 176
ProgElement 480: *(cclng + cclp) = 1;
ProgElement 481: return;
Block: 177
ProgElement 482: _IO_putc(']', file);
ProgElement 483: return;
Block: 178
ProgElement 484: i___0 ++;
Block: 179
ProgElement 485: _IO_putc(' ', file);
Block: 180
ProgElement 486: tmp___0 = readable_form(i___0 - 1);
ProgElement 487: fprintf((FILE * __restrict  )file, (char const   * __restrict  )"-%s", tmp___0);
Block: 181
ProgElement 488: i___0 ++;
Block: 182
ProgElement 489: start_char = i___0;
ProgElement 490: _IO_putc(' ', file);
ProgElement 491: tmp = readable_form(i___0);
ProgElement 492: fputs((char const   * __restrict  )tmp, (FILE * __restrict  )file);
Block: 183
ProgElement 493: _IO_putc('[', file);
ProgElement 494: i___0 = 0;
Block: 184
ProgElement 495: return;
Block: 185
ProgElement 496: fprintf((FILE * __restrict  )backing_up_file, (char const   * __restrict  )"State #%d is non-accepting -\n",
                ds);
ProgElement 497: dump_associated_rules(backing_up_file, ds);
ProgElement 498: dump_transitions(backing_up_file, state);
ProgElement 499: _IO_putc('\n', backing_up_file);
Block: 186
ProgElement 500: num_backing_up ++;
Block: 187
ProgElement 501: return;
Block: 188
ProgElement 502: i___0 ++;
Block: 189
ProgElement 503: j ++;
Block: 190
ProgElement 504: line_warning((char *)"dangerous trailing context", *(rule_linenum + ar));
ProgElement 505: return;
Block: 191
ProgElement 506: j = 1;
Block: 192
ProgElement 507: ns = *(nfa_states + i___0);
ProgElement 508: type = *(state_type + ns);
ProgElement 509: ar = *(assoc_rule + ns);
Block: 193
ProgElement 510: i___0 = 1;
Block: 194
ProgElement 511: _IO_putc('\n', file);
ProgElement 512: return;
Block: 195
ProgElement 513: fprintf((FILE * __restrict  )file, (char const   * __restrict  )"\t%d", rule_set[i___0]);
ProgElement 514: i___0 ++;
Block: 196
ProgElement 515: _IO_putc('\n', file);
Block: 197
ProgElement 516: bubble(rule_set, num_associated_rules);
ProgElement 517: fprintf((FILE * __restrict  )file, (char const   * __restrict  )" associated rule line numbers:");
ProgElement 518: i___0 = 1;
Block: 198
ProgElement 519: i___0 ++;
Block: 199
ProgElement 520: num_associated_rules ++;
ProgElement 521: rule_set[num_associated_rules] = rule_num;
Block: 200
ProgElement 522: rule_num = *(rule_linenum + *(assoc_rule + *(dset + i___0)));
ProgElement 523: j = 1;
Block: 201
ProgElement 524: num_associated_rules = 0;
ProgElement 525: dset = *(dss + ds);
ProgElement 526: size = *(dfasiz + ds);
ProgElement 527: i___0 = 1;
Block: 202
ProgElement 528: fprintf((FILE * __restrict  )file, (char const   * __restrict  )"\n jam-transitions: EOF ");
ProgElement 529: list_character_set(file, out_char_set);
ProgElement 530: _IO_putc('\n', file);
ProgElement 531: return;
Block: 203
ProgElement 532: out_char_set[i___0] = ! out_char_set[i___0];
ProgElement 533: i___0 ++;
Block: 204
ProgElement 534: fprintf((FILE * __restrict  )file, (char const   * __restrict  )" out-transitions: ");
ProgElement 535: list_character_set(file, out_char_set);
ProgElement 536: i___0 = 0;
Block: 205
ProgElement 537: out_char_set[i___0] = *(state + ec);
ProgElement 538: i___0 ++;
Block: 206
ProgElement 539: ec = ecgroup[i___0];
Block: 207
ProgElement 540: ec = - ecgroup[i___0];
Block: 208
ProgElement 541: i___0 = 0;
Block: 209
ProgElement 542: *ns_addr = numstates;
ProgElement 543: *hv_addr = hashval;
ProgElement 544: *nacc_addr = nacc;
ProgElement 545: return (t);
Block: 210
ProgElement 546: stkpos ++;
Block: 211
ProgElement 547: *(trans1 + *(stk + stkpos)) += 32001;
Block: 212
ProgElement 548: stkpos = 1;
Block: 213
ProgElement 549: stkpos ++;
Block: 214
ProgElement 550: *(t + numstates) = tsp;
ProgElement 551: hashval += tsp;
Block: 215
ProgElement 552: numstates ++;
Block: 216
ProgElement 553: nacc ++;
ProgElement 554: *(accset + nacc) = nfaccnum;
Block: 217
ProgElement 555: *(stk + stkend) = tsp;
ProgElement 556: *(trans1 + tsp) -= 32001;
ProgElement 557: nfaccnum = *(accptnum + tsp);
Block: 218
ProgElement 558: stkend ++;
Block: 219
ProgElement 559: tsp = *(trans2 + ns);
Block: 220
ProgElement 560: *(t + numstates) = tsp;
ProgElement 561: hashval += tsp;
Block: 221
ProgElement 562: numstates ++;
Block: 222
ProgElement 563: *(stk + stkend) = tsp;
ProgElement 564: *(trans1 + tsp) -= 32001;
ProgElement 565: nfaccnum = *(accptnum + tsp);
Block: 223
ProgElement 566: current_max_dfa_size += 750;
ProgElement 567: num_reallocs ++;
ProgElement 568: tmp___2 = reallocate_array((void *)t, current_max_dfa_size, sizeof(int ));
ProgElement 569: t = (int *)tmp___2;
ProgElement 570: tmp___3 = reallocate_array((void *)stk, current_max_dfa_size, sizeof(int ));
ProgElement 571: stk = (int *)tmp___3;
Block: 224
ProgElement 572: stkend ++;
Block: 225
ProgElement 573: tsp = *(trans1 + ns) + 32001;
Block: 226
ProgElement 574: ns = *(stk + stkpos);
ProgElement 575: transsym = *(transchar + ns);
Block: 227
ProgElement 576: stkpos = 1;
Block: 228
ProgElement 577: nstate ++;
Block: 229
ProgElement 578: hashval += ns;
Block: 230
ProgElement 579: nacc ++;
ProgElement 580: *(accset + nacc) = nfaccnum;
Block: 231
ProgElement 581: *(stk + stkend) = ns;
ProgElement 582: *(trans1 + ns) -= 32001;
ProgElement 583: nfaccnum = *(accptnum + ns);
Block: 232
ProgElement 584: stkend ++;
Block: 233
ProgElement 585: ns = *(t + nstate);
Block: 234
ProgElement 586: hashval = 0;
ProgElement 587: stkend = hashval;
ProgElement 588: nacc = stkend;
ProgElement 589: nstate = 1;
Block: 235
ProgElement 590: tmp = allocate_array(current_max_dfa_size, sizeof(int ));
ProgElement 591: stk = (int *)tmp;
ProgElement 592: did_stk_init = 1;
Block: 236
ProgElement 593: numstates = *ns_addr;
Block: 237
ProgElement 594: return;
Block: 238
ProgElement 595: current_max_dfas += 1000;
ProgElement 596: num_reallocs ++;
ProgElement 597: tmp = reallocate_array((void *)base, current_max_dfas, sizeof(int ));
ProgElement 598: base = (int *)tmp;
ProgElement 599: tmp___0 = reallocate_array((void *)def, current_max_dfas, sizeof(int ));
ProgElement 600: def = (int *)tmp___0;
ProgElement 601: tmp___1 = reallocate_array((void *)dfasiz, current_max_dfas, sizeof(int ));
ProgElement 602: dfasiz = (int *)tmp___1;
ProgElement 603: tmp___2 = reallocate_array((void *)accsiz, current_max_dfas, sizeof(int ));
ProgElement 604: accsiz = (int *)tmp___2;
ProgElement 605: tmp___3 = reallocate_array((void *)dhash, current_max_dfas, sizeof(int ));
ProgElement 606: dhash = (int *)tmp___3;
ProgElement 607: tmp___4 = reallocate_array((void *)dss, current_max_dfas, sizeof(int *));
ProgElement 608: dss = (int **)tmp___4;
ProgElement 609: tmp___5 = reallocate_array((void *)dfaacc, current_max_dfas, sizeof(union dfaacc_union ));
ProgElement 610: dfaacc = (union dfaacc_union *)tmp___5;
Block: 239
ProgElement 611: flex_free((void *)accset);
ProgElement 612: flex_free((void *)nset);
ProgElement 613: return;
Block: 240
ProgElement 614: mkdeftbl();
Block: 241
ProgElement 615: mk1tbl(onestate[onesp], onesym[onesp], onenext[onesp], onedef[onesp]);
ProgElement 616: onesp --;
Block: 242
ProgElement 617: cmptmps();
Block: 243
ProgElement 618: dataend();
Block: 244
ProgElement 619: bldtbl(state, ds, totaltrans, comstate, comfreq);
Block: 245
ProgElement 620: i___0 ++;
Block: 246
ProgElement 621: comfreq = targfreq[i___0];
ProgElement 622: comstate = targstate[i___0];
Block: 247
ProgElement 623: comfreq = 0;
ProgElement 624: comstate = 0;
ProgElement 625: i___0 = 1;
Block: 248
ProgElement 626: stack1(ds, 0, 0, -32766);
Block: 249
ProgElement 627: place_state(state, ds, totaltrans);
Block: 250
ProgElement 628: dataflush();
ProgElement 629: outn("    },\n");
Block: 251
ProgElement 630: mk2data(tmp___6);
ProgElement 631: i___0 ++;
Block: 252
ProgElement 632: tmp___6 = - ds;
Block: 253
ProgElement 633: tmp___6 = state[i___0];
Block: 254
ProgElement 634: i___0 = 1;
Block: 255
ProgElement 635: mk2data(end_of_buffer_state);
Block: 256
ProgElement 636: mk2data(- end_of_buffer_state);
Block: 257
ProgElement 637: outn("    {");
Block: 258
ProgElement 638: *(nultrans + ds) = state[NUL_ec];
ProgElement 639: state[NUL_ec] = 0;
Block: 259
ProgElement 640: check_for_backing_up(ds, state);
Block: 260
ProgElement 641: numsnpairs += totaltrans;
Block: 261
ProgElement 642: sym ++;
Block: 262
ProgElement 643: totaltrans ++;
ProgElement 644: duplist[sym] = 0;
Block: 263
ProgElement 645: (targfreq[i___0]) ++;
ProgElement 646: numdup ++;
Block: 264
ProgElement 647: i___0 ++;
Block: 265
ProgElement 648: i___0 = 0;
Block: 266
ProgElement 649: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t%d\t%d\n",
                    sym, targ);
Block: 267
ProgElement 650: targ = state[duplist[sym]];
ProgElement 651: state[sym] = targ;
Block: 268
ProgElement 652: targptr ++;
ProgElement 653: targfreq[targptr] = 1;
ProgElement 654: targstate[targptr] = newds;
ProgElement 655: numuniq ++;
Block: 269
ProgElement 656: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\t%d\t%d\n",
                    sym, newds);
Block: 270
ProgElement 657: state[sym] = newds;
Block: 271
ProgElement 658: check_trailing_context(nset, numstates, accset, nacc);
Block: 272
ProgElement 659: totnst += numstates;
ProgElement 660: todo_next ++;
ProgElement 661: numas += nacc;
Block: 273
ProgElement 662: numstates = symfollowset(dset, dsize, sym, nset);
ProgElement 663: nset = epsclosure(nset, & numstates, accset, & nacc, & hashval);
ProgElement 664: tmp___5 = snstods(nset, numstates, accset, nacc, hashval, & newds);
Block: 274
ProgElement 665: symlist[sym] = 0;
Block: 275
ProgElement 666: sympartition(dset, dsize, symlist, duplist);
ProgElement 667: sym = 1;
Block: 276
ProgElement 668: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"state # %d:\n",
              ds);
Block: 277
ProgElement 669: todo_head ++;
ProgElement 670: ds = todo_head;
ProgElement 671: dset = *(dss + ds);
ProgElement 672: dsize = *(dfasiz + ds);
Block: 278
ProgElement 673: state[i___0] = 0;
ProgElement 674: i___0 ++;
Block: 279
ProgElement 675: targptr = 0;
ProgElement 676: totaltrans = 0;
ProgElement 677: i___0 = 1;
Block: 280
ProgElement 678: numas ++;
ProgElement 679: num_start_states ++;
ProgElement 680: todo_next ++;
Block: 281
ProgElement 681: tmp___4 = snstods(nset, 0, accset, 0, 0, & end_of_buffer_state);
Block: 282
ProgElement 682: i___0 ++;
Block: 283
ProgElement 683: numas += nacc;
ProgElement 684: totnst += numstates;
ProgElement 685: todo_next ++;
Block: 284
ProgElement 686: nset = epsclosure(nset, & numstates, accset, & nacc, & hashval);
ProgElement 687: tmp___3 = snstods(nset, numstates, accset, nacc, hashval, & ds);
Block: 285
ProgElement 688: *(nset + numstates) = mkbranch(*(scbol + i___0 / 2), *(scset + i___0 / 2));
Block: 286
ProgElement 689: *(nset + numstates) = *(scset + (i___0 / 2 + 1));
Block: 287
ProgElement 690: numstates = 1;
Block: 288
ProgElement 691: num_start_states = lastsc * 2;
ProgElement 692: i___0 = 1;
Block: 289
ProgElement 693: dataflush();
ProgElement 694: outn("    },\n");
Block: 290
ProgElement 695: mk2data(0);
ProgElement 696: i___0 ++;
Block: 291
ProgElement 697: out_str_dec("static yyconst %s yy_nxt[][%d] =\n    {\n", tmp___2, num_full_table_rows);
ProgElement 698: outn("    {");
ProgElement 699: i___0 = 0;
Block: 292
ProgElement 700: tmp___2 = "short";
Block: 293
ProgElement 701: num_full_table_rows = numecs + 1;
Block: 294
ProgElement 702: num_full_table_rows = numecs;
Block: 295
ProgElement 703: place_state(state, 0, 0);
ProgElement 704: (dfaacc + 0)->dfaacc_state = 0;
Block: 296
ProgElement 705: state[i___0] = 0;
ProgElement 706: i___0 ++;
Block: 297
ProgElement 707: i___0 = 0;
Block: 298
ProgElement 708: tmp___1 = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 709: nultrans = (int *)tmp___1;
Block: 299
ProgElement 710: use_NUL_table = numecs == csize;
Block: 300
ProgElement 711: inittbl();
Block: 301
ProgElement 712: dumpnfa(*(scset + 1));
ProgElement 713: fputs((char const   * __restrict  )"\n\nDFA Dump:\n\n", (FILE * __restrict  )err);
Block: 302
ProgElement 714: *(accset + i___0) = 0;
ProgElement 715: i___0 ++;
Block: 303
ProgElement 716: i___0 = 0;
Block: 304
ProgElement 717: duplist[i___0] = 0;
ProgElement 718: symlist[i___0] = 0;
ProgElement 719: i___0 ++;
Block: 305
ProgElement 720: tmp = allocate_array(num_rules + 1, sizeof(int ));
ProgElement 721: accset = (int *)tmp;
ProgElement 722: tmp___0 = allocate_array(current_max_dfa_size, sizeof(int ));
ProgElement 723: nset = (int *)tmp___0;
ProgElement 724: todo_next = 0;
ProgElement 725: todo_head = todo_next;
ProgElement 726: i___0 = 0;
Block: 306
ProgElement 727: *newds_addr = newds;
ProgElement 728: return (1);
Block: 307
ProgElement 729: *(rule_useful + j) = 1;
Block: 308
ProgElement 730: (dfaacc + newds)->dfaacc_state = j;
Block: 309
ProgElement 731: i___0 ++;
Block: 310
ProgElement 732: j = *(accset + i___0);
Block: 311
ProgElement 733: j = num_rules + 1;
ProgElement 734: i___0 = 1;
Block: 312
ProgElement 735: *(accsiz + newds) = nacc;
Block: 313
ProgElement 736: i___0 ++;
Block: 314
ProgElement 737: *(rule_useful + *(accset + i___0)) = 1;
Block: 315
ProgElement 738: *((dfaacc + newds)->dfaacc_set + i___0) = *(accset + i___0);
Block: 316
ProgElement 739: bubble(accset, nacc);
ProgElement 740: tmp___0 = allocate_array(nacc + 1, sizeof(int ));
ProgElement 741: (dfaacc + newds)->dfaacc_set = (int *)tmp___0;
ProgElement 742: i___0 = 1;
Block: 317
ProgElement 743: *(accsiz + newds) = 0;
Block: 318
ProgElement 744: (dfaacc + newds)->dfaacc_state = 0;
Block: 319
ProgElement 745: (dfaacc + newds)->dfaacc_set = (int *)0;
Block: 320
ProgElement 746: *(dfasiz + newds) = numstates;
ProgElement 747: *(dhash + newds) = hashval;
Block: 321
ProgElement 748: *(*(dss + newds) + i___0) = *(sns + i___0);
ProgElement 749: i___0 ++;
Block: 322
ProgElement 750: i___0 = 1;
Block: 323
ProgElement 751: bubble(sns, numstates);
Block: 324
ProgElement 752: newds = lastdfa;
ProgElement 753: tmp = allocate_array(numstates + 1, sizeof(int ));
ProgElement 754: *(dss + newds) = (int *)tmp;
Block: 325
ProgElement 755: increase_max_dfas();
Block: 326
ProgElement 756: lastdfa ++;
Block: 327
ProgElement 757: i___0 ++;
Block: 328
ProgElement 758: hshsave ++;
Block: 329
ProgElement 759: hshcol ++;
Block: 330
ProgElement 760: dfaeql ++;
ProgElement 761: *newds_addr = i___0;
ProgElement 762: return (0);
Block: 331
ProgElement 763: j ++;
Block: 332
ProgElement 764: j = 1;
Block: 333
ProgElement 765: bubble(sns, numstates);
ProgElement 766: didsort = 1;
Block: 334
ProgElement 767: oldsns = *(dss + i___0);
Block: 335
ProgElement 768: didsort = 0;
ProgElement 769: i___0 = 1;
Block: 336
ProgElement 770: return (numstates);
Block: 337
ProgElement 771: i___0 ++;
Block: 338
ProgElement 772: numstates ++;
ProgElement 773: *(nset + numstates) = tsp;
Block: 339
ProgElement 774: tmp = ecgroup[sym];
Block: 340
ProgElement 775: j ++;
Block: 341
ProgElement 776: numstates ++;
ProgElement 777: *(nset + numstates) = tsp;
ProgElement 778: goto while_break___1;
Block: 342
ProgElement 779: ch = NUL_ec;
Block: 343
ProgElement 780: ch = (int )*(ccltbl + (ccllist + j));
Block: 344
ProgElement 781: j = 0;
Block: 345
ProgElement 782: numstates ++;
ProgElement 783: *(nset + numstates) = tsp;
Block: 346
ProgElement 784: j ++;
Block: 347
ProgElement 785: ch = (int )*(ccltbl + (ccllist + j));
Block: 348
ProgElement 786: j = 0;
Block: 349
ProgElement 787: sym = - sym;
ProgElement 788: ccllist = *(cclmap + sym);
ProgElement 789: lenccl = *(ccllen + sym);
Block: 350
ProgElement 790: ns = *(ds + i___0);
ProgElement 791: sym = *(transchar + ns);
ProgElement 792: tsp = *(trans1 + ns);
Block: 351
ProgElement 793: numstates = 0;
ProgElement 794: i___0 = 1;
Block: 352
ProgElement 795: return;
Block: 353
ProgElement 796: i___0 ++;
Block: 354
ProgElement 797: *(symlist + ich) = 1;
ProgElement 798: k ++;
Block: 355
ProgElement 799: ich = NUL_ec;
Block: 356
ProgElement 800: ich = (int )*(ccltbl + (cclp + k));
Block: 357
ProgElement 801: k = 0;
Block: 358
ProgElement 802: *(symlist + j) = 1;
ProgElement 803: j ++;
Block: 359
ProgElement 804: j ++;
Block: 360
ProgElement 805: k ++;
Block: 361
ProgElement 806: *(symlist + j) = 1;
ProgElement 807: j ++;
Block: 362
ProgElement 808: j ++;
Block: 363
ProgElement 809: ich = (int )*(ccltbl + (cclp + k));
Block: 364
ProgElement 810: j = 0;
ProgElement 811: k = 0;
Block: 365
ProgElement 812: tch = - tch;
ProgElement 813: lenccl = *(ccllen + tch);
ProgElement 814: cclp = *(cclmap + tch);
ProgElement 815: mkeccl(ccltbl + cclp, lenccl, dupfwd, duplist, numecs, NUL_ec);
Block: 366
ProgElement 816: ec = ecgroup[tch];
ProgElement 817: mkechar(ec, dupfwd, duplist);
ProgElement 818: *(symlist + ec) = 1;
Block: 367
ProgElement 819: ns = *(ds + i___0);
ProgElement 820: tch = *(transchar + ns);
Block: 368
ProgElement 821: *(duplist + 1) = 0;
ProgElement 822: dupfwd[numecs] = 0;
ProgElement 823: i___0 = 1;
Block: 369
ProgElement 824: *(duplist + i___0) = i___0 - 1;
ProgElement 825: dupfwd[i___0] = i___0 + 1;
ProgElement 826: i___0 ++;
Block: 370
ProgElement 827: i___0 = 1;
Block: 371
ProgElement 828: return;
Block: 372
ProgElement 829: *(ccllen + i___0) = newlen;
ProgElement 830: i___0 ++;
Block: 373
ProgElement 831: ccls ++;
Block: 374
ProgElement 832: *(ccltbl + (cclp + newlen)) = (unsigned char )cclmec;
ProgElement 833: newlen ++;
Block: 375
ProgElement 834: ich = (int )*(ccltbl + (cclp + ccls));
ProgElement 835: cclmec = ecgroup[ich];
Block: 376
ProgElement 836: newlen = 0;
ProgElement 837: cclp = *(cclmap + i___0);
ProgElement 838: ccls = 0;
Block: 377
ProgElement 839: i___0 = 1;
Block: 378
ProgElement 840: return (numcl);
Block: 379
ProgElement 841: i___0 ++;
Block: 380
ProgElement 842: *(bck + j) = - numcl;
ProgElement 843: j = *(fwd + j);
Block: 381
ProgElement 844: numcl ++;
ProgElement 845: *(bck + i___0) = numcl;
ProgElement 846: j = *(fwd + i___0);
Block: 382
ProgElement 847: numcl = 0;
ProgElement 848: i___0 = 1;
Block: 383
ProgElement 849: return;
Block: 384
ProgElement 850: cclflags[cclp] = (unsigned char)0;
ProgElement 851: cclp ++;
Block: 385
ProgElement 852: *(fwd + newec) = 0;
ProgElement 853: cclp ++;
Block: 386
ProgElement 854: *(bck + cclm) = 0;
ProgElement 855: *(fwd + oldec) = 0;
Block: 387
ProgElement 856: *(bck + cclm) = 0;
ProgElement 857: *(fwd + oldec) = 0;
Block: 388
ProgElement 858: i___0 = *(fwd + i___0);
Block: 389
ProgElement 859: oldec = i___0;
Block: 390
ProgElement 860: *(fwd + oldec) = i___0;
Block: 391
ProgElement 861: *(bck + i___0) = oldec;
Block: 392
ProgElement 862: j ++;
Block: 393
ProgElement 863: *(bck + i___0) = newec;
ProgElement 864: *(fwd + newec) = i___0;
ProgElement 865: newec = i___0;
ProgElement 866: cclflags[j] = (unsigned char)1;
ProgElement 867: goto next_pt;
Block: 394
ProgElement 868: ccl_char = (int )*(ccls + j);
Block: 395
ProgElement 869: ccl_char = (int )*(ccls + j);
Block: 396
ProgElement 870: ccl_char = NUL_mapping;
Block: 397
ProgElement 871: oldec = *(bck + cclm);
ProgElement 872: newec = cclm;
ProgElement 873: j = cclp + 1;
ProgElement 874: i___0 = *(fwd + cclm);
Block: 398
ProgElement 875: cclm = NUL_mapping;
Block: 399
ProgElement 876: cclm = (int )*(ccls + cclp);
Block: 400
ProgElement 877: cclp = 0;
Block: 401
ProgElement 878: *(fwd + tch) = 0;
ProgElement 879: *(bck + tch) = 0;
ProgElement 880: return;
Block: 402
ProgElement 881: *(fwd + *(bck + tch)) = *(fwd + tch);
Block: 403
ProgElement 882: *(bck + *(fwd + tch)) = *(bck + tch);
Block: 404
ProgElement 883: return;
Block: 405
ProgElement 884: outc('\t');
ProgElement 885: i___0 -= 8;
Block: 406
ProgElement 886: i___0 = indent_level * 8;
Block: 407
ProgElement 887: indent_level ++;
ProgElement 888: indent_puts((char *)"{");
ProgElement 889: indent_puts((char *)"yy_last_accepting_state = yy_current_state;");
ProgElement 890: indent_puts((char *)"yy_last_accepting_cpos = yy_cp;");
ProgElement 891: indent_puts((char *)"}");
ProgElement 892: indent_level --;
ProgElement 893: return;
Block: 408
ProgElement 894: indent_puts((char *)"if ( yy_accept[yy_current_state] )");
Block: 409
ProgElement 895: indent_puts((char *)"if ( yy_current_state[-1].yy_nxt )");
Block: 410
ProgElement 896: return;
Block: 411
ProgElement 897: return;
Block: 412
ProgElement 898: indent_puts((char *)"yy_current_state = yy_last_accepting_state;");
ProgElement 899: indent_puts((char *)"goto yy_find_action;");
ProgElement 900: outc('\n');
ProgElement 901: indent_level = 0;
ProgElement 902: return;
Block: 413
ProgElement 903: indent_puts((char *)"yy_cp = yy_last_accepting_cpos;");
Block: 414
ProgElement 904: indent_puts((char *)"yy_cp = yy_last_accepting_cpos + 1;");
Block: 415
ProgElement 905: indent_puts((char *)"yy_cp = yy_last_accepting_cpos + 1;");
Block: 416
ProgElement 906: indent_level = 3;
ProgElement 907: indent_puts((char *)"case 0: /* must back up */");
ProgElement 908: indent_puts((char *)"/* undo the effects of YY_DO_BEFORE_ACTION */");
ProgElement 909: indent_puts((char *)"*yy_cp = yy_hold_char;");
Block: 417
ProgElement 910: return;
Block: 418
ProgElement 911: return;
Block: 419
ProgElement 912: return;
Block: 420
ProgElement 913: genecs();
Block: 421
ProgElement 914: dataend();
Block: 422
ProgElement 915: out_dec("    &yy_transition[%d],\n", *(base + i___0));
ProgElement 916: i___0 ++;
Block: 423
ProgElement 917: transition_struct_out(*(chk + (tblend + 1)), *(nxt + (tblend + 1)));
ProgElement 918: transition_struct_out(*(chk + (tblend + 2)), *(nxt + (tblend + 2)));
ProgElement 919: outn("    };\n");
ProgElement 920: out_dec("static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n", lastsc * 2 + 1);
ProgElement 921: outn("    {");
ProgElement 922: i___0 = 0;
Block: 424
ProgElement 923: i___0 ++;
Block: 425
ProgElement 924: transition_struct_out(*(chk + i___0), *(base + *(nxt + i___0)) - (i___0 - *(chk + i___0)));
Block: 426
ProgElement 925: transition_struct_out(0, 0);
Block: 427
ProgElement 926: transition_struct_out(0, *(nxt + i___0));
Block: 428
ProgElement 927: transition_struct_out(0, *(base + (lastdfa + 1)) - i___0);
Block: 429
ProgElement 928: i___0 = 0;
Block: 430
ProgElement 929: anum = (dfaacc + i___0)->dfaacc_state;
ProgElement 930: offset = *(base + i___0);
ProgElement 931: *(chk + offset) = -1;
ProgElement 932: *(chk + (offset - 1)) = -2;
ProgElement 933: *(nxt + (offset - 1)) = anum;
ProgElement 934: i___0 ++;
Block: 431
ProgElement 935: *(base + (lastdfa + 1)) = tblend + 2;
ProgElement 936: *(nxt + (tblend + 1)) = end_of_buffer_action;
ProgElement 937: *(chk + (tblend + 1)) = numecs + 1;
ProgElement 938: *(chk + (tblend + 2)) = 1;
ProgElement 939: *(nxt + (tblend + 2)) = 0;
ProgElement 940: i___0 = 0;
Block: 432
ProgElement 941: end_of_buffer_action = num_rules + 1;
ProgElement 942: out_dec("static yyconst struct yy_trans_info yy_transition[%d] =\n", (tblend + numecs) + 1);
ProgElement 943: outn("    {");
Block: 433
ProgElement 944: return;
Block: 434
ProgElement 945: _IO_putc('\n', err);
ProgElement 946: j ++;
Block: 435
ProgElement 947: tmp___0 = readable_form(i___0);
ProgElement 948: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%4s = %-2d",
                tmp___0, ecgroup[i___0]);
ProgElement 949: _IO_putc(' ', err);
ProgElement 950: i___0 += numrows;
Block: 436
ProgElement 951: i___0 = j;
Block: 437
ProgElement 952: fputs((char const   * __restrict  )"\n\nEquivalence Classes:\n\n", (FILE * __restrict  )err);
ProgElement 953: numrows = csize / 8;
ProgElement 954: j = 0;
Block: 438
ProgElement 955: dataend();
Block: 439
ProgElement 956: mkdata(ecgroup[i___0]);
ProgElement 957: i___0 ++;
Block: 440
ProgElement 958: ecgroup[i___0] = ecgroup[i___0];
Block: 441
ProgElement 959: ecgroup[i___0] = - ecgroup[i___0];
Block: 442
ProgElement 960: tmp = clower(i___0);
ProgElement 961: ecgroup[i___0] = ecgroup[tmp];
Block: 443
ProgElement 962: out_str_dec((char const   *)(C_int_decl), "yy_ec", csize);
ProgElement 963: i___0 = 1;
Block: 444
ProgElement 964: return;
Block: 445
ProgElement 965: indent_puts((char *)"if ( yy_act == 0 )");
ProgElement 966: indent_level ++;
ProgElement 967: indent_puts((char *)"{ /* have to back up */");
ProgElement 968: indent_puts((char *)"yy_cp = yy_last_accepting_cpos;");
ProgElement 969: indent_puts((char *)"yy_current_state = yy_last_accepting_state;");
ProgElement 970: indent_puts((char *)"yy_act = yy_accept[yy_current_state];");
ProgElement 971: indent_puts((char *)"}");
ProgElement 972: indent_level --;
Block: 446
ProgElement 973: indent_puts((char *)"yy_act = yy_accept[yy_current_state];");
Block: 447
ProgElement 974: indent_puts((char *)"}");
ProgElement 975: indent_level --;
ProgElement 976: indent_puts((char *)"--yy_cp;");
ProgElement 977: indent_puts((char *)"yy_current_state = *--yy_state_ptr;");
ProgElement 978: indent_puts((char *)"yy_lp = yy_accept[yy_current_state];");
ProgElement 979: indent_puts((char *)"}");
ProgElement 980: indent_level --;
Block: 448
ProgElement 981: indent_level ++;
ProgElement 982: indent_puts((char *)"{");
ProgElement 983: indent_puts((char *)"yy_full_match = yy_cp;");
ProgElement 984: indent_puts((char *)"break;");
ProgElement 985: indent_puts((char *)"}");
ProgElement 986: indent_level --;
Block: 449
ProgElement 987: indent_puts((char *)"}");
ProgElement 988: indent_level --;
ProgElement 989: indent_puts((char *)"else");
ProgElement 990: indent_level ++;
ProgElement 991: indent_puts((char *)"{");
ProgElement 992: indent_puts((char *)"yy_full_match = yy_cp;");
ProgElement 993: indent_puts((char *)"yy_full_state = yy_state_ptr;");
ProgElement 994: indent_puts((char *)"yy_full_lp = yy_lp;");
ProgElement 995: indent_puts((char *)"break;");
ProgElement 996: indent_puts((char *)"}");
ProgElement 997: indent_level --;
ProgElement 998: indent_puts((char *)"++yy_lp;");
ProgElement 999: indent_puts((char *)"goto find_rule;");
Block: 450
ProgElement 1000: indent_puts((char *)"yy_full_match = yy_cp;");
ProgElement 1001: indent_puts((char *)"yy_full_state = yy_state_ptr;");
ProgElement 1002: indent_puts((char *)"yy_full_lp = yy_lp;");
Block: 451
ProgElement 1003: indent_puts((char *)"if ( yy_act & YY_TRAILING_HEAD_MASK ||");
ProgElement 1004: indent_puts((char *)"     yy_looking_for_trail_begin )");
ProgElement 1005: indent_level ++;
ProgElement 1006: indent_puts((char *)"{");
ProgElement 1007: indent_puts((char *)"if ( yy_act == yy_looking_for_trail_begin )");
ProgElement 1008: indent_level ++;
ProgElement 1009: indent_puts((char *)"{");
ProgElement 1010: indent_puts((char *)"yy_looking_for_trail_begin = 0;");
ProgElement 1011: indent_puts((char *)"yy_act &= ~YY_TRAILING_HEAD_MASK;");
ProgElement 1012: indent_puts((char *)"break;");
ProgElement 1013: indent_puts((char *)"}");
ProgElement 1014: indent_level --;
ProgElement 1015: indent_puts((char *)"}");
ProgElement 1016: indent_level --;
ProgElement 1017: indent_puts((char *)"else if ( yy_act & YY_TRAILING_MASK )");
ProgElement 1018: indent_level ++;
ProgElement 1019: indent_puts((char *)"{");
ProgElement 1020: indent_puts((char *)"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;");
ProgElement 1021: indent_puts((char *)"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;");
Block: 452
ProgElement 1022: indent_puts((char *)"yy_current_state = *--yy_state_ptr;");
ProgElement 1023: indent_puts((char *)"yy_lp = yy_accept[yy_current_state];");
ProgElement 1024: outn("find_rule: /* we branch to this label when backing up */");
ProgElement 1025: indent_puts((char *)"for ( ; ; ) /* until we find what rule we matched */");
ProgElement 1026: indent_level ++;
ProgElement 1027: indent_puts((char *)"{");
ProgElement 1028: indent_puts((char *)"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )");
ProgElement 1029: indent_level ++;
ProgElement 1030: indent_puts((char *)"{");
ProgElement 1031: indent_puts((char *)"yy_act = yy_acclist[yy_lp];");
Block: 453
ProgElement 1032: indent_puts((char *)"yy_act = yy_accept[yy_current_state];");
Block: 454
ProgElement 1033: indent_puts((char *)"yy_act = yy_current_state[-1].yy_nxt;");
Block: 455
ProgElement 1034: return;
Block: 456
ProgElement 1035: genecs();
Block: 457
ProgElement 1036: dataend();
Block: 458
ProgElement 1037: i___0 ++;
Block: 459
ProgElement 1038: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"state # %d accepts: [%d]\n",
                i___0, anum);
Block: 460
ProgElement 1039: anum = (dfaacc + i___0)->dfaacc_state;
ProgElement 1040: mkdata(anum);
Block: 461
ProgElement 1041: out_str_dec((char const   *)tmp, "yy_accept", lastdfa + 1);
ProgElement 1042: (dfaacc + end_of_buffer_state)->dfaacc_state = end_of_buffer_action;
ProgElement 1043: i___0 = 1;
Block: 462
ProgElement 1044: tmp = C_short_decl;
Block: 463
ProgElement 1045: end_of_buffer_action = num_rules + 1;
Block: 464
ProgElement 1046: indent_puts((char *)"}");
ProgElement 1047: indent_level --;
ProgElement 1048: indent_puts((char *)"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];");
ProgElement 1049: return;
Block: 465
ProgElement 1050: do_indent();
ProgElement 1051: out_dec("if ( yy_current_state >= %d )\n", lastdfa + 2);
ProgElement 1052: indent_level ++;
ProgElement 1053: indent_puts((char *)"yy_c = yy_meta[(unsigned int) yy_c];");
ProgElement 1054: indent_level --;
Block: 466
ProgElement 1055: indent_put2s((char *)"register YY_CHAR yy_c = %s;", char_map);
ProgElement 1056: gen_backing_up();
ProgElement 1057: indent_puts((char *)"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )");
ProgElement 1058: indent_level ++;
ProgElement 1059: indent_puts((char *)"{");
ProgElement 1060: indent_puts((char *)"yy_current_state = (int) yy_def[yy_current_state];");
Block: 467
ProgElement 1061: return;
Block: 468
ProgElement 1062: indent_puts((char *)"yy_cp = yy_last_accepting_cpos;");
ProgElement 1063: indent_puts((char *)"yy_current_state = yy_last_accepting_state;");
Block: 469
ProgElement 1064: out_dec("while ( yy_current_state != %d );\n", jamstate);
Block: 470
ProgElement 1065: out_dec("while ( yy_base[yy_current_state] != %d );\n", jambase);
Block: 471
ProgElement 1066: indent_puts((char *)"do");
ProgElement 1067: indent_level ++;
ProgElement 1068: indent_puts((char *)"{");
ProgElement 1069: gen_next_state(0);
ProgElement 1070: indent_puts((char *)"++yy_cp;");
ProgElement 1071: indent_puts((char *)"}");
ProgElement 1072: indent_level --;
ProgElement 1073: do_indent();
Block: 472
ProgElement 1074: indent_level --;
ProgElement 1075: indent_puts((char *)"}");
Block: 473
ProgElement 1076: outc('\n');
ProgElement 1077: gen_backing_up();
ProgElement 1078: indent_puts((char *)"}");
Block: 474
ProgElement 1079: indent_puts((char *)"yy_current_state += yy_trans_info->yy_nxt;");
Block: 475
ProgElement 1080: indent_puts((char *)"{");
Block: 476
ProgElement 1081: indent_puts((char *)"{");
ProgElement 1082: indent_puts((char *)"register yyconst struct yy_trans_info *yy_trans_info;\n");
ProgElement 1083: indent_puts((char *)"register YY_CHAR yy_c;\n");
ProgElement 1084: indent_put2s((char *)"for ( yy_c = %s;", char_map);
ProgElement 1085: indent_puts((char *)"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->");
ProgElement 1086: indent_puts((char *)"yy_verify == yy_c;");
ProgElement 1087: indent_put2s((char *)"      yy_c = %s )", char_map_2);
ProgElement 1088: indent_level ++;
Block: 477
ProgElement 1089: indent_level --;
ProgElement 1090: outc('\n');
ProgElement 1091: indent_puts((char *)"yy_current_state = -yy_current_state;");
Block: 478
ProgElement 1092: indent_puts((char *)"}");
Block: 479
ProgElement 1093: indent_puts((char *)"++yy_cp;");
Block: 480
ProgElement 1094: indent_puts((char *)"{");
ProgElement 1095: gen_backing_up();
ProgElement 1096: outc('\n');
Block: 481
ProgElement 1097: indent_put2s((char *)"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
                 char_map);
ProgElement 1098: indent_level ++;
Block: 482
ProgElement 1099: char_map_2 = (char *)tmp___0;
Block: 483
ProgElement 1100: tmp___0 = "YY_SC_TO_UI(*++yy_cp)";
Block: 484
ProgElement 1101: tmp___0 = "yy_ec[YY_SC_TO_UI(*++yy_cp)]";
Block: 485
ProgElement 1102: char_map = (char *)tmp;
Block: 486
ProgElement 1103: tmp = "YY_SC_TO_UI(*yy_cp)";
Block: 487
ProgElement 1104: tmp = "yy_ec[YY_SC_TO_UI(*yy_cp)]";
Block: 488
ProgElement 1105: return;
Block: 489
ProgElement 1106: indent_puts((char *)"*yy_state_ptr++ = yy_current_state;");
Block: 490
ProgElement 1107: gen_backing_up();
Block: 491
ProgElement 1108: gen_backing_up();
Block: 492
ProgElement 1109: indent_puts((char *)"}");
ProgElement 1110: indent_level --;
ProgElement 1111: indent_puts((char *)"else");
ProgElement 1112: indent_level ++;
ProgElement 1113: indent_puts((char *)"yy_current_state = yy_NUL_trans[yy_current_state];");
ProgElement 1114: indent_level --;
Block: 493
ProgElement 1115: gen_next_compressed_state(char_map);
Block: 494
ProgElement 1116: indent_put2s((char *)"yy_current_state += yy_current_state[%s].yy_nxt;", char_map);
Block: 495
ProgElement 1117: indent_put2s((char *)"yy_current_state = yy_nxt[yy_current_state][%s];", char_map);
Block: 496
ProgElement 1118: indent_puts((char *)"if ( *yy_cp )");
ProgElement 1119: indent_level ++;
ProgElement 1120: indent_puts((char *)"{");
Block: 497
ProgElement 1121: gen_backing_up();
Block: 498
ProgElement 1122: strcpy((char * __restrict  )(char_map), (char const   * __restrict  )tmp);
Block: 499
ProgElement 1123: tmp = "YY_SC_TO_UI(*yy_cp)";
Block: 500
ProgElement 1124: tmp = "yy_ec[YY_SC_TO_UI(*yy_cp)]";
Block: 501
ProgElement 1125: sprintf((char * __restrict  )(char_map), (char const   * __restrict  )"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)",
                NUL_ec);
Block: 502
ProgElement 1126: sprintf((char * __restrict  )(char_map), (char const   * __restrict  )"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
                NUL_ec);
Block: 503
ProgElement 1127: return;
Block: 504
ProgElement 1128: outc('\n');
ProgElement 1129: indent_puts((char *)"if ( ! yy_is_jam )");
ProgElement 1130: indent_level ++;
ProgElement 1131: indent_puts((char *)"{");
ProgElement 1132: gen_backing_up();
ProgElement 1133: indent_puts((char *)"}");
ProgElement 1134: indent_level --;
Block: 505
ProgElement 1135: indent_puts((char *)"if ( ! yy_is_jam )");
ProgElement 1136: indent_level ++;
ProgElement 1137: indent_puts((char *)"*yy_state_ptr++ = yy_current_state;");
ProgElement 1138: indent_level --;
Block: 506
ProgElement 1139: sprintf((char * __restrict  )(NUL_ec_str), (char const   * __restrict  )"%d",
            NUL_ec);
ProgElement 1140: gen_next_compressed_state(NUL_ec_str);
ProgElement 1141: do_indent();
ProgElement 1142: out_dec("yy_is_jam = (yy_current_state == %d);\n", jamstate);
Block: 507
ProgElement 1143: do_indent();
ProgElement 1144: out_dec("register int yy_c = %d;\n", NUL_ec);
ProgElement 1145: indent_puts((char *)"register yyconst struct yy_trans_info *yy_trans_info;\n");
ProgElement 1146: indent_puts((char *)"yy_trans_info = &yy_current_state[(unsigned int) yy_c];");
ProgElement 1147: indent_puts((char *)"yy_current_state += yy_trans_info->yy_nxt;");
ProgElement 1148: indent_puts((char *)"yy_is_jam = (yy_trans_info->yy_verify != yy_c);");
Block: 508
ProgElement 1149: do_indent();
ProgElement 1150: out_dec("yy_current_state = yy_nxt[yy_current_state][%d];\n", NUL_ec);
ProgElement 1151: indent_puts((char *)"yy_is_jam = (yy_current_state <= 0);");
Block: 509
ProgElement 1152: indent_puts((char *)"yy_current_state = yy_NUL_trans[yy_current_state];");
ProgElement 1153: indent_puts((char *)"yy_is_jam = (yy_current_state == 0);");
Block: 510
ProgElement 1154: outc('\n');
Block: 511
ProgElement 1155: indent_puts((char *)"register char *yy_cp = yy_c_buf_p;");
Block: 512
ProgElement 1156: indent_puts((char *)"register char *yy_cp = yy_c_buf_p;");
Block: 513
ProgElement 1157: need_backing_up = tmp;
Block: 514
ProgElement 1158: tmp = 0;
Block: 515
ProgElement 1159: tmp = 0;
Block: 516
ProgElement 1160: tmp = 1;
Block: 517
ProgElement 1161: return;
Block: 518
ProgElement 1162: indent_puts((char *)"yy_state_ptr = yy_state_buf;");
ProgElement 1163: indent_puts((char *)"*yy_state_ptr++ = yy_current_state;");
Block: 519
ProgElement 1164: indent_puts((char *)"yy_current_state += YY_AT_BOL();");
Block: 520
ProgElement 1165: indent_puts((char *)"yy_current_state = yy_start;");
Block: 521
ProgElement 1166: indent_puts((char *)"yy_current_state = yy_start_state_list[yy_start];");
Block: 522
ProgElement 1167: indent_puts((char *)"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];");
Block: 523
ProgElement 1168: dataend();
ProgElement 1169: return;
Block: 524
ProgElement 1170: mkdata(*(chk + i___0));
ProgElement 1171: i___0 ++;
Block: 525
ProgElement 1172: nummt ++;
Block: 526
ProgElement 1173: out_str_dec((char const   *)tmp___8, "yy_chk", tblend + 1);
ProgElement 1174: i___0 = 1;
Block: 527
ProgElement 1175: tmp___8 = C_short_decl;
Block: 528
ProgElement 1176: tmp___8 = C_long_decl;
Block: 529
ProgElement 1177: dataend();
Block: 530
ProgElement 1178: mkdata(*(nxt + i___0));
ProgElement 1179: i___0 ++;
Block: 531
ProgElement 1180: *(nxt + i___0) = jamstate;
Block: 532
ProgElement 1181: *(nxt + i___0) = jamstate;
Block: 533
ProgElement 1182: out_str_dec((char const   *)tmp___7, "yy_nxt", tblend + 1);
ProgElement 1183: i___0 = 1;
Block: 534
ProgElement 1184: tmp___7 = C_short_decl;
Block: 535
ProgElement 1185: tmp___7 = C_long_decl;
Block: 536
ProgElement 1186: dataend();
Block: 537
ProgElement 1187: mkdata(*(def + i___0));
ProgElement 1188: i___0 ++;
Block: 538
ProgElement 1189: out_str_dec((char const   *)tmp___6, "yy_def", total_states + 1);
ProgElement 1190: i___0 = 1;
Block: 539
ProgElement 1191: tmp___6 = C_short_decl;
Block: 540
ProgElement 1192: tmp___6 = C_long_decl;
Block: 541
ProgElement 1193: dataend();
Block: 542
ProgElement 1194: mkdata(*(base + i___0));
ProgElement 1195: *(def + i___0) = jamstate;
ProgElement 1196: i___0 ++;
Block: 543
ProgElement 1197: mkdata(*(base + i___0));
ProgElement 1198: i___0 ++;
Block: 544
ProgElement 1199: mkdata(*(base + i___0));
ProgElement 1200: i___0 ++;
Block: 545
ProgElement 1201: tmpuses ++;
ProgElement 1202: *(def + i___0) = (lastdfa - d) + 1;
Block: 546
ProgElement 1203: *(def + i___0) = jamstate;
Block: 547
ProgElement 1204: *(base + i___0) = jambase;
Block: 548
ProgElement 1205: d = *(def + i___0);
Block: 549
ProgElement 1206: out_str_dec((char const   *)tmp___5, "yy_base", total_states + 1);
ProgElement 1207: i___0 = 1;
Block: 550
ProgElement 1208: tmp___5 = C_short_decl;
Block: 551
ProgElement 1209: tmp___5 = C_long_decl;
Block: 552
ProgElement 1210: total_states = lastdfa + numtemps;
Block: 553
ProgElement 1211: dataend();
Block: 554
ProgElement 1212: mkdata(tmp___4);
ProgElement 1213: i___0 ++;
Block: 555
ProgElement 1214: tmp___4 = tecbck[i___0];
Block: 556
ProgElement 1215: tmp___4 = - tecbck[i___0];
Block: 557
ProgElement 1216: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%d = %d\n",
                i___0, tmp___3);
Block: 558
ProgElement 1217: tmp___3 = tecbck[i___0];
Block: 559
ProgElement 1218: tmp___3 = - tecbck[i___0];
Block: 560
ProgElement 1219: out_str_dec((char const   *)(C_int_decl), "yy_meta", numecs + 1);
ProgElement 1220: i___0 = 1;
Block: 561
ProgElement 1221: fputs((char const   * __restrict  )"\n\nMeta-Equivalence Classes:\n", (FILE * __restrict  )err);
Block: 562
ProgElement 1222: genecs();
Block: 563
ProgElement 1223: dataend();
Block: 564
ProgElement 1224: mkdata(*(acc_array + i___0));
Block: 565
ProgElement 1225: mkdata(*(acc_array + i___0));
Block: 566
ProgElement 1226: i___0 ++;
Block: 567
ProgElement 1227: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"state # %d accepts: [%d]\n",
                  i___0, *(acc_array + i___0));
Block: 568
ProgElement 1228: mkdata(*(acc_array + i___0));
Block: 569
ProgElement 1229: out_str_dec((char const   *)tmp___2, "yy_accept", k);
ProgElement 1230: i___0 = 1;
Block: 570
ProgElement 1231: tmp___2 = C_short_decl;
Block: 571
ProgElement 1232: tmp___2 = C_long_decl;
Block: 572
ProgElement 1233: k ++;
Block: 573
ProgElement 1234: k = lastdfa + 2;
Block: 574
ProgElement 1235: *(acc_array + i___0) = 0;
Block: 575
ProgElement 1236: *(acc_array + i___0) = (dfaacc + i___0)->dfaacc_state;
ProgElement 1237: i___0 ++;
Block: 576
ProgElement 1238: (dfaacc + end_of_buffer_state)->dfaacc_state = end_of_buffer_action;
ProgElement 1239: i___0 = 1;
Block: 577
ProgElement 1240: *(acc_array + i___0) = j;
ProgElement 1241: dataend();
Block: 578
ProgElement 1242: i___0 ++;
Block: 579
ProgElement 1243: k ++;
Block: 580
ProgElement 1244: _IO_putc('\n', err);
Block: 581
ProgElement 1245: fputs((char const   * __restrict  )", ", (FILE * __restrict  )err);
Block: 582
ProgElement 1246: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"[%d]",
                    *(accset + k));
Block: 583
ProgElement 1247: mkdata(accnum);
Block: 584
ProgElement 1248: accnum |= 8192;
Block: 585
ProgElement 1249: accnum = *(accset + k);
ProgElement 1250: j ++;
Block: 586
ProgElement 1251: k = 1;
Block: 587
ProgElement 1252: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"state # %d accepts: ",
                  i___0);
Block: 588
ProgElement 1253: accset = (dfaacc + i___0)->dfaacc_set;
ProgElement 1254: nacc = *(accsiz + i___0);
Block: 589
ProgElement 1255: *(acc_array + i___0) = j;
Block: 590
ProgElement 1256: out_str_dec((char const   *)tmp___1, "yy_acclist", tmp___0 + 1);
ProgElement 1257: j = 1;
ProgElement 1258: i___0 = 1;
Block: 591
ProgElement 1259: tmp___1 = C_short_decl;
Block: 592
ProgElement 1260: tmp___1 = C_long_decl;
Block: 593
ProgElement 1261: tmp___0 = numas;
Block: 594
ProgElement 1262: EOB_accepting_list[0] = 0;
ProgElement 1263: EOB_accepting_list[1] = end_of_buffer_action;
ProgElement 1264: *(accsiz + end_of_buffer_state) = 1;
ProgElement 1265: (dfaacc + end_of_buffer_state)->dfaacc_set = EOB_accepting_list;
Block: 595
ProgElement 1266: end_of_buffer_action = num_rules + 1;
ProgElement 1267: tmp = allocate_array(current_max_dfas, sizeof(int ));
ProgElement 1268: acc_array = (int *)tmp;
ProgElement 1269: nummt = 0;
ProgElement 1270: num_backing_up ++;
Block: 596
ProgElement 1271: do_indent();
ProgElement 1272: out_str((char const   *)fmt, (char const   *)arg);
ProgElement 1273: outn("");
ProgElement 1274: return;
Block: 597
ProgElement 1275: do_indent();
ProgElement 1276: outn((char const   *)str);
ProgElement 1277: return;
Block: 598
ProgElement 1278: return;
Block: 599
ProgElement 1279: flexscan();
Block: 600
ProgElement 1280: skelout();
ProgElement 1281: line_directive_out(stdout, 1);
Block: 601
ProgElement 1282: indent_puts((char *)"if ( c == \'\\n\' )");
ProgElement 1283: indent_level ++;
ProgElement 1284: indent_puts((char *)"++yylineno;");
ProgElement 1285: indent_level --;
Block: 602
ProgElement 1286: indent_puts((char *)"if ( yy_current_buffer->yy_at_bol )");
ProgElement 1287: indent_level ++;
ProgElement 1288: indent_puts((char *)"++yylineno;");
ProgElement 1289: indent_level --;
Block: 603
ProgElement 1290: indent_puts((char *)"yy_current_buffer->yy_at_bol = (c == \'\\n\');");
Block: 604
ProgElement 1291: skelout();
Block: 605
ProgElement 1292: indent_puts((char *)"if ( c == \'\\n\' )");
ProgElement 1293: indent_level ++;
ProgElement 1294: indent_puts((char *)"--yylineno;");
ProgElement 1295: indent_level --;
Block: 606
ProgElement 1296: indent_level = 1;
ProgElement 1297: skelout();
ProgElement 1298: gen_start_state();
ProgElement 1299: indent_level = 2;
ProgElement 1300: skelout();
ProgElement 1301: gen_next_state(1);
ProgElement 1302: indent_level = 1;
ProgElement 1303: skelout();
ProgElement 1304: gen_NUL_trans();
ProgElement 1305: skelout();
Block: 607
ProgElement 1306: indent_puts((char *)"yy_cp = yy_c_buf_p;");
Block: 608
ProgElement 1307: indent_puts((char *)"yy_cp = yy_c_buf_p;");
Block: 609
ProgElement 1308: indent_puts((char *)"yy_cp = yy_last_accepting_cpos;");
ProgElement 1309: indent_puts((char *)"yy_current_state = yy_last_accepting_state;");
Block: 610
ProgElement 1310: indent_puts((char *)"yy_cp = yy_c_buf_p;");
Block: 611
ProgElement 1311: indent_puts((char *)"yy_cp = yy_c_buf_p;");
Block: 612
ProgElement 1312: skelout();
ProgElement 1313: indent_level = 4;
Block: 613
ProgElement 1314: indent_level ++;
ProgElement 1315: indent_puts((char *)"yyterminate();");
ProgElement 1316: indent_level --;
Block: 614
ProgElement 1317: i___0 ++;
Block: 615
ProgElement 1318: do_indent();
ProgElement 1319: out_str("case YY_STATE_EOF(%s):\n", (char const   *)*(scname + i___0));
ProgElement 1320: did_eof_rule = 1;
Block: 616
ProgElement 1321: skelout();
ProgElement 1322: indent_level ++;
ProgElement 1323: gen_bu_action();
ProgElement 1324: out((char const   *)(action_array + action_offset));
ProgElement 1325: line_directive_out(stdout, 0);
ProgElement 1326: i___0 = 1;
Block: 617
ProgElement 1327: indent_level --;
ProgElement 1328: indent_puts((char *)"}");
ProgElement 1329: indent_level --;
Block: 618
ProgElement 1330: indent_puts((char *)"fprintf( err, \"--EOF (start condition %d)\\n\", YY_START );");
Block: 619
ProgElement 1331: indent_puts((char *)tmp___2);
ProgElement 1332: indent_level --;
ProgElement 1333: do_indent();
ProgElement 1334: outn("else");
ProgElement 1335: indent_level ++;
Block: 620
ProgElement 1336: tmp___2 = "fprintf( err, \"--(end of buffer or a NUL)\\n\" );
Block: 621
ProgElement 1337: indent_level --;
ProgElement 1338: do_indent();
ProgElement 1339: out_dec("else if ( yy_act == %d )\n", num_rules + 1);
ProgElement 1340: indent_level ++;
Block: 622
ProgElement 1341: indent_puts((char *)"fprintf( err, \"--accepting default rule (\\\"%s\\\")\\n\",");
ProgElement 1342: indent_puts((char *)"         yytext );");
Block: 623
ProgElement 1343: indent_level --;
ProgElement 1344: do_indent();
ProgElement 1345: out_dec("else if ( yy_act == %d )\n", num_rules);
ProgElement 1346: indent_level ++;
Block: 624
ProgElement 1347: indent_puts((char *)"fprintf( err, \"--accepting rule at line %d (\\\"%s\\\")\\n\",");
ProgElement 1348: indent_puts((char *)"         yy_rule_linenum[yy_act], yytext );");
Block: 625
ProgElement 1349: indent_puts((char *)tmp___1);
ProgElement 1350: indent_level --;
ProgElement 1351: do_indent();
ProgElement 1352: out_dec("else if ( yy_act < %d )\n", num_rules);
ProgElement 1353: indent_level ++;
Block: 626
ProgElement 1354: tmp___1 = "fprintf( err, \"--scanner backing up\\n\" );
Block: 627
ProgElement 1355: indent_puts((char *)"if ( yy_flex_debug )");
ProgElement 1356: indent_level ++;
ProgElement 1357: indent_puts((char *)"{");
ProgElement 1358: indent_puts((char *)"if ( yy_act == 0 )");
ProgElement 1359: indent_level ++;
Block: 628
ProgElement 1360: skelout();
Block: 629
ProgElement 1361: indent_puts((char *)"if ( yy_act != YY_END_OF_BUFFER )");
ProgElement 1362: indent_level ++;
ProgElement 1363: indent_puts((char *)"{");
ProgElement 1364: indent_puts((char *)"int yyl;");
ProgElement 1365: indent_puts((char *)"for ( yyl = 0; yyl < yyleng; ++yyl )");
ProgElement 1366: indent_level ++;
ProgElement 1367: indent_puts((char *)"if ( yytext[yyl] == \'\\n\' )");
ProgElement 1368: indent_level ++;
ProgElement 1369: indent_puts((char *)"++yylineno;");
ProgElement 1370: indent_level --;
ProgElement 1371: indent_level --;
ProgElement 1372: indent_puts((char *)"}");
ProgElement 1373: indent_level --;
Block: 630
ProgElement 1374: skelout();
ProgElement 1375: gen_start_state();
ProgElement 1376: outn("yy_match:");
ProgElement 1377: gen_next_match();
ProgElement 1378: skelout();
ProgElement 1379: indent_level = 2;
ProgElement 1380: gen_find_action();
ProgElement 1381: skelout();
Block: 631
ProgElement 1382: indent_puts((char *)"yy_more_len = 0;");
ProgElement 1383: indent_puts((char *)"if ( yy_more_flag )");
ProgElement 1384: indent_level ++;
ProgElement 1385: indent_puts((char *)"{");
ProgElement 1386: indent_puts((char *)"yy_more_len = yy_c_buf_p - yytext_ptr;");
ProgElement 1387: indent_puts((char *)"yy_more_flag = 0;");
ProgElement 1388: indent_puts((char *)"}");
ProgElement 1389: indent_level --;
Block: 632
ProgElement 1390: indent_puts((char *)"YY_USER_ACTION");
ProgElement 1391: indent_level --;
ProgElement 1392: skelout();
ProgElement 1393: out((char const   *)(action_array + prolog_offset));
ProgElement 1394: line_directive_out(stdout, 0);
ProgElement 1395: skelout();
ProgElement 1396: indent_level = 2;
Block: 633
ProgElement 1397: indent_puts((char *)"if ( yyleng > 0 ) \\");
ProgElement 1398: indent_level ++;
ProgElement 1399: indent_puts((char *)"yy_current_buffer->yy_at_bol = \\");
ProgElement 1400: indent_puts((char *)"\t\t(yytext[yyleng - 1] == \'\\n\'); \\");
ProgElement 1401: indent_level --;
Block: 634
ProgElement 1402: skelout();
ProgElement 1403: indent_puts((char *)"#define YY_RULE_SETUP \\");
ProgElement 1404: indent_level ++;
Block: 635
ProgElement 1405: outn("\tif ( yy_current_buffer->yy_is_interactive ) \\");
ProgElement 1406: outn("\t\t{ \\");
ProgElement 1407: outn("\t\tint c = \'*\', n; \\");
ProgElement 1408: outn("\t\tfor ( n = 0; n < max_size && \\");
ProgElement 1409: outn("\t\t\t     (c = getc( yyin )) != EOF && c != \'\\n\'; ++n ) \\");
ProgElement 1410: outn("\t\t\tbuf[n] = (char) c; \\");
ProgElement 1411: outn("\t\tif ( c == \'\\n\' ) \\");
ProgElement 1412: outn("\t\t\tbuf[n++] = (char) c; \\");
ProgElement 1413: outn("\t\tif ( c == EOF && ferror( yyin ) ) \\");
ProgElement 1414: outn("\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
ProgElement 1415: outn("\t\tresult = n; \\");
ProgElement 1416: outn("\t\t} \\");
ProgElement 1417: outn("\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\");
ProgElement 1418: outn("\t\t  && ferror( yyin ) ) \\");
ProgElement 1419: outn("\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );");
Block: 636
ProgElement 1420: outn("\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\");
ProgElement 1421: outn("\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );");
Block: 637
ProgElement 1422: out((char const   *)(action_array + defs1_offset));
ProgElement 1423: line_directive_out(stdout, 0);
ProgElement 1424: skelout();
Block: 638
ProgElement 1425: outn("char *yytext;");
Block: 639
ProgElement 1426: outn("#ifndef YYLMAX");
ProgElement 1427: outn("#define YYLMAX 8192");
ProgElement 1428: outn("#endif\n");
ProgElement 1429: outn("char yytext[YYLMAX];");
ProgElement 1430: outn("char *yytext_ptr;");
Block: 640
ProgElement 1431: indent_puts((char *)"#define yymore() yymore_used_but_not_detected");
ProgElement 1432: indent_puts((char *)"#define YY_MORE_ADJ 0");
ProgElement 1433: indent_puts((char *)"#define YY_RESTORE_YY_MORE_OFFSET");
Block: 641
ProgElement 1434: indent_puts((char *)"#define yymore() (yy_more_flag = 1)");
ProgElement 1435: indent_puts((char *)"#define YY_MORE_ADJ yy_more_len");
ProgElement 1436: indent_puts((char *)"#define YY_RESTORE_YY_MORE_OFFSET");
Block: 642
ProgElement 1437: indent_puts((char *)"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))");
ProgElement 1438: indent_puts((char *)"#define YY_NEED_STRLEN");
ProgElement 1439: indent_puts((char *)"#define YY_MORE_ADJ 0");
ProgElement 1440: indent_puts((char *)"#define YY_RESTORE_YY_MORE_OFFSET \\");
ProgElement 1441: indent_level ++;
ProgElement 1442: indent_puts((char *)"{ \\");
ProgElement 1443: indent_puts((char *)"yy_more_offset = yy_prev_more_offset; \\");
ProgElement 1444: indent_puts((char *)"yyleng -= yy_more_offset; \\");
ProgElement 1445: indent_puts((char *)"}");
ProgElement 1446: indent_level --;
Block: 643
ProgElement 1447: indent_puts((char *)"static int yy_more_flag = 0;");
ProgElement 1448: indent_puts((char *)"static int yy_more_len = 0;");
Block: 644
ProgElement 1449: indent_puts((char *)"static int yy_more_offset = 0;");
ProgElement 1450: indent_puts((char *)"static int yy_prev_more_offset = 0;");
Block: 645
ProgElement 1451: outn("/* The intent behind this definition is that it\'ll catch");
ProgElement 1452: outn(" * any uses of REJECT which flex missed.");
ProgElement 1453: outn(" */");
ProgElement 1454: outn("#define REJECT reject_used_but_not_detected");
Block: 646
ProgElement 1455: outn("++yy_lp; \\");
ProgElement 1456: outn("goto find_rule; \\");
ProgElement 1457: outn("}");
Block: 647
ProgElement 1458: outn("yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\");
ProgElement 1459: outn("yy_state_ptr = yy_full_state; /* restore orig. state */ \\");
ProgElement 1460: outn("yy_current_state = *yy_state_ptr; /* restore curr. state */ \\");
Block: 648
ProgElement 1461: outn("#define REJECT \\");
ProgElement 1462: outn("{ \\");
ProgElement 1463: outn("*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\");
ProgElement 1464: outn("yy_cp = yy_full_match; /* restore poss. backed-over text */ \\");
Block: 649
ProgElement 1465: out_hex("#define YY_TRAILING_MASK 0x%x\n", 8192U);
ProgElement 1466: out_hex("#define YY_TRAILING_HEAD_MASK 0x%x\n", 16384U);
Block: 650
ProgElement 1467: outn("static int yy_looking_for_trail_begin = 0;");
ProgElement 1468: outn("static int yy_full_lp;");
ProgElement 1469: outn("static int *yy_full_state;");
Block: 651
ProgElement 1470: outn("static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;");
ProgElement 1471: outn("static char *yy_full_match;");
ProgElement 1472: outn("static int yy_lp;");
Block: 652
ProgElement 1473: dataend();
Block: 653
ProgElement 1474: mkdata(*(rule_linenum + i___0));
ProgElement 1475: i___0 ++;
Block: 654
ProgElement 1476: out_str_dec((char const   *)tmp___0, "yy_rule_linenum", num_rules);
ProgElement 1477: i___0 = 1;
Block: 655
ProgElement 1478: tmp___0 = C_short_decl;
Block: 656
ProgElement 1479: tmp___0 = C_long_decl;
Block: 657
ProgElement 1480: indent_puts((char *)"extern int yy_flex_debug;");
ProgElement 1481: indent_puts((char *)"int yy_flex_debug = 1;\n");
Block: 658
ProgElement 1482: dataend();
Block: 659
ProgElement 1483: i___0 ++;
Block: 660
ProgElement 1484: mkdata(*(nultrans + i___0));
Block: 661
ProgElement 1485: out_str_dec((char const   *)(C_state_decl), "yy_NUL_trans", lastdfa + 1);
ProgElement 1486: i___0 = 1;
Block: 662
ProgElement 1487: indent_puts((char *)"static yy_state_type yy_last_accepting_state;");
ProgElement 1488: indent_puts((char *)"static char *yy_last_accepting_cpos;\n");
Block: 663
ProgElement 1489: gentabs();
Block: 664
ProgElement 1490: genftbl();
Block: 665
ProgElement 1491: genctbl();
Block: 666
ProgElement 1492: indent_put2s((char *)"%s yy_nxt;", trans_offset_type);
ProgElement 1493: indent_puts((char *)"};");
ProgElement 1494: indent_level --;
Block: 667
ProgElement 1495: indent_puts((char *)"short yy_verify;");
Block: 668
ProgElement 1496: indent_puts((char *)"long yy_verify;");
Block: 669
ProgElement 1497: trans_offset_type = (char *)tmp;
ProgElement 1498: indent_level = 0;
ProgElement 1499: indent_puts((char *)"struct yy_trans_info");
ProgElement 1500: indent_level ++;
ProgElement 1501: indent_puts((char *)"{");
Block: 670
ProgElement 1502: tmp = "short";
Block: 671
ProgElement 1503: tmp = "long";
Block: 672
ProgElement 1504: total_table_size = (tblend + numecs) + 1;
Block: 673
ProgElement 1505: indent_level = 0;
ProgElement 1506: skelout();
ProgElement 1507: out_dec("#define YY_NUM_RULES %d\n", num_rules);
ProgElement 1508: out_dec("#define YY_END_OF_BUFFER %d\n", num_rules + 1);
Block: 674
ProgElement 1509: indent_puts((char *)"yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\");
ProgElement 1510: indent_puts((char *)"yyleng += yy_more_offset; \\");
ProgElement 1511: indent_puts((char *)"yy_prev_more_offset = yy_more_offset; \\");
ProgElement 1512: indent_puts((char *)"yy_more_offset = 0; \\");
Block: 675
ProgElement 1513: indent_level ++;
ProgElement 1514: indent_puts((char *)"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\");
ProgElement 1515: indent_level --;
Block: 676
ProgElement 1516: indent_puts((char *)"if ( yyleng + yy_more_offset >= YYLMAX ) \\");
Block: 677
ProgElement 1517: skelout();
Block: 678
ProgElement 1518: indent_puts((char *)"yyleng = (int) (yy_cp - yy_bp); \\");
Block: 679
ProgElement 1519: indent_puts((char *)"yyleng = (int) (yy_cp - yy_bp); \\");
Block: 680
ProgElement 1520: indent_puts((char *)"yytext_ptr -= yy_more_len; \\");
ProgElement 1521: indent_puts((char *)"yyleng = (int) (yy_cp - yytext_ptr); \\");
Block: 681
ProgElement 1522: did_eof_rule = 0;
ProgElement 1523: skelout();
ProgElement 1524: indent_level = 1;
Block: 682
ProgElement 1525: sprintf((char * __restrict  )(buf), (char const   * __restrict  )"#define %s %d\n",
          defname, value);
ProgElement 1526: add_action(buf);
ProgElement 1527: return;
Block: 683
ProgElement 1528: tmp = strlen((char const   *)defname);
Block: 684
ProgElement 1529: strcpy((char * __restrict  )(action_array + action_index), (char const   * __restrict  )new_text);
ProgElement 1530: action_index += len;
ProgElement 1531: return;
Block: 685
ProgElement 1532: tmp___0 = reallocate_array((void *)action_array, action_size, sizeof(char ));
ProgElement 1533: action_array = (char *)tmp___0;
Block: 686
ProgElement 1534: action_size = new_size;
Block: 687
ProgElement 1535: new_size = action_size * 2;
Block: 688
ProgElement 1536: tmp = strlen((char const   *)new_text);
ProgElement 1537: len = (int )tmp;
Block: 689
ProgElement 1538: return (mem);
Block: 690
ProgElement 1539: num_bytes = element_size * (size_t )size;
ProgElement 1540: mem = flex_alloc(num_bytes);
Block: 691
ProgElement 1541: return (1);
Block: 692
ProgElement 1542: str ++;
Block: 693
ProgElement 1543: tmp = __ctype_b_loc();
Block: 694
ProgElement 1544: return (1);
Block: 695
ProgElement 1545: str ++;
Block: 696
ProgElement 1546: tmp = __ctype_b_loc();
Block: 697
ProgElement 1547: return;
Block: 698
ProgElement 1548: i___0 --;
Block: 699
ProgElement 1549: j ++;
Block: 700
ProgElement 1550: k = *(v + j);
ProgElement 1551: *(v + j) = *(v + (j + 1));
ProgElement 1552: *(v + (j + 1)) = k;
Block: 701
ProgElement 1553: j = 1;
Block: 702
ProgElement 1554: i___0 = n;
Block: 703
ProgElement 1555: return;
Block: 704
ProgElement 1556: tmp___0 = readable_form(c);
ProgElement 1557: lerrsf("scanner requires -8 flag to use the character %s", (char const   *)tmp___0);
Block: 705
ProgElement 1558: return ((unsigned char )tmp___1);
Block: 706
ProgElement 1559: tmp___0 = tolower(c);
ProgElement 1560: tmp___1 = tmp___0;
Block: 707
ProgElement 1561: tmp___2 = __ctype_b_loc();
Block: 708
ProgElement 1562: return (copy);
Block: 709
ProgElement 1563: tmp___0 = c2;
ProgElement 1564: c2 ++;
ProgElement 1565: tmp___2 = str;
ProgElement 1566: str ++;
ProgElement 1567: tmp___1 = (char )*tmp___2;
ProgElement 1568: *tmp___0 = tmp___1;
Block: 710
ProgElement 1569: c2 = copy;
Block: 711
ProgElement 1570: size = (unsigned int )((unsigned long )((c1 - str) + 1L) * sizeof(char ));
ProgElement 1571: tmp = flex_alloc((size_t )size);
ProgElement 1572: copy = (char *)tmp;
Block: 712
ProgElement 1573: c1 ++;
Block: 713
ProgElement 1574: c1 = str;
Block: 714
ProgElement 1575: return (copy);
Block: 715
ProgElement 1576: tmp___0 = c;
ProgElement 1577: c ++;
ProgElement 1578: tmp___2 = str;
ProgElement 1579: str ++;
ProgElement 1580: tmp___1 = *tmp___2;
ProgElement 1581: *tmp___0 = tmp___1;
Block: 716
ProgElement 1582: tmp = allocate_array((int )((c - str) + 1L), sizeof(unsigned char ));
ProgElement 1583: copy = (unsigned char *)tmp;
ProgElement 1584: c = copy;
Block: 717
ProgElement 1585: c ++;
Block: 718
ProgElement 1586: c = str;
Block: 719
ProgElement 1587: return;
Block: 720
ProgElement 1588: gap /= 2;
Block: 721
ProgElement 1589: i___0 ++;
Block: 722
ProgElement 1590: k = *(v + j);
ProgElement 1591: *(v + j) = *(v + jg);
ProgElement 1592: *(v + jg) = k;
ProgElement 1593: j -= gap;
Block: 723
ProgElement 1594: jg = j + gap;
Block: 724
ProgElement 1595: j = i___0 - gap;
Block: 725
ProgElement 1596: i___0 = gap;
Block: 726
ProgElement 1597: gap = n / 2;
Block: 727
ProgElement 1598: outn("    } ;\n");
ProgElement 1599: dataline = 0;
ProgElement 1600: datapos = 0;
ProgElement 1601: return;
Block: 728
ProgElement 1602: dataflush();
Block: 729
ProgElement 1603: datapos = 0;
ProgElement 1604: return;
Block: 730
ProgElement 1605: outc('\n');
ProgElement 1606: dataline = 0;
Block: 731
ProgElement 1607: outc('\n');
ProgElement 1608: dataline ++;
Block: 732
ProgElement 1609: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%s: %s\n", program_name,
          msg);
ProgElement 1610: flexend(1);
ProgElement 1611: return;
Block: 733
ProgElement 1612: sscanf((char const   * __restrict  )((char *)str), (char const   * __restrict  )"%x",
         & result);
ProgElement 1613: return ((int )result);
Block: 734
ProgElement 1614: sprintf((char * __restrict  )(errmsg), (char const   * __restrict  )msg, arg);
ProgElement 1615: flexerror((char const   *)(errmsg));
ProgElement 1616: return;
Block: 735
ProgElement 1617: sprintf((char * __restrict  )(errmsg), (char const   * __restrict  )msg, arg);
ProgElement 1618: flexerror((char const   *)(errmsg));
ProgElement 1619: return;
Block: 736
ProgElement 1620: return;
Block: 737
ProgElement 1621: add_action(directive);
Block: 738
ProgElement 1622: fputs((char const   * __restrict  )(directive), (FILE * __restrict  )output_file);
Block: 739
ProgElement 1623: sprintf((char * __restrict  )(directive), (char const   * __restrict  )(line_fmt),
            out_linenum, filename);
Block: 740
ProgElement 1624: out_linenum ++;
Block: 741
ProgElement 1625: sprintf((char * __restrict  )(directive), (char const   * __restrict  )(line_fmt),
            linenum, filename);
Block: 742
ProgElement 1626: *s2 = (char )'\000';
Block: 743
ProgElement 1627: tmp___0 = s2;
ProgElement 1628: s2 ++;
ProgElement 1629: tmp___1 = s1;
ProgElement 1630: s1 ++;
ProgElement 1631: *tmp___0 = *tmp___1;
Block: 744
ProgElement 1632: s2 = filename;
ProgElement 1633: s3 = & filename[sizeof(filename) - 2UL];
Block: 745
ProgElement 1634: s1 = outfilename;
Block: 746
ProgElement 1635: s1 = infilename;
Block: 747
ProgElement 1636: return;
Block: 748
ProgElement 1637: return;
Block: 749
ProgElement 1638: defs1_offset = 0;
ProgElement 1639: tmp = action_index;
ProgElement 1640: action_index ++;
ProgElement 1641: *(action_array + tmp) = (char )'\000';
ProgElement 1642: prolog_offset = action_index;
ProgElement 1643: action_offset = prolog_offset;
ProgElement 1644: *(action_array + action_index) = (char )'\000';
ProgElement 1645: return;
Block: 750
ProgElement 1646: tmp = action_index;
ProgElement 1647: action_index ++;
ProgElement 1648: *(action_array + tmp) = (char )'\000';
ProgElement 1649: action_offset = action_index;
ProgElement 1650: *(action_array + action_index) = (char )'\000';
ProgElement 1651: return;
Block: 751
ProgElement 1652: datapos ++;
ProgElement 1653: out_dec("%5d", value);
ProgElement 1654: return;
Block: 752
ProgElement 1655: outc(',');
Block: 753
ProgElement 1656: out("    ");
Block: 754
ProgElement 1657: outc(',');
ProgElement 1658: dataflush();
Block: 755
ProgElement 1659: datapos ++;
ProgElement 1660: out_dec("%5d", value);
ProgElement 1661: return;
Block: 756
ProgElement 1662: outc(',');
Block: 757
ProgElement 1663: out("    ");
Block: 758
ProgElement 1664: outc(',');
ProgElement 1665: dataflush();
Block: 759
ProgElement 1666: val = 0;
ProgElement 1667: sscanf((char const   * __restrict  )array, (char const   * __restrict  )"%d", & val);
ProgElement 1668: return (val);
Block: 760
ProgElement 1669: return (*(array + 1));
Block: 761
ProgElement 1670: c = *(array + sptr___0);
ProgElement 1671: *(array + sptr___0) = (unsigned char )'\000';
ProgElement 1672: tmp___2 = htoi(array + 2);
ProgElement 1673: esc_char = (unsigned char )tmp___2;
ProgElement 1674: *(array + sptr___0) = c;
ProgElement 1675: return (esc_char);
Block: 762
ProgElement 1676: sptr___0 ++;
Block: 763
ProgElement 1677: tmp___1 = __ctype_b_loc();
Block: 764
ProgElement 1678: sptr___0 = 2;
Block: 765
ProgElement 1679: c = *(array + sptr);
ProgElement 1680: *(array + sptr) = (unsigned char )'\000';
ProgElement 1681: tmp___0 = otoi(array + 1);
ProgElement 1682: esc_char = (unsigned char )tmp___0;
ProgElement 1683: *(array + sptr) = c;
ProgElement 1684: return (esc_char);
Block: 766
ProgElement 1685: sptr ++;
Block: 767
ProgElement 1686: tmp = __ctype_b_loc();
Block: 768
ProgElement 1687: sptr = 1;
Block: 769
ProgElement 1688: return ((unsigned char )'\v');
Block: 770
ProgElement 1689: return ((unsigned char )'\a');
Block: 771
ProgElement 1690: return ((unsigned char )'\t');
Block: 772
ProgElement 1691: return ((unsigned char )'\r');
Block: 773
ProgElement 1692: return ((unsigned char )'\n');
Block: 774
ProgElement 1693: return ((unsigned char )'\f');
Block: 775
ProgElement 1694: return ((unsigned char )'\b');
Block: 776
ProgElement 1695: sscanf((char const   * __restrict  )((char *)str), (char const   * __restrict  )"%o",
         & result);
ProgElement 1696: return ((int )result);
Block: 777
ProgElement 1697: fputs((char const   * __restrict  )str, (FILE * __restrict  )stdout);
ProgElement 1698: out_line_count(str);
ProgElement 1699: return;
Block: 778
ProgElement 1700: printf((char const   * __restrict  )fmt, n);
ProgElement 1701: out_line_count(fmt);
ProgElement 1702: return;
Block: 779
ProgElement 1703: printf((char const   * __restrict  )fmt, n1, n2);
ProgElement 1704: out_line_count(fmt);
ProgElement 1705: return;
Block: 780
ProgElement 1706: printf((char const   * __restrict  )fmt, x);
ProgElement 1707: out_line_count(fmt);
ProgElement 1708: return;
Block: 781
ProgElement 1709: return;
Block: 782
ProgElement 1710: i___0 ++;
Block: 783
ProgElement 1711: out_linenum ++;
Block: 784
ProgElement 1712: i___0 = 0;
Block: 785
ProgElement 1713: printf((char const   * __restrict  )fmt, str);
ProgElement 1714: out_line_count(fmt);
ProgElement 1715: out_line_count(str);
ProgElement 1716: return;
Block: 786
ProgElement 1717: printf((char const   * __restrict  )fmt, s1, s2, s3);
ProgElement 1718: out_line_count(fmt);
ProgElement 1719: out_line_count(s1);
ProgElement 1720: out_line_count(s2);
ProgElement 1721: out_line_count(s3);
ProgElement 1722: return;
Block: 787
ProgElement 1723: printf((char const   * __restrict  )fmt, str, n);
ProgElement 1724: out_line_count(fmt);
ProgElement 1725: out_line_count(str);
ProgElement 1726: return;
Block: 788
ProgElement 1727: return;
Block: 789
ProgElement 1728: out_linenum ++;
Block: 790
ProgElement 1729: _IO_putc(c, stdout);
Block: 791
ProgElement 1730: puts(str);
ProgElement 1731: out_line_count(str);
ProgElement 1732: out_linenum ++;
ProgElement 1733: return;
Block: 792
ProgElement 1734: rform[0] = (char )c;
ProgElement 1735: rform[1] = (char )'\000';
ProgElement 1736: return (rform);
Block: 793
ProgElement 1737: return ((char *)"\' \'");
Block: 794
ProgElement 1738: sprintf((char * __restrict  )(rform), (char const   * __restrict  )"\\%.3o", (unsigned int )c);
ProgElement 1739: return (rform);
Block: 795
ProgElement 1740: return ((char *)"\\v");
Block: 796
ProgElement 1741: return ((char *)"\\a");
Block: 797
ProgElement 1742: return ((char *)"\\t");
Block: 798
ProgElement 1743: return ((char *)"\\r");
Block: 799
ProgElement 1744: return ((char *)"\\n");
Block: 800
ProgElement 1745: return ((char *)"\\f");
Block: 801
ProgElement 1746: return ((char *)"\\b");
Block: 802
ProgElement 1747: return (new_array);
Block: 803
ProgElement 1748: num_bytes = element_size * (size_t )size;
ProgElement 1749: new_array = flex_realloc(array, num_bytes);
Block: 804
ProgElement 1750: return;
Block: 805
ProgElement 1751: outn((char const   *)buf);
Block: 806
ProgElement 1752: out((char const   *)buf);
Block: 807
ProgElement 1753: do_copy = 1;
ProgElement 1754: goto switch_break;
Block: 808
ProgElement 1755: do_copy = ! C_plus_plus;
ProgElement 1756: goto switch_break;
Block: 809
ProgElement 1757: do_copy = C_plus_plus;
ProgElement 1758: goto switch_break;
Block: 810
ProgElement 1759: return;
Block: 811
ProgElement 1760: tmp___0 = skel_ind;
ProgElement 1761: skel_ind ++;
ProgElement 1762: buf = (char *)skel[tmp___0];
ProgElement 1763: tmp___1 = (unsigned long )buf != (unsigned long )((char *)0);
Block: 812
ProgElement 1764: tmp = fgets((char * __restrict  )buf, 2048, (FILE * __restrict  )skelfile);
ProgElement 1765: tmp___1 = (unsigned long )tmp != (unsigned long )((void *)0);
Block: 813
ProgElement 1766: buf = buf_storage;
ProgElement 1767: do_copy = 1;
Block: 814
ProgElement 1768: return;
Block: 815
ProgElement 1769: datapos = 0;
Block: 816
ProgElement 1770: outc('\n');
Block: 817
ProgElement 1771: outc('\n');
ProgElement 1772: dataline ++;
Block: 818
ProgElement 1773: out_dec2(" {%4d,%4d },", element_v, element_n);
ProgElement 1774: datapos += 14;
Block: 819
ProgElement 1775: return;
Block: 820
ProgElement 1776: tmp = rp;
ProgElement 1777: rp ++;
ProgElement 1778: *tmp = (char)0;
Block: 821
ProgElement 1779: rp = region_ptr;
ProgElement 1780: rp_end = region_ptr + size_in_bytes;
Block: 822
ProgElement 1781: return;
Block: 823
ProgElement 1782: tmp = mkstate(257);
ProgElement 1783: astate = tmp;
ProgElement 1784: *(accptnum + astate) = accepting_number;
ProgElement 1785: link_machines(mach, astate);
Block: 824
ProgElement 1786: *(accptnum + *(finalst + mach)) = accepting_number;
Block: 825
ProgElement 1787: return (copy);
Block: 826
ProgElement 1788: tmp = dupmachine(singl);
ProgElement 1789: copy = link_machines(copy, tmp);
ProgElement 1790: i___0 ++;
Block: 827
ProgElement 1791: copy = mkstate(257);
ProgElement 1792: i___0 = 1;
Block: 828
ProgElement 1793: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"********** end of dump\n");
ProgElement 1794: return;
Block: 829
ProgElement 1795: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\n");
ProgElement 1796: ns ++;
Block: 830
ProgElement 1797: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"  [%d]", anum);
Block: 831
ProgElement 1798: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"state # %4d\t",
            ns);
ProgElement 1799: sym = *(transchar + ns);
ProgElement 1800: tsp1 = *(trans1 + ns);
ProgElement 1801: tsp2 = *(trans2 + ns);
ProgElement 1802: anum = *(accptnum + ns);
ProgElement 1803: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%3d:  %4d, %4d",
            sym, tsp1, tsp2);
Block: 832
ProgElement 1804: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\n\n********** beginning dump of nfa with start state %d\n",
          state1);
ProgElement 1805: ns = 1;
Block: 833
ProgElement 1806: state_offset = (state - i___0) + 1;
ProgElement 1807: init = mach + state_offset;
ProgElement 1808: *(firstst + init) = *(firstst + mach) + state_offset;
ProgElement 1809: *(finalst + init) = *(finalst + mach) + state_offset;
ProgElement 1810: *(lastst + init) = *(lastst + mach) + state_offset;
ProgElement 1811: return (init);
Block: 834
ProgElement 1812: *(accptnum + state) = *(accptnum + i___0);
ProgElement 1813: i___0 ++;
Block: 835
ProgElement 1814: state = mkstate(*(transchar + i___0));
Block: 836
ProgElement 1815: state = 0;
ProgElement 1816: last = *(lastst + mach);
ProgElement 1817: i___0 = *(firstst + mach);
Block: 837
ProgElement 1818: line_directive_out((FILE *)0, 1);
ProgElement 1819: return;
Block: 838
ProgElement 1820: add_action((char *)"YY_RULE_SETUP\n");
Block: 839
ProgElement 1821: add_action((char *)"YY_DO_BEFORE_ACTION; /* set up yytext again */\n");
Block: 840
ProgElement 1822: sprintf((char * __restrict  )(action_text), (char const   * __restrict  )"%s -= %d;\n",
                scanner_cp, trailcnt___0);
ProgElement 1823: add_action(action_text);
Block: 841
ProgElement 1824: sprintf((char * __restrict  )(action_text), (char const   * __restrict  )"%s = %s + %d;\n",
                scanner_cp, scanner_bp, headcnt___0);
ProgElement 1825: add_action(action_text);
Block: 842
ProgElement 1826: scanner_cp = (char *)"yy_c_buf_p = yy_cp";
ProgElement 1827: scanner_bp = (char *)"yy_bp";
ProgElement 1828: add_action((char *)"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n");
Block: 843
ProgElement 1829: *(rule_type + num_rules) = 0;
Block: 844
ProgElement 1830: variable_trailing_context_rules = 1;
Block: 845
ProgElement 1831: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"Variable trailing context rule at line %d\n",
              *(rule_linenum + num_rules));
Block: 846
ProgElement 1832: *(rule_type + num_rules) = 1;
Block: 847
ProgElement 1833: sprintf((char * __restrict  )(action_text), (char const   * __restrict  )"case %d:\n",
          num_rules);
ProgElement 1834: add_action(action_text);
Block: 848
ProgElement 1835: (*(rule_linenum + num_rules)) --;
Block: 849
ProgElement 1836: add_accept(mach, num_rules);
ProgElement 1837: *(rule_linenum + num_rules) = linenum;
Block: 850
ProgElement 1838: return (first);
Block: 851
ProgElement 1839: *(firstst + first) = *(firstst + last);
Block: 852
ProgElement 1840: *(firstst + first) = *(firstst + first);
Block: 853
ProgElement 1841: *(lastst + first) = *(lastst + last);
Block: 854
ProgElement 1842: *(lastst + first) = *(lastst + first);
Block: 855
ProgElement 1843: mkxtion(*(finalst + first), last);
ProgElement 1844: *(finalst + first) = *(finalst + last);
Block: 856
ProgElement 1845: return;
Block: 857
ProgElement 1846: *(state_type + mach) = 1;
Block: 858
ProgElement 1847: eps___0 = mkstate(257);
ProgElement 1848: mkxtion(eps___0, first);
ProgElement 1849: mkxtion(eps___0, second);
ProgElement 1850: return (eps___0);
Block: 859
ProgElement 1851: tmp = mkposcl(state);
ProgElement 1852: tmp___0 = mkopt(tmp);
ProgElement 1853: return (tmp___0);
Block: 860
ProgElement 1854: eps___0 = mkstate(257);
ProgElement 1855: mach = link_machines(eps___0, mach);
ProgElement 1856: mkxtion(mach, *(finalst + mach));
ProgElement 1857: return (mach);
Block: 861
ProgElement 1858: eps___0 = mkstate(257);
ProgElement 1859: mach = link_machines(mach, eps___0);
Block: 862
ProgElement 1860: eps___0 = mkstate(257);
ProgElement 1861: mach = link_machines(mach, eps___0);
Block: 863
ProgElement 1862: *(finalst + first) = orend;
ProgElement 1863: return (first);
Block: 864
ProgElement 1864: eps___0 = mkstate(257);
ProgElement 1865: first = link_machines(first, eps___0);
ProgElement 1866: orend = *(finalst + first);
ProgElement 1867: mkxtion(*(finalst + second), orend);
Block: 865
ProgElement 1868: orend = *(finalst + second);
ProgElement 1869: mkxtion(*(finalst + first), orend);
Block: 866
ProgElement 1870: orend = *(finalst + first);
ProgElement 1871: mkxtion(*(finalst + second), orend);
Block: 867
ProgElement 1872: eps___0 = mkstate(257);
ProgElement 1873: first = link_machines(eps___0, first);
ProgElement 1874: mkxtion(first, second);
Block: 868
ProgElement 1875: eps___0 = mkstate(257);
ProgElement 1876: mkxtion(eps___0, state);
ProgElement 1877: tmp = link_machines(state, eps___0);
ProgElement 1878: return (tmp);
Block: 869
ProgElement 1879: return (mach);
Block: 870
ProgElement 1880: tmp___2 = link_machines(base_mach, tail);
ProgElement 1881: mach = link_machines(mach, tmp___2);
Block: 871
ProgElement 1882: copy = dupmachine(mach);
ProgElement 1883: tmp___1 = link_machines(copy, tail);
ProgElement 1884: tail = mkopt(tmp___1);
ProgElement 1885: i___0 ++;
Block: 872
ProgElement 1886: tail = mkstate(257);
ProgElement 1887: i___0 = lb;
Block: 873
ProgElement 1888: copy = dupmachine(mach);
ProgElement 1889: tmp = mkclos(copy);
ProgElement 1890: tmp___0 = link_machines(base_mach, tmp);
ProgElement 1891: mach = link_machines(mach, tmp___0);
Block: 874
ProgElement 1892: base_mach = copysingl(mach, lb - 1);
Block: 875
ProgElement 1893: return (lastnfa);
Block: 876
ProgElement 1894: mkechar(tmp___8, nextecm, ecgroup);
Block: 877
ProgElement 1895: tmp___8 = csize;
Block: 878
ProgElement 1896: tmp___8 = sym;
Block: 879
ProgElement 1897: check_char(sym);
Block: 880
ProgElement 1898: numeps ++;
Block: 881
ProgElement 1899: *(firstst + lastnfa) = lastnfa;
ProgElement 1900: *(finalst + lastnfa) = lastnfa;
ProgElement 1901: *(lastst + lastnfa) = lastnfa;
ProgElement 1902: *(transchar + lastnfa) = sym;
ProgElement 1903: *(trans1 + lastnfa) = 0;
ProgElement 1904: *(trans2 + lastnfa) = 0;
ProgElement 1905: *(accptnum + lastnfa) = 0;
ProgElement 1906: *(assoc_rule + lastnfa) = num_rules;
ProgElement 1907: *(state_type + lastnfa) = current_state_type;
Block: 882
ProgElement 1908: num_reallocs ++;
ProgElement 1909: tmp = reallocate_array((void *)firstst, current_mns, sizeof(int ));
ProgElement 1910: firstst = (int *)tmp;
ProgElement 1911: tmp___0 = reallocate_array((void *)lastst, current_mns, sizeof(int ));
ProgElement 1912: lastst = (int *)tmp___0;
ProgElement 1913: tmp___1 = reallocate_array((void *)finalst, current_mns, sizeof(int ));
ProgElement 1914: finalst = (int *)tmp___1;
ProgElement 1915: tmp___2 = reallocate_array((void *)transchar, current_mns, sizeof(int ));
ProgElement 1916: transchar = (int *)tmp___2;
ProgElement 1917: tmp___3 = reallocate_array((void *)trans1, current_mns, sizeof(int ));
ProgElement 1918: trans1 = (int *)tmp___3;
ProgElement 1919: tmp___4 = reallocate_array((void *)trans2, current_mns, sizeof(int ));
ProgElement 1920: trans2 = (int *)tmp___4;
ProgElement 1921: tmp___5 = reallocate_array((void *)accptnum, current_mns, sizeof(int ));
ProgElement 1922: accptnum = (int *)tmp___5;
ProgElement 1923: tmp___6 = reallocate_array((void *)assoc_rule, current_mns, sizeof(int ));
ProgElement 1924: assoc_rule = (int *)tmp___6;
ProgElement 1925: tmp___7 = reallocate_array((void *)state_type, current_mns, sizeof(int ));
ProgElement 1926: state_type = (int *)tmp___7;
Block: 883
ProgElement 1927: current_mns += 1000;
Block: 884
ProgElement 1928: lastnfa ++;
Block: 885
ProgElement 1929: return;
Block: 886
ProgElement 1930: eps2 ++;
ProgElement 1931: *(trans2 + statefrom) = stateto;
Block: 887
ProgElement 1932: *(trans1 + statefrom) = stateto;
Block: 888
ProgElement 1933: *(rule_linenum + num_rules) = linenum;
ProgElement 1934: *(rule_useful + num_rules) = 0;
ProgElement 1935: return;
Block: 889
ProgElement 1936: num_reallocs ++;
ProgElement 1937: current_max_rules += 100;
ProgElement 1938: tmp = reallocate_array((void *)rule_type, current_max_rules, sizeof(int ));
ProgElement 1939: rule_type = (int *)tmp;
ProgElement 1940: tmp___0 = reallocate_array((void *)rule_linenum, current_max_rules, sizeof(int ));
ProgElement 1941: rule_linenum = (int *)tmp___0;
ProgElement 1942: tmp___1 = reallocate_array((void *)rule_useful, current_max_rules, sizeof(int ));
ProgElement 1943: rule_useful = (int *)tmp___1;
Block: 890
ProgElement 1944: num_rules ++;
Block: 891
ProgElement 1945: new_entry->prev = (struct hash_entry *)((void *)0);
ProgElement 1946: new_entry->name = sym;
ProgElement 1947: new_entry->str_val = str_def;
ProgElement 1948: new_entry->int_val = int_def;
ProgElement 1949: *(table + hash_val) = new_entry;
ProgElement 1950: return (0);
Block: 892
ProgElement 1951: new_entry->next = (struct hash_entry *)((void *)0);
Block: 893
ProgElement 1952: new_entry->next = successor;
ProgElement 1953: successor->prev = new_entry;
Block: 894
ProgElement 1954: successor = *(table + hash_val);
Block: 895
ProgElement 1955: tmp___1 = flex_alloc(sizeof(struct hash_entry ));
ProgElement 1956: new_entry = (struct hash_entry *)tmp___1;
Block: 896
ProgElement 1957: sym_entry = sym_entry->next;
Block: 897
ProgElement 1958: return (-1);
Block: 898
ProgElement 1959: tmp___0 = strcmp((char const   *)sym, (char const   *)sym_entry->name);
Block: 899
ProgElement 1960: tmp = hashfunct(sym, table_size);
ProgElement 1961: hash_val = tmp;
ProgElement 1962: sym_entry = *(table + hash_val);
Block: 900
ProgElement 1963: tmp = copy_unsigned_string(ccltxt);
ProgElement 1964: addsym((char *)tmp, (char *)0, cclnum, ccltab, 101);
ProgElement 1965: return;
Block: 901
ProgElement 1966: tmp = findsym((char *)ccltxt, ccltab, 101);
ProgElement 1967: return (tmp->int_val);
Block: 902
ProgElement 1968: return (& empty_entry);
Block: 903
ProgElement 1969: sym_entry = sym_entry->next;
Block: 904
ProgElement 1970: return (sym_entry);
Block: 905
ProgElement 1971: tmp___0 = strcmp((char const   *)sym, (char const   *)sym_entry->name);
Block: 906
ProgElement 1972: tmp = hashfunct(sym, table_size);
ProgElement 1973: sym_entry = *(table + tmp);
Block: 907
ProgElement 1974: return (hashval);
Block: 908
ProgElement 1975: tmp = locstr;
ProgElement 1976: locstr ++;
ProgElement 1977: hashval = (hashval << 1) + (int )((unsigned char )*(str + tmp));
ProgElement 1978: hashval %= hash_size;
Block: 909
ProgElement 1979: hashval = 0;
ProgElement 1980: locstr = 0;
Block: 910
ProgElement 1981: return;
Block: 911
ProgElement 1982: synerr((char *)"name defined twice");
Block: 912
ProgElement 1983: tmp = copy_unsigned_string(definition);
ProgElement 1984: tmp___0 = copy_string((char const   *)name);
ProgElement 1985: tmp___1 = addsym(tmp___0, (char *)tmp, 0, ndtbl, 101);
Block: 913
ProgElement 1986: tmp = findsym(nd, ndtbl, 101);
ProgElement 1987: return ((unsigned char *)tmp->str_val);
Block: 914
ProgElement 1988: *(scset + lastsc) = mkstate(257);
ProgElement 1989: *(scbol + lastsc) = mkstate(257);
ProgElement 1990: *(scxclu + lastsc) = xcluflg___0;
ProgElement 1991: *(sceof + lastsc) = 0;
ProgElement 1992: return;
Block: 915
ProgElement 1993: *(scname + lastsc) = copy_string((char const   *)str);
ProgElement 1994: tmp = addsym(*(scname + lastsc), (char *)0, lastsc, sctbl, 101);
Block: 916
ProgElement 1995: action_define(str, lastsc);
ProgElement 1996: lastsc ++;
Block: 917
ProgElement 1997: tmp = findsym(str, sctbl, 101);
ProgElement 1998: return (tmp->int_val);
Block: 918
ProgElement 1999: return;
Block: 919
ProgElement 2000: mv2front(minprot);
Block: 920
ProgElement 2001: mkprot(state, statenum, comstate);
Block: 921
ProgElement 2002: mkentry(extrct[extptr], numecs, statenum, prottbl[minprot], mindiff);
Block: 922
ProgElement 2003: mkprot(state, statenum, comstate);
ProgElement 2004: mkentry(state, numecs, statenum, -32766, totaltrans);
Block: 923
ProgElement 2005: mktemplate(state, statenum, comstate);
Block: 924
ProgElement 2006: i___0 = protnext[i___0];
Block: 925
ProgElement 2007: extptr = 1 - extptr;
ProgElement 2008: mindiff = d;
ProgElement 2009: minprot = i___0;
Block: 926
ProgElement 2010: d = tbldiff(state, i___0, extrct[1 - extptr]);
Block: 927
ProgElement 2011: i___0 = minprot;
Block: 928
ProgElement 2012: minprot = firstprot;
ProgElement 2013: mindiff = tbldiff(state, minprot, extrct[extptr]);
Block: 929
ProgElement 2014: comstate = 0;
Block: 930
ProgElement 2015: i___0 = protnext[i___0];
Block: 931
ProgElement 2016: minprot = i___0;
ProgElement 2017: mindiff = tbldiff(state, minprot, extrct[extptr]);
ProgElement 2018: goto while_break;
Block: 932
ProgElement 2019: i___0 = firstprot;
Block: 933
ProgElement 2020: checkcom = comfreq * 100 > totaltrans * 50;
ProgElement 2021: minprot = firstprot;
ProgElement 2022: mindiff = totaltrans;
Block: 934
ProgElement 2023: mkentry(state, numecs, statenum, -32766, totaltrans);
Block: 935
ProgElement 2024: extptr = 0;
Block: 936
ProgElement 2025: return;
Block: 937
ProgElement 2026: mkentry(tmp, nummecs, (lastdfa + i___0) + 1, -32766, totaltrans);
ProgElement 2027: i___0 ++;
Block: 938
ProgElement 2028: j ++;
Block: 939
ProgElement 2029: totaltrans ++;
Block: 940
ProgElement 2030: *(tmp + j) = trans;
Block: 941
ProgElement 2031: totaltrans ++;
Block: 942
ProgElement 2032: *(tmp + tecbck[j]) = trans;
Block: 943
ProgElement 2033: trans = *(tnxt + (numecs * i___0 + j));
Block: 944
ProgElement 2034: totaltrans = 0;
ProgElement 2035: j = 1;
Block: 945
ProgElement 2036: i___0 = 1;
Block: 946
ProgElement 2037: nummecs = numecs;
Block: 947
ProgElement 2038: nummecs = cre8ecs(tecfwd, tecbck, numecs);
Block: 948
ProgElement 2039: tmp = tmpstorage;
ProgElement 2040: peakpairs = numtemps * numecs + tblend;
Block: 949
ProgElement 2041: old_max = current_max_xpairs;
ProgElement 2042: current_max_xpairs += 2000;
ProgElement 2043: num_reallocs ++;
ProgElement 2044: tmp = reallocate_array((void *)nxt, current_max_xpairs, sizeof(int ));
ProgElement 2045: nxt = (int *)tmp;
ProgElement 2046: tmp___0 = reallocate_array((void *)chk, current_max_xpairs, sizeof(int ));
ProgElement 2047: chk = (int *)tmp___0;
ProgElement 2048: zero_out((char *)(chk + old_max), 2000UL * sizeof(int ));
ProgElement 2049: return;
Block: 950
ProgElement 2050: i___0 ++;
Block: 951
ProgElement 2051: return (i___0);
Block: 952
ProgElement 2052: chk_ptr ++;
Block: 953
ProgElement 2053: tmp = state_ptr;
ProgElement 2054: state_ptr ++;
Block: 954
ProgElement 2055: state_ptr = state + 1;
ProgElement 2056: ptr_to_last_entry_in_state = chk + ((i___0 + numecs) + 1);
ProgElement 2057: chk_ptr = chk + (i___0 + 1);
Block: 955
ProgElement 2058: firstfree = i___0 + 1;
Block: 956
ProgElement 2059: expand_nxt_chk();
Block: 957
ProgElement 2060: i___0 ++;
Block: 958
ProgElement 2061: i___0 += 2;
Block: 959
ProgElement 2062: i___0 = firstfree;
Block: 960
ProgElement 2063: i___0 = tblend - numecs;
Block: 961
ProgElement 2064: return;
Block: 962
ProgElement 2065: tecfwd[numecs] = 0;
Block: 963
ProgElement 2066: tecbck[i___0] = i___0 - 1;
ProgElement 2067: tecfwd[i___0 - 1] = i___0;
ProgElement 2068: i___0 ++;
Block: 964
ProgElement 2069: tecbck[1] = 0;
ProgElement 2070: i___0 = 2;
Block: 965
ProgElement 2071: zero_out((char *)chk, (unsigned long )current_max_xpairs * sizeof(int ));
ProgElement 2072: tblend = 0;
ProgElement 2073: firstfree = tblend + 1;
ProgElement 2074: numtemps = 0;
Block: 966
ProgElement 2075: jambase = tblend;
ProgElement 2076: *(base + jamstate) = jambase;
ProgElement 2077: *(def + jamstate) = 0;
ProgElement 2078: tblend += numecs;
ProgElement 2079: numtemps ++;
ProgElement 2080: return;
Block: 967
ProgElement 2081: *(nxt + (tblend + i___0)) = 0;
ProgElement 2082: *(chk + (tblend + i___0)) = jamstate;
ProgElement 2083: i___0 ++;
Block: 968
ProgElement 2084: *(nxt + tblend) = end_of_buffer_state;
ProgElement 2085: *(chk + tblend) = jamstate;
ProgElement 2086: i___0 = 1;
Block: 969
ProgElement 2087: expand_nxt_chk();
Block: 970
ProgElement 2088: jamstate = lastdfa + 1;
ProgElement 2089: tblend ++;
Block: 971
ProgElement 2090: return;
Block: 972
ProgElement 2091: tblend = tbllast;
Block: 973
ProgElement 2092: tblend = tblend;
Block: 974
ProgElement 2093: firstfree ++;
Block: 975
ProgElement 2094: firstfree ++;
Block: 976
ProgElement 2095: i___0 ++;
Block: 977
ProgElement 2096: *(nxt + (tblbase + i___0)) = *(state + i___0);
ProgElement 2097: *(chk + (tblbase + i___0)) = statenum;
Block: 978
ProgElement 2098: *(base + statenum) = tblbase;
ProgElement 2099: *(def + statenum) = deflink;
ProgElement 2100: i___0 = minec;
Block: 979
ProgElement 2101: expand_nxt_chk();
Block: 980
ProgElement 2102: tblbase = baseaddr - minec;
ProgElement 2103: tbllast = tblbase + maxec;
Block: 981
ProgElement 2104: baseaddr = minec;
Block: 982
ProgElement 2105: baseaddr = tblend + 1;
Block: 983
ProgElement 2106: i___0 ++;
Block: 984
ProgElement 2107: i___0 = minec - 1;
Block: 985
ProgElement 2108: expand_nxt_chk();
Block: 986
ProgElement 2109: baseaddr ++;
Block: 987
ProgElement 2110: baseaddr ++;
Block: 988
ProgElement 2111: i___0 = minec;
Block: 989
ProgElement 2112: baseaddr ++;
Block: 990
ProgElement 2113: baseaddr ++;
Block: 991
ProgElement 2114: baseaddr = firstfree;
Block: 992
ProgElement 2115: maxec --;
Block: 993
ProgElement 2116: maxec = numchars;
Block: 994
ProgElement 2117: stack1(statenum, minec, *(state + minec), deflink);
ProgElement 2118: return;
Block: 995
ProgElement 2119: minec ++;
Block: 996
ProgElement 2120: minec = 1;
Block: 997
ProgElement 2121: *(def + statenum) = deflink;
ProgElement 2122: return;
Block: 998
ProgElement 2123: *(base + statenum) = 0;
Block: 999
ProgElement 2124: *(base + statenum) = -32766;
Block: 1000
ProgElement 2125: return;
Block: 1001
ProgElement 2126: tmp = firstfree;
ProgElement 2127: firstfree ++;
ProgElement 2128: tblend = tmp;
Block: 1002
ProgElement 2129: *(base + state) = firstfree - sym;
ProgElement 2130: *(def + state) = onedef___0;
ProgElement 2131: *(chk + firstfree) = state;
ProgElement 2132: *(nxt + firstfree) = onenxt;
Block: 1003
ProgElement 2133: firstfree ++;
Block: 1004
ProgElement 2134: firstfree = sym;
Block: 1005
ProgElement 2135: return;
Block: 1006
ProgElement 2136: protsave[tblbase + i___0] = *(state + i___0);
ProgElement 2137: i___0 ++;
Block: 1007
ProgElement 2138: firstprot = slot;
ProgElement 2139: prottbl[slot] = statenum;
ProgElement 2140: protcomst[slot] = comstate;
ProgElement 2141: tblbase = numecs * (slot - 1);
ProgElement 2142: i___0 = 1;
Block: 1008
ProgElement 2143: protprev[firstprot] = slot;
Block: 1009
ProgElement 2144: protnext[slot] = firstprot;
Block: 1010
ProgElement 2145: slot = numprots;
Block: 1011
ProgElement 2146: numprots ++;
Block: 1012
ProgElement 2147: mkprot(tnxt + tmpbase, - numtemps, comstate);
ProgElement 2148: numdiff = tbldiff(state, firstprot, tmp);
ProgElement 2149: mkentry(tmp, numecs, statenum, - numtemps, numdiff);
ProgElement 2150: return;
Block: 1013
ProgElement 2151: mkeccl(transset, tsptr, tecfwd, tecbck, numecs, 0);
Block: 1014
ProgElement 2152: i___0 ++;
Block: 1015
ProgElement 2153: tmp___1 = tsptr;
ProgElement 2154: tsptr ++;
ProgElement 2155: transset[tmp___1] = (unsigned char )i___0;
ProgElement 2156: *(tnxt + (tmpbase + i___0)) = comstate;
Block: 1016
ProgElement 2157: *(tnxt + (tmpbase + i___0)) = 0;
Block: 1017
ProgElement 2158: i___0 = 1;
Block: 1018
ProgElement 2159: numtemps ++;
ProgElement 2160: tsptr = 0;
ProgElement 2161: tmpbase = numtemps * numecs;
Block: 1019
ProgElement 2162: return;
Block: 1020
ProgElement 2163: protprev[qelm] = 0;
ProgElement 2164: protnext[qelm] = firstprot;
ProgElement 2165: protprev[firstprot] = qelm;
ProgElement 2166: firstprot = qelm;
Block: 1021
ProgElement 2167: protprev[protnext[qelm]] = protprev[qelm];
Block: 1022
ProgElement 2168: protnext[protprev[qelm]] = protnext[qelm];
Block: 1023
ProgElement 2169: lastprot = protprev[lastprot];
Block: 1024
ProgElement 2170: return;
Block: 1025
ProgElement 2171: tblend = position + numecs;
Block: 1026
ProgElement 2172: i___0 ++;
ProgElement 2173: state_ptr ++;
Block: 1027
ProgElement 2174: *(chk + (position + i___0)) = i___0;
ProgElement 2175: *(nxt + (position + i___0)) = *state_ptr;
Block: 1028
ProgElement 2176: tmp = find_table_space(state, transnum);
ProgElement 2177: position = tmp;
ProgElement 2178: *(base + statenum) = position;
ProgElement 2179: *(chk + (position - 1)) = 1;
ProgElement 2180: *(chk + position) = 1;
ProgElement 2181: state_ptr = state + 1;
ProgElement 2182: i___0 = 1;
Block: 1029
ProgElement 2183: return;
Block: 1030
ProgElement 2184: onesp ++;
ProgElement 2185: onestate[onesp] = statenum;
ProgElement 2186: onesym[onesp] = sym;
ProgElement 2187: onenext[onesp] = nextstate;
ProgElement 2188: onedef[onesp] = deflink;
Block: 1031
ProgElement 2189: return (numdiff);
Block: 1032
ProgElement 2190: i___0 --;
Block: 1033
ProgElement 2191: ep ++;
ProgElement 2192: *ep = *sp;
ProgElement 2193: numdiff ++;
Block: 1034
ProgElement 2194: ep ++;
ProgElement 2195: *ep = -1;
Block: 1035
ProgElement 2196: protp ++;
ProgElement 2197: sp ++;
Block: 1036
ProgElement 2198: sp = state;
ProgElement 2199: ep = ext;
ProgElement 2200: numdiff = 0;
ProgElement 2201: protp = & protsave[numecs * (pr - 1)];
ProgElement 2202: i___0 = numecs;
Block: 1037
ProgElement 2203: return (toktype);
Block: 1038
ProgElement 2204: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"End Marker\n");
ProgElement 2205: goto switch_break;
Block: 1039
ProgElement 2206: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"<<EOF>>");
ProgElement 2207: goto switch_break;
Block: 1040
ProgElement 2208: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"[%d]", yylval);
ProgElement 2209: goto switch_break;
Block: 1041
ProgElement 2210: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%d", yylval);
ProgElement 2211: goto switch_break;
Block: 1042
ProgElement 2212: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\\%.3o", (unsigned int )yylval);
Block: 1043
ProgElement 2213: _IO_putc(yylval, err);
Block: 1044
ProgElement 2214: tmp = __ctype_b_loc();
Block: 1045
ProgElement 2215: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\\%.3o", (unsigned int )yylval);
Block: 1046
ProgElement 2216: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\\%c", yylval);
ProgElement 2217: goto switch_break___0;
Block: 1047
ProgElement 2218: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\'%s\'", nmstr);
ProgElement 2219: goto switch_break;
Block: 1048
ProgElement 2220: beglin = 1;
Block: 1049
ProgElement 2221: fputs((char const   * __restrict  )"%%\n", (FILE * __restrict  )err);
Block: 1050
ProgElement 2222: fputs((char const   * __restrict  )"%x", (FILE * __restrict  )err);
ProgElement 2223: goto switch_break;
Block: 1051
ProgElement 2224: fputs((char const   * __restrict  )"%s", (FILE * __restrict  )err);
ProgElement 2225: goto switch_break;
Block: 1052
ProgElement 2226: beglin = 1;
Block: 1053
ProgElement 2227: _IO_putc('\n', err);
Block: 1054
ProgElement 2228: _IO_putc(toktype, err);
ProgElement 2229: goto switch_break;
Block: 1055
ProgElement 2230: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"%d\t", num_rules + 1);
ProgElement 2231: beglin = 0;
Block: 1056
ProgElement 2232: toktype = 0;
Block: 1057
ProgElement 2233: eofseen = 1;
Block: 1058
ProgElement 2234: toktype = flexscan();
Block: 1059
ProgElement 2235: return (1);
Block: 1060
ProgElement 2236: return (0);
Block: 1061
ProgElement 2237: yyvsp ++;
ProgElement 2238: *yyvsp = yylval;
ProgElement 2239: yystate = yyn;
ProgElement 2240: goto yynewstate;
Block: 1062
ProgElement 2241: yyn = (int )yytable[yyn];
Block: 1063
ProgElement 2242: yyn ++;
Block: 1064
ProgElement 2243: yyn = (int )yypact[yystate];
Block: 1065
ProgElement 2244: yyvsp --;
ProgElement 2245: yyssp --;
ProgElement 2246: yystate = (int )*yyssp;
Block: 1066
ProgElement 2247: yyerrstatus = 3;
ProgElement 2248: goto yyerrhandle;
Block: 1067
ProgElement 2249: yychar = -2;
Block: 1068
ProgElement 2250: yynerrs ++;
ProgElement 2251: yyerror((char *)"parse error");
Block: 1069
ProgElement 2252: yystate = (int )yydefgoto[yyn - 48];
Block: 1070
ProgElement 2253: yystate = (int )yydefgoto[yyn - 48];
Block: 1071
ProgElement 2254: yystate = (int )yytable[yystate];
Block: 1072
ProgElement 2255: yyvsp -= yylen;
ProgElement 2256: yyssp -= yylen;
ProgElement 2257: yyvsp ++;
ProgElement 2258: *yyvsp = yyval;
ProgElement 2259: yyn = (int )yyr1[yyn];
ProgElement 2260: yystate = (int )((int const   )yypgoto[yyn - 48] + (int const   )*yyssp);
Block: 1073
ProgElement 2261: yyval = mkstate(257);
ProgElement 2262: goto switch_break;
Block: 1074
ProgElement 2263: rulelen ++;
ProgElement 2264: tmp___26 = mkstate(*(yyvsp + 0));
ProgElement 2265: yyval = link_machines(*(yyvsp + -1), tmp___26);
ProgElement 2266: goto switch_break;
Block: 1075
ProgElement 2267: c___11 ++;
Block: 1076
ProgElement 2268: ccladd(currccl, c___11);
Block: 1077
ProgElement 2269: tmp___24 = __ctype_b_loc();
Block: 1078
ProgElement 2270: c___11 = 0;
Block: 1079
ProgElement 2271: c___10 ++;
Block: 1080
ProgElement 2272: ccladd(currccl, c___10);
Block: 1081
ProgElement 2273: tmp___23 = __ctype_b_loc();
Block: 1082
ProgElement 2274: c___10 = 0;
Block: 1083
ProgElement 2275: c___8 ++;
Block: 1084
ProgElement 2276: ccladd(currccl, c___8);
Block: 1085
ProgElement 2277: tmp___21 = __ctype_b_loc();
Block: 1086
ProgElement 2278: c___8 = 0;
Block: 1087
ProgElement 2279: c___7 ++;
Block: 1088
ProgElement 2280: ccladd(currccl, c___7);
Block: 1089
ProgElement 2281: tmp___20 = __ctype_b_loc();
Block: 1090
ProgElement 2282: c___7 = 0;
Block: 1091
ProgElement 2283: c___5 ++;
Block: 1092
ProgElement 2284: ccladd(currccl, c___5);
Block: 1093
ProgElement 2285: tmp___18 = __ctype_b_loc();
Block: 1094
ProgElement 2286: c___5 = 0;
Block: 1095
ProgElement 2287: c___2 ++;
Block: 1096
ProgElement 2288: ccladd(currccl, c___2);
Block: 1097
ProgElement 2289: tmp___15 = __ctype_b_loc();
Block: 1098
ProgElement 2290: c___2 = 0;
Block: 1099
ProgElement 2291: c___1 ++;
Block: 1100
ProgElement 2292: ccladd(currccl, c___1);
Block: 1101
ProgElement 2293: ccladd(currccl, c___1);
Block: 1102
ProgElement 2294: c___1 = 0;
Block: 1103
ProgElement 2295: c ++;
Block: 1104
ProgElement 2296: ccladd(currccl, c);
Block: 1105
ProgElement 2297: tmp___13 = __ctype_b_loc();
Block: 1106
ProgElement 2298: c = 0;
Block: 1107
ProgElement 2299: cclsorted = 1;
ProgElement 2300: lastchar = 0;
ProgElement 2301: yyval = cclinit();
ProgElement 2302: currccl = yyval;
ProgElement 2303: goto switch_break;
Block: 1108
ProgElement 2304: cclsorted = 0;
ProgElement 2305: yyval = *(yyvsp + -1);
ProgElement 2306: goto switch_break;
Block: 1109
ProgElement 2307: cclsorted = tmp___12;
ProgElement 2308: lastchar = *(yyvsp + 0);
ProgElement 2309: yyval = *(yyvsp + -1);
ProgElement 2310: goto switch_break;
Block: 1110
ProgElement 2311: tmp___12 = 0;
Block: 1111
ProgElement 2312: tmp___12 = 0;
Block: 1112
ProgElement 2313: tmp___12 = 1;
Block: 1113
ProgElement 2314: ccladd(*(yyvsp + -1), *(yyvsp + 0));
Block: 1114
ProgElement 2315: yyval = *(yyvsp + -3);
ProgElement 2316: goto switch_break;
Block: 1115
ProgElement 2317: cclsorted = tmp___10;
ProgElement 2318: lastchar = *(yyvsp + 0);
Block: 1116
ProgElement 2319: tmp___10 = 0;
Block: 1117
ProgElement 2320: tmp___10 = 0;
Block: 1118
ProgElement 2321: tmp___10 = 1;
Block: 1119
ProgElement 2322: ccladd(*(yyvsp + -3), i);
ProgElement 2323: i ++;
Block: 1120
ProgElement 2324: i = *(yyvsp + -2);
Block: 1121
ProgElement 2325: synerr((char *)"negative range in character class");
Block: 1122
ProgElement 2326: cclnegate(*(yyvsp + -1));
ProgElement 2327: yyval = *(yyvsp + -1);
ProgElement 2328: goto switch_break;
Block: 1123
ProgElement 2329: yyval = *(yyvsp + -1);
ProgElement 2330: goto switch_break;
Block: 1124
ProgElement 2331: yyval = mkstate(*(yyvsp + 0));
ProgElement 2332: goto switch_break;
Block: 1125
ProgElement 2333: rulelen ++;
Block: 1126
ProgElement 2334: yyval = *(yyvsp + -1);
ProgElement 2335: goto switch_break;
Block: 1127
ProgElement 2336: yyval = *(yyvsp + -1);
ProgElement 2337: goto switch_break;
Block: 1128
ProgElement 2338: rulelen ++;
ProgElement 2339: yyval = mkstate(- *(yyvsp + 0));
ProgElement 2340: goto switch_break;
Block: 1129
ProgElement 2341: rulelen ++;
ProgElement 2342: yyval = mkstate(- *(yyvsp + 0));
ProgElement 2343: goto switch_break;
Block: 1130
ProgElement 2344: mkeccl(ccltbl + *(cclmap + *(yyvsp + 0)), *(ccllen + *(yyvsp + 0)), nextecm, ecgroup,
           csize, csize);
Block: 1131
ProgElement 2345: cshell(ccltbl + *(cclmap + *(yyvsp + 0)), *(ccllen + *(yyvsp + 0)), 1);
Block: 1132
ProgElement 2346: rulelen ++;
ProgElement 2347: yyval = mkstate(- anyccl);
ProgElement 2348: goto switch_break;
Block: 1133
ProgElement 2349: madeany = 1;
Block: 1134
ProgElement 2350: mkeccl(ccltbl + *(cclmap + anyccl), *(ccllen + anyccl), nextecm, ecgroup, csize,
             csize);
Block: 1135
ProgElement 2351: anyccl = cclinit();
ProgElement 2352: ccladd(anyccl, '\n');
ProgElement 2353: cclnegate(anyccl);
Block: 1136
ProgElement 2354: tmp___6 = copysingl(*(yyvsp + -3), *(yyvsp + -1) - 1);
ProgElement 2355: yyval = link_machines(*(yyvsp + -3), tmp___6);
Block: 1137
ProgElement 2356: varlength = 1;
Block: 1138
ProgElement 2357: yyval = mkrep(*(yyvsp + -4), *(yyvsp + -2), -1);
Block: 1139
ProgElement 2358: varlength = 1;
Block: 1140
ProgElement 2359: yyval = mkrep(*(yyvsp + -5), *(yyvsp + -3), *(yyvsp + -1));
Block: 1141
ProgElement 2360: varlength = 1;
Block: 1142
ProgElement 2361: varlength = 1;
ProgElement 2362: yyval = mkopt(*(yyvsp + -1));
ProgElement 2363: goto switch_break;
Block: 1143
ProgElement 2364: varlength = 1;
ProgElement 2365: yyval = mkposcl(*(yyvsp + -1));
ProgElement 2366: goto switch_break;
Block: 1144
ProgElement 2367: varlength = 1;
ProgElement 2368: yyval = mkclos(*(yyvsp + -1));
ProgElement 2369: goto switch_break;
Block: 1145
ProgElement 2370: yyval = *(yyvsp + 0);
ProgElement 2371: goto switch_break;
Block: 1146
ProgElement 2372: yyval = link_machines(*(yyvsp + -1), *(yyvsp + 0));
ProgElement 2373: goto switch_break;
Block: 1147
ProgElement 2374: rulelen = 0;
ProgElement 2375: current_state_type = 2;
ProgElement 2376: yyval = *(yyvsp + -1);
ProgElement 2377: goto switch_break;
Block: 1148
ProgElement 2378: headcnt = rulelen;
Block: 1149
ProgElement 2379: varlength = 0;
Block: 1150
ProgElement 2380: trlcontxt = 1;
Block: 1151
ProgElement 2381: yyval = *(yyvsp + 0);
ProgElement 2382: goto switch_break;
Block: 1152
ProgElement 2383: varlength = 1;
ProgElement 2384: yyval = mkor(*(yyvsp + -2), *(yyvsp + 0));
ProgElement 2385: goto switch_break;
Block: 1153
ProgElement 2386: yyval = *(yyvsp + 0);
Block: 1154
ProgElement 2387: trlcontxt = 1;
ProgElement 2388: eps = mkstate(257);
ProgElement 2389: tmp___3 = mkstate('\n');
ProgElement 2390: tmp___4 = link_machines(eps, tmp___3);
ProgElement 2391: yyval = link_machines(*(yyvsp + -1), tmp___4);
ProgElement 2392: goto switch_break;
Block: 1155
ProgElement 2393: add_accept(*(yyvsp + -1), num_rules | 16384);
ProgElement 2394: variable_trail_rule = 1;
Block: 1156
ProgElement 2395: headcnt = 0;
ProgElement 2396: trailcnt = 1;
ProgElement 2397: rulelen = 1;
ProgElement 2398: varlength = 0;
ProgElement 2399: current_state_type = 2;
Block: 1157
ProgElement 2400: yyval = link_machines(*(yyvsp + -1), *(yyvsp + 0));
ProgElement 2401: goto switch_break;
Block: 1158
ProgElement 2402: trailcnt = rulelen;
Block: 1159
ProgElement 2403: add_accept(*(yyvsp + -1), num_rules | 16384);
ProgElement 2404: variable_trail_rule = 1;
Block: 1160
ProgElement 2405: add_accept(*(yyvsp + -1), num_rules | 16384);
ProgElement 2406: variable_trail_rule = 1;
Block: 1161
ProgElement 2407: varlength = 1;
ProgElement 2408: headcnt = 0;
Block: 1162
ProgElement 2409: mark_beginning_as_normal(*(yyvsp + 0));
ProgElement 2410: current_state_type = 1;
Block: 1163
ProgElement 2411: tmp___2 = mkstate(257);
ProgElement 2412: *(yyvsp + 0) = link_machines(*(yyvsp + 0), tmp___2);
Block: 1164
ProgElement 2413: scon_stk_ptr ++;
ProgElement 2414: *(scon_stk + scon_stk_ptr) = scnum;
Block: 1165
ProgElement 2415: i ++;
Block: 1166
ProgElement 2416: i = 1;
Block: 1167
ProgElement 2417: scnum = sclookup(nmstr);
Block: 1168
ProgElement 2418: yyval = scon_stk_ptr;
ProgElement 2419: goto switch_break;
Block: 1169
ProgElement 2420: i ++;
Block: 1170
ProgElement 2421: scon_stk_ptr ++;
ProgElement 2422: *(scon_stk + scon_stk_ptr) = i;
Block: 1171
ProgElement 2423: j ++;
Block: 1172
ProgElement 2424: j = 1;
Block: 1173
ProgElement 2425: yyval = scon_stk_ptr;
ProgElement 2426: i = 1;
Block: 1174
ProgElement 2427: yyval = *(yyvsp + -2);
ProgElement 2428: goto switch_break;
Block: 1175
ProgElement 2429: yyval = scon_stk_ptr;
ProgElement 2430: goto switch_break;
Block: 1176
ProgElement 2431: synerr((char *)"unrecognized rule");
ProgElement 2432: goto switch_break;
Block: 1177
ProgElement 2433: build_eof_action();
Block: 1178
ProgElement 2434: i ++;
Block: 1179
ProgElement 2435: scon_stk_ptr ++;
ProgElement 2436: *(scon_stk + scon_stk_ptr) = i;
Block: 1180
ProgElement 2437: i = 1;
Block: 1181
ProgElement 2438: build_eof_action();
Block: 1182
ProgElement 2439: i ++;
Block: 1183
ProgElement 2440: *(scset + i) = mkbranch(*(scset + i), pat);
Block: 1184
ProgElement 2441: i = 1;
Block: 1185
ProgElement 2442: *(scset + *(scon_stk + i)) = mkbranch(*(scset + *(scon_stk + i)), pat);
ProgElement 2443: i ++;
Block: 1186
ProgElement 2444: i = 1;
Block: 1187
ProgElement 2445: pat = *(yyvsp + 0);
ProgElement 2446: finish_rule(pat, variable_trail_rule, headcnt, trailcnt);
Block: 1188
ProgElement 2447: bol_needed = 1;
Block: 1189
ProgElement 2448: i ++;
Block: 1190
ProgElement 2449: *(scbol + i) = mkbranch(*(scbol + i), pat);
Block: 1191
ProgElement 2450: i = 1;
Block: 1192
ProgElement 2451: pat = *(yyvsp + 0);
ProgElement 2452: finish_rule(pat, variable_trail_rule, headcnt, trailcnt);
Block: 1193
ProgElement 2453: varlength = 0;
ProgElement 2454: variable_trail_rule = varlength;
ProgElement 2455: trlcontxt = variable_trail_rule;
ProgElement 2456: rulelen = 0;
ProgElement 2457: headcnt = rulelen;
ProgElement 2458: trailcnt = headcnt;
ProgElement 2459: current_state_type = 1;
ProgElement 2460: previous_continued_action = continued_action;
ProgElement 2461: in_rule = 1;
ProgElement 2462: new_rule();
ProgElement 2463: goto switch_break;
Block: 1194
ProgElement 2464: scon_stk_ptr = *(yyvsp + -3);
ProgElement 2465: goto switch_break;
Block: 1195
ProgElement 2466: outfilename = copy_string((char const   *)(nmstr));
ProgElement 2467: did_outfilename = 1;
ProgElement 2468: goto switch_break;
Block: 1196
ProgElement 2469: scinstal(nmstr, xcluflg);
ProgElement 2470: goto switch_break;
Block: 1197
ProgElement 2471: xcluflg = 1;
ProgElement 2472: goto switch_break;
Block: 1198
ProgElement 2473: xcluflg = 0;
ProgElement 2474: goto switch_break;
Block: 1199
ProgElement 2475: check_options();
ProgElement 2476: tmp___1 = allocate_array(lastsc + 1, sizeof(int ));
ProgElement 2477: scon_stk = (int *)tmp___1;
ProgElement 2478: scon_stk_ptr = 0;
ProgElement 2479: goto switch_break;
Block: 1200
ProgElement 2480: scinstal((char *)"INITIAL", 0);
ProgElement 2481: goto switch_break;
Block: 1201
ProgElement 2482: add_action((char *)";\n\tYY_BREAK\n");
ProgElement 2483: goto switch_break;
Block: 1202
ProgElement 2484: add_action((char *)"ECHO");
Block: 1203
ProgElement 2485: add_action((char *)"YY_FATAL_ERROR( \"flex scanner jammed\" )");
Block: 1204
ProgElement 2486: *(scset + i) = mkbranch(*(scset + i), def_rule);
ProgElement 2487: i ++;
Block: 1205
ProgElement 2488: pat = cclinit();
ProgElement 2489: cclnegate(pat);
ProgElement 2490: def_rule = mkstate(- pat);
ProgElement 2491: default_rule = num_rules;
ProgElement 2492: finish_rule(def_rule, 0, 0, 0);
ProgElement 2493: i = 1;
Block: 1206
ProgElement 2494: yyval = *(yyvsp + (1 - yylen));
Block: 1207
ProgElement 2495: yylen = (int )yyr2[yyn];
Block: 1208
ProgElement 2496: yyn = (int )yydefact[yystate];
Block: 1209
ProgElement 2497: yystate = yyn;
ProgElement 2498: goto yynewstate;
Block: 1210
ProgElement 2499: yyerrstatus --;
Block: 1211
ProgElement 2500: yyvsp ++;
ProgElement 2501: *yyvsp = yylval;
Block: 1212
ProgElement 2502: yychar = -2;
Block: 1213
ProgElement 2503: yyn = - yyn;
ProgElement 2504: goto yyreduce;
Block: 1214
ProgElement 2505: yyn = (int )yytable[yyn];
Block: 1215
ProgElement 2506: yyn += yychar1;
Block: 1216
ProgElement 2507: yychar1 = (int )yytranslate[yychar];
Block: 1217
ProgElement 2508: yychar1 = 0;
ProgElement 2509: yychar = 0;
Block: 1218
ProgElement 2510: yychar = yylex();
Block: 1219
ProgElement 2511: yyn = (int )yypact[yystate];
Block: 1220
ProgElement 2512: yyssp ++;
ProgElement 2513: *yyssp = (short )yystate;
Block: 1221
ProgElement 2514: yychar1 = 0;
ProgElement 2515: yyss = yyssa;
ProgElement 2516: yyvs = yyvsa;
ProgElement 2517: yystacksize = 200;
ProgElement 2518: yyfree_stacks = 0;
ProgElement 2519: yystate = 0;
ProgElement 2520: yyerrstatus = 0;
ProgElement 2521: yynerrs = 0;
ProgElement 2522: yychar = -2;
ProgElement 2523: yyssp = yyss - 1;
ProgElement 2524: yyvsp = yyvs;
Block: 1222
ProgElement 2525: line_directive_out((FILE *)0, 1);
ProgElement 2526: num_rules --;
ProgElement 2527: num_eof_rules ++;
ProgElement 2528: return;
Block: 1223
ProgElement 2529: i___0 ++;
Block: 1224
ProgElement 2530: *(sceof + *(scon_stk + i___0)) = 1;
ProgElement 2531: sprintf((char * __restrict  )(action_text), (char const   * __restrict  )"case YY_STATE_EOF(%s):\n",
              *(scname + *(scon_stk + i___0)));
ProgElement 2532: add_action(action_text);
Block: 1225
ProgElement 2533: format_pinpoint_message((char *)"multiple <<EOF>> rules for start condition %s",
                              *(scname + *(scon_stk + i___0)));
Block: 1226
ProgElement 2534: i___0 = 1;
Block: 1227
ProgElement 2535: sprintf((char * __restrict  )(errmsg), (char const   * __restrict  )msg, arg);
ProgElement 2536: synerr(errmsg);
ProgElement 2537: return;
Block: 1228
ProgElement 2538: syntaxerror = 1;
ProgElement 2539: pinpoint_message(str);
ProgElement 2540: return;
Block: 1229
ProgElement 2541: sprintf((char * __restrict  )(errmsg), (char const   * __restrict  )msg, arg);
ProgElement 2542: pinpoint_message(errmsg);
ProgElement 2543: return;
Block: 1230
ProgElement 2544: line_pinpoint(str, linenum);
ProgElement 2545: return;
Block: 1231
ProgElement 2546: return;
Block: 1232
ProgElement 2547: sprintf((char * __restrict  )(warning), (char const   * __restrict  )"warning, %s",
            str);
ProgElement 2548: line_pinpoint(warning, line);
Block: 1233
ProgElement 2549: fprintf((FILE * __restrict  )err, (char const   * __restrict  )"\"%s\", line %d: %s\n",
          infilename, line, str);
ProgElement 2550: return;
Block: 1234
ProgElement 2551: return;
Block: 1235
ProgElement 2552: yy_c_buf_p = yytext + yy_amount_of_matched_text;
ProgElement 2553: yy_current_state = yy_get_previous_state();
ProgElement 2554: yy_cp = yy_c_buf_p;
ProgElement 2555: yy_bp = yytext + 0;
ProgElement 2556: goto yy_match;
Block: 1236
ProgElement 2557: yyrestart(yyin);
Block: 1237
ProgElement 2558: yy_c_buf_p = yytext + 0;
ProgElement 2559: yy_act = (166 + (yy_start - 1) / 2) + 1;
ProgElement 2560: goto do_action;
Block: 1238
ProgElement 2561: yy_did_buffer_switch_on_eof = 0;
ProgElement 2562: tmp___11 = yywrap();
Block: 1239
ProgElement 2563: tmp___10 = yy_get_next_buffer();
Block: 1240
ProgElement 2564: yy_n_chars = yy_current_buffer->yy_n_chars;
ProgElement 2565: yy_current_buffer->yy_input_file = yyin;
ProgElement 2566: yy_current_buffer->yy_buffer_status = 1;
Block: 1241
ProgElement 2567: yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
ProgElement 2568: *yy_cp = yy_hold_char;
Block: 1242
ProgElement 2569: return (0);
Block: 1243
ProgElement 2570: sectnum = 0;
ProgElement 2571: return (0);
Block: 1244
ProgElement 2572: fwrite((void const   * __restrict  )yytext, (size_t )yyleng, (size_t )1, (FILE * __restrict  )yyout);
ProgElement 2573: goto switch_break;
Block: 1245
ProgElement 2574: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1246
ProgElement 2575: return (257);
Block: 1247
ProgElement 2576: yy_start = 23;
Block: 1248
ProgElement 2577: tmp___9 = myesc((unsigned char *)yytext);
ProgElement 2578: yylval = (int )tmp___9;
Block: 1249
ProgElement 2579: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1250
ProgElement 2580: add_action(yytext);
ProgElement 2581: yy_start = 25;
ProgElement 2582: goto switch_break;
Block: 1251
ProgElement 2583: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1252
ProgElement 2584: add_action(yytext);
ProgElement 2585: goto switch_break;
Block: 1253
ProgElement 2586: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1254
ProgElement 2587: add_action(yytext);
ProgElement 2588: goto switch_break;
Block: 1255
ProgElement 2589: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1256
ProgElement 2590: doing_rule_action = 0;
ProgElement 2591: yy_start = 3;
Block: 1257
ProgElement 2592: add_action((char *)"\tYY_BREAK\n");
Block: 1258
ProgElement 2593: linenum ++;
ProgElement 2594: add_action(yytext);
Block: 1259
ProgElement 2595: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1260
ProgElement 2596: add_action(yytext);
ProgElement 2597: yy_start = 31;
ProgElement 2598: goto switch_break;
Block: 1261
ProgElement 2599: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1262
ProgElement 2600: add_action(yytext);
ProgElement 2601: goto switch_break;
Block: 1263
ProgElement 2602: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1264
ProgElement 2603: add_action(yytext);
ProgElement 2604: goto switch_break;
Block: 1265
ProgElement 2605: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1266
ProgElement 2606: add_action(yytext);
ProgElement 2607: goto switch_break;
Block: 1267
ProgElement 2608: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1268
ProgElement 2609: add_action(yytext);
ProgElement 2610: bracelevel --;
ProgElement 2611: goto switch_break;
Block: 1269
ProgElement 2612: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1270
ProgElement 2613: add_action(yytext);
ProgElement 2614: bracelevel ++;
ProgElement 2615: goto switch_break;
Block: 1271
ProgElement 2616: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1272
ProgElement 2617: yymore_used = 1;
Block: 1273
ProgElement 2618: add_action(yytext);
ProgElement 2619: tmp___8 = all_lower(yytext);
Block: 1274
ProgElement 2620: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1275
ProgElement 2621: reject = 1;
Block: 1276
ProgElement 2622: add_action(yytext);
ProgElement 2623: tmp___7 = all_upper(yytext);
Block: 1277
ProgElement 2624: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1278
ProgElement 2625: add_action(yytext);
ProgElement 2626: yy_push_state(14);
ProgElement 2627: goto switch_break;
Block: 1279
ProgElement 2628: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1280
ProgElement 2629: yy_start = 3;
ProgElement 2630: return ('}');
Block: 1281
ProgElement 2631: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1282
ProgElement 2632: return (',');
Block: 1283
ProgElement 2633: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1284
ProgElement 2634: yylval = myctoi(yytext);
ProgElement 2635: return (258);
Block: 1285
ProgElement 2636: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1286
ProgElement 2637: yy_start = 23;
ProgElement 2638: return (280);
Block: 1287
ProgElement 2639: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1288
ProgElement 2640: yy_start = 23;
ProgElement 2641: return (279);
Block: 1289
ProgElement 2642: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1290
ProgElement 2643: yy_start = 23;
ProgElement 2644: return (278);
Block: 1291
ProgElement 2645: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1292
ProgElement 2646: yy_start = 23;
ProgElement 2647: return (277);
Block: 1293
ProgElement 2648: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1294
ProgElement 2649: yy_start = 23;
ProgElement 2650: return (275);
Block: 1295
ProgElement 2651: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1296
ProgElement 2652: yy_start = 23;
ProgElement 2653: return (272);
Block: 1297
ProgElement 2654: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1298
ProgElement 2655: yy_start = 23;
ProgElement 2656: return (271);
Block: 1299
ProgElement 2657: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1300
ProgElement 2658: yy_start = 23;
ProgElement 2659: return (269);
Block: 1301
ProgElement 2660: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1302
ProgElement 2661: yy_start = 3;
ProgElement 2662: return (']');
Block: 1303
ProgElement 2663: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1304
ProgElement 2664: yylval = (int )((unsigned char )*(yytext + 0));
ProgElement 2665: return (257);
Block: 1305
ProgElement 2666: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1306
ProgElement 2667: return ('-');
Block: 1307
ProgElement 2668: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1308
ProgElement 2669: *yy_cp = yy_hold_char;
ProgElement 2670: yy_cp = yy_bp + 1;
ProgElement 2671: yy_c_buf_p = yy_cp;
ProgElement 2672: yytext = yy_bp;
ProgElement 2673: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2674: yy_hold_char = *yy_cp;
ProgElement 2675: *yy_cp = (char )'\000';
ProgElement 2676: yy_c_buf_p = yy_cp;
Block: 1309
ProgElement 2677: yy_start = 23;
ProgElement 2678: yylval = (int )((unsigned char )*(yytext + 0));
ProgElement 2679: return (257);
Block: 1310
ProgElement 2680: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1311
ProgElement 2681: yy_start = 23;
ProgElement 2682: return ('^');
Block: 1312
ProgElement 2683: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1313
ProgElement 2684: *yy_cp = yy_hold_char;
ProgElement 2685: yy_cp = yy_bp + 1;
ProgElement 2686: yy_c_buf_p = yy_cp;
ProgElement 2687: yytext = yy_bp;
ProgElement 2688: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2689: yy_hold_char = *yy_cp;
ProgElement 2690: *yy_cp = (char )'\000';
ProgElement 2691: yy_c_buf_p = yy_cp;
Block: 1314
ProgElement 2692: yy_start = 3;
ProgElement 2693: return ('\"');
Block: 1315
ProgElement 2694: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1316
ProgElement 2695: yylval = (int )((unsigned char )*(yytext + 0));
ProgElement 2696: return (257);
Block: 1317
ProgElement 2697: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1318
ProgElement 2698: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )yytext);
ProgElement 2699: return (262);
Block: 1319
ProgElement 2700: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1320
ProgElement 2701: yy_start = 3;
ProgElement 2702: return ('>');
Block: 1321
ProgElement 2703: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1322
ProgElement 2704: return ((int )((unsigned char )*(yytext + 0)));
Block: 1323
ProgElement 2705: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1324
ProgElement 2706: yylval = (int )((unsigned char )*(yytext + 0));
ProgElement 2707: return (257);
Block: 1325
ProgElement 2708: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1326
ProgElement 2709: return ((int )((unsigned char )*(yytext + 0)));
Block: 1327
ProgElement 2710: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1328
ProgElement 2711: yyunput('(', yytext);
Block: 1329
ProgElement 2712: yyunput((int )*((char *)nmdefptr + i___0), yytext);
ProgElement 2713: i___0 --;
Block: 1330
ProgElement 2714: yyunput(')', yytext);
ProgElement 2715: tmp___6 = strlen((char const   *)((char *)nmdefptr));
ProgElement 2716: i___0 = (int )(tmp___6 - 1UL);
Block: 1331
ProgElement 2717: yyunput((int )*((char *)nmdefptr + i___0), yytext);
ProgElement 2718: i___0 --;
Block: 1332
ProgElement 2719: tmp___5 = strlen((char const   *)((char *)nmdefptr));
ProgElement 2720: i___0 = (int )(tmp___5 - 1UL);
Block: 1333
ProgElement 2721: tmp___4 = strlen((char const   *)((char *)nmdefptr));
ProgElement 2722: len = (int )tmp___4;
Block: 1334
ProgElement 2723: format_synerr((char *)"undefined definition {%s}", nmstr);
Block: 1335
ProgElement 2724: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )(yytext + 1));
ProgElement 2725: nmstr[yyleng - 2] = (char )'\000';
ProgElement 2726: nmdefptr = ndlookup(nmstr);
Block: 1336
ProgElement 2727: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1337
ProgElement 2728: yy_start = 21;
ProgElement 2729: return ('[');
Block: 1338
ProgElement 2730: *yy_cp = yy_hold_char;
ProgElement 2731: yy_cp = (yy_bp + 1) - 0;
ProgElement 2732: yy_c_buf_p = yy_cp;
ProgElement 2733: yytext = yy_bp;
ProgElement 2734: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2735: yy_hold_char = *yy_cp;
ProgElement 2736: *yy_cp = (char )'\000';
ProgElement 2737: yy_c_buf_p = yy_cp;
ProgElement 2738: goto while_break___7;
Block: 1339
ProgElement 2739: cclinstal((unsigned char *)(nmstr), lastccl + 1);
Block: 1340
ProgElement 2740: yylval = cclval;
ProgElement 2741: cclreuse ++;
ProgElement 2742: return (263);
Block: 1341
ProgElement 2743: tmp___3 = input();
Block: 1342
ProgElement 2744: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )yytext);
ProgElement 2745: cclval = ccllookup((unsigned char *)(nmstr));
Block: 1343
ProgElement 2746: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1344
ProgElement 2747: sectnum = 3;
ProgElement 2748: yy_start = 7;
ProgElement 2749: return (0);
Block: 1345
ProgElement 2750: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1346
ProgElement 2751: return (264);
Block: 1347
ProgElement 2752: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1348
ProgElement 2753: doing_rule_action = 1;
ProgElement 2754: in_rule = 0;
ProgElement 2755: return ('\n');
Block: 1349
ProgElement 2756: bracelevel = 0;
ProgElement 2757: continued_action = 0;
ProgElement 2758: yy_start = 25;
ProgElement 2759: yyunput('\n', yytext);
Block: 1350
ProgElement 2760: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1351
ProgElement 2761: doing_rule_action = 1;
ProgElement 2762: in_rule = 0;
ProgElement 2763: return ('\n');
Block: 1352
ProgElement 2764: bracelevel = 0;
ProgElement 2765: continued_action = 0;
ProgElement 2766: yy_start = 25;
Block: 1353
ProgElement 2767: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1354
ProgElement 2768: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1355
ProgElement 2769: bracelevel = 0;
ProgElement 2770: continued_action = 0;
ProgElement 2771: yy_start = 25;
ProgElement 2772: goto switch_break;
Block: 1356
ProgElement 2773: *yy_cp = yy_hold_char;
ProgElement 2774: yy_cp = ((yy_bp + yyleng) - 2) - 0;
ProgElement 2775: yy_c_buf_p = yy_cp;
ProgElement 2776: yytext = yy_bp;
ProgElement 2777: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2778: yy_hold_char = *yy_cp;
ProgElement 2779: *yy_cp = (char )'\000';
ProgElement 2780: yy_c_buf_p = yy_cp;
ProgElement 2781: goto while_break___6;
Block: 1357
ProgElement 2782: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1358
ProgElement 2783: continued_action = 1;
ProgElement 2784: linenum ++;
ProgElement 2785: return ('\n');
Block: 1359
ProgElement 2786: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1360
ProgElement 2787: return ('$');
Block: 1361
ProgElement 2788: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1362
ProgElement 2789: *yy_cp = yy_hold_char;
ProgElement 2790: yy_cp = yy_bp + 1;
ProgElement 2791: yy_c_buf_p = yy_cp;
ProgElement 2792: yytext = yy_bp;
ProgElement 2793: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2794: yy_hold_char = *yy_cp;
ProgElement 2795: *yy_cp = (char )'\000';
ProgElement 2796: yy_c_buf_p = yy_cp;
Block: 1363
ProgElement 2797: yy_start = 17;
ProgElement 2798: return ('{');
Block: 1364
ProgElement 2799: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1365
ProgElement 2800: *yy_cp = yy_hold_char;
ProgElement 2801: yy_cp = yy_bp + 1;
ProgElement 2802: yy_c_buf_p = yy_cp;
ProgElement 2803: yytext = yy_bp;
ProgElement 2804: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2805: yy_hold_char = *yy_cp;
ProgElement 2806: *yy_cp = (char )'\000';
ProgElement 2807: yy_c_buf_p = yy_cp;
Block: 1366
ProgElement 2808: yy_start = 19;
ProgElement 2809: return ('\"');
Block: 1367
ProgElement 2810: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1368
ProgElement 2811: return ('^');
Block: 1369
ProgElement 2812: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1370
ProgElement 2813: yy_start = 13;
ProgElement 2814: return ('<');
Block: 1371
ProgElement 2815: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1372
ProgElement 2816: linenum ++;
ProgElement 2817: goto switch_break;
Block: 1373
ProgElement 2818: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1374
ProgElement 2819: mark_prolog();
ProgElement 2820: sectnum = 0;
ProgElement 2821: return (0);
Block: 1375
ProgElement 2822: linenum ++;
ProgElement 2823: add_action(yytext);
ProgElement 2824: goto switch_break;
Block: 1376
ProgElement 2825: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1377
ProgElement 2826: yy_current_buffer->yy_at_bol = 1;
ProgElement 2827: mark_prolog();
ProgElement 2828: yy_start = 3;
Block: 1378
ProgElement 2829: *yy_cp = yy_hold_char;
ProgElement 2830: yy_cp = (yy_bp + 0) - 0;
ProgElement 2831: yy_c_buf_p = yy_cp;
ProgElement 2832: yytext = yy_bp;
ProgElement 2833: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2834: yy_hold_char = *yy_cp;
ProgElement 2835: *yy_cp = (char )'\000';
ProgElement 2836: yy_c_buf_p = yy_cp;
ProgElement 2837: goto while_break___5;
Block: 1379
ProgElement 2838: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1380
ProgElement 2839: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )(yytext + 1));
ProgElement 2840: tmp___2 = strlen((char const   *)(nmstr));
ProgElement 2841: nmstr[tmp___2 - 1UL] = (char )'\000';
ProgElement 2842: return (262);
Block: 1381
ProgElement 2843: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1382
ProgElement 2844: return (266);
Block: 1383
ProgElement 2845: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1384
ProgElement 2846: return ('=');
Block: 1385
ProgElement 2847: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1386
ProgElement 2848: option_sense = 1;
ProgElement 2849: goto switch_break;
Block: 1387
ProgElement 2850: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1388
ProgElement 2851: linenum ++;
ProgElement 2852: yy_start = 1;
ProgElement 2853: goto switch_break;
Block: 1389
ProgElement 2854: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1390
ProgElement 2855: yy_start = 1;
ProgElement 2856: linenum ++;
ProgElement 2857: goto switch_break;
Block: 1391
ProgElement 2858: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1392
ProgElement 2859: nmdef[i___0 + 1] = (unsigned char )'\000';
ProgElement 2860: ndinstal(nmstr, nmdef);
ProgElement 2861: didadef = 1;
ProgElement 2862: goto switch_break;
Block: 1393
ProgElement 2863: strcpy((char * __restrict  )((char *)(nmdef)), (char const   * __restrict  )yytext);
ProgElement 2864: tmp___0 = strlen((char const   *)((char *)(nmdef)));
ProgElement 2865: i___0 = (int )(tmp___0 - 1UL);
Block: 1394
ProgElement 2866: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1395
ProgElement 2867: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1396
ProgElement 2868: yy_start = 1;
Block: 1397
ProgElement 2869: linenum ++;
ProgElement 2870: add_action(yytext);
Block: 1398
ProgElement 2871: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1399
ProgElement 2872: add_action(yytext);
ProgElement 2873: goto switch_break;
Block: 1400
ProgElement 2874: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1401
ProgElement 2875: linenum ++;
ProgElement 2876: yy_start = 1;
ProgElement 2877: goto switch_break;
Block: 1402
ProgElement 2878: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1403
ProgElement 2879: add_action(yytext);
ProgElement 2880: goto switch_break;
Block: 1404
ProgElement 2881: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1405
ProgElement 2882: add_action(yytext);
ProgElement 2883: yy_pop_state();
ProgElement 2884: goto switch_break;
Block: 1406
ProgElement 2885: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1407
ProgElement 2886: add_action(yytext);
ProgElement 2887: linenum ++;
ProgElement 2888: goto switch_break;
Block: 1408
ProgElement 2889: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1409
ProgElement 2890: linenum ++;
ProgElement 2891: goto switch_break;
Block: 1410
ProgElement 2892: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1411
ProgElement 2893: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )yytext);
ProgElement 2894: return (262);
Block: 1412
ProgElement 2895: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1413
ProgElement 2896: strcpy((char * __restrict  )(nmstr), (char const   * __restrict  )yytext);
ProgElement 2897: didadef = 0;
ProgElement 2898: yy_start = 11;
ProgElement 2899: goto switch_break;
Block: 1414
ProgElement 2900: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1415
ProgElement 2901: yy_start = 35;
ProgElement 2902: return (265);
Block: 1416
ProgElement 2903: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1417
ProgElement 2904: sectnum = 2;
ProgElement 2905: bracelevel = 0;
ProgElement 2906: mark_defs1();
ProgElement 2907: line_directive_out((FILE *)0, 1);
ProgElement 2908: yy_start = 5;
ProgElement 2909: return (259);
Block: 1418
ProgElement 2910: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1419
ProgElement 2911: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1420
ProgElement 2912: linenum ++;
ProgElement 2913: line_directive_out((FILE *)0, 1);
ProgElement 2914: indented_code = 0;
ProgElement 2915: yy_start = 9;
ProgElement 2916: goto switch_break;
Block: 1421
ProgElement 2917: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1422
ProgElement 2918: return (261);
Block: 1423
ProgElement 2919: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1424
ProgElement 2920: return (260);
Block: 1425
ProgElement 2921: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1426
ProgElement 2922: add_action(yytext);
ProgElement 2923: yy_push_state(14);
ProgElement 2924: goto switch_break;
Block: 1427
ProgElement 2925: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1428
ProgElement 2926: indented_code = 1;
ProgElement 2927: yy_start = 9;
ProgElement 2928: goto switch_break;
Block: 1429
ProgElement 2929: yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
Block: 1430
ProgElement 2930: yytext = yy_bp;
ProgElement 2931: yyleng = (int )(yy_cp - yy_bp);
ProgElement 2932: yy_hold_char = *yy_cp;
ProgElement 2933: *yy_cp = (char )'\000';
ProgElement 2934: yy_c_buf_p = yy_cp;
Block: 1431
ProgElement 2935: yy_cp = yy_last_accepting_cpos;
ProgElement 2936: yy_current_state = yy_last_accepting_state;
ProgElement 2937: yy_act = (int )yy_accept[yy_current_state];
Block: 1432
ProgElement 2938: yy_act = (int )yy_accept[yy_current_state];
Block: 1433
ProgElement 2939: yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
ProgElement 2940: yy_cp ++;
Block: 1434
ProgElement 2941: yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
Block: 1435
ProgElement 2942: yy_current_state = (int )yy_def[yy_current_state];
Block: 1436
ProgElement 2943: yy_last_accepting_state = yy_current_state;
ProgElement 2944: yy_last_accepting_cpos = yy_cp;
Block: 1437
ProgElement 2945: yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
Block: 1438
ProgElement 2946: yy_cp = yy_c_buf_p;
ProgElement 2947: *yy_cp = yy_hold_char;
ProgElement 2948: yy_bp = yy_cp;
ProgElement 2949: yy_current_state = yy_start;
ProgElement 2950: yy_current_state += yy_current_buffer->yy_at_bol;
Block: 1439
ProgElement 2951: yy_load_buffer_state();
Block: 1440
ProgElement 2952: yy_current_buffer = yy_create_buffer(yyin, 16384);
Block: 1441
ProgElement 2953: yyout = stdout;
Block: 1442
ProgElement 2954: yy_start = 1;
Block: 1443
ProgElement 2955: yy_init = 0;
Block: 1444
ProgElement 2956: doing_codeblock = 0;
Block: 1445
ProgElement 2957: yy_n_chars += number_to_move;
ProgElement 2958: *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
ProgElement 2959: *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
ProgElement 2960: yytext = yy_current_buffer->yy_ch_buf + 0;
ProgElement 2961: return (ret_val);
Block: 1446
ProgElement 2962: ret_val = 0;
Block: 1447
ProgElement 2963: ret_val = 1;
ProgElement 2964: yyrestart(yyin);
Block: 1448
ProgElement 2965: yy_current_buffer->yy_n_chars = yy_n_chars;
Block: 1449
ProgElement 2966: tmp___5 = ferror(yyin);
Block: 1450
ProgElement 2967: tmp___4 = fread((void * __restrict  )(yy_current_buffer->yy_ch_buf + number_to_move),
                      (size_t )1, (size_t )num_to_read, (FILE * __restrict  )yyin);
ProgElement 2968: yy_n_chars = (int )tmp___4;
Block: 1451
ProgElement 2969: num_to_read = 8192;
Block: 1452
ProgElement 2970: num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
Block: 1453
ProgElement 2971: tmp = dest;
ProgElement 2972: dest ++;
ProgElement 2973: tmp___0 = source;
ProgElement 2974: source ++;
ProgElement 2975: *tmp = *tmp___0;
ProgElement 2976: i___0 ++;
Block: 1454
ProgElement 2977: number_to_move = (int )(yy_c_buf_p - yytext) - 1;
ProgElement 2978: i___0 = 0;
Block: 1455
ProgElement 2979: dest = yy_current_buffer->yy_ch_buf;
ProgElement 2980: source = yytext;
Block: 1456
ProgElement 2981: return (yy_current_state);
Block: 1457
ProgElement 2982: yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
ProgElement 2983: yy_cp ++;
Block: 1458
ProgElement 2984: yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
Block: 1459
ProgElement 2985: yy_current_state = (int )yy_def[yy_current_state];
Block: 1460
ProgElement 2986: yy_last_accepting_state = yy_current_state;
ProgElement 2987: yy_last_accepting_cpos = yy_cp;
Block: 1461
ProgElement 2988: yy_c = (YY_CHAR )tmp;
Block: 1462
ProgElement 2989: tmp = (int )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
Block: 1463
ProgElement 2990: yy_current_state = yy_start;
ProgElement 2991: yy_current_state += yy_current_buffer->yy_at_bol;
ProgElement 2992: yy_cp = yytext + 0;
Block: 1464
ProgElement 2993: yy_cp --;
ProgElement 2994: *yy_cp = (char )c;
ProgElement 2995: yytext = yy_bp;
ProgElement 2996: yy_hold_char = *yy_cp;
ProgElement 2997: yy_c_buf_p = yy_cp;
ProgElement 2998: return;
Block: 1465
ProgElement 2999: yy_cp = yy_c_buf_p;
ProgElement 3000: *yy_cp = yy_hold_char;
Block: 1466
ProgElement 3001: c = (int )*((unsigned char *)yy_c_buf_p);
ProgElement 3002: *yy_c_buf_p = (char )'\000';
ProgElement 3003: yy_c_buf_p ++;
ProgElement 3004: yy_hold_char = *yy_c_buf_p;
ProgElement 3005: yy_current_buffer->yy_at_bol = c == 10;
ProgElement 3006: return (c);
Block: 1467
ProgElement 3007: *yy_c_buf_p = yy_hold_char;
Block: 1468
ProgElement 3008: yy_init_buffer(yy_current_buffer, input_file);
ProgElement 3009: yy_load_buffer_state();
ProgElement 3010: return;
Block: 1469
ProgElement 3011: yy_n_chars = yy_current_buffer->yy_n_chars;
ProgElement 3012: yy_c_buf_p = yy_current_buffer->yy_buf_pos;
ProgElement 3013: yytext = yy_c_buf_p;
ProgElement 3014: yyin = yy_current_buffer->yy_input_file;
ProgElement 3015: yy_hold_char = *yy_c_buf_p;
ProgElement 3016: return;
Block: 1470
ProgElement 3017: b->yy_is_our_buffer = 1;
ProgElement 3018: yy_init_buffer(b, file);
ProgElement 3019: return (b);
Block: 1471
ProgElement 3020: b->yy_buf_size = (yy_size_t )size;
ProgElement 3021: tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
ProgElement 3022: b->yy_ch_buf = (char *)tmp___0;
Block: 1472
ProgElement 3023: tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
ProgElement 3024: b = (YY_BUFFER_STATE )tmp;
Block: 1473
ProgElement 3025: return;
Block: 1474
ProgElement 3026: tmp = fileno(file);
ProgElement 3027: tmp___0 = isatty(tmp);
ProgElement 3028: b->yy_is_interactive = tmp___0 > 0;
Block: 1475
ProgElement 3029: yy_flush_buffer(b);
ProgElement 3030: b->yy_input_file = file;
ProgElement 3031: b->yy_fill_buffer = 1;
Block: 1476
ProgElement 3032: return;
Block: 1477
ProgElement 3033: yy_load_buffer_state();
Block: 1478
ProgElement 3034: b->yy_n_chars = 0;
ProgElement 3035: *(b->yy_ch_buf + 0) = (char)0;
ProgElement 3036: *(b->yy_ch_buf + 1) = (char)0;
ProgElement 3037: b->yy_buf_pos = b->yy_ch_buf + 0;
ProgElement 3038: b->yy_at_bol = 1;
ProgElement 3039: b->yy_buffer_status = 0;
Block: 1479
ProgElement 3040: tmp___1 = yy_start_stack_ptr;
ProgElement 3041: yy_start_stack_ptr ++;
ProgElement 3042: *(yy_start_stack + tmp___1) = (yy_start - 1) / 2;
ProgElement 3043: yy_start = 1 + 2 * new_state;
ProgElement 3044: return;
Block: 1480
ProgElement 3045: tmp = yy_flex_alloc(new_size);
ProgElement 3046: yy_start_stack = (int *)tmp;
Block: 1481
ProgElement 3047: yy_start_stack_depth += 25;
ProgElement 3048: new_size = (yy_size_t )((unsigned long )yy_start_stack_depth * sizeof(int ));
Block: 1482
ProgElement 3049: yy_start = 1 + 2 * *(yy_start_stack + yy_start_stack_ptr);
ProgElement 3050: return;
Block: 1483
ProgElement 3051: yy_start_stack_ptr --;
Block: 1484
ProgElement 3052: tmp = malloc((size_t )size);
ProgElement 3053: return (tmp);
Block: 1485
ProgElement 3054: return (1);
Block: 1486
ProgElement 3055: input_files ++;
ProgElement 3056: set_input_file(*input_files);
ProgElement 3057: return (0);
Block: 1487
ProgElement 3058: num_input_files --;
Block: 1488
ProgElement 3059: linenum = 1;
ProgElement 3060: return;
Block: 1489
ProgElement 3061: lerrsf("can\'t open %s", (char const   *)file);
Block: 1490
ProgElement 3062: infilename = copy_string((char const   *)file);
ProgElement 3063: yyin = fopen((char const   * __restrict  )infilename, (char const   * __restrict  )"r");
Block: 1491
ProgElement 3064: tmp = strcmp((char const   *)file, "-");
Block: 1492
ProgElement 3065: tmp = malloc(size);
ProgElement 3066: return (tmp);
Block: 1493
ProgElement 3067: tmp = realloc(ptr, size);
ProgElement 3068: return (tmp);
Block: 1494
ProgElement 3069: return;
Block: 1495
ProgElement 3070: free(ptr);
Block: 1496
ProgElement 3071: goto while_break;
Block: 1497
ProgElement 3072: goto while_break;
Block: 1498
ProgElement 3073: goto while_break___0;
Block: 1499
ProgElement 3074: goto while_break___0;
Block: 1500
ProgElement 3075: goto _L;
Block: 1501
ProgElement 3076: goto _L___0;
Block: 1502
ProgElement 3077: goto while_break;
Block: 1503
ProgElement 3078: goto while_break___0;
Block: 1504
ProgElement 3079: goto while_break;
Block: 1505
ProgElement 3080: goto while_break;
Block: 1506
ProgElement 3081: goto while_break___0;
Block: 1507
ProgElement 3082: goto while_break___1;
Block: 1508
ProgElement 3083: goto while_break___1;
Block: 1509
ProgElement 3084: goto while_break___2;
Block: 1510
ProgElement 3085: goto while_break;
Block: 1511
ProgElement 3086: goto while_break___0;
Block: 1512
ProgElement 3087: goto while_break;
Block: 1513
ProgElement 3088: goto while_break___0;
Block: 1514
ProgElement 3089: goto while_break___1;
Block: 1515
ProgElement 3090: goto while_break___2;
Block: 1516
ProgElement 3091: goto while_break___3;
Block: 1517
ProgElement 3092: goto while_break;
Block: 1518
ProgElement 3093: goto while_break___0;
Block: 1519
ProgElement 3094: goto while_break___1;
Block: 1520
ProgElement 3095: goto while_break;
Block: 1521
ProgElement 3096: goto _L;
Block: 1522
ProgElement 3097: goto _L;
Block: 1523
ProgElement 3098: goto while_break;
Block: 1524
ProgElement 3099: goto while_break___0;
Block: 1525
ProgElement 3100: goto while_break___1;
Block: 1526
ProgElement 3101: goto while_break___2;
Block: 1527
ProgElement 3102: goto while_break;
Block: 1528
ProgElement 3103: goto _L;
Block: 1529
ProgElement 3104: goto _L___0;
Block: 1530
ProgElement 3105: goto case_8;
Block: 1531
ProgElement 3106: goto case_12;
Block: 1532
ProgElement 3107: goto case_10;
Block: 1533
ProgElement 3108: goto case_13;
Block: 1534
ProgElement 3109: goto case_9;
Block: 1535
ProgElement 3110: goto case_7;
Block: 1536
ProgElement 3111: goto case_11;
Block: 1537
ProgElement 3112: goto switch_default;
Block: 1538
ProgElement 3113: goto while_break;
Block: 1539
ProgElement 3114: goto case_37;
Block: 1540
ProgElement 3115: goto case_43;
Block: 1541
ProgElement 3116: goto case_45;
Block: 1542
ProgElement 3117: goto case_42;
Block: 1543
ProgElement 3118: goto while_break;
Block: 1544
ProgElement 3119: goto while_break;
Block: 1545
ProgElement 3120: goto while_break;
Block: 1546
ProgElement 3121: goto while_break;
Block: 1547
ProgElement 3122: goto _L;
Block: 1548
ProgElement 3123: goto case_2;
Block: 1549
ProgElement 3124: goto switch_break;
Block: 1550
ProgElement 3125: goto while_break;
Block: 1551
ProgElement 3126: goto case_97;
Block: 1552
ProgElement 3127: goto case_101;
Block: 1553
ProgElement 3128: goto case_70;
Block: 1554
ProgElement 3129: goto case_102;
Block: 1555
ProgElement 3130: goto case_109;
Block: 1556
ProgElement 3131: goto case_114;
Block: 1557
ProgElement 3132: goto switch_default;
Block: 1558
ProgElement 3133: goto get_next_arg;
Block: 1559
ProgElement 3134: goto switch_break;
Block: 1560
ProgElement 3135: goto _L;
Block: 1561
ProgElement 3136: goto _L;
Block: 1562
ProgElement 3137: goto _L___0;
Block: 1563
ProgElement 3138: goto while_break;
Block: 1564
ProgElement 3139: goto while_break___0;
Block: 1565
ProgElement 3140: goto while_break;
Block: 1566
ProgElement 3141: goto while_break___0;
Block: 1567
ProgElement 3142: goto case_66;
Block: 1568
ProgElement 3143: goto case_98;
Block: 1569
ProgElement 3144: goto case_99;
Block: 1570
ProgElement 3145: goto case_67;
Block: 1571
ProgElement 3146: goto case_100;
Block: 1572
ProgElement 3147: goto case_102___0;
Block: 1573
ProgElement 3148: goto case_70___0;
Block: 1574
ProgElement 3149: goto case_63;
Block: 1575
ProgElement 3150: goto case_73;
Block: 1576
ProgElement 3151: goto case_105;
Block: 1577
ProgElement 3152: goto case_108;
Block: 1578
ProgElement 3153: goto case_76;
Block: 1579
ProgElement 3154: goto case_110;
Block: 1580
ProgElement 3155: goto case_111;
Block: 1581
ProgElement 3156: goto case_80;
Block: 1582
ProgElement 3157: goto case_112;
Block: 1583
ProgElement 3158: goto case_83;
Block: 1584
ProgElement 3159: goto case_115;
Block: 1585
ProgElement 3160: goto case_116;
Block: 1586
ProgElement 3161: goto case_84;
Block: 1587
ProgElement 3162: goto case_118;
Block: 1588
ProgElement 3163: goto case_86;
Block: 1589
ProgElement 3164: goto case_119;
Block: 1590
ProgElement 3165: goto case_55;
Block: 1591
ProgElement 3166: goto case_56;
Block: 1592
ProgElement 3167: goto switch_break;
Block: 1593
ProgElement 3168: goto while_break___1;
Block: 1594
ProgElement 3169: goto while_break;
Block: 1595
ProgElement 3170: goto while_break;
Block: 1596
ProgElement 3171: goto while_break;
Block: 1597
ProgElement 3172: goto while_break;
Block: 1598
ProgElement 3173: goto case_60;
Block: 1599
ProgElement 3174: goto case_60;
Block: 1600
ProgElement 3175: goto case_60;
Block: 1601
ProgElement 3176: goto case_60;
Block: 1602
ProgElement 3177: goto case_60;
Block: 1603
ProgElement 3178: goto case_60;
Block: 1604
ProgElement 3179: goto case_60;
Block: 1605
ProgElement 3180: goto case_60;
Block: 1606
ProgElement 3181: goto case_60;
Block: 1607
ProgElement 3182: goto case_60;
Block: 1608
ProgElement 3183: goto case_60;
Block: 1609
ProgElement 3184: goto case_60;
Block: 1610
ProgElement 3185: goto case_60;
Block: 1611
ProgElement 3186: goto case_60;
Block: 1612
ProgElement 3187: goto case_60;
Block: 1613
ProgElement 3188: goto case_60;
Block: 1614
ProgElement 3189: goto case_60;
Block: 1615
ProgElement 3190: goto case_60;
Block: 1616
ProgElement 3191: goto case_60;
Block: 1617
ProgElement 3192: goto case_10;
Block: 1618
ProgElement 3193: goto case_260;
Block: 1619
ProgElement 3194: goto case_261;
Block: 1620
ProgElement 3195: goto case_259;
Block: 1621
ProgElement 3196: goto case_262;
Block: 1622
ProgElement 3197: goto case_257;
Block: 1623
ProgElement 3198: goto case_258;
Block: 1624
ProgElement 3199: goto case_263;
Block: 1625
ProgElement 3200: goto case_264;
Block: 1626
ProgElement 3201: goto case_0;
Block: 1627
ProgElement 3202: goto switch_break;
Block: 1628
ProgElement 3203: goto switch_break;
Block: 1629
ProgElement 3204: goto case_60___0;
Block: 1630
ProgElement 3205: goto case_60___0;
Block: 1631
ProgElement 3206: goto case_60___0;
Block: 1632
ProgElement 3207: goto case_60___0;
Block: 1633
ProgElement 3208: goto case_60___0;
Block: 1634
ProgElement 3209: goto case_60___0;
Block: 1635
ProgElement 3210: goto case_60___0;
Block: 1636
ProgElement 3211: goto case_60___0;
Block: 1637
ProgElement 3212: goto case_60___0;
Block: 1638
ProgElement 3213: goto case_60___0;
Block: 1639
ProgElement 3214: goto case_60___0;
Block: 1640
ProgElement 3215: goto case_60___0;
Block: 1641
ProgElement 3216: goto case_60___0;
Block: 1642
ProgElement 3217: goto switch_default;
Block: 1643
ProgElement 3218: goto switch_break___0;
Block: 1644
ProgElement 3219: goto switch_break;
Block: 1645
ProgElement 3220: goto yybackup;
Block: 1646
ProgElement 3221: goto yydefault;
Block: 1647
ProgElement 3222: goto yydefault;
Block: 1648
ProgElement 3223: goto yydefault;
Block: 1649
ProgElement 3224: goto yydefault;
Block: 1650
ProgElement 3225: goto yyacceptlab;
Block: 1651
ProgElement 3226: goto yyerrlab;
Block: 1652
ProgElement 3227: goto case_1;
Block: 1653
ProgElement 3228: goto case_2;
Block: 1654
ProgElement 3229: goto case_7;
Block: 1655
ProgElement 3230: goto case_8;
Block: 1656
ProgElement 3231: goto case_9;
Block: 1657
ProgElement 3232: goto case_11;
Block: 1658
ProgElement 3233: goto case_16;
Block: 1659
ProgElement 3234: goto case_19;
Block: 1660
ProgElement 3235: goto case_22;
Block: 1661
ProgElement 3236: goto case_23;
Block: 1662
ProgElement 3237: goto case_24;
Block: 1663
ProgElement 3238: goto case_25;
Block: 1664
ProgElement 3239: goto case_26;
Block: 1665
ProgElement 3240: goto case_27;
Block: 1666
ProgElement 3241: goto case_28;
Block: 1667
ProgElement 3242: goto case_29;
Block: 1668
ProgElement 3243: goto case_30;
Block: 1669
ProgElement 3244: goto case_34;
Block: 1670
ProgElement 3245: goto case_35;
Block: 1671
ProgElement 3246: goto case_37;
Block: 1672
ProgElement 3247: goto case_38;
Block: 1673
ProgElement 3248: goto case_39;
Block: 1674
ProgElement 3249: goto case_40;
Block: 1675
ProgElement 3250: goto case_41;
Block: 1676
ProgElement 3251: goto case_42;
Block: 1677
ProgElement 3252: goto case_43;
Block: 1678
ProgElement 3253: goto case_44;
Block: 1679
ProgElement 3254: goto case_45;
Block: 1680
ProgElement 3255: goto case_46;
Block: 1681
ProgElement 3256: goto case_47;
Block: 1682
ProgElement 3257: goto case_48;
Block: 1683
ProgElement 3258: goto case_49;
Block: 1684
ProgElement 3259: goto case_50;
Block: 1685
ProgElement 3260: goto case_51;
Block: 1686
ProgElement 3261: goto case_52;
Block: 1687
ProgElement 3262: goto case_53;
Block: 1688
ProgElement 3263: goto case_54;
Block: 1689
ProgElement 3264: goto case_55;
Block: 1690
ProgElement 3265: goto case_56;
Block: 1691
ProgElement 3266: goto case_57;
Block: 1692
ProgElement 3267: goto case_58;
Block: 1693
ProgElement 3268: goto case_59;
Block: 1694
ProgElement 3269: goto case_60;
Block: 1695
ProgElement 3270: goto case_61;
Block: 1696
ProgElement 3271: goto case_62;
Block: 1697
ProgElement 3272: goto case_64;
Block: 1698
ProgElement 3273: goto case_65;
Block: 1699
ProgElement 3274: goto case_68;
Block: 1700
ProgElement 3275: goto case_70;
Block: 1701
ProgElement 3276: goto case_71;
Block: 1702
ProgElement 3277: goto case_72;
Block: 1703
ProgElement 3278: goto case_73;
Block: 1704
ProgElement 3279: goto case_74;
Block: 1705
ProgElement 3280: goto case_75;
Block: 1706
ProgElement 3281: goto switch_break;
Block: 1707
ProgElement 3282: goto while_break;
Block: 1708
ProgElement 3283: goto while_break___1;
Block: 1709
ProgElement 3284: goto switch_break;
Block: 1710
ProgElement 3285: goto while_break___2;
Block: 1711
ProgElement 3286: goto while_break___3;
Block: 1712
ProgElement 3287: goto switch_break;
Block: 1713
ProgElement 3288: goto while_break___4;
Block: 1714
ProgElement 3289: goto switch_break;
Block: 1715
ProgElement 3290: goto while_break___5;
Block: 1716
ProgElement 3291: goto while_break___6;
Block: 1717
ProgElement 3292: goto switch_break;
Block: 1718
ProgElement 3293: goto while_break___7;
Block: 1719
ProgElement 3294: goto switch_break;
Block: 1720
ProgElement 3295: goto switch_break;
Block: 1721
ProgElement 3296: goto switch_break;
Block: 1722
ProgElement 3297: goto switch_break;
Block: 1723
ProgElement 3298: goto switch_break;
Block: 1724
ProgElement 3299: goto while_break___8;
Block: 1725
ProgElement 3300: goto while_break___9;
Block: 1726
ProgElement 3301: goto switch_break;
Block: 1727
ProgElement 3302: goto while_break___11;
Block: 1728
ProgElement 3303: goto switch_break;
Block: 1729
ProgElement 3304: goto while_break___12;
Block: 1730
ProgElement 3305: goto switch_break;
Block: 1731
ProgElement 3306: goto while_break___15;
Block: 1732
ProgElement 3307: goto switch_break;
Block: 1733
ProgElement 3308: goto while_break___17;
Block: 1734
ProgElement 3309: goto switch_break;
Block: 1735
ProgElement 3310: goto while_break___18;
Block: 1736
ProgElement 3311: goto switch_break;
Block: 1737
ProgElement 3312: goto while_break___20;
Block: 1738
ProgElement 3313: goto switch_break;
Block: 1739
ProgElement 3314: goto while_break___21;
Block: 1740
ProgElement 3315: goto switch_break;
Block: 1741
ProgElement 3316: goto yynewstate;
Block: 1742
ProgElement 3317: goto yyerrlab1;
Block: 1743
ProgElement 3318: goto yyabortlab;
Block: 1744
ProgElement 3319: goto yyerrdefault;
Block: 1745
ProgElement 3320: goto while_break;
Block: 1746
ProgElement 3321: goto while_break___3;
Block: 1747
ProgElement 3322: goto while_break___4;
Block: 1748
ProgElement 3323: goto while_break___5;
Block: 1749
ProgElement 3324: goto while_break___6;
Block: 1750
ProgElement 3325: goto while_break___7;
Block: 1751
ProgElement 3326: goto while_break___8;
Block: 1752
ProgElement 3327: goto while_break;
Block: 1753
ProgElement 3328: goto while_break___0;
Block: 1754
ProgElement 3329: goto while_break___1;
Block: 1755
ProgElement 3330: goto while_break;
Block: 1756
ProgElement 3331: goto while_break;
Block: 1757
ProgElement 3332: goto while_break;
Block: 1758
ProgElement 3333: goto while_break;
Block: 1759
ProgElement 3334: goto while_break___0;
Block: 1760
ProgElement 3335: goto while_break;
Block: 1761
ProgElement 3336: goto while_break___0;
Block: 1762
ProgElement 3337: goto while_break;
Block: 1763
ProgElement 3338: goto while_break___0;
Block: 1764
ProgElement 3339: goto while_break;
Block: 1765
ProgElement 3340: goto while_break___0;
Block: 1766
ProgElement 3341: goto while_break___1;
Block: 1767
ProgElement 3342: goto while_break___1;
Block: 1768
ProgElement 3343: goto while_break___1;
Block: 1769
ProgElement 3344: goto _L;
Block: 1770
ProgElement 3345: goto while_break;
Block: 1771
ProgElement 3346: goto case_98;
Block: 1772
ProgElement 3347: goto case_102;
Block: 1773
ProgElement 3348: goto case_110;
Block: 1774
ProgElement 3349: goto case_114;
Block: 1775
ProgElement 3350: goto case_116;
Block: 1776
ProgElement 3351: goto case_97;
Block: 1777
ProgElement 3352: goto case_118;
Block: 1778
ProgElement 3353: goto case_48;
Block: 1779
ProgElement 3354: goto case_48;
Block: 1780
ProgElement 3355: goto case_48;
Block: 1781
ProgElement 3356: goto case_48;
Block: 1782
ProgElement 3357: goto case_120;
Block: 1783
ProgElement 3358: goto switch_default;
Block: 1784
ProgElement 3359: goto while_break;
Block: 1785
ProgElement 3360: goto while_break___0;
Block: 1786
ProgElement 3361: goto while_break___0;
Block: 1787
ProgElement 3362: goto while_break___0;
Block: 1788
ProgElement 3363: goto while_break___1;
Block: 1789
ProgElement 3364: goto while_break;
Block: 1790
ProgElement 3365: goto while_break___0;
Block: 1791
ProgElement 3366: goto while_break;
Block: 1792
ProgElement 3367: goto while_break___0;
Block: 1793
ProgElement 3368: goto _L___0;
Block: 1794
ProgElement 3369: goto while_break___1;
Block: 1795
ProgElement 3370: goto while_break;
Block: 1796
ProgElement 3371: goto while_break___0;
Block: 1797
ProgElement 3372: goto while_break___2;
Block: 1798
ProgElement 3373: goto while_break___3;
Block: 1799
ProgElement 3374: goto while_break___4;
Block: 1800
ProgElement 3375: goto while_break___5;
Block: 1801
ProgElement 3376: goto while_break___6;
Block: 1802
ProgElement 3377: goto while_break___7;
Block: 1803
ProgElement 3378: goto while_break___8;
Block: 1804
ProgElement 3379: goto while_break___10;
Block: 1805
ProgElement 3380: goto while_break___11;
Block: 1806
ProgElement 3381: goto while_break___12;
Block: 1807
ProgElement 3382: goto while_break;
Block: 1808
ProgElement 3383: goto while_break___0;
Block: 1809
ProgElement 3384: goto while_break___0;
Block: 1810
ProgElement 3385: goto while_break___1;
Block: 1811
ProgElement 3386: goto while_break___2;
Block: 1812
ProgElement 3387: goto while_break___3;
Block: 1813
ProgElement 3388: goto while_break;
Block: 1814
ProgElement 3389: goto while_break___0;
Block: 1815
ProgElement 3390: goto while_break___0;
Block: 1816
ProgElement 3391: goto bottom;
Block: 1817
ProgElement 3392: goto while_break___1;
Block: 1818
ProgElement 3393: goto while_break___1;
Block: 1819
ProgElement 3394: goto _L___0;
Block: 1820
ProgElement 3395: goto _L___0;
Block: 1821
ProgElement 3396: goto while_break;
Block: 1822
ProgElement 3397: goto while_break___0;
Block: 1823
ProgElement 3398: goto while_break___1;
Block: 1824
ProgElement 3399: goto while_break___2;
Block: 1825
ProgElement 3400: goto while_break___3;
Block: 1826
ProgElement 3401: goto while_break___4;
Block: 1827
ProgElement 3402: goto while_break;
Block: 1828
ProgElement 3403: goto while_break___0;
Block: 1829
ProgElement 3404: goto while_break;
Block: 1830
ProgElement 3405: goto while_break___0;
Block: 1831
ProgElement 3406: goto while_break;
Block: 1832
ProgElement 3407: goto while_break;
Block: 1833
ProgElement 3408: goto while_break;
Block: 1834
ProgElement 3409: goto while_break;
Block: 1835
ProgElement 3410: goto while_break___0;
Block: 1836
ProgElement 3411: goto while_break;
Block: 1837
ProgElement 3412: goto while_break___0;
Block: 1838
ProgElement 3413: goto while_break___1;
Block: 1839
ProgElement 3414: goto while_break___0;
Block: 1840
ProgElement 3415: goto while_break___1;
Block: 1841
ProgElement 3416: goto while_break___2;
Block: 1842
ProgElement 3417: goto while_break___3;
Block: 1843
ProgElement 3418: goto while_break___3;
Block: 1844
ProgElement 3419: goto while_break;
Block: 1845
ProgElement 3420: goto while_break;
Block: 1846
ProgElement 3421: goto while_break___0;
Block: 1847
ProgElement 3422: goto while_break;
Block: 1848
ProgElement 3423: goto while_break___0;
Block: 1849
ProgElement 3424: goto while_break___1;
Block: 1850
ProgElement 3425: goto while_break___2;
Block: 1851
ProgElement 3426: goto while_break___3;
Block: 1852
ProgElement 3427: goto while_break___4;
Block: 1853
ProgElement 3428: goto _L;
Block: 1854
ProgElement 3429: goto while_break___5;
Block: 1855
ProgElement 3430: goto while_break___6;
Block: 1856
ProgElement 3431: goto while_break___7;
Block: 1857
ProgElement 3432: goto while_break___8;
Block: 1858
ProgElement 3433: goto while_break___9;
Block: 1859
ProgElement 3434: goto while_break;
Block: 1860
ProgElement 3435: goto while_break;
Block: 1861
ProgElement 3436: goto while_break___1;
Block: 1862
ProgElement 3437: goto while_break___0;
Block: 1863
ProgElement 3438: goto case_1;
Block: 1864
ProgElement 3439: goto case_2;
Block: 1865
ProgElement 3440: goto case_4;
Block: 1866
ProgElement 3441: goto case_5;
Block: 1867
ProgElement 3442: goto case_6;
Block: 1868
ProgElement 3443: goto case_7;
Block: 1869
ProgElement 3444: goto case_8;
Block: 1870
ProgElement 3445: goto case_11;
Block: 1871
ProgElement 3446: goto case_15;
Block: 1872
ProgElement 3447: goto case_16;
Block: 1873
ProgElement 3448: goto case_17;
Block: 1874
ProgElement 3449: goto case_18;
Block: 1875
ProgElement 3450: goto case_19;
Block: 1876
ProgElement 3451: goto case_21;
Block: 1877
ProgElement 3452: goto case_27;
Block: 1878
ProgElement 3453: goto case_28;
Block: 1879
ProgElement 3454: goto case_29;
Block: 1880
ProgElement 3455: goto case_30;
Block: 1881
ProgElement 3456: goto case_31;
Block: 1882
ProgElement 3457: goto case_32;
Block: 1883
ProgElement 3458: goto case_33;
Block: 1884
ProgElement 3459: goto case_34;
Block: 1885
ProgElement 3460: goto case_35;
Block: 1886
ProgElement 3461: goto case_77;
Block: 1887
ProgElement 3462: goto case_80;
Block: 1888
ProgElement 3463: goto case_86;
Block: 1889
ProgElement 3464: goto case_88;
Block: 1890
ProgElement 3465: goto case_169;
Block: 1891
ProgElement 3466: goto case_89;
Block: 1892
ProgElement 3467: goto case_91;
Block: 1893
ProgElement 3468: goto case_92;
Block: 1894
ProgElement 3469: goto case_93;
Block: 1895
ProgElement 3470: goto case_94;
Block: 1896
ProgElement 3471: goto case_95;
Block: 1897
ProgElement 3472: goto case_97;
Block: 1898
ProgElement 3473: goto case_98;
Block: 1899
ProgElement 3474: goto case_99;
Block: 1900
ProgElement 3475: goto case_100;
Block: 1901
ProgElement 3476: goto case_101;
Block: 1902
ProgElement 3477: goto case_102;
Block: 1903
ProgElement 3478: goto case_102;
Block: 1904
ProgElement 3479: goto case_104;
Block: 1905
ProgElement 3480: goto case_105;
Block: 1906
ProgElement 3481: goto case_106;
Block: 1907
ProgElement 3482: goto case_107;
Block: 1908
ProgElement 3483: goto case_108;
Block: 1909
ProgElement 3484: goto case_109;
Block: 1910
ProgElement 3485: goto case_110;
Block: 1911
ProgElement 3486: goto case_112;
Block: 1912
ProgElement 3487: goto case_115;
Block: 1913
ProgElement 3488: goto case_116;
Block: 1914
ProgElement 3489: goto case_118;
Block: 1915
ProgElement 3490: goto case_120;
Block: 1916
ProgElement 3491: goto case_121;
Block: 1917
ProgElement 3492: goto case_122;
Block: 1918
ProgElement 3493: goto case_123;
Block: 1919
ProgElement 3494: goto case_125;
Block: 1920
ProgElement 3495: goto case_127;
Block: 1921
ProgElement 3496: goto case_128;
Block: 1922
ProgElement 3497: goto case_131;
Block: 1923
ProgElement 3498: goto case_133;
Block: 1924
ProgElement 3499: goto case_134;
Block: 1925
ProgElement 3500: goto case_135;
Block: 1926
ProgElement 3501: goto case_136;
Block: 1927
ProgElement 3502: goto case_138;
Block: 1928
ProgElement 3503: goto case_139;
Block: 1929
ProgElement 3504: goto case_140;
Block: 1930
ProgElement 3505: goto case_144;
Block: 1931
ProgElement 3506: goto case_145;
Block: 1932
ProgElement 3507: goto case_146;
Block: 1933
ProgElement 3508: goto case_149;
Block: 1934
ProgElement 3509: goto case_150;
Block: 1935
ProgElement 3510: goto case_151;
Block: 1936
ProgElement 3511: goto case_152;
Block: 1937
ProgElement 3512: goto case_153;
Block: 1938
ProgElement 3513: goto case_154;
Block: 1939
ProgElement 3514: goto case_155;
Block: 1940
ProgElement 3515: goto case_157;
Block: 1941
ProgElement 3516: goto case_158;
Block: 1942
ProgElement 3517: goto case_160;
Block: 1943
ProgElement 3518: goto case_162;
Block: 1944
ProgElement 3519: goto case_163;
Block: 1945
ProgElement 3520: goto case_170;
Block: 1946
ProgElement 3521: goto case_167;
Block: 1947
ProgElement 3522: goto case_166;
Block: 1948
ProgElement 3523: goto switch_break;
Block: 1949
ProgElement 3524: goto switch_break;
Block: 1950
ProgElement 3525: goto switch_break;
Block: 1951
ProgElement 3526: goto while_break___2;
Block: 1952
ProgElement 3527: goto switch_break;
Block: 1953
ProgElement 3528: goto switch_break;
Block: 1954
ProgElement 3529: goto switch_break;
Block: 1955
ProgElement 3530: goto switch_break;
Block: 1956
ProgElement 3531: goto switch_break;
Block: 1957
ProgElement 3532: goto switch_break;
Block: 1958
ProgElement 3533: goto switch_break;
Block: 1959
ProgElement 3534: goto switch_break;
Block: 1960
ProgElement 3535: goto switch_break;
Block: 1961
ProgElement 3536: goto switch_break;
Block: 1962
ProgElement 3537: goto switch_break;
Block: 1963
ProgElement 3538: goto switch_break;
Block: 1964
ProgElement 3539: goto switch_break;
Block: 1965
ProgElement 3540: goto switch_break;
Block: 1966
ProgElement 3541: goto switch_break;
Block: 1967
ProgElement 3542: goto _L;
Block: 1968
ProgElement 3543: goto while_break___8;
Block: 1969
ProgElement 3544: goto _L___0;
Block: 1970
ProgElement 3545: goto while_break___9;
Block: 1971
ProgElement 3546: goto switch_break;
Block: 1972
ProgElement 3547: goto switch_break;
Block: 1973
ProgElement 3548: goto switch_break;
Block: 1974
ProgElement 3549: goto switch_break;
Block: 1975
ProgElement 3550: goto switch_break;
Block: 1976
ProgElement 3551: goto switch_break;
Block: 1977
ProgElement 3552: goto switch_break;
Block: 1978
ProgElement 3553: goto switch_break;
Block: 1979
ProgElement 3554: goto switch_break;
Block: 1980
ProgElement 3555: goto switch_break;
Block: 1981
ProgElement 3556: goto switch_break;
Block: 1982
ProgElement 3557: goto switch_break;
Block: 1983
ProgElement 3558: goto switch_break;
Block: 1984
ProgElement 3559: goto switch_break;
Block: 1985
ProgElement 3560: goto switch_break;
Block: 1986
ProgElement 3561: goto switch_break;
Block: 1987
ProgElement 3562: goto switch_break;
Block: 1988
ProgElement 3563: goto switch_break;
Block: 1989
ProgElement 3564: goto switch_break;
Block: 1990
ProgElement 3565: goto switch_break;
Block: 1991
ProgElement 3566: goto switch_break;
Block: 1992
ProgElement 3567: goto switch_break;
Block: 1993
ProgElement 3568: goto switch_break;
Block: 1994
ProgElement 3569: goto switch_break;
Block: 1995
ProgElement 3570: goto switch_break;
Block: 1996
ProgElement 3571: goto switch_break;
Block: 1997
ProgElement 3572: goto switch_break;
Block: 1998
ProgElement 3573: goto switch_break;
Block: 1999
ProgElement 3574: goto switch_break;
Block: 2000
ProgElement 3575: goto switch_break;
Block: 2001
ProgElement 3576: goto switch_break;
Block: 2002
ProgElement 3577: goto switch_break;
Block: 2003
ProgElement 3578: goto switch_break;
Block: 2004
ProgElement 3579: goto switch_break;
Block: 2005
ProgElement 3580: goto switch_break;
Block: 2006
ProgElement 3581: goto switch_break;
Block: 2007
ProgElement 3582: goto switch_break;
Block: 2008
ProgElement 3583: goto switch_break;
Block: 2009
ProgElement 3584: goto switch_break;
Block: 2010
ProgElement 3585: goto case_1___0;
Block: 2011
ProgElement 3586: goto case_0___0;
Block: 2012
ProgElement 3587: goto switch_break___0;
Block: 2013
ProgElement 3588: goto switch_break;
Block: 2014
ProgElement 3589: goto while_break;
Block: 2015
ProgElement 3590: goto while_break___0;
Block: 2016
ProgElement 3591: goto while_break;
Block: 2017
ProgElement 3592: goto while_break___0;
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56402)
Iteration 2 (Word: 44090)
Iteration 3 (Word: 39457)
Iteration 1 (Word: 39457)

Initial SR-Score: 1.000000; Initial AR-Score: 0.987460; Initial R-Score: 0.993730; Initial G-Score: 0.156716; Initial O-Score: 0.910028; Initial D-Score: 57678889055361695744.000000

Current Iteration: 0; Current Samples: 0
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.85667986
Curren PROB is 0.8567658!
Selected ProgElement Index: 1950
Adding back ProgElement of Index: 1950
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56404)
Iteration 2 (Word: 44092)
Iteration 3 (Word: 39459)
Iteration 1 (Word: 39459)
Sample Id: 0
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987460; Last R-Score: 0.993730; Last G-Score: 0.156716; Last O-Score: 0.910028; Last D-Score: 57678889055361695744.000000
Accepted? Yes

Current Iteration: 1; Current Samples: 1
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.30547097
Curren PROB is 0.30560946!
Selected ProgElement Index: 3559
Adding back ProgElement of Index: 3559
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56406)
Iteration 2 (Word: 44095)
Iteration 3 (Word: 40392)
Iteration 1 (Word: 40392)
Sample Id: 1
SR-Score: 1.000000; AR-Score: 0.986784; R-Score: 0.993392; G-Score: 0.156716; O-Score: 0.909724; D-Score: 56808273758256103424.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 2; Current Samples: 2
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.7249341
Curren PROB is 0.7254302!
Selected ProgElement Index: 1506
Adding back ProgElement of Index: 1506
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56407)
Iteration 2 (Word: 44096)
Iteration 3 (Word: 40393)
Iteration 1 (Word: 40393)
Sample Id: 2
SR-Score: 1.000000; AR-Score: 0.986784; R-Score: 0.993392; G-Score: 0.156716; O-Score: 0.909724; D-Score: 56808273758256103424.000000
Last SR-Score: 1.000000; Last AR-Score: 0.986784; Last R-Score: 0.993392; Last G-Score: 0.156716; Last O-Score: 0.909724; Last D-Score: 56808273758256103424.000000
Accepted? Yes

Current Iteration: 3; Current Samples: 3
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.47383428
Curren PROB is 0.4739423!
Selected ProgElement Index: 1485
Adding back ProgElement of Index: 1485
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56414)
Iteration 2 (Word: 44103)
Iteration 3 (Word: 40415)
Iteration 1 (Word: 40415)
Sample Id: 3
SR-Score: 1.000000; AR-Score: 0.986784; R-Score: 0.993392; G-Score: 0.156716; O-Score: 0.909724; D-Score: 56808273758256103424.000000
Last SR-Score: 1.000000; Last AR-Score: 0.986784; Last R-Score: 0.993392; Last G-Score: 0.156716; Last O-Score: 0.909724; Last D-Score: 56808273758256103424.000000
Accepted? Yes

Current Iteration: 4; Current Samples: 4
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.8967116
Curren PROB is 0.8969839!
Selected ProgElement Index: 343
Adding back ProgElement of Index: 343
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56419)
Iteration 2 (Word: 44111)
Iteration 3 (Word: 40423)
Iteration 1 (Word: 40423)
Sample Id: 4
SR-Score: 1.000000; AR-Score: 0.986784; R-Score: 0.993392; G-Score: 0.156716; O-Score: 0.909724; D-Score: 56808273758256103424.000000
Last SR-Score: 1.000000; Last AR-Score: 0.986784; Last R-Score: 0.993392; Last G-Score: 0.156716; Last O-Score: 0.909724; Last D-Score: 56808273758256103424.000000
Accepted? Yes

Current Iteration: 5; Current Samples: 5
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.78724635
Curren PROB is 0.78774226!
Selected ProgElement Index: 2829
Adding back ProgElement of Index: 2829
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56422)
Iteration 2 (Word: 44118)
Iteration 3 (Word: 40459)
Iteration 1 (Word: 40459)
Sample Id: 5
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.986784; Last R-Score: 0.993392; Last G-Score: 0.156716; Last O-Score: 0.909724; Last D-Score: 56808273758256103424.000000
Accepted? Yes

Current Iteration: 6; Current Samples: 6
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.34975135
Curren PROB is 0.34989434!
Selected ProgElement Index: 3270
Adding back ProgElement of Index: 3270
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56424)
Iteration 2 (Word: 44131)
Iteration 3 (Word: 40472)
Iteration 1 (Word: 40472)
Sample Id: 6
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 7; Current Samples: 7
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.77273625
Curren PROB is 0.77281004!
Selected ProgElement Index: 1639
Adding back ProgElement of Index: 1639
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56427)
Iteration 2 (Word: 44137)
Iteration 3 (Word: 40478)
Iteration 1 (Word: 40478)
Sample Id: 7
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 8; Current Samples: 8
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.5996275
Curren PROB is 0.59970456!
Selected ProgElement Index: 3234
Adding back ProgElement of Index: 3234
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56429)
Iteration 2 (Word: 44146)
Iteration 3 (Word: 40487)
Iteration 1 (Word: 40487)
Sample Id: 8
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 9; Current Samples: 9
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.050202865
Curren PROB is 0.050308783!
Selected ProgElement Index: 2308
Adding back ProgElement of Index: 2308
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56434)
Iteration 2 (Word: 44151)
Iteration 3 (Word: 40496)
Iteration 1 (Word: 40496)
Sample Id: 9
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 10; Current Samples: 10
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.7794584
Curren PROB is 0.7797767!
Selected ProgElement Index: 1645
Adding back ProgElement of Index: 1645
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56435)
Iteration 2 (Word: 44152)
Iteration 3 (Word: 40497)
Iteration 1 (Word: 40497)
Sample Id: 10
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 11; Current Samples: 11
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.22968443
Curren PROB is 0.22974822!
Selected ProgElement Index: 3452
Adding back ProgElement of Index: 3452
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56437)
Iteration 2 (Word: 44165)
Iteration 3 (Word: 40510)
Iteration 1 (Word: 40510)
Sample Id: 11
SR-Score: 1.000000; AR-Score: 0.987234; R-Score: 0.993617; G-Score: 0.156716; O-Score: 0.909927; D-Score: 57387210610745278464.000000
Last SR-Score: 1.000000; Last AR-Score: 0.987234; Last R-Score: 0.993617; Last G-Score: 0.156716; Last O-Score: 0.909927; Last D-Score: 57387210610745278464.000000
Accepted? Yes

Current Iteration: 12; Current Samples: 12
Current Best Sample Id: -1
Current Best SR-Score: 1.000000; AR-Score: 0.987460; R-Score: 0.993730; G-Score: 0.156716; O-Score: 0.910028; D-Score: 57678889055361695744.000000
Random PROB generated: 0.46325767
Curren PROB is 0.4634279!
Selected ProgElement Index: 2382
Adding back ProgElement of Index: 2382
Input: flex-2.5.4.tmp.c
Iteration 1 (Word: 56439)
