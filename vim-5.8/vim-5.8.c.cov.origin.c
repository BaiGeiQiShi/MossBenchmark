/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
typedef __ino_t ino_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef unsigned char char_u;
typedef unsigned long long_u;
enum auto_event {
    EVENT_BUFCREATE = 0,
    EVENT_BUFDELETE = 1,
    EVENT_BUFENTER = 2,
    EVENT_BUFFILEPOST = 3,
    EVENT_BUFFILEPRE = 4,
    EVENT_BUFLEAVE = 5,
    EVENT_BUFNEWFILE = 6,
    EVENT_BUFREADPOST = 7,
    EVENT_BUFREADPRE = 8,
    EVENT_BUFUNLOAD = 9,
    EVENT_BUFHIDDEN = 10,
    EVENT_BUFWRITEPOST = 11,
    EVENT_BUFWRITEPRE = 12,
    EVENT_FILEAPPENDPOST = 13,
    EVENT_FILEAPPENDPRE = 14,
    EVENT_FILECHANGEDSHELL = 15,
    EVENT_FILEREADPOST = 16,
    EVENT_FILEREADPRE = 17,
    EVENT_FILETYPE = 18,
    EVENT_FILEWRITEPOST = 19,
    EVENT_FILEWRITEPRE = 20,
    EVENT_FILTERREADPOST = 21,
    EVENT_FILTERREADPRE = 22,
    EVENT_FILTERWRITEPOST = 23,
    EVENT_FILTERWRITEPRE = 24,
    EVENT_FOCUSGAINED = 25,
    EVENT_FOCUSLOST = 26,
    EVENT_GUIENTER = 27,
    EVENT_STDINREADPOST = 28,
    EVENT_STDINREADPRE = 29,
    EVENT_SYNTAX = 30,
    EVENT_TERMCHANGED = 31,
    EVENT_USER = 32,
    EVENT_VIMENTER = 33,
    EVENT_VIMLEAVE = 34,
    EVENT_VIMLEAVEPRE = 35,
    EVENT_WINENTER = 36,
    EVENT_WINLEAVE = 37,
    EVENT_FILEENCODING = 38,
    EVENT_CURSORHOLD = 39,
    NUM_EVENTS = 40
} ;
typedef enum auto_event EVENT_T;
typedef long linenr_t;
typedef unsigned int colnr_t;
struct __anonstruct_vim_regexp_55 {
   char_u *startp[10] ;
   char_u *endp[10] ;
   char_u regstart ;
   char_u reganch ;
   char_u *regmust ;
   int regmlen ;
   char_u program[1] ;
};
typedef struct __anonstruct_vim_regexp_55 vim_regexp;
struct fpos;
struct fpos;
typedef struct fpos FPOS;
struct fpos {
   linenr_t lnum ;
   colnr_t col ;
};
struct filemark {
   FPOS mark ;
   int fnum ;
};
struct taggy {
   char_u *tagname ;
   struct filemark fmark ;
   int cur_match ;
};
struct window;
struct window;
typedef struct window WIN;
struct winfpos;
struct winfpos;
typedef struct winfpos WINFPOS;
struct winfpos {
   WINFPOS *wl_next ;
   WINFPOS *wl_prev ;
   WIN *wl_win ;
   FPOS wl_fpos ;
};
struct u_entry {
   struct u_entry *ue_next ;
   linenr_t ue_top ;
   linenr_t ue_bot ;
   linenr_t ue_lcount ;
   char_u **ue_array ;
   long ue_size ;
};
struct u_header {
   struct u_header *uh_next ;
   struct u_header *uh_prev ;
   struct u_entry *uh_entry ;
   FPOS uh_cursor ;
   int uh_flags ;
   FPOS uh_namedm[26] ;
};
struct m_info;
struct m_info;
typedef struct m_info info_t;
struct m_info {
   long_u m_size ;
   info_t *m_next ;
};
struct m_block {
   struct m_block *mb_next ;
   info_t mb_info ;
};
struct growarray {
   int ga_len ;
   int ga_room ;
   int ga_itemsize ;
   int ga_growsize ;
   void *ga_data ;
};
struct block_hdr;
struct block_hdr;
typedef struct block_hdr BHDR;
struct memfile;
struct memfile;
typedef struct memfile MEMFILE;
typedef long blocknr_t;
struct block_hdr {
   BHDR *bh_next ;
   BHDR *bh_prev ;
   BHDR *bh_hash_next ;
   BHDR *bh_hash_prev ;
   blocknr_t bh_bnum ;
   char_u *bh_data ;
   int bh_page_count ;
   char bh_flags ;
};
struct nr_trans;
struct nr_trans;
typedef struct nr_trans NR_TRANS;
struct nr_trans {
   NR_TRANS *nt_next ;
   NR_TRANS *nt_prev ;
   blocknr_t nt_old_bnum ;
   blocknr_t nt_new_bnum ;
};
struct memfile {
   char_u *mf_fname ;
   char_u *mf_ffname ;
   int mf_fd ;
   BHDR *mf_free_first ;
   BHDR *mf_used_first ;
   BHDR *mf_used_last ;
   unsigned int mf_used_count ;
   unsigned int mf_used_count_max ;
   BHDR *mf_hash[64] ;
   NR_TRANS *mf_trans[64] ;
   blocknr_t mf_blocknr_max ;
   blocknr_t mf_blocknr_min ;
   blocknr_t mf_neg_count ;
   blocknr_t mf_infile_count ;
   unsigned int mf_page_size ;
   int mf_dirty ;
};
struct info_pointer;
struct info_pointer;
typedef struct info_pointer IPTR;
struct info_pointer {
   blocknr_t ip_bnum ;
   linenr_t ip_low ;
   linenr_t ip_high ;
   int ip_index ;
};
struct ml_chunksize {
   int mlcs_numlines ;
   int mlcs_totalsize ;
};
typedef struct ml_chunksize ML_CHUNKSIZE;
struct memline;
struct memline;
typedef struct memline MEMLINE;
struct memline {
   linenr_t ml_line_count ;
   MEMFILE *ml_mfp ;
   int ml_flags ;
   IPTR *ml_stack ;
   int ml_stack_top ;
   int ml_stack_size ;
   linenr_t ml_line_lnum ;
   char_u *ml_line_ptr ;
   BHDR *ml_locked ;
   linenr_t ml_locked_low ;
   linenr_t ml_locked_high ;
   int ml_locked_lineadd ;
   ML_CHUNKSIZE *ml_chunksize ;
   int ml_numchunks ;
   int ml_usedchunks ;
};
struct keyentry {
   struct keyentry *next ;
   int syn_inc_tag ;
   short syn_id ;
   short *next_list ;
   short flags ;
   char_u keyword[1] ;
};
struct syn_state {
   struct growarray sst_ga ;
   short *sst_next_list ;
   int sst_next_flags ;
};
struct buffer;
struct buffer;
typedef struct buffer BUF;
struct buffer {
   MEMLINE b_ml ;
   BUF *b_next ;
   BUF *b_prev ;
   int b_changed ;
   int b_nwindows ;
   int b_flags ;
   char_u *b_ffname ;
   char_u *b_sfname ;
   char_u *b_fname ;
   int b_dev ;
   ino_t b_ino ;
   int b_fnum ;
   WINFPOS *b_winfpos ;
   long b_mtime ;
   long b_mtime_read ;
   FPOS b_namedm[26] ;
   FPOS b_visual_start ;
   FPOS b_visual_end ;
   int b_visual_mode ;
   FPOS b_last_cursor ;
   char b_chartab[256] ;
   FPOS b_op_start ;
   FPOS b_op_end ;
   int b_marks_read ;
   struct u_header *b_u_oldhead ;
   struct u_header *b_u_newhead ;
   struct u_header *b_u_curhead ;
   int b_u_numhead ;
   int b_u_synced ;
   char_u *b_u_line_ptr ;
   linenr_t b_u_line_lnum ;
   colnr_t b_u_line_colnr ;
   struct m_block b_block_head ;
   info_t *b_m_search ;
   struct m_block *b_mb_current ;
   int b_scanned ;
   int b_p_initialized ;
   int b_p_ai ;
   int b_p_ro ;
   int b_p_lisp ;
   int b_p_inf ;
   char_u *b_p_cpt ;
   int b_p_bin ;
   int b_p_eol ;
   int b_p_et ;
   int b_p_ml ;
   int b_p_tx ;
   int b_p_swf ;
   int b_p_sn ;
   long b_p_sw ;
   long b_p_sts ;
   long b_p_ts ;
   long b_p_tw ;
   long b_p_wm ;
   char_u *b_p_ff ;
   char_u *b_p_fo ;
   char_u *b_p_com ;
   char_u *b_p_isk ;
   char_u *b_p_key ;
   char_u *b_p_nf ;
   char_u *b_p_mps ;
   long b_p_wm_nobin ;
   long b_p_tw_nobin ;
   int b_p_ml_nobin ;
   int b_p_et_nobin ;
   int b_p_ai_save ;
   int b_p_lisp_save ;
   long b_p_tw_save ;
   long b_p_wm_save ;
   long b_p_sts_save ;
   int b_p_si ;
   int b_p_si_save ;
   int b_p_cin ;
   int b_p_cin_save ;
   char_u *b_p_cino ;
   char_u *b_p_cink ;
   char_u *b_p_cinw ;
   char_u *b_p_syn ;
   char_u *b_p_ft ;
   int b_start_ffc ;
   struct growarray b_vars ;
   int b_may_swap ;
   int b_did_warn ;
   int b_help ;
   int b_shortname ;
   struct keyentry **b_keywtab ;
   struct keyentry **b_keywtab_ic ;
   int b_syn_ic ;
   struct growarray b_syn_patterns ;
   struct growarray b_syn_clusters ;
   int b_syn_sync_flags ;
   short b_syn_sync_id ;
   long b_syn_sync_minlines ;
   long b_syn_sync_maxlines ;
   char_u *b_syn_linecont_pat ;
   vim_regexp *b_syn_linecont_prog ;
   int b_syn_linecont_ic ;
   int b_syn_topgrp ;
   struct syn_state *b_syn_states ;
   int b_syn_states_len ;
   linenr_t b_syn_states_lnum ;
   linenr_t b_syn_change_lnum ;
};
struct window {
   BUF *w_buffer ;
   WIN *w_prev ;
   WIN *w_next ;
   FPOS w_cursor ;
   int w_valid ;
   FPOS w_valid_cursor ;
   colnr_t w_valid_leftcol ;
   int w_wrow ;
   int w_wcol ;
   int w_cline_height ;
   int w_cline_row ;
   colnr_t w_virtcol ;
   colnr_t w_curswant ;
   int w_set_curswant ;
   linenr_t w_old_cursor_lnum ;
   colnr_t w_old_cursor_fcol ;
   colnr_t w_old_cursor_lcol ;
   linenr_t w_old_visual_lnum ;
   colnr_t w_old_curswant ;
   linenr_t w_topline ;
   linenr_t w_botline ;
   int w_empty_rows ;
   int w_winpos ;
   int w_height ;
   int w_status_height ;
   int w_redr_status ;
   int w_redr_type ;
   FPOS w_ru_cursor ;
   colnr_t w_ru_virtcol ;
   linenr_t w_ru_topline ;
   char w_ru_empty ;
   colnr_t w_leftcol ;
   colnr_t w_skipcol ;
   int w_lsize_valid ;
   linenr_t *w_lsize_lnum ;
   char_u *w_lsize ;
   int w_alt_fnum ;
   int w_arg_idx ;
   int w_arg_idx_invalid ;
   int w_p_list ;
   int w_p_nu ;
   int w_p_wrap ;
   int w_p_lbr ;
   long w_p_scroll ;
   int w_p_scb ;
   long w_scbind_pos ;
   int w_preview ;
   struct growarray w_vars ;
   FPOS w_pcmark ;
   FPOS w_prev_pcmark ;
   struct filemark w_jumplist[50] ;
   int w_jumplistlen ;
   int w_jumplistidx ;
   struct taggy w_tagstack[20] ;
   int w_tagstackidx ;
   int w_tagstacklen ;
   int w_fraction ;
   int w_prev_fraction_row ;
};
enum hlf_value {
    HLF_8 = 0,
    HLF_AT = 1,
    HLF_D = 2,
    HLF_E = 3,
    HLF_H = 4,
    HLF_I = 5,
    HLF_L = 6,
    HLF_M = 7,
    HLF_CM = 8,
    HLF_N = 9,
    HLF_R = 10,
    HLF_S = 11,
    HLF_SNC = 12,
    HLF_T = 13,
    HLF_V = 14,
    HLF_VNC = 15,
    HLF_W = 16,
    HLF_WM = 17,
    HLF_COUNT = 18
} ;
struct oparg {
   int op_type ;
   int regname ;
   int motion_type ;
   int inclusive ;
   int end_adjusted ;
   FPOS start ;
   FPOS end ;
   long line_count ;
   int empty ;
   int is_VIsual ;
   int block_mode ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
};
typedef struct oparg OPARG;
struct Completion {
   struct Completion *next ;
   struct Completion *prev ;
   char_u *str ;
   char_u *fname ;
   int original ;
};
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
enum CMD_index {
    CMD_append = 0,
    CMD_abbreviate = 1,
    CMD_abclear = 2,
    CMD_all = 3,
    CMD_amenu = 4,
    CMD_anoremenu = 5,
    CMD_args = 6,
    CMD_argument = 7,
    CMD_ascii = 8,
    CMD_autocmd = 9,
    CMD_augroup = 10,
    CMD_aunmenu = 11,
    CMD_buffer = 12,
    CMD_bNext = 13,
    CMD_ball = 14,
    CMD_badd = 15,
    CMD_bdelete = 16,
    CMD_behave = 17,
    CMD_blast = 18,
    CMD_bmodified = 19,
    CMD_bnext = 20,
    CMD_bprevious = 21,
    CMD_brewind = 22,
    CMD_break = 23,
    CMD_browse = 24,
    CMD_buffers = 25,
    CMD_bunload = 26,
    CMD_change = 27,
    CMD_cNext = 28,
    CMD_cabbrev = 29,
    CMD_cabclear = 30,
    CMD_call = 31,
    CMD_cc = 32,
    CMD_cd = 33,
    CMD_center = 34,
    CMD_cfile = 35,
    CMD_chdir = 36,
    CMD_checkpath = 37,
    CMD_clist = 38,
    CMD_clast = 39,
    CMD_close = 40,
    CMD_cmap = 41,
    CMD_cmapclear = 42,
    CMD_cmenu = 43,
    CMD_cnext = 44,
    CMD_cnewer = 45,
    CMD_cnfile = 46,
    CMD_cnoremap = 47,
    CMD_cnoreabbrev = 48,
    CMD_cnoremenu = 49,
    CMD_copy = 50,
    CMD_colder = 51,
    CMD_command = 52,
    CMD_comclear = 53,
    CMD_continue = 54,
    CMD_confirm = 55,
    CMD_cprevious = 56,
    CMD_cquit = 57,
    CMD_crewind = 58,
    CMD_cscope = 59,
    CMD_cstag = 60,
    CMD_cunmap = 61,
    CMD_cunabbrev = 62,
    CMD_cunmenu = 63,
    CMD_delete = 64,
    CMD_delcommand = 65,
    CMD_delfunction = 66,
    CMD_display = 67,
    CMD_digraphs = 68,
    CMD_djump = 69,
    CMD_dlist = 70,
    CMD_doautocmd = 71,
    CMD_doautoall = 72,
    CMD_dsearch = 73,
    CMD_dsplit = 74,
    CMD_edit = 75,
    CMD_echo = 76,
    CMD_echohl = 77,
    CMD_echon = 78,
    CMD_else = 79,
    CMD_elseif = 80,
    CMD_exemenu = 81,
    CMD_endif = 82,
    CMD_endfunction = 83,
    CMD_endwhile = 84,
    CMD_ex = 85,
    CMD_execute = 86,
    CMD_exit = 87,
    CMD_file = 88,
    CMD_files = 89,
    CMD_filetype = 90,
    CMD_find = 91,
    CMD_fixdel = 92,
    CMD_function = 93,
    CMD_global = 94,
    CMD_goto = 95,
    CMD_grep = 96,
    CMD_gui = 97,
    CMD_gvim = 98,
    CMD_help = 99,
    CMD_helpfind = 100,
    CMD_highlight = 101,
    CMD_hide = 102,
    CMD_history = 103,
    CMD_insert = 104,
    CMD_iabbrev = 105,
    CMD_iabclear = 106,
    CMD_if = 107,
    CMD_ijump = 108,
    CMD_ilist = 109,
    CMD_imap = 110,
    CMD_imapclear = 111,
    CMD_imenu = 112,
    CMD_inoremap = 113,
    CMD_inoreabbrev = 114,
    CMD_inoremenu = 115,
    CMD_intro = 116,
    CMD_isearch = 117,
    CMD_isplit = 118,
    CMD_iunmap = 119,
    CMD_iunabbrev = 120,
    CMD_iunmenu = 121,
    CMD_join = 122,
    CMD_jumps = 123,
    CMD_k = 124,
    CMD_list = 125,
    CMD_last = 126,
    CMD_left = 127,
    CMD_let = 128,
    CMD_ls = 129,
    CMD_move = 130,
    CMD_mark = 131,
    CMD_make = 132,
    CMD_map = 133,
    CMD_mapclear = 134,
    CMD_marks = 135,
    CMD_menu = 136,
    CMD_messages = 137,
    CMD_mkexrc = 138,
    CMD_mksession = 139,
    CMD_mkvimrc = 140,
    CMD_mode = 141,
    CMD_next = 142,
    CMD_new = 143,
    CMD_nmap = 144,
    CMD_nmapclear = 145,
    CMD_nmenu = 146,
    CMD_nnoremap = 147,
    CMD_nnoremenu = 148,
    CMD_noremap = 149,
    CMD_nohlsearch = 150,
    CMD_noreabbrev = 151,
    CMD_noremenu = 152,
    CMD_normal = 153,
    CMD_number = 154,
    CMD_nunmap = 155,
    CMD_nunmenu = 156,
    CMD_open = 157,
    CMD_omap = 158,
    CMD_omapclear = 159,
    CMD_omenu = 160,
    CMD_only = 161,
    CMD_onoremap = 162,
    CMD_onoremenu = 163,
    CMD_options = 164,
    CMD_ounmap = 165,
    CMD_ounmenu = 166,
    CMD_print = 167,
    CMD_pclose = 168,
    CMD_perl = 169,
    CMD_perldo = 170,
    CMD_pop = 171,
    CMD_ppop = 172,
    CMD_preserve = 173,
    CMD_previous = 174,
    CMD_promptfind = 175,
    CMD_promptrepl = 176,
    CMD_ptag = 177,
    CMD_ptNext = 178,
    CMD_ptjump = 179,
    CMD_ptlast = 180,
    CMD_ptnext = 181,
    CMD_ptprevious = 182,
    CMD_ptrewind = 183,
    CMD_ptselect = 184,
    CMD_put = 185,
    CMD_pwd = 186,
    CMD_python = 187,
    CMD_pyfile = 188,
    CMD_quit = 189,
    CMD_qall = 190,
    CMD_read = 191,
    CMD_recover = 192,
    CMD_redo = 193,
    CMD_redir = 194,
    CMD_registers = 195,
    CMD_resize = 196,
    CMD_retab = 197,
    CMD_return = 198,
    CMD_rewind = 199,
    CMD_right = 200,
    CMD_rviminfo = 201,
    CMD_substitute = 202,
    CMD_sNext = 203,
    CMD_sargument = 204,
    CMD_sall = 205,
    CMD_sbuffer = 206,
    CMD_sbNext = 207,
    CMD_sball = 208,
    CMD_sblast = 209,
    CMD_sbmodified = 210,
    CMD_sbnext = 211,
    CMD_sbprevious = 212,
    CMD_sbrewind = 213,
    CMD_set = 214,
    CMD_sfind = 215,
    CMD_shell = 216,
    CMD_sleep = 217,
    CMD_slast = 218,
    CMD_smagic = 219,
    CMD_snext = 220,
    CMD_sniff = 221,
    CMD_snomagic = 222,
    CMD_source = 223,
    CMD_split = 224,
    CMD_sprevious = 225,
    CMD_srewind = 226,
    CMD_stop = 227,
    CMD_stag = 228,
    CMD_startinsert = 229,
    CMD_stjump = 230,
    CMD_stselect = 231,
    CMD_sunhide = 232,
    CMD_suspend = 233,
    CMD_sview = 234,
    CMD_swapname = 235,
    CMD_syntax = 236,
    CMD_syncbind = 237,
    CMD_t = 238,
    CMD_tNext = 239,
    CMD_tag = 240,
    CMD_tags = 241,
    CMD_tcl = 242,
    CMD_tcldo = 243,
    CMD_tclfile = 244,
    CMD_tearoff = 245,
    CMD_tjump = 246,
    CMD_tlast = 247,
    CMD_tmenu = 248,
    CMD_tnext = 249,
    CMD_tprevious = 250,
    CMD_trewind = 251,
    CMD_tselect = 252,
    CMD_tunmenu = 253,
    CMD_undo = 254,
    CMD_unabbreviate = 255,
    CMD_unhide = 256,
    CMD_unlet = 257,
    CMD_unmap = 258,
    CMD_unmenu = 259,
    CMD_update = 260,
    CMD_vglobal = 261,
    CMD_version = 262,
    CMD_visual = 263,
    CMD_view = 264,
    CMD_vmap = 265,
    CMD_vmapclear = 266,
    CMD_vmenu = 267,
    CMD_vnoremap = 268,
    CMD_vnoremenu = 269,
    CMD_vunmap = 270,
    CMD_vunmenu = 271,
    CMD_write = 272,
    CMD_wNext = 273,
    CMD_wall = 274,
    CMD_while = 275,
    CMD_winsize = 276,
    CMD_winpos = 277,
    CMD_wnext = 278,
    CMD_wprevious = 279,
    CMD_wq = 280,
    CMD_wqall = 281,
    CMD_wviminfo = 282,
    CMD_xit = 283,
    CMD_xall = 284,
    CMD_yank = 285,
    CMD_z = 286,
    CMD_bang = 287,
    CMD_pound = 288,
    CMD_and = 289,
    CMD_star = 290,
    CMD_lshift = 291,
    CMD_equal = 292,
    CMD_rshift = 293,
    CMD_at = 294,
    CMD_Next = 295,
    CMD_Print = 296,
    CMD_X = 297,
    CMD_tilde = 298,
    CMD_SIZE = 299,
    CMD_USER = -1
} ;
typedef enum CMD_index CMDIDX;
struct exarg {
   char_u *arg ;
   char_u *nextcmd ;
   char_u *cmd ;
   CMDIDX cmdidx ;
   long argt ;
   int skip ;
   int forceit ;
   int addr_count ;
   linenr_t line1 ;
   linenr_t line2 ;
   char_u *do_ecmd_cmd ;
   linenr_t do_ecmd_lnum ;
   int append ;
   int usefilter ;
   int amount ;
   int regname ;
   int useridx ;
};
typedef struct exarg EXARG;
typedef int var_number_type;
union __anonunion_var_val_170 {
   var_number_type var_number ;
   char_u *var_string ;
};
struct __anonstruct_var_169 {
   char_u *var_name ;
   char var_type ;
   union __anonunion_var_val_170 var_val ;
};
typedef struct __anonstruct_var_169 var;
typedef var *VAR;
struct ufunc {
   struct ufunc *next ;
   char_u *name ;
   int varargs ;
   int flags ;
   int calls ;
   struct growarray args ;
   struct growarray lines ;
};
struct funccall {
   struct ufunc *func ;
   int linenr ;
   int argcount ;
   VAR argvars ;
   var a0_var ;
   var firstline ;
   var lastline ;
   struct growarray l_vars ;
   VAR retvar ;
};
struct vimvar {
   char *name ;
   int len ;
   char_u *val ;
   char type ;
   char flags ;
};
enum exp_type {
    TYPE_UNKNOWN = 0,
    TYPE_EQUAL = 1,
    TYPE_NEQUAL = 2,
    TYPE_GREATER = 3,
    TYPE_GEQUAL = 4,
    TYPE_SMALLER = 5,
    TYPE_SEQUAL = 6,
    TYPE_MATCH = 7,
    TYPE_NOMATCH = 8
} ;
struct fst {
   char *f_name ;
   char f_min_argc ;
   char f_max_argc ;
   void (*f_func)(VAR args , VAR rvar ) ;
};
enum __anonenum_VAR_FLAVOUR_171 {
    VAR_FLAVOUR_DEFAULT = 0,
    VAR_FLAVOUR_SESSION = 1,
    VAR_FLAVOUR_VIMINFO = 2
} ;
typedef enum __anonenum_VAR_FLAVOUR_171 VAR_FLAVOUR;
typedef __mode_t mode_t;
struct cmdname {
   char_u *cmd_name ;
   long_u cmd_argt ;
};
struct condstack {
   char cs_flags[50] ;
   int cs_line[50] ;
   int cs_idx ;
   int cs_whilelevel ;
   char cs_had_while ;
   char cs_had_continue ;
   char cs_had_endwhile ;
};
struct ucmd {
   char_u *uc_name ;
   long uc_argt ;
   char_u *uc_rep ;
   long uc_def ;
   int uc_compl ;
};
typedef struct ucmd UCMD;
struct source_cookie {
   FILE *fp ;
   char_u *nextline ;
};
enum __anonenum_type_169 {
    ct_ARGS = 0,
    ct_BANG = 1,
    ct_COUNT = 2,
    ct_LINE1 = 3,
    ct_LINE2 = 4,
    ct_REGISTER = 5,
    ct_LT = 6,
    ct_NONE = 7
} ;
struct cmdline_info {
   char_u *cmdbuff ;
   int cmdbufflen ;
   int cmdlen ;
   int cmdpos ;
   int cmdspos ;
   int cmdfirstc ;
   int cmdindent ;
   char_u *cmdprompt ;
   int cmdattr ;
   int overstrike ;
};
struct hist_entry {
   int hisnum ;
   char_u *hisstr ;
};
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef __uid_t uid_t;
struct aco_save {
   WIN *save_curwin ;
   BUF *save_buf ;
   FPOS save_cursor ;
   linenr_t save_topline ;
};
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
struct AutoCmd {
   char_u *cmd ;
   char nested ;
   char last ;
   struct AutoCmd *next ;
};
typedef struct AutoCmd AutoCmd;
struct AutoPat {
   int group ;
   char_u *pat ;
   int patlen ;
   char_u *reg_pat ;
   char allow_dirs ;
   char last ;
   AutoCmd *cmds ;
   struct AutoPat *next ;
};
typedef struct AutoPat AutoPat;
struct event_name {
   char *name ;
   EVENT_T event ;
};
struct AutoPatCmd {
   AutoPat *curpat ;
   AutoCmd *nextcmd ;
   int group ;
   char_u *fname ;
   char_u *sfname ;
   char_u *tail ;
   EVENT_T event ;
};
typedef struct AutoPatCmd AutoPatCmd;
struct bufblock {
   struct bufblock *b_next ;
   char_u b_str[1] ;
};
struct buffheader {
   struct bufblock bh_first ;
   struct bufblock *bh_curr ;
   int bh_index ;
   int bh_space ;
};
struct mapblock {
   struct mapblock *m_next ;
   char_u *m_keys ;
   int m_keylen ;
   char_u *m_str ;
   int m_mode ;
   int m_noremap ;
};
struct initmap {
   char_u *arg ;
   int mode ;
};
typedef unsigned short short_u;
typedef unsigned long Atom;
struct _XDisplay;
struct _XDisplay;
typedef struct _XDisplay Display;
struct _XtAppStruct;
struct _XtAppStruct;
typedef struct _XtAppStruct *XtAppContext;
struct VimMenu {
   int modes ;
   char_u *name ;
   char_u *dname ;
   int mnemonic ;
   char_u *actext ;
   int priority ;
   char_u *strings[6] ;
   int noremap[6] ;
   struct VimMenu *children ;
   struct VimMenu *next ;
};
typedef struct VimMenu VimMenu;
struct VimClipboard {
   int available ;
   int owned ;
   FPOS start ;
   FPOS end ;
   int vmode ;
   short_u origin_row ;
   short_u origin_start_col ;
   short_u origin_end_col ;
   short_u word_start_col ;
   short_u word_end_col ;
   FPOS prev ;
   short_u state ;
   short_u mode ;
   Atom xatom ;
   Atom xa_targets ;
   Atom xa_text ;
   Atom xa_compound_text ;
};
typedef struct VimClipboard VimClipboard;
typedef __off_t off_t;
typedef int __pid_t;
typedef __pid_t pid_t;
struct block0;
struct block0;
typedef struct block0 ZERO_BL;
struct pointer_block;
struct pointer_block;
typedef struct pointer_block PTR_BL;
struct data_block;
struct data_block;
typedef struct data_block DATA_BL;
struct pointer_entry;
struct pointer_entry;
typedef struct pointer_entry PTR_EN;
struct pointer_entry {
   blocknr_t pe_bnum ;
   linenr_t pe_line_count ;
   linenr_t pe_old_lnum ;
   int pe_page_count ;
};
struct pointer_block {
   short_u pb_id ;
   short_u pb_count ;
   short_u pb_count_max ;
   PTR_EN pb_pointer[1] ;
};
struct data_block {
   short_u db_id ;
   unsigned int db_free ;
   unsigned int db_txt_start ;
   unsigned int db_txt_end ;
   linenr_t db_line_count ;
   unsigned int db_index[1] ;
};
struct block0 {
   char_u b0_id[2] ;
   char_u b0_version[10] ;
   char_u b0_page_size[4] ;
   char_u b0_mtime[4] ;
   char_u b0_ino[4] ;
   char_u b0_pid[4] ;
   char_u b0_uname[40] ;
   char_u b0_hname[40] ;
   char_u b0_fname[900] ;
   long b0_magic_long ;
   int b0_magic_int ;
   short b0_magic_short ;
   char_u b0_magic_char ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct msg_hist {
   struct msg_hist *next ;
   char_u *msg ;
   int attr ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct modmasktable {
   int mod_mask ;
   char_u name ;
};
struct key_name_entry {
   int key ;
   char_u *name ;
};
struct mousetable {
   int pseudo_code ;
   int button ;
   int is_click ;
   int is_drag ;
};
typedef unsigned short ush;
typedef unsigned long ulg;
struct cmdarg {
   OPARG *oap ;
   int prechar ;
   int cmdchar ;
   int nchar ;
   int extra_char ;
   long count0 ;
   long count1 ;
};
typedef struct cmdarg CMDARG;
typedef unsigned int int_u;
struct yankreg {
   char_u **y_array ;
   linenr_t y_size ;
   char_u y_type ;
};
struct block_def {
   int startspaces ;
   int endspaces ;
   int textlen ;
   char_u *textstart ;
   colnr_t textcol ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
   int is_short ;
   int is_MAX ;
   int is_EOL ;
   int is_oneChar ;
   int pre_whitesp ;
   int pre_whitesp_c ;
   colnr_t end_char_vcols ;
   colnr_t start_char_vcols ;
};
struct vimoption {
   char *fullname ;
   char *shortname ;
   short_u flags ;
   char_u *var ;
   char_u *def_val[2] ;
};
struct lcstab {
   int *lcsp ;
   char *name ;
};
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_8 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_8 fd_set;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
struct __dirstream;
typedef struct __dirstream DIR;
typedef unsigned long XID;
typedef unsigned long VisualID;
typedef XID Window;
typedef XID Colormap;
typedef char *XPointer;
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
typedef struct _XExtData XExtData;
struct _XGC;
struct _XGC;
typedef struct _XGC *GC;
struct __anonstruct_Visual_60 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
typedef struct __anonstruct_Visual_60 Visual;
struct __anonstruct_Depth_61 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
typedef struct __anonstruct_Depth_61 Depth;
struct __anonstruct_Screen_62 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
typedef struct __anonstruct_Screen_62 Screen;
struct __anonstruct_ScreenFormat_63 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
typedef struct __anonstruct_ScreenFormat_63 ScreenFormat;
struct _XPrivate;
struct _XPrivate;
struct _XrmHashBucketRec;
struct _XrmHashBucketRec;
struct __anonstruct__XPrivDisplay_78 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
typedef struct __anonstruct__XPrivDisplay_78 *_XPrivDisplay;
struct __anonstruct_XErrorEvent_109 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
typedef struct __anonstruct_XErrorEvent_109 XErrorEvent;
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
struct __anonstruct_min_aspect_138 {
   int x ;
   int y ;
};
struct __anonstruct_XSizeHints_137 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_138 min_aspect ;
   struct __anonstruct_min_aspect_138 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
typedef struct __anonstruct_XSizeHints_137 XSizeHints;
struct __anonstruct_XTextProperty_140 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
typedef struct __anonstruct_XTextProperty_140 XTextProperty;
enum __anonenum_XrmOptionKind_148 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
typedef enum __anonenum_XrmOptionKind_148 XrmOptionKind;
struct __anonstruct_XrmOptionDescRec_149 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
typedef struct __anonstruct_XrmOptionDescRec_149 XrmOptionDescRec;
struct _WidgetRec;
struct _WidgetRec;
typedef struct _WidgetRec *Widget;
struct _WidgetClassRec;
struct _WidgetClassRec;
typedef struct _WidgetClassRec *WidgetClass;
typedef unsigned int Cardinal;
typedef unsigned long XtInputMask;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct signalinfo {
   int sig ;
   char *name ;
   char deadly ;
};
struct dir_stack_t {
   struct dir_stack_t *next ;
   char_u *dirname ;
};
struct qf_line {
   struct qf_line *qf_next ;
   struct qf_line *qf_prev ;
   linenr_t qf_lnum ;
   int qf_fnum ;
   int qf_col ;
   int qf_nr ;
   char_u *qf_text ;
   char_u qf_cleared ;
   char_u qf_type ;
   char_u qf_valid ;
};
struct qf_list {
   struct qf_line *qf_start ;
   struct qf_line *qf_ptr ;
   int qf_count ;
   int qf_index ;
   int qf_nonevalid ;
};
struct eformat {
   vim_regexp *prog ;
   struct eformat *next ;
   char_u addr[7] ;
   char_u prefix ;
   char_u flags ;
};
struct fmtpattern {
   char_u convchar ;
   char *pattern ;
};
struct __anonstruct_namedata_t_169 {
   size_t len ;
   int (*func)(int  ) ;
   char_u name[sizeof("backspace:]")] ;
};
typedef struct __anonstruct_namedata_t_169 namedata_t;
typedef void (*(*fptr)(char_u * , int  ))();
struct __anonstruct_term_167 {
   char_u *start ;
   char_u *stop ;
};
struct __anonstruct_cterm_168 {
   char_u fg_color ;
   char_u bg_color ;
};
union __anonunion_ae_u_166 {
   struct __anonstruct_term_167 term ;
   struct __anonstruct_cterm_168 cterm ;
};
struct attr_entry {
   short ae_attr ;
   union __anonunion_ae_u_166 ae_u ;
};
struct stl_hlrec {
   char_u *start ;
   int userhl ;
};
enum __anonenum_type_169___0 {
    Normal = 0,
    Empty = 1,
    Group = 2,
    Middle = 3,
    Highlight = 4,
    Trunc = 5
} ;
struct stl_item {
   char_u *start ;
   int minwid ;
   int maxwid ;
   enum __anonenum_type_169___0 type ;
};
struct soffset {
   int dir ;
   int line ;
   int end ;
   long off ;
};
struct spat {
   char_u *pat ;
   int magic ;
   int no_scs ;
   struct soffset off ;
};
struct SearchedFile {
   FILE *fp ;
   char_u *name ;
   linenr_t lnum ;
   int matched ;
};
typedef struct SearchedFile SearchedFile;
struct hl_group {
   char_u *sg_name ;
   char_u *sg_name_u ;
   int sg_term ;
   char_u *sg_start ;
   char_u *sg_stop ;
   int sg_term_attr ;
   int sg_cterm ;
   int sg_cterm_bold ;
   int sg_cterm_fg ;
   int sg_cterm_bg ;
   int sg_cterm_attr ;
   int sg_link ;
   int sg_set ;
};
struct syn_pattern {
   char sp_type ;
   char sp_syncing ;
   short sp_flags ;
   int sp_syn_inc_tag ;
   short sp_syn_id ;
   short sp_syn_match_id ;
   char_u *sp_pattern ;
   vim_regexp *sp_prog ;
   int sp_ic ;
   short sp_off_flags ;
   int sp_offsets[7] ;
   short *sp_cont_list ;
   short *sp_next_list ;
   int sp_sync_idx ;
   int sp_line_id ;
   int sp_startcol ;
};
struct buf_state {
   int bs_idx ;
   int bs_flags ;
};
struct syn_cluster {
   char_u *scl_name ;
   char_u *scl_name_u ;
   short *scl_list ;
};
struct state_item {
   int si_idx ;
   int si_id ;
   int si_trans_id ;
   int si_m_lnum ;
   int si_m_startcol ;
   int si_m_endcol ;
   int si_h_startcol ;
   int si_h_endcol ;
   int si_eoe_col ;
   int si_end_idx ;
   int si_ends ;
   int si_attr ;
   int si_flags ;
   short *si_cont_list ;
   short *si_next_list ;
};
struct flag {
   char *name ;
   int len ;
   int val ;
};
struct pat_ptr {
   struct syn_pattern *pp_synp ;
   int pp_matchgroup_id ;
   struct pat_ptr *pp_next ;
};
struct subcommand {
   char *name ;
   void (*func)(EXARG * , int  ) ;
};
enum __anonenum_expand_what_169 {
    EXP_SUBCMD = 0,
    EXP_CASE = 1
} ;
struct tag_pointers {
   char_u *tagname ;
   char_u *tagname_end ;
   char_u *fname ;
   char_u *fname_end ;
   char_u *command ;
   char_u *command_end ;
   char_u *tag_fname ;
   char_u *tagkind ;
   char_u *tagkind_end ;
};
struct tag_search_info {
   off_t low_offset ;
   off_t high_offset ;
   off_t curr_offset ;
   off_t match_offset ;
   int low_char ;
   int high_char ;
};
enum __anonenum_state_169 {
    TS_START = 0,
    TS_LINEAR = 1,
    TS_BINARY = 2,
    TS_SKIP_BACK = 3,
    TS_STEP_FORWARD = 4
} ;
struct visited {
   struct visited *v_next ;
   struct stat v_st ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
enum SpecialKey {
    KS_NAME = 0,
    KS_CE = 1,
    KS_AL = 2,
    KS_CAL = 3,
    KS_DL = 4,
    KS_CDL = 5,
    KS_CS = 6,
    KS_CL = 7,
    KS_CD = 8,
    KS_DA = 9,
    KS_DB = 10,
    KS_VI = 11,
    KS_VE = 12,
    KS_VS = 13,
    KS_ME = 14,
    KS_MR = 15,
    KS_MD = 16,
    KS_SE = 17,
    KS_SO = 18,
    KS_CZH = 19,
    KS_CZR = 20,
    KS_UE = 21,
    KS_US = 22,
    KS_MS = 23,
    KS_CM = 24,
    KS_SR = 25,
    KS_CRI = 26,
    KS_VB = 27,
    KS_KS = 28,
    KS_KE = 29,
    KS_TI = 30,
    KS_TE = 31,
    KS_BC = 32,
    KS_CCS = 33,
    KS_CCO = 34,
    KS_CSF = 35,
    KS_CSB = 36,
    KS_XS = 37,
    KS_MB = 38,
    KS_CAF = 39,
    KS_CAB = 40,
    KS_LE = 41,
    KS_ND = 42,
    KS_CIS = 43,
    KS_CIE = 44,
    KS_TS = 45,
    KS_FS = 46,
    KS_CWP = 47,
    KS_CWS = 48,
    KS_CRV = 49,
    KS_OP = 50
} ;
struct builtin_term {
   int bt_entry ;
   char *bt_string ;
};
struct __anonstruct_string_names_169 {
   enum SpecialKey dest ;
   char *name ;
};
struct termcode {
   char_u name[2] ;
   char_u *code ;
   int len ;
};
typedef unsigned long Time;
typedef XID Drawable;
struct __anonstruct_XKeyEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
typedef struct __anonstruct_XKeyEvent_79 XKeyEvent;
struct __anonstruct_XButtonEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
typedef struct __anonstruct_XButtonEvent_80 XButtonEvent;
struct __anonstruct_XMotionEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
typedef struct __anonstruct_XMotionEvent_81 XMotionEvent;
struct __anonstruct_XCrossingEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
typedef struct __anonstruct_XCrossingEvent_82 XCrossingEvent;
struct __anonstruct_XFocusChangeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
typedef struct __anonstruct_XFocusChangeEvent_83 XFocusChangeEvent;
struct __anonstruct_XKeymapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
typedef struct __anonstruct_XKeymapEvent_84 XKeymapEvent;
struct __anonstruct_XExposeEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
typedef struct __anonstruct_XExposeEvent_85 XExposeEvent;
struct __anonstruct_XGraphicsExposeEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XGraphicsExposeEvent_86 XGraphicsExposeEvent;
struct __anonstruct_XNoExposeEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XNoExposeEvent_87 XNoExposeEvent;
struct __anonstruct_XVisibilityEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
typedef struct __anonstruct_XVisibilityEvent_88 XVisibilityEvent;
struct __anonstruct_XCreateWindowEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
typedef struct __anonstruct_XCreateWindowEvent_89 XCreateWindowEvent;
struct __anonstruct_XDestroyWindowEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
typedef struct __anonstruct_XDestroyWindowEvent_90 XDestroyWindowEvent;
struct __anonstruct_XUnmapEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
typedef struct __anonstruct_XUnmapEvent_91 XUnmapEvent;
struct __anonstruct_XMapEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
typedef struct __anonstruct_XMapEvent_92 XMapEvent;
struct __anonstruct_XMapRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
typedef struct __anonstruct_XMapRequestEvent_93 XMapRequestEvent;
struct __anonstruct_XReparentEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
typedef struct __anonstruct_XReparentEvent_94 XReparentEvent;
struct __anonstruct_XConfigureEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
typedef struct __anonstruct_XConfigureEvent_95 XConfigureEvent;
struct __anonstruct_XGravityEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
typedef struct __anonstruct_XGravityEvent_96 XGravityEvent;
struct __anonstruct_XResizeRequestEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
typedef struct __anonstruct_XResizeRequestEvent_97 XResizeRequestEvent;
struct __anonstruct_XConfigureRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
typedef struct __anonstruct_XConfigureRequestEvent_98 XConfigureRequestEvent;
struct __anonstruct_XCirculateEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateEvent_99 XCirculateEvent;
struct __anonstruct_XCirculateRequestEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateRequestEvent_100 XCirculateRequestEvent;
struct __anonstruct_XPropertyEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
typedef struct __anonstruct_XPropertyEvent_101 XPropertyEvent;
struct __anonstruct_XSelectionClearEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
typedef struct __anonstruct_XSelectionClearEvent_102 XSelectionClearEvent;
struct __anonstruct_XSelectionRequestEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionRequestEvent_103 XSelectionRequestEvent;
struct __anonstruct_XSelectionEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionEvent_104 XSelectionEvent;
struct __anonstruct_XColormapEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
typedef struct __anonstruct_XColormapEvent_105 XColormapEvent;
union __anonunion_data_107 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
struct __anonstruct_XClientMessageEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_107 data ;
};
typedef struct __anonstruct_XClientMessageEvent_106 XClientMessageEvent;
struct __anonstruct_XMappingEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
typedef struct __anonstruct_XMappingEvent_108 XMappingEvent;
struct __anonstruct_XAnyEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
typedef struct __anonstruct_XAnyEvent_110 XAnyEvent;
struct __anonstruct_XGenericEvent_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
typedef struct __anonstruct_XGenericEvent_111 XGenericEvent;
struct __anonstruct_XGenericEventCookie_112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
typedef struct __anonstruct_XGenericEventCookie_112 XGenericEventCookie;
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
typedef union _XEvent XEvent;
enum __anonenum_XICCEncodingStyle_141 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
typedef enum __anonenum_XICCEncodingStyle_141 XICCEncodingStyle;
typedef char Boolean;
typedef void *XtPointer;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-iFTblII1.i","-O0")
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
long Columns ;
int cmdline_row  ;
int msg_row  ;
int need_fileinfo ;
int msg_scroll ;
char_u *sourcing_name ;
linenr_t sourcing_lnum ;
int autocmd_no_enter ;
int autocmd_no_leave ;
int modified_was_set  ;
BUF *au_new_curbuf ;
WIN *firstwin  ;
WIN *lastwin  ;
WIN *curwin  ;
BUF *firstbuf ;
BUF *lastbuf ;
BUF *curbuf ;
char_u **arg_files  ;
int arg_file_count  ;
int arg_had_last ;
int swap_exists_action ;
char_u *IObuff  ;
char_u *NameBuff  ;
int RedrawingDisabled ;
int readonlymode ;
int got_int ;
int reg_ic ;
char_u no_lines_msg[23] ;
int stl_syntax ;
char_u e_noalt[18] ;
char_u e_nowrtmsg[47] ;
char_u e_trailing[20] ;
int p_ea  ;
int p_hid  ;
int p_icon  ;
char_u *p_iconstring  ;
int p_magic  ;
long p_mls  ;
int p_ru  ;
int p_sb  ;
int p_sol  ;
char_u *p_swb  ;
int p_title  ;
long p_titlelen  ;
char_u *p_titlestring  ;
void mch_settitle(char_u *title , char_u *icon ) ;
int mch_dirname(char_u *buf___3 , int len___0 ) ;
int open_buffer(int read_stdin ) ;
int buf_valid(BUF *buf___3 ) ;
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) ;
void buf_clear(BUF *buf___3 ) ;
void buf_freeall(BUF *buf___3 , int del_buf ) ;
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) ;
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) ;
void enter_buffer(BUF *buf___3 ) ;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) ;
void free_buf_options(BUF *buf___3 , int free_p_ff ) ;
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) ;
void buflist_getfpos(void) ;
BUF *buflist_findname(char_u *ffname ) ;
int buflist_findpat(char_u *pattern , char_u *pattern_end ) ;
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) ;
BUF *buflist_findnr(int nr ) ;
char_u *buflist_nr2name(int n , int fullname , int helptail ) ;
FPOS *buflist_findfpos(BUF *buf___3 ) ;
linenr_t buflist_findlnum(BUF *buf___3 ) ;
void buflist_list(void) ;
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) ;
int setfname(char_u *ffname , char_u *sfname , int message ) ;
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) ;
char_u *getaltfname(int errmsg ) ;
int buflist_add(char_u *fname ) ;
void buflist_altfpos(void) ;
int otherfile(char_u *ffname ) ;
void fileinfo(int fullname , int shorthelp , int dont_truncate ) ;
void cursor_pos_info(void) ;
void col_print(char_u *buf___3 , int col , int vcol ) ;
void maketitle(void) ;
void resettitle(void) ;
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) ;
char_u *fix_fname(char_u *fname ) ;
void fname_expand(char_u **ffname , char_u **sfname ) ;
void do_arg_all(int count___2 , int forceit ) ;
void do_buffer_all(int count___2 , int all ) ;
void do_modelines(void) ;
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_bufferlist(FILE *fp___0 ) ;
int init_chartab(void) ;
char_u *transchar(int c ) ;
int vim_strsize(char_u *s ) ;
int linetabsize(char_u *s ) ;
char_u *skipwhite(char_u *p___0 ) ;
char_u *skiptowhite_esc(char_u *p___0 ) ;
long getdigits(char_u **pp ) ;
void var_init(struct growarray *gap ) ;
void var_clear(struct growarray *gap ) ;
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) ;
void viminfo_writestring(FILE *fd , char_u *p___0 ) ;
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) ;
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) ;
int autowrite(BUF *buf___3 , int forceit ) ;
int can_abandon(BUF *buf___3 , int forceit ) ;
void check_arg_idx(WIN *win ) ;
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) ;
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) ;
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) ;
int buf_check_timestamp(BUF *buf___3 , int focus ) ;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) ;
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) ;
int vgetc(void) ;
void getout(int r ) ;
void setpcmark(void) ;
void fmarks_check_names(BUF *buf___3 ) ;
void clrallmarks(BUF *buf___3 ) ;
void set_last_cursor(WIN *win ) ;
int removable(char_u *name___1 ) ;
int smsg(char_u *s  , ...) ;
int ml_open(void) ;
void ml_setname(void) ;
void ml_close(BUF *buf___3 , int del_file ) ;
void ml_timestamp(BUF *buf___3 ) ;
void ml_recover(void) ;
char_u *ml_get(linenr_t lnum ) ;
char_u *ml_get_curline(void) ;
int msg(char_u *s ) ;
int emsg(char_u *s ) ;
int emsg2(char_u *s , char_u *a1 ) ;
int emsgn(char_u *s , long n ) ;
char_u *msg_trunc_attr(char_u *s , int force , int attr ) ;
void msg_putchar(int c ) ;
int msg_outtrans(char_u *str___1 ) ;
void msg_puts(char_u *s ) ;
char *plural(long n ) ;
void changed(void) ;
void unchanged(BUF *buf___3 , int ff ) ;
void expand_env(char_u *src , char_u *dst , int dstlen ) ;
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) ;
char_u *home_replace_save(BUF *buf___3 , char_u *src ) ;
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) ;
char_u *gettail(char_u *fname ) ;
char_u *FullName_save(char_u *fname , int force ) ;
void check_cursor_lnum(void) ;
void check_cursor_col(void) ;
char_u *alloc(unsigned int size ) ;
char_u *alloc_clear(unsigned int size ) ;
char_u *vim_strsave(char_u *string___0 ) ;
void vim_free(void *x___0 ) ;
char_u *vim_strchr(char_u *string___0 , int n ) ;
char_u *vim_strrchr(char_u *string___0 , int n ) ;
int vim_isspace(int x___0 ) ;
int get_fileformat(BUF *buf___3 ) ;
int do_set(char_u *arg , int modeline ) ;
char_u *find_viminfo_parameter(int type ) ;
void free_string_option(char_u *p___0 ) ;
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) ;
int shortmess(int x___0 ) ;
vim_regexp *vim_regcomp(char_u *expr , int magic ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
void update_screen(int type ) ;
void status_redraw_all(void) ;
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) ;
void scroll_cursor_halfway(int atend ) ;
void validate_virtcol(void) ;
void syntax_clear(BUF *buf___3 ) ;
void out_flush(void) ;
void ui_delay(long msec , int ignoreinput ) ;
void ui_breakcheck(void) ;
void u_sync(void) ;
void u_clearall(BUF *buf___3 ) ;
void u_blockfree(BUF *buf___3 ) ;
int buf_changed(BUF *buf___3 ) ;
int curbuf_changed(void) ;
int win_split(int new_height , int redraw , int req_room ) ;
int win_valid(WIN *win ) ;
void win_move_after(WIN *win1 , WIN *win2 ) ;
void close_windows(BUF *buf___3 ) ;
void close_window(WIN *win , int free_buf ) ;
void close_others(int message , int forceit ) ;
void win_enter(WIN *wp , int undo_sync ) ;
WIN *buf_jump_open_win(BUF *buf___3 ) ;
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) ;
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) ;
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) ;
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) ;
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) ;
static void buf_setino(BUF *buf___3 ) ;
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) ;
static int ti_change(char_u *str___1 , char_u **last ) ;
static void free_buffer(BUF *buf___3 ) ;
int open_buffer(int read_stdin ) 
{ 
  int retval ;
  BUF *old_curbuf ;
  BUF *new_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  retval = 1;
  if (readonlymode) {





  }
  {
  tmp = ml_open();
  }
  if (tmp == 0) {
    {


    }
    {










    while_break: ;/* CIL Label */ ;
    }






    {


    }

  }
  old_curbuf = curbuf;
  modified_was_set = 0;
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    retval = readfile(curbuf->b_ffname, curbuf->b_fname, (linenr_t )0, (linenr_t )0,
                      (linenr_t )2147483647, 1);
    }
  } else { //Added block






  }
  if (curbuf->b_flags & 4) {
    {
    init_chartab();
    }
  }
  if (read_stdin) {







  } else { //Added block
  _L: ;
  if (modified_was_set) {
    {

    }
  } else { //Added block
  if (retval != 0) {
    {
    unchanged(curbuf, 0);
    }
  }
  }
  }
  curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  if (got_int) {

  }
  {
  curwin->w_topline = (linenr_t )1;
  apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (retval != 0) {
    {
    tmp___0 = buf_valid(old_curbuf);
    }
    if (tmp___0) {
      {
      new_curbuf = curbuf;
      curbuf = old_curbuf;
      curwin->w_buffer = old_curbuf;
      do_modelines();
      curbuf->b_flags &= -7;
      curbuf = new_curbuf;
      curwin->w_buffer = new_curbuf;
      }
    }
  }
  return (retval);
}
}
int buf_valid(BUF *buf___3 ) 
{ 
  BUF *bp___0 ;

  {
  bp___0 = firstbuf;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {

    }
    if ((unsigned long )bp___0 == (unsigned long )buf___3) {
      return (1);
    }
    bp___0 = bp___0->b_next;
  }
  while_break: ;/* CIL Label */ ;
  }

}
}
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) 
{ 
  int is_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  if (buf___3->b_nwindows > 0) {
    (buf___3->b_nwindows) --;
  }
  if (buf___3->b_nwindows == 0) {
    if ((unsigned long )win != (unsigned long )((void *)0)) {
      {
      set_last_cursor(win);
      }
      if ((unsigned long )win == (unsigned long )curwin) {
        if (curwin->w_cursor.lnum != 1L) {
          {

          }
        }
      }
    }
  }
  if (buf___3->b_nwindows == 0) {
    if (! free_buf) {
      {


      }



    }
  }
  if (buf___3->b_nwindows > 0) {
    goto _L;
  } else { //Added block
  if (! free_buf) {
    _L: ;
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      {
      u_sync();
      }
    }
    return;
  }
  }
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {

  }
  {
  is_curbuf = (unsigned long )buf___3 == (unsigned long )curbuf;
  buf_freeall(buf___3, del_buf);
  tmp___0 = buf_valid(buf___3);
  }
  if (tmp___0) {
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      if (! is_curbuf) {

      }
    }
  } else {

  }
  if (del_buf) {
    {


    }










    {

    }
  } else {
    {
    buf_clear(buf___3);
    }
  }
  return;
}
}
void buf_clear(BUF *buf___3 ) 
{ 


  {
  {
  buf___3->b_ml.ml_line_count = (linenr_t )1;
  unchanged(buf___3, 1);
  buf___3->b_shortname = 0;
  buf___3->b_p_eol = 1;
  buf___3->b_ml.ml_mfp = (MEMFILE *)((void *)0);
  buf___3->b_ml.ml_flags = 1;
  }
  return;
}
}
void buf_freeall(BUF *buf___3 , int del_buf ) 
{ 
  int is_curbuf ;
  int tmp ;
  int tmp___0 ;

  {
  {
  is_curbuf = (unsigned long )buf___3 == (unsigned long )curbuf;
  apply_autocmds((EVENT_T )9, buf___3->b_fname, buf___3->b_fname, 0, buf___3);
  tmp = buf_valid(buf___3);
  }
  if (! tmp) {

  }
  if (del_buf) {
    {


    }



  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    if (! is_curbuf) {

    }
  }
  {
  u_blockfree(buf___3);
  ml_close(buf___3, 1);
  buf___3->b_ml.ml_line_count = (linenr_t )0;
  u_clearall(buf___3);
  syntax_clear(buf___3);
  }
  return;
}
}
static void free_buffer(BUF *buf___3 ) 
{
























}
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) 
{






















































































































}
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) 
{ 
  BUF *buf___3 ;
  BUF *delbuf ;
  int retval ;
  int forward ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  BUF *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int jumpidx ;
  int tmp___8 ;
  char_u *tmp___9 ;
  WIN *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  WIN *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
  if (start___0 == 1) {
    goto case_1;
  }




  case_1: ;/* CIL Label */ 
  buf___3 = firstbuf;
  goto switch_break;
  case_2: ;/* CIL Label */ 


  switch_default: ;/* CIL Label */ 


  switch_break: ;/* CIL Label */ ;
  }
  if (start___0 == 3) {
    {




























    while_break: ;/* CIL Label */ ;
    }
    {

    }






  } else { //Added block
  if (start___0 == 1) {
    if (count___2) {
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
          if (! (buf___3->b_fnum != count___2)) {
            goto while_break___1;
          }
        } else {

        }

      }
      while_break___1: ;/* CIL Label */ ;
      }
    } else {

    }
  } else {
    _L: ;
    {



























    while_break___2: ;/* CIL Label */ ;
    }
  }
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {




















  }
  if (action == 2) {

  } else { //Added block
  if (action == 3) {
    _L___1: ;













































    {













    while_break___3: ;/* CIL Label */ ;
    }








































































































  }
  }
  if (action == 1) {
    {

    }








    {

    }



  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    return (1);
  }











  {






  }



















































  {

  }






}
}
void enter_buffer(BUF *buf___3 ) 
{




































}
static int top_file_num  =    1;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) 
{ 
  BUF *buf___3 ;
  struct stat st ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  fname_expand(& ffname, & sfname);
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {
    st.st_dev = (__dev_t )4294967295U;
  } else {
    {
    tmp = stat((char const   * __restrict  )((char *)sfname), (struct stat * __restrict  )(& st));
    }
    if (tmp < 0) {
      st.st_dev = (__dev_t )4294967295U;
    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    {
    buf___3 = buflist_findname_stat(ffname, & st);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      {
      vim_free((void *)ffname);
      }
      if (lnum != 0L) {
        {
        buflist_setfpos(buf___3, lnum, (colnr_t )0);
        }
      }
      {
      buf_copy_options(curbuf, buf___3, 0);
      }
      return (buf___3);
    }
  }
  if (use_curbuf) {




































  } else {
    _L___2: ;
    {
    tmp___0 = alloc_clear((unsigned int )sizeof(BUF ));
    buf___3 = (BUF *)tmp___0;
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      {

      }

    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    {
    buf___3->b_ffname = ffname;
    buf___3->b_sfname = vim_strsave(sfname);
    }
  }
  if ((unsigned long )buf___3->b_winfpos == (unsigned long )((void *)0)) {
    {
    tmp___2 = alloc((unsigned int )sizeof(WINFPOS ));
    buf___3->b_winfpos = (WINFPOS *)tmp___2;
    }
  }
  if ((unsigned long )ffname != (unsigned long )((void *)0)) {
    if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {

    } else { //Added block
    if ((unsigned long )buf___3->b_sfname == (unsigned long )((void *)0)) {

    } else {
      goto _L___4;
    }
    }
  } else { //Added block
  _L___4: ;
  if ((unsigned long )buf___3->b_winfpos == (unsigned long )((void *)0)) {
    _L___3: ;
    {




    }






  }
  }
  if ((unsigned long )buf___3 == (unsigned long )curbuf) {
    {

    }




  } else {
    buf___3->b_next = (BUF *)((void *)0);
    if ((unsigned long )firstbuf == (unsigned long )((void *)0)) {
      buf___3->b_prev = (BUF *)((void *)0);
      firstbuf = buf___3;
    } else {
      lastbuf->b_next = buf___3;
      buf___3->b_prev = lastbuf;
    }
    lastbuf = buf___3;
    tmp___3 = top_file_num;
    top_file_num ++;
    buf___3->b_fnum = tmp___3;
    if (top_file_num < 0) {
      {




      }
    }
    {
    (buf___3->b_winfpos)->wl_fpos.lnum = lnum;
    (buf___3->b_winfpos)->wl_fpos.col = (colnr_t )0;
    (buf___3->b_winfpos)->wl_next = (WINFPOS *)((void *)0);
    (buf___3->b_winfpos)->wl_prev = (WINFPOS *)((void *)0);
    (buf___3->b_winfpos)->wl_win = curwin;
    var_init(& buf___3->b_vars);
    buf_copy_options(curbuf, buf___3, 2);
    }
  }
  buf___3->b_fname = buf___3->b_sfname;
  if (st.st_dev == 4294967295UL) {
    buf___3->b_dev = -1;
  } else {
    buf___3->b_dev = (int )st.st_dev;
    buf___3->b_ino = st.st_ino;
  }
  {
  buf___3->b_u_synced = 1;
  buf___3->b_flags = 6;
  buf_clear(buf___3);
  clrallmarks(buf___3);
  fmarks_check_names(buf___3);
  apply_autocmds((EVENT_T )0, (char_u *)((void *)0), (char_u *)((void *)0), 0, buf___3);
  }
  return (buf___3);
}
}
void free_buf_options(BUF *buf___3 , int free_p_ff ) 
{ 


  {
  if (free_p_ff) {
    {
    free_string_option(buf___3->b_p_ff);
    }
  }
  {
  free_string_option(buf___3->b_p_key);
  free_string_option(buf___3->b_p_mps);
  free_string_option(buf___3->b_p_fo);
  free_string_option(buf___3->b_p_isk);
  free_string_option(buf___3->b_p_com);
  free_string_option(buf___3->b_p_nf);
  free_string_option(buf___3->b_p_syn);
  free_string_option(buf___3->b_p_ft);
  free_string_option(buf___3->b_p_cink);
  free_string_option(buf___3->b_p_cino);
  free_string_option(buf___3->b_p_cinw);
  free_string_option(buf___3->b_p_cpt);
  }
  return;
}
}
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) 
{























































































}
void buflist_getfpos(void) 
{


















}
BUF *buflist_findname(char_u *ffname ) 
{
















}
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) 
{ 
  BUF *buf___3 ;
  int tmp ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = otherfile_buf(buf___3, ffname, stp);
    }
    if (! tmp) {
      return (buf___3);
    }
    buf___3 = buf___3->b_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return ((BUF *)((void *)0));
}
}
int buflist_findpat(char_u *pattern , char_u *pattern_end ) 
{
































































































































}
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) 
{














































































































}
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) 
{

















}
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) 
{
































}
BUF *buflist_findnr(int nr ) 
{ 
  BUF *buf___3 ;
  WIN *wp ;
  char_u *tmp ;

  {
  if (nr == 0) {

  }
  {
  tmp = vim_strchr(p_swb, 'u');
  }
  if (tmp) {

    {










    while_break: ;/* CIL Label */ ;
    }
  }
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {

    }
    if (buf___3->b_fnum == nr) {
      return (buf___3);
    }

  }
  while_break___0: ;/* CIL Label */ ;
  }

}
}
char_u *buflist_nr2name(int n , int fullname , int helptail ) 
{ 
  BUF *buf___3 ;
  char_u *tmp ;
  BUF *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  buf___3 = buflist_findnr(n);
  }
  if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {

  }
  if (fullname) {
    tmp = buf___3->b_ffname;
  } else {

  }
  if (helptail) {

  } else {
    tmp___0 = (BUF *)((void *)0);
  }
  {
  tmp___1 = home_replace_save(tmp___0, tmp);
  }
  return (tmp___1);
}
}
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) 
{ 
  WINFPOS *wlp ;
  char_u *tmp ;

  {
  wlp = buf___3->b_winfpos;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wlp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wlp->wl_win == (unsigned long )curwin) {
      goto while_break;
    }
    wlp = wlp->wl_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )wlp == (unsigned long )((void *)0)) {
    {
    tmp = alloc((unsigned int )sizeof(WINFPOS ));
    wlp = (WINFPOS *)tmp;
    }
    if ((unsigned long )wlp == (unsigned long )((void *)0)) {

    }
    wlp->wl_win = curwin;
  } else {
    if (wlp->wl_prev) {

    } else {
      buf___3->b_winfpos = wlp->wl_next;
    }
    if (wlp->wl_next) {

    }
  }
  wlp->wl_fpos.lnum = lnum;
  wlp->wl_fpos.col = col;
  wlp->wl_next = buf___3->b_winfpos;
  buf___3->b_winfpos = wlp;
  wlp->wl_prev = (WINFPOS *)((void *)0);
  if (wlp->wl_next) {
    (wlp->wl_next)->wl_prev = wlp;
  }
  return;
}
}
static FPOS no_position  =    {(linenr_t )1, (colnr_t )0};
FPOS *buflist_findfpos(BUF *buf___3 ) 
{ 
  WINFPOS *wlp ;

  {
  wlp = buf___3->b_winfpos;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wlp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wlp->wl_win == (unsigned long )curwin) {
      goto while_break;
    }
    wlp = wlp->wl_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )wlp == (unsigned long )((void *)0)) {
    wlp = buf___3->b_winfpos;
  }
  if ((unsigned long )wlp != (unsigned long )((void *)0)) {
    return (& wlp->wl_fpos);
  } else {

  }
}
}
linenr_t buflist_findlnum(BUF *buf___3 ) 
{ 
  FPOS *tmp ;

  {
  {
  tmp = buflist_findfpos(buf___3);
  }
  return (tmp->lnum);
}
}
void buflist_list(void) 
{ 
  BUF *buf___3 ;
  int len___0 ;
  int i___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  linenr_t tmp___11 ;
  linenr_t tmp___12 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      if (! (! got_int)) {

      }
    } else {
      goto while_break;
    }
    {
    msg_putchar('\n');
    }
    if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {
      {

      }
    } else {
      {
      home_replace(buf___3, buf___3->b_fname, NameBuff, 1024, 1);
      }
    }
    {
    tmp___1 = buf_changed(buf___3);
    }
    if (tmp___1) {

    } else {
      tmp___0 = ' ';
    }
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      tmp___3 = '-';
    } else {
      if (buf___3->b_nwindows == 0) {

      } else {
        tmp___2 = ' ';
      }
      tmp___3 = tmp___2;
    }
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      tmp___5 = '%';
    } else {
      if (curwin->w_alt_fnum == buf___3->b_fnum) {

      } else {
        tmp___4 = ' ';
      }
      tmp___5 = tmp___4;
    }
    {
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%3d %c%c%c \"",
            buf___3->b_fnum, tmp___5, tmp___3, tmp___0);
    tmp___6 = strlen((char const   *)((char *)IObuff));
    len___0 = (int )tmp___6;
    strncpy((char * __restrict  )((char *)(IObuff + len___0)), (char const   * __restrict  )((char *)NameBuff),
            (size_t )(1005 - len___0));
    tmp___7 = strlen((char const   *)((char *)IObuff));
    len___0 = (int )tmp___7;
    tmp___8 = len___0;
    len___0 ++;
    *(IObuff + tmp___8) = (char_u )'\"';
    *(IObuff + len___0) = (char_u )'\000';
    tmp___9 = vim_strsize(IObuff);
    i___0 = 40 - tmp___9;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      tmp___10 = len___0;
      len___0 ++;
      *(IObuff + tmp___10) = (char_u )' ';
      i___0 --;
      if (i___0 > 0) {
        if (! (len___0 < 1007)) {

        }
      } else {
        goto while_break___0;
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((unsigned long )buf___3 == (unsigned long )curbuf) {
      tmp___12 = curwin->w_cursor.lnum;
    } else {
      {
      tmp___11 = buflist_findlnum(buf___3);
      tmp___12 = tmp___11;
      }
    }
    {
    sprintf((char * __restrict  )((char *)IObuff + len___0), (char const   * __restrict  )"line %ld",
            tmp___12);
    msg_outtrans(IObuff);
    out_flush();
    ui_breakcheck();
    buf___3 = buf___3->b_next;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) 
{



















}
int setfname(char_u *ffname , char_u *sfname , int message ) 
{ 
  BUF *buf___3 ;
  struct stat st ;
  int tmp ;

  {
  if ((unsigned long )ffname == (unsigned long )((void *)0)) {
    {





    }
  } else { //Added block
  if ((int )*ffname == 0) {
    {





    }
  } else {
    {
    fname_expand(& ffname, & sfname);
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {

    }
    {
    tmp = stat((char const   * __restrict  )((char *)ffname), (struct stat * __restrict  )(& st));
    }
    if (tmp < 0) {
      st.st_dev = (__dev_t )4294967295U;
    }
    {
    buf___3 = buflist_findname_stat(ffname, & st);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
















    }
    {
    sfname = vim_strsave(sfname);
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {
      {


      }

    } else { //Added block
    if ((unsigned long )sfname == (unsigned long )((void *)0)) {
      {


      }

    }
    }
    {
    vim_free((void *)curbuf->b_ffname);
    vim_free((void *)curbuf->b_sfname);
    curbuf->b_ffname = ffname;
    curbuf->b_sfname = sfname;
    }
  }
  }
  curbuf->b_fname = curbuf->b_sfname;
  if (st.st_dev == 4294967295UL) {
    curbuf->b_dev = -1;
  } else {
    curbuf->b_dev = (int )st.st_dev;
    curbuf->b_ino = st.st_ino;
  }
  curbuf->b_shortname = 0;
  if ((unsigned long )curbuf->b_ml.ml_mfp != (unsigned long )((void *)0)) {
    {
    ml_setname();
    }
  }
  {
  check_arg_idx(curwin);
  maketitle();
  status_redraw_all();
  fmarks_check_names(curbuf);
  ml_timestamp(curbuf);
  }
  return (1);
}
}
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) 
{ 
  BUF *buf___3 ;

  {
  {
  buf___3 = buflist_new(ffname, sfname, lnum, 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    curwin->w_alt_fnum = buf___3->b_fnum;
  }
  return;
}
}
char_u *getaltfname(int errmsg ) 
{


















}
int buflist_add(char_u *fname ) 
{ 
  BUF *buf___3 ;

  {
  {
  buf___3 = buflist_new(fname, (char_u *)((void *)0), (linenr_t )0, 0);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    return (buf___3->b_fnum);
  }

}
}
void buflist_altfpos(void) 
{ 


  {
  {
  buflist_setfpos(curbuf, curwin->w_cursor.lnum, curwin->w_cursor.col);
  }
  return;
}
}
int otherfile(char_u *ffname ) 
{ 
  int tmp ;

  {
  {
  tmp = otherfile_buf(curbuf, ffname, (struct stat *)((void *)0));
  }
  return (tmp);
}
}
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) 
{ 
  int tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )ffname == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*ffname == 0) {

  } else { //Added block
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return (1);
  }
  }
  }
  {
  tmp = strcmp((char const   *)((char *)ffname), (char const   *)((char *)buf___3->b_ffname));
  }
  if (tmp == 0) {
    return (0);
  }
  if ((unsigned long )stp == (unsigned long )((void *)0)) {
    if (buf___3->b_dev < 0) {

    } else {
      {
      tmp___0 = stat((char const   * __restrict  )((char *)ffname), (struct stat * __restrict  )(& st));
      }
      if (tmp___0 < 0) {
        st.st_dev = (__dev_t )4294967295U;
      }
    }
    stp = & st;
  }
  {
  tmp___2 = buf_same_ino(buf___3, stp);
  }
  if (tmp___2) {
    {


    }



  }
  return (1);
}
}
static void buf_setino(BUF *buf___3 ) 
{



















}
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) 
{ 
  int tmp ;

  {
  if (buf___3->b_dev >= 0) {
    if (stp->st_dev == (__dev_t )buf___3->b_dev) {
      if (stp->st_ino == buf___3->b_ino) {

      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void fileinfo(int fullname , int shorthelp , int dont_truncate ) 
{ 
  char_u *name___1 ;
  int n ;
  char_u *p___0 ;
  char_u *buffer ;
  size_t tmp ;
  char_u *tmp___0 ;
  BUF *tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
  buffer = alloc(1025U);
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {

  }
  if (fullname > 1) {
    {
    sprintf((char * __restrict  )((char *)buffer), (char const   * __restrict  )"buf %d: ",
            curbuf->b_fnum);
    tmp = strlen((char const   *)((char *)buffer));
    p___0 = buffer + tmp;
    }
  } else {
    p___0 = buffer;
  }
  tmp___0 = p___0;
  p___0 ++;
  *tmp___0 = (char_u )'\"';
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {

    }
  } else {
    if (! fullname) {
      if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
        name___1 = curbuf->b_fname;
      } else {

      }
    } else {
      name___1 = curbuf->b_ffname;
    }
    if (shorthelp) {

    } else {
      tmp___1 = (BUF *)((void *)0);
    }
    {
    home_replace(tmp___1, name___1, p___0, (int )(1025L - (p___0 - buffer)), 1);
    }
  }
  {
  tmp___4 = curbuf_changed();
  }
  if (tmp___4) {
    tmp___3 = " ";
  } else { //Added block
  if (curbuf->b_flags & 88) {
    tmp___3 = " ";
  } else { //Added block
  if (curbuf->b_p_ro) {

  } else {
    tmp___3 = "";
  }
  }
  }
  if (curbuf->b_p_ro) {
    {

    }






  } else {
    tmp___8 = "";
  }
  if (curbuf->b_flags & 64) {

  } else {
    tmp___9 = "";
  }
  if (curbuf->b_flags & 16) {
    tmp___10 = "[New file]";
  } else {
    tmp___10 = "";
  }
  if (curbuf->b_flags & 8) {
    tmp___11 = "[Not edited]";
  } else {
    tmp___11 = "";
  }
  {
  tmp___17 = curbuf_changed();
  }
  if (tmp___17) {
    {
    tmp___15 = shortmess('m');
    }
    if (tmp___15) {

    } else {
      tmp___14 = " [Modified]";
    }
    tmp___16 = tmp___14;
  } else {
    tmp___16 = " ";
  }
  {
  tmp___18 = strlen((char const   *)((char *)buffer));
  sprintf((char * __restrict  )((char *)buffer + tmp___18), (char const   * __restrict  )"\"%s%s%s%s%s%s",
          tmp___16, tmp___11, tmp___10, tmp___9, tmp___8, tmp___3);
  n = (int )((curwin->w_cursor.lnum * 100L) / curbuf->b_ml.ml_line_count);
  }
  if (curbuf->b_ml.ml_flags & 1) {
    {
    tmp___19 = strlen((char const   *)((char *)buffer));
    strcpy((char * __restrict  )((char *)(buffer + tmp___19)), (char const   * __restrict  )((char *)(no_lines_msg)));
    }
  } else { //Added block
  if (p_ru) {
    {




    }
  } else {
    {
    tmp___22 = strlen((char const   *)((char *)buffer));
    sprintf((char * __restrict  )((char *)buffer + tmp___22), (char const   * __restrict  )"line %ld of %ld --%d%%-- col ",
            curwin->w_cursor.lnum, curbuf->b_ml.ml_line_count, n);
    validate_virtcol();
    tmp___23 = strlen((char const   *)((char *)buffer));
    col_print(buffer + tmp___23, (int )curwin->w_cursor.col + 1, (int )curwin->w_virtcol + 1);
    }
  }
  }
  {
  tmp___24 = shortmess('f');
  }
  if (tmp___24) {

  } else {
    tmp___25 = 1;
  }
  {
  append_arg_number(curwin, buffer, tmp___25, 1025);
  }
  if (dont_truncate) {
    {
    n = msg_scroll;
    msg_scroll = 1;
    msg(buffer);
    msg_scroll = n;
    }
  } else {
    {
    msg_trunc_attr(buffer, 0, 0);
    }
  }
  {
  vim_free((void *)buffer);
  }
  return;
}
}
void cursor_pos_info(void) 
{ 
  char_u *p___0 ;
  char_u buf1[20] ;
  char_u buf2[20] ;
  linenr_t lnum ;
  long char_count ;
  long char_count_cursor ;
  int eol_size ;
  long last_check ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  char_count = 0L;
  char_count_cursor = 0L;
  last_check = 100000L;
  if (curbuf->b_ml.ml_flags & 1) {
    {

    }
  } else {
    {
    tmp = get_fileformat(curbuf);
    }
    if (tmp == 1) {

    } else {
      eol_size = 1;
    }
    lnum = (linenr_t )1;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (lnum <= curbuf->b_ml.ml_line_count)) {
        goto while_break;
      }
      if (lnum == curwin->w_cursor.lnum) {
        char_count_cursor = (char_count + (long )curwin->w_cursor.col) + 1L;
      }
      {
      tmp___0 = ml_get(lnum);
      tmp___1 = strlen((char const   *)((char *)tmp___0));
      char_count = (long )((size_t )char_count + (tmp___1 + (size_t )eol_size));
      }
      if (char_count > last_check) {
        {

        }




      }
      lnum ++;
    }
    while_break: ;/* CIL Label */ ;
    }
    if (! curbuf->b_p_eol) {



    }
    {
    p___0 = ml_get_curline();
    validate_virtcol();
    col_print(buf1, (int )curwin->w_cursor.col + 1, (int )curwin->w_virtcol + 1);
    tmp___2 = linetabsize(p___0);
    tmp___3 = strlen((char const   *)((char *)p___0));
    col_print(buf2, (int )tmp___3, tmp___2);
    sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"Col %s of %s; Line %ld of %ld; Char %ld of %ld",
            (char *)(buf1), (char *)(buf2), curwin->w_cursor.lnum, curbuf->b_ml.ml_line_count,
            char_count_cursor, char_count);
    msg(IObuff);
    }
  }
  return;
}
}
void col_print(char_u *buf___3 , int col , int vcol ) 
{ 


  {
  if (col == vcol) {
    {
    sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"%d",
            col);
    }
  } else {
    {
    sprintf((char * __restrict  )((char *)buf___3), (char const   * __restrict  )"%d-%d",
            col, vcol);
    }
  }
  return;
}
}
static char_u *lasttitle  =    (char_u *)((void *)0);
static char_u *lasticon  =    (char_u *)((void *)0);
void maketitle(void) 
{ 
  char_u *t_name ;
  char_u *t_str ;
  char_u *i_name ;
  char_u *i_str ;
  char_u *p___0 ;
  int maxlen ;
  int len___0 ;
  int mustset ;
  char_u buf___3[1025] ;
  size_t tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  int tmp___6 ;

  {
  t_str = (char_u *)((void *)0);
  i_str = (char_u *)((void *)0);
  maxlen = 0;
  if (p_title) {
    if (p_titlelen > 0L) {
      maxlen = (int )((p_titlelen * Columns) / 100L);
      if (maxlen < 10) {

      }
    }
    t_str = buf___3;
    if ((int )*p_titlestring != 0) {







    } else {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {

      } else {
        {
        t_name = buf___3 + 100;
        strcpy((char * __restrict  )((char *)t_name), (char const   * __restrict  )((char *)"VIM - "));
        home_replace(curbuf, curbuf->b_ffname, t_name + 6, 919, 1);
        append_arg_number(curwin, t_name, 0, 925);
        }
        if (maxlen) {
          {
          tmp = strlen((char const   *)((char *)t_name));
          len___0 = (int )tmp;
          }
          if (len___0 > maxlen) {
            {



            }
          }
        }
      }
      p___0 = buf___3;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (*t_name) {
          if (! ((unsigned long )p___0 < (unsigned long )((buf___3 + 1025) - 5))) {

          }
        } else {
          goto while_break;
        }
        {
        tmp___1 = t_name;
        t_name ++;
        tmp___2 = transchar((int )*tmp___1);
        strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)tmp___2));
        tmp___0 = strlen((char const   *)((char *)p___0));
        p___0 += tmp___0;
        }
      }
      while_break: ;/* CIL Label */ ;
      }
      *p___0 = (char_u )'\000';
    }
  }
  {
  mustset = ti_change(t_str, & lasttitle);
  }
  if (p_icon) {
    i_str = buf___3;
    if ((int )*p_iconstring != 0) {







    } else {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {

      } else {
        {
        i_name = gettail(curbuf->b_ffname);
        }
      }
      p___0 = buf___3;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (*i_name) {
          if (! ((unsigned long )p___0 < (unsigned long )((buf___3 + 1025) - 5))) {

          }
        } else {
          goto while_break___0;
        }
        {
        tmp___4 = i_name;
        i_name ++;
        tmp___5 = transchar((int )*tmp___4);
        strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)tmp___5));
        tmp___3 = strlen((char const   *)((char *)p___0));
        p___0 += tmp___3;
        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
      *p___0 = (char_u )'\000';
    }
  }
  {
  tmp___6 = ti_change(i_str, & lasticon);
  mustset |= tmp___6;
  }
  if (mustset) {
    {
    resettitle();
    }
  }
  return;
}
}
static int ti_change(char_u *str___1 , char_u **last ) 
{ 
  int tmp ;

  {
  if (((unsigned long )str___1 == (unsigned long )((void *)0)) != ((unsigned long )*last == (unsigned long )((void *)0))) {
    goto _L;
  } else { //Added block
  if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
    if ((unsigned long )*last != (unsigned long )((void *)0)) {
      {

      }
      if (tmp != 0) {
        _L: ;
        {
        vim_free((void *)*last);
        }
        if ((unsigned long )str___1 == (unsigned long )((void *)0)) {

        } else {
          {
          *last = vim_strsave(str___1);
          }
        }
        return (1);
      }
    }
  }
  }
  return (0);
}
}
void resettitle(void) 
{ 


  {
  {
  mch_settitle(lasttitle, lasticon);
  }
  return;
}
}
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (arg_file_count <= 1) {
    return (0);
  }
  {
  tmp = strlen((char const   *)((char *)buf___3));
  p___0 = buf___3 + tmp;
  }
  if (maxlen) {
    if ((p___0 - buf___3) + 35L >= (long )maxlen) {

    }
  }
  tmp___0 = p___0;
  p___0 ++;
  *tmp___0 = (char_u )' ';
  tmp___1 = p___0;
  p___0 ++;
  *tmp___1 = (char_u )'(';
  if (add_file) {
    {
    strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"file "));
    p___0 += 5;
    }
  }
  if (wp->w_arg_idx_invalid) {

  } else {
    tmp___2 = "%d of %d)";
  }
  {
  sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )tmp___2,
          wp->w_arg_idx + 1, arg_file_count);
  }
  return (1);
}
}
char_u *fix_fname(char_u *fname ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = FullName_save(fname, 1);
  }
  return (tmp);
}
}
void fname_expand(char_u **ffname , char_u **sfname ) 
{ 


  {
  if ((unsigned long )*ffname == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )*sfname == (unsigned long )((void *)0)) {
    *sfname = *ffname;
  }
  {
  *ffname = fix_fname(*ffname);
  }
  return;
}
}
void do_arg_all(int count___2 , int forceit ) 
{ 
  int i___0 ;
  WIN *wp ;
  WIN *wpnext ;
  char_u *opened ;
  int opened_len ;
  int use_firstwin ;
  int split_ret ;
  int p_sb_save ;
  int p_ea_save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  use_firstwin = 0;
  split_ret = 1;
  if (arg_file_count <= 0) {

  }
  {
  setpcmark();
  opened_len = arg_file_count;
  opened = alloc_clear((unsigned int )opened_len);
  }
  if ((unsigned long )opened == (unsigned long )((void *)0)) {

  }
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    wpnext = wp->w_next;
    if ((unsigned long )(wp->w_buffer)->b_ffname == (unsigned long )((void *)0)) {

    } else { //Added block
    if ((wp->w_buffer)->b_nwindows > 1) {

    } else {
      i___0 = 0;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! (i___0 < arg_file_count)) {

        }
        {
        tmp = fullpathcmp(*(arg_files + i___0), (wp->w_buffer)->b_ffname, 1);
        }
        if (tmp & 1) {
          if (i___0 < opened_len) {
            *(opened + i___0) = (char_u )1;
          }
          goto while_break___0;
        }

      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    }
    wp->w_arg_idx = i___0;
    if (i___0 == arg_file_count) {


























































    }
    __Cont: ;
    wp = wpnext;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (count___2 > arg_file_count) {
    count___2 = arg_file_count;
  } else { //Added block



  }
  {
  autocmd_no_enter ++;
  autocmd_no_leave ++;
  win_enter(lastwin, 0);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (i___0 < count___2) {
      if (i___0 < arg_file_count) {
        if (! (! got_int)) {

        }
      } else {

      }
    } else {
      goto while_break___1;
    }
    if (i___0 == arg_file_count - 1) {
      arg_had_last = 1;
    }
    if (i___0 < opened_len) {
      if (*(opened + i___0)) {
        if (curwin->w_arg_idx != i___0) {

          {













          while_break___2: ;/* CIL Label */ ;
          }
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if (split_ret == 1) {
      if (! use_firstwin) {
        {
        p_sb_save = p_sb;
        p_ea_save = p_ea;
        p_sb = 1;
        p_ea = 1;
        split_ret = win_split(0, 0, 1);
        p_sb = p_sb_save;
        p_ea = p_ea_save;
        }
        if (split_ret == 0) {

        }
      } else {

      }
      curwin->w_arg_idx = i___0;
      if (p_hid) {

      } else {
        {
        tmp___8 = buf_changed(curwin->w_buffer);
        }
        if (tmp___8) {

        } else {
          tmp___7 = 0;
        }
      }
      {
      do_ecmd(0, *(arg_files + i___0), (char_u *)((void *)0), (char_u *)((void *)0),
              (linenr_t )1, tmp___7 + 4);
      }
      if (use_firstwin) {

      }
      use_firstwin = 0;
    }
    }
    {
    ui_breakcheck();
    }
    __Cont___0: ;
    i___0 ++;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  {
  autocmd_no_enter --;
  win_enter(firstwin, 0);
  autocmd_no_leave --;
  }
  return;
}
}
void do_buffer_all(int count___2 , int all ) 
{
























































































































































































}
static int chk_modeline(linenr_t lnum ) ;
static int entered  =    0;
void do_modelines(void) 
{ 
  linenr_t lnum ;
  int nmlines ;
  int tmp ;
  int tmp___0 ;

  {
  if (! curbuf->b_p_ml) {
    return;
  } else {




  }





  {

















  while_break: ;/* CIL Label */ ;
  }

  {





















  while_break___0: ;/* CIL Label */ ;
  }


}
}
static int chk_modeline(linenr_t lnum ) 
{

































































































































































}
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) 
{










































































}
void write_viminfo_bufferlist(FILE *fp___0 ) 
{ 
  BUF *buf___3 ;
  WIN *win ;
  char_u *line ;
  char_u *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
  tmp = find_viminfo_parameter('%');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return;
  }
  {

  }




  {










  while_break: ;/* CIL Label */ ;
  }
  {


  }
  {






























  while_break___0: ;/* CIL Label */ ;
  }
  {

  }

}
}
#pragma merger("0","/tmp/cil-TCvMZy5O.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
int VIsual_active ;
int State ;
char_u chartab[256]  ;
char breakat_flags[256]  ;
int lcs_tab1 ;
char_u *p_isf  ;
char_u *p_isi  ;
char_u *p_isp  ;
char_u *p_sel  ;
char_u *p_sbr  ;
void trans_characters(char_u *buf___3 , int bufsize ) ;
char_u *transstr(char_u *s ) ;
void transchar_nonprint(char_u *buf___3 , int c ) ;
int charsize(int c ) ;
int chartabsize(int c , colnr_t col ) ;
int win_linetabsize(WIN *wp , char_u *s ) ;
int vim_isIDc(int c ) ;
int vim_iswordc(int c ) ;
int vim_iswordc_buf(int c , BUF *buf___3 ) ;
int vim_isfilec(int c ) ;
int vim_isprintc(int c ) ;
int safe_vim_isprintc(int c ) ;
int lbr_chartabsize(unsigned char *s , colnr_t col ) ;
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) ;
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) ;
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) ;
char_u *skipdigits(char_u *p___0 ) ;
int vim_isdigit(int c ) ;
char_u *skiptowhite(char_u *p___0 ) ;
int vim_isblankline(char_u *lbuf ) ;
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) ;
int hex2nr(int c ) ;
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) ;
char_u *skip_to_option_part(char_u *p___0 ) ;
static int win_chartabsize(WIN *wp , int c , colnr_t col ) ;
static int chartab_initialized  =    0;
int init_chartab(void) 
{ 
  int c ;
  int c2 ;
  char_u *p___0 ;
  int i___0 ;
  int tilde ;
  int do_isalpha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char_u *tmp___3 ;
  unsigned short const   **tmp___4 ;
  long tmp___5 ;
  char_u *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  c = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (c < 32)) {
      goto while_break;
    }
    tmp = c;
    c ++;
    chartab[tmp] = (char_u )2;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (c <= 126)) {
      goto while_break___0;
    }
    tmp___0 = c;
    c ++;
    chartab[tmp___0] = (char_u )5;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! (c < 256)) {
      goto while_break___1;
    }
    tmp___1 = c;
    c ++;
    chartab[tmp___1] = (char_u )2;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  if ((unsigned long )curbuf != (unsigned long )((void *)0)) {
    c = 0;
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      if (! (c < 256)) {
        goto while_break___2;
      }
      curbuf->b_chartab[c] = (char)0;
      c ++;
    }
    while_break___2: ;/* CIL Label */ ;
    }
  }
  if (curbuf->b_p_lisp) {

  }
  i___0 = 0;
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break___3;
    }
    if (i___0 == 0) {
      p___0 = p_isi;
    } else { //Added block
    if (i___0 == 1) {
      p___0 = p_isp;
    } else { //Added block
    if (i___0 == 2) {
      p___0 = p_isf;
    } else {
      p___0 = curbuf->b_p_isk;
    }
    }
    }
    {
    while (1) {
      while_continue___4: ;/* CIL Label */ ;
      if (! *p___0) {
        goto while_break___4;
      }
      tilde = 0;
      do_isalpha = 0;
      if ((int )*p___0 == 94) {




      }
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + (int )*p___0) & 2048) {
        {
        tmp___2 = getdigits(& p___0);
        c = (int )tmp___2;
        }
      } else {
        tmp___3 = p___0;
        p___0 ++;
        c = (int )*tmp___3;
      }
      c2 = -1;
      if ((int )*p___0 == 45) {
        if ((int )*(p___0 + 1) != 0) {
          {
          p___0 ++;
          tmp___7 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___7 + (int )*p___0) & 2048) {
            {
            tmp___5 = getdigits(& p___0);
            c2 = (int )tmp___5;
            }
          } else {



          }
        }
      }
      if (c <= 0) {

      } else { //Added block
      if (c2 < c) {
        if (c2 != -1) {

        } else {
          goto _L;
        }
      } else { //Added block
      _L: ;
      if (c2 >= 256) {

      } else { //Added block
      if (! ((int )*p___0 == 0)) {
        if (! ((int )*p___0 == 44)) {

        }
      }
      }
      }
      }
      if (c2 == -1) {
        if (c == 64) {
          do_isalpha = 1;
          c = 1;
          c2 = 255;
        } else {
          c2 = c;
        }
      }
      {
      while (1) {
        while_continue___5: ;/* CIL Label */ ;
        if (! (c <= c2)) {
          goto while_break___5;
        }
        if (! do_isalpha) {
          goto _L___1;
        } else {
          {
          tmp___8 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___8 + c) & 1024) {
            _L___1: ;
            if (i___0 == 0) {
              if (tilde) {

              } else {
                chartab[c] = (char_u )((int )chartab[c] | 8);
              }
            } else { //Added block
            if (i___0 == 1) {
              if (c < 32) {

              } else { //Added block
              if (c > 126) {
                _L___0: ;
                if (tilde) {


                } else {
                  chartab[c] = (char_u )(((int )chartab[c] & -4) + 1);
                  chartab[c] = (char_u )((int )chartab[c] | 4);
                }
              }
              }
            } else { //Added block
            if (i___0 == 2) {
              if (tilde) {

              } else {
                chartab[c] = (char_u )((int )chartab[c] | 16);
              }
            } else {
              curbuf->b_chartab[c] = (char )(! tilde);
            }
            }
            }
          }
        }
        c ++;
      }
      while_break___5: ;/* CIL Label */ ;
      }
      {
      p___0 = skip_to_option_part(p___0);
      }
    }
    while_break___4: ;/* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break___3: ;/* CIL Label */ ;
  }
  chartab_initialized = 1;
  return (1);
}
}
void trans_characters(char_u *buf___3 , int bufsize ) 
{ 
  int len___0 ;
  int room ;
  char_u *new ;
  int new_len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)buf___3));
  len___0 = (int )tmp;
  room = bufsize - len___0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *buf___3) {
      goto while_break;
    }
    {
    new = transchar((int )*buf___3);
    tmp___0 = strlen((char const   *)((char *)new));
    new_len = (int )tmp___0;
    }
    if (new_len > 1) {




      {


      }
    }
    {
    memmove((void *)((char *)buf___3), (void const   *)((char *)new), (size_t )new_len);
    buf___3 += new_len;
    len___0 --;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
char_u *transstr(char_u *s ) 
{






























}
static char_u buf[5]  ;
char_u *transchar(int c ) 
{ 
  int i___0 ;
  int tmp ;

  {
  i___0 = 0;
  if (c >= 512) {













  }
  if (! chartab_initialized) {










  } else { //Added block
  _L: ;
  if ((int )chartab[c] & 4) {
    buf[i___0] = (char_u )c;
    buf[i___0 + 1] = (char_u )'\000';
  } else {
    {
    transchar_nonprint(buf + i___0, c);
    }
  }
  }
  return (buf);
}
}
void transchar_nonprint(char_u *buf___3 , int c ) 
{ 
  int tmp ;

  {
  if (c <= 127) {
    if (c == 10) {

    } else { //Added block
    if (c == 13) {
      {

      }



    }
    }
    *(buf___3 + 0) = (char_u )'^';
    *(buf___3 + 1) = (char_u )(c ^ 64);
    *(buf___3 + 2) = (char_u )'\000';
  } else { //Added block















  }
  return;
}
}
int charsize(int c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (c >= 512) {











  }
  return ((int )chartab[c] & 3);
}
}
int vim_strsize(char_u *s ) 
{ 
  int len___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = charsize((int )*tmp);
    len___0 += tmp___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (len___0);
}
}
int chartabsize(int c , colnr_t col ) 
{


























}
static int win_chartabsize(WIN *wp , int c , colnr_t col ) 
{ 
  int ts ;
  int tmp ;

  {
  if (c == 9) {
    if (! wp->w_p_list) {
      ts = (int )(wp->w_buffer)->b_p_ts;
      return ((int )((unsigned int )ts - col % (unsigned int )ts));
    } else { //Added block









    }
  } else {
    {
    tmp = charsize(c);
    }
    return (tmp);
  }
}
}
int linetabsize(char_u *s ) 
{ 
  colnr_t col ;
  char_u *tmp ;
  int tmp___0 ;

  {
  col = (colnr_t )0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = lbr_chartabsize(tmp, col);
    col += (colnr_t )tmp___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return ((int )col);
}
}
int win_linetabsize(WIN *wp , char_u *s ) 
{ 
  colnr_t col ;
  char_u *tmp ;
  int tmp___0 ;

  {
  col = (colnr_t )0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    tmp___0 = win_lbr_chartabsize(wp, tmp, col, (int *)((void *)0));
    col += (colnr_t )tmp___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return ((int )col);
}
}
int vim_isIDc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if ((int )chartab[c] & 8) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {

  }
  return (tmp);
}
}
int vim_iswordc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if (curbuf->b_chartab[c]) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {

  }
  return (tmp);
}
}
int vim_iswordc_buf(int c , BUF *buf___3 ) 
{














}
int vim_isfilec(int c ) 
{














}
int vim_isprintc(int c ) 
{ 
  int tmp ;

  {
  if (c < 256) {
    if ((int )chartab[c] & 4) {
      tmp = 1;
    } else {

    }
  } else {

  }
  return (tmp);
}
}
int safe_vim_isprintc(int c ) 
{ 


  {
  return ((int )chartab[c] & 4);
}
}
int lbr_chartabsize(unsigned char *s , colnr_t col ) 
{ 
  int ts ;
  int tmp ;
  int tmp___0 ;

  {
  if (! curwin->w_p_lbr) {
    if ((int )*p_sbr == 0) {
      if ((int )*s == 9) {
        if (! curwin->w_p_list) {
          ts = (int )curbuf->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else { //Added block









        }
      } else {
        {
        tmp = charsize((int )*s);
        }
        return (tmp);
      }
    }
  }
  {

  }

}
}
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) 
{ 
  int c ;
  int size ;
  colnr_t col2 ;
  colnr_t colmax ;
  int added ;
  int numberextra ;
  int ts ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  c = (int )*s;
  if (! wp->w_p_lbr) {
    if ((int )*p_sbr == 0) {
      if (c == 9) {
        if (! wp->w_p_list) {
          ts = (int )(wp->w_buffer)->b_p_ts;
          return ((int )((unsigned int )ts - col % (unsigned int )ts));
        } else { //Added block
        if (lcs_tab1) {


        } else {
          {
          tmp = charsize(c);
          }
          return (tmp);
        }
        }
      } else {
        {
        tmp = charsize(c);
        }
        return (tmp);
      }
    }
  }
  {
  size = win_chartabsize(wp, c, col);
  }
  if (wp->w_p_lbr) {
    if (breakat_flags[(char_u )c]) {
      if (! breakat_flags[*(s + 1)]) {
        if (! wp->w_p_list) {
          if (wp->w_p_wrap) {
            if (wp->w_p_nu) {

            } else {
              numberextra = 0;
            }
            col2 = col;
            colmax = (colnr_t )(((long )(col + (colnr_t )numberextra) / Columns + 1L) * Columns);
            {
            while (1) {
              while_continue: ;/* CIL Label */ ;
              s ++;
              c = (int )*s;
              if (c != 0) {
                if (! breakat_flags[(char_u )c]) {
                  if (! breakat_flags[(char_u )c]) {
                    if (! (col2 == col)) {
                      if (! (! breakat_flags[*(s + -1)])) {
                        goto while_break;
                      }
                    }
                  } else {

                  }
                }
              } else {
                goto while_break;
              }
              {
              tmp___0 = win_chartabsize(wp, c, col2);
              col2 += (colnr_t )tmp___0;
              }
              if (col2 + (colnr_t )numberextra >= colmax) {
                size = (int )(Columns - (long )(col + (colnr_t )numberextra) % Columns);
                goto while_break;
              }
            }
            while_break: ;/* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  added = 0;
  if ((int )*p_sbr != 0) {

























  }
  if ((unsigned long )head != (unsigned long )((void *)0)) {
    *head = added;
  }
  return (size);
}
}
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) 
{ 
  int col ;
  colnr_t vcol ;
  char_u *ptr ;
  int incr ;
  int head ;
  int ts ;
  int c ;

  {
  {
  ts = (int )(wp->w_buffer)->b_p_ts;
  vcol = (colnr_t )0;
  ptr = ml_get_buf(wp->w_buffer, pos___0->lnum, 0);
  }
  if (! wp->w_p_list) {
    goto _L___1;
  } else { //Added block
  if (lcs_tab1) {
    _L___1: ;
    if (! wp->w_p_lbr) {
      if ((int )*p_sbr == 0) {
        head = 0;
        col = (int )pos___0->col;
        {
        while (1) {
          while_continue: ;/* CIL Label */ ;
          c = (int )*ptr;
          if (c == 0) {
            incr = 1;
            goto while_break;
          }
          if (c == 9) {
            incr = (int )((unsigned int )ts - vcol % (unsigned int )ts);
          } else {
            incr = (int )chartab[c] & 3;
          }
          if (col == 0) {
            goto while_break;
          }
          vcol += (colnr_t )incr;
          col --;
          ptr ++;
        }
        while_break: ;/* CIL Label */ ;
        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
    col = (int )pos___0->col;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      head = 0;
      incr = win_lbr_chartabsize(wp, ptr, vcol, & head);
      }
      if ((int )*ptr == 0) {


      }
      if (col == 0) {
        goto while_break___0;
      }



    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  }
  if ((unsigned long )start___0 != (unsigned long )((void *)0)) {
    *start___0 = vcol + (colnr_t )head;
  }
  if ((unsigned long )end != (unsigned long )((void *)0)) {
    *end = (vcol + (colnr_t )incr) - 1U;
  }
  if ((unsigned long )cursor != (unsigned long )((void *)0)) {
    if ((int )*ptr == 9) {
      if (State & 1) {
        if (! wp->w_p_list) {
          if (VIsual_active) {





          } else {
            *cursor = (vcol + (colnr_t )incr) - 1U;
          }
        } else {

        }
      } else {

      }
    } else {
      *cursor = vcol + (colnr_t )head;
    }
  }
  return;
}
}
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) 
{






















}
char_u *skipwhite(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*p___0 == 32)) {
      if (! ((int )*p___0 == 9)) {
        goto while_break;
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
char_u *skipdigits(char_u *p___0 ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = __ctype_b_loc();
    }
    if (! ((int const   )*(*tmp + (int )*p___0) & 2048)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
int vim_isdigit(int c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  if (c > 0) {
    if (c < 256) {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + c) & 2048) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {

    }
  } else {

  }
  return (tmp___0);
}
}
char_u *skiptowhite(char_u *p___0 ) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((int )*p___0 != 32) {
      if ((int )*p___0 != 9) {
        if (! ((int )*p___0 != 0)) {
          goto while_break;
        }
      } else {

      }
    } else {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
char_u *skiptowhite_esc(char_u *p___0 ) 
{

































}
long getdigits(char_u **pp ) 
{ 
  char_u *p___0 ;
  long retval ;

  {
  {
  p___0 = *pp;
  retval = atol((char const   *)((char *)p___0));
  }
  if ((int )*p___0 == 45) {

  }
  {
  p___0 = skipdigits(p___0);
  *pp = p___0;
  }
  return (retval);
}
}
int vim_isblankline(char_u *lbuf ) 
{






















}
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) 
{





































































































































}
int hex2nr(int c ) 
{











}
#pragma merger("0","/tmp/cil-_1DEHuqF.i","-O0")
int must_redraw ;
char_u e_number[16] ;
int p_dg  ;
int do_digraph(int c ) ;
int getdigraph(int char1 , int char2 , int meta ) ;
void putdigraph(char_u *str___1 ) ;
void listdigraphs(void) ;
static int getexactdigraph(int char1 , int char2 , int meta ) ;
static void printdigraph(char_u *p___0 ) ;
static char_u (*digraphnew)[3]  ;
static int digraphcount  =    0;
char_u digraphdefault[101][3]  = 
  { {        (char_u )'~',        (char_u )'!',        (char_u )161}, 
   {        (char_u )'c',        (char_u )'|',        (char_u )162}, 
   {        (char_u )'$',        (char_u )'$',        (char_u )163}, 
   {        (char_u )'o',        (char_u )'x',        (char_u )164}, 
   {        (char_u )'e',        (char_u )'=',        (char_u )164}, 
   {        (char_u )'Y',        (char_u )'-',        (char_u )165}, 
   {        (char_u )'|',        (char_u )'|',        (char_u )166}, 
   {        (char_u )'p',        (char_u )'a',        (char_u )167}, 
   {        (char_u )'\"',        (char_u )'\"',        (char_u )168}, 
   {        (char_u )'c',        (char_u )'O',        (char_u )169}, 
   {        (char_u )'a',        (char_u )'-',        (char_u )170}, 
   {        (char_u )'<',        (char_u )'<',        (char_u )171}, 
   {        (char_u )'-',        (char_u )',',        (char_u )172}, 
   {        (char_u )'-',        (char_u )'-',        (char_u )173}, 
   {        (char_u )'r',        (char_u )'O',        (char_u )174}, 
   {        (char_u )'-',        (char_u )'=',        (char_u )175}, 
   {        (char_u )'~',        (char_u )'o',        (char_u )176}, 
   {        (char_u )'+',        (char_u )'-',        (char_u )177}, 
   {        (char_u )'2',        (char_u )'2',        (char_u )178}, 
   {        (char_u )'3',        (char_u )'3',        (char_u )179}, 
   {        (char_u )'\'',        (char_u )'\'',        (char_u )180}, 
   {        (char_u )'j',        (char_u )'u',        (char_u )181}, 
   {        (char_u )'p',        (char_u )'p',        (char_u )182}, 
   {        (char_u )'~',        (char_u )'.',        (char_u )183}, 
   {        (char_u )',',        (char_u )',',        (char_u )184}, 
   {        (char_u )'1',        (char_u )'1',        (char_u )185}, 
   {        (char_u )'o',        (char_u )'-',        (char_u )186}, 
   {        (char_u )'>',        (char_u )'>',        (char_u )187}, 
   {        (char_u )'1',        (char_u )'4',        (char_u )188}, 
   {        (char_u )'1',        (char_u )'2',        (char_u )189}, 
   {        (char_u )'3',        (char_u )'4',        (char_u )190}, 
   {        (char_u )'~',        (char_u )'?',        (char_u )191}, 
   {        (char_u )'A',        (char_u )'`',        (char_u )192}, 
   {        (char_u )'A',        (char_u )'\'',        (char_u )193}, 
   {        (char_u )'A',        (char_u )'^',        (char_u )194}, 
   {        (char_u )'A',        (char_u )'~',        (char_u )195}, 
   {        (char_u )'A',        (char_u )'\"',        (char_u )196}, 
   {        (char_u )'A',        (char_u )'@',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'A',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'E',        (char_u )198}, 
   {        (char_u )'C',        (char_u )',',        (char_u )199}, 
   {        (char_u )'E',        (char_u )'`',        (char_u )200}, 
   {        (char_u )'E',        (char_u )'\'',        (char_u )201}, 
   {        (char_u )'E',        (char_u )'^',        (char_u )202}, 
   {        (char_u )'E',        (char_u )'\"',        (char_u )203}, 
   {        (char_u )'I',        (char_u )'`',        (char_u )204}, 
   {        (char_u )'I',        (char_u )'\'',        (char_u )205}, 
   {        (char_u )'I',        (char_u )'^',        (char_u )206}, 
   {        (char_u )'I',        (char_u )'\"',        (char_u )207}, 
   {        (char_u )'D',        (char_u )'-',        (char_u )208}, 
   {        (char_u )'N',        (char_u )'~',        (char_u )209}, 
   {        (char_u )'O',        (char_u )'`',        (char_u )210}, 
   {        (char_u )'O',        (char_u )'\'',        (char_u )211}, 
   {        (char_u )'O',        (char_u )'^',        (char_u )212}, 
   {        (char_u )'O',        (char_u )'~',        (char_u )213}, 
   {        (char_u )'O',        (char_u )'\"',        (char_u )214}, 
   {        (char_u )'/',        (char_u )'\\',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'E',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'/',        (char_u )216}, 
   {        (char_u )'U',        (char_u )'`',        (char_u )217}, 
   {        (char_u )'U',        (char_u )'\'',        (char_u )218}, 
   {        (char_u )'U',        (char_u )'^',        (char_u )219}, 
   {        (char_u )'U',        (char_u )'\"',        (char_u )220}, 
   {        (char_u )'Y',        (char_u )'\'',        (char_u )221}, 
   {        (char_u )'I',        (char_u )'p',        (char_u )222}, 
   {        (char_u )'s',        (char_u )'s',        (char_u )223}, 
   {        (char_u )'a',        (char_u )'`',        (char_u )224}, 
   {        (char_u )'a',        (char_u )'\'',        (char_u )225}, 
   {        (char_u )'a',        (char_u )'^',        (char_u )226}, 
   {        (char_u )'a',        (char_u )'~',        (char_u )227}, 
   {        (char_u )'a',        (char_u )'\"',        (char_u )228}, 
   {        (char_u )'a',        (char_u )'@',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'a',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'e',        (char_u )230}, 
   {        (char_u )'c',        (char_u )',',        (char_u )231}, 
   {        (char_u )'e',        (char_u )'`',        (char_u )232}, 
   {        (char_u )'e',        (char_u )'\'',        (char_u )233}, 
   {        (char_u )'e',        (char_u )'^',        (char_u )234}, 
   {        (char_u )'e',        (char_u )'\"',        (char_u )235}, 
   {        (char_u )'i',        (char_u )'`',        (char_u )236}, 
   {        (char_u )'i',        (char_u )'\'',        (char_u )237}, 
   {        (char_u )'i',        (char_u )'^',        (char_u )238}, 
   {        (char_u )'i',        (char_u )'\"',        (char_u )239}, 
   {        (char_u )'d',        (char_u )'-',        (char_u )240}, 
   {        (char_u )'n',        (char_u )'~',        (char_u )241}, 
   {        (char_u )'o',        (char_u )'`',        (char_u )242}, 
   {        (char_u )'o',        (char_u )'\'',        (char_u )243}, 
   {        (char_u )'o',        (char_u )'^',        (char_u )244}, 
   {        (char_u )'o',        (char_u )'~',        (char_u )245}, 
   {        (char_u )'o',        (char_u )'\"',        (char_u )246}, 
   {        (char_u )':',        (char_u )'-',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'e',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'/',        (char_u )248}, 
   {        (char_u )'u',        (char_u )'`',        (char_u )249}, 
   {        (char_u )'u',        (char_u )'\'',        (char_u )250}, 
   {        (char_u )'u',        (char_u )'^',        (char_u )251}, 
   {        (char_u )'u',        (char_u )'\"',        (char_u )252}, 
   {        (char_u )'y',        (char_u )'\'',        (char_u )253}, 
   {        (char_u )'i',        (char_u )'p',        (char_u )254}, 
   {        (char_u )'y',        (char_u )'\"',        (char_u )255}, 
   {        (char_u )'\000',        (char_u )'\000',        (char_u )'\000'}};
static int backspaced  ;
static int lastchar  ;
int do_digraph(int c ) 
{ 


  {
  if (c == -1) {
    backspaced = -1;
  } else { //Added block
  if (p_dg) {
    if (backspaced >= 0) {
      {

      }
    }
    backspaced = -1;
    if (c == 107 + (98 << 8)) {

    } else { //Added block
    if (c == 8) {
      _L: ;



    }
    }
  }
  }
  lastchar = c;
  return (c);
}
}
static int getexactdigraph(int char1 , int char2 , int meta ) 
{
























































}
int getdigraph(int char1 , int char2 , int meta ) 
{


















}
void putdigraph(char_u *str___1 ) 
{







































































































}
void listdigraphs(void) 
{

























































}
static int len  ;
static void printdigraph(char_u *p___0 ) 
{




























}
#pragma merger("0","/tmp/cil-oAbd5Qx5.i","-O0")
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
char_u *NextScreen ;
int mod_mask ;
int redraw_cmdline ;
int clear_cmdline ;
colnr_t dollar_vcol ;
int completion_length ;
int continue_status ;
int completion_interrupted ;
int emsg_on_display ;
int intr_char ;
int highlight_attr[18]  ;
int sc_col  ;
int sandbox ;
FPOS where_paste_started  ;
int did_ai ;
colnr_t ai_col ;
int end_comment_pending ;
int did_si ;
int can_si ;
int can_si_back ;
FPOS Insstart  ;
int orig_line_count ;
int vr_lines_changed ;
colnr_t vr_virtcol ;
int Recording ;
int no_mapping ;
int allow_keys ;
int no_u_sync ;
int restart_edit ;
int arrow_used  ;
char_u *edit_submode ;
char_u *edit_submode_extra ;
enum hlf_value edit_submode_highl  ;
int ctrl_x_mode ;
int no_abbr ;
int fo_do_comments ;
int typelen  ;
int global_busy ;
int replace_offset ;
int no_hlsearch ;
char_u e_internal[15] ;
char_u e_noinstext[21] ;
char_u e_patnotf[18] ;
char_u e_sandbox[23] ;
char_u *p_cpo  ;
char_u *p_dict  ;
int p_hls  ;
int p_ic  ;
int p_im  ;
int p_js  ;
char_u *p_km  ;
int p_paste  ;
long p_so  ;
int p_sm  ;
int p_smd  ;
int p_scs  ;
int p_sta  ;
char_u *p_ww  ;
int p_ws  ;
int edit(int cmdchar , int startln , long count___2 ) ;
void display_dollar(colnr_t col ) ;
void change_indent(int type , int amount , int round , int replaced ) ;
void truncate_spaces(char_u *line ) ;
void backspace_until_column(int col ) ;
int vim_is_ctrl_x_key(int c ) ;
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) ;
void ins_compl_check_keys(void) ;
int get_literal(void) ;
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) ;
int comp_textwidth(int ff ) ;
void stop_arrow(void) ;
void set_last_insert(int c ) ;
void beginline(int flags___0 ) ;
int oneright(void) ;
int oneleft(void) ;
int cursor_up(long n , int upd_topline ) ;
int cursor_down(long n , int upd_topline ) ;
int stuff_inserted(int c , long count___2 , int no_esc ) ;
char_u *get_last_insert(void) ;
char_u *get_last_insert_save(void) ;
void replace_push(int c ) ;
int get_replace_stack_virtcol(void) ;
void fixthisline(int (*get_the_indent)(void) ) ;
int in_cinkeys(int keytyped , int when , int line_is_empty ) ;
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) ;
char_u *addstar(char_u *fname , int len___0 , int context ) ;
char_u *get_inserted(void) ;
int stuff_empty(void) ;
void ResetRedobuff(void) ;
void AppendToRedobuff(char_u *s ) ;
void AppendCharToRedobuff(int c ) ;
void AppendNumberToRedobuff(long n ) ;
void stuffReadbuff(char_u *s ) ;
void stuffcharReadbuff(int c ) ;
int start_redo_ins(void) ;
void stop_redo_ins(void) ;
int using_script(void) ;
int safe_vgetc(void) ;
int vpeekc(void) ;
int char_avail(void) ;
void vungetc(int c ) ;
int check_abbr(int c , char_u *ptr , int col , int mincol ) ;
char_u *ml_get_cursor(void) ;
int ml_replace(linenr_t lnum , char_u *line , int copy ) ;
int msg_attr(char_u *s , int attr ) ;
int get_indent(void) ;
void set_indent(int size , int del_first ) ;
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) ;
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) ;
void ins_char(int c ) ;
void ins_str(char_u *s ) ;
int del_char(int fixpos ) ;
int gchar_cursor(void) ;
void pchar_cursor(int c ) ;
int inindent(int extra ) ;
void change_warning(int col ) ;
void vim_beep(void) ;
int cin_islabel(int ind_maxcomment ) ;
int cin_iscase(char_u *s ) ;
int cin_isscopedecl(char_u *s ) ;
int get_c_indent(void) ;
void line_breakcheck(void) ;
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) ;
void FreeWild(int num , char_u **file ) ;
int goto_im(void) ;
int coladvance(colnr_t wcol ) ;
int inc_cursor(void) ;
int dec_cursor(void) ;
int dec(FPOS *lp ) ;
char_u *lalloc(long_u size , int message ) ;
char_u *vim_strnsave(char_u *string___0 , int len___0 ) ;
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) ;
char_u *get_special_key_name(int c , int modifiers ) ;
int get_special_key_code(char_u *name___1 ) ;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) ;
void clear_showcmd(void) ;
int add_to_showcmd(int c ) ;
void add_to_showcmd_c(int c ) ;
void do_check_scrollbind(int check ) ;
void scroll_redraw(int up , long count___2 ) ;
void start_selection(void) ;
void shift_line(int left , int round , int amount ) ;
int get_expr_register(void) ;
int insert_reg(int regname___0 , int literally ) ;
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) ;
int do_join(int insert_space , int redraw ) ;
int has_format_option(int x___0 ) ;
int can_bs(int what ) ;
void update_screenline(void) ;
void redraw_later(int type ) ;
void redraw_statuslines(void) ;
void win_redr_status(WIN *wp ) ;
void screen_putchar(int c , int row , int col , int attr ) ;
void update_topline(void) ;
void update_curswant(void) ;
void setcursor(void) ;
void changed_cline_bef_curs(void) ;
void set_topline(WIN *wp , linenr_t lnum ) ;
void validate_cursor(void) ;
void validate_cursor_col(void) ;
void curs_columns(int scroll ) ;
void scrolldown_clamp(void) ;
void scrollup_clamp(void) ;
int showmode(void) ;
void showruler(int always ) ;
void check_for_delay(int check_msg_scroll ) ;
int redrawing(void) ;
int onepage(int dir , long count___2 ) ;
void set_reg_ic(char_u *pat ) ;
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) ;
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) ;
FPOS *findmatch(OPARG *oap , int initc ) ;
int fwd_word(long count___2 , int type , int eol ) ;
int bck_word(long count___2 , int type , int stop ) ;
int linewhite(linenr_t lnum ) ;
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) ;
void syn_changed(linenr_t lnum ) ;
int syntax_present(BUF *buf___3 ) ;
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) ;
void setmouse(void) ;
int mouse_has(int c ) ;
void cursor_off(void) ;
int u_save_cursor(void) ;
int u_save(linenr_t top , linenr_t bot ) ;
static char *ctrl_x_msgs[10]  = 
  {      (char *)" Adding Keyword completion (^N/^P)",      (char *)" ^X mode (^E/^Y/^L/^]/^F/^I/^K/^D/^N/^P)",      (char *)" Adding Keyword Local completion (^N/^P)",      (char *)" Adding Whole line completion (^L/^N/^P)", 
        (char *)" Adding File name completion (^F/^N/^P)",      (char *)" Adding Tag completion (^]/^N/^P)",      (char *)" Adding Path pattern completion (^N/^P)",      (char *)" Adding Definition completion (^D/^N/^P)", 
        (char *)((void *)0),      (char *)" Adding Dictionary completion (^K/^N/^P)"};
static char_u e_hitend[21]  = 
  {      (char_u )'H',      (char_u )'i',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'p', 
        (char_u )'a',      (char_u )'r',      (char_u )'a',      (char_u )'g', 
        (char_u )'r',      (char_u )'a',      (char_u )'p',      (char_u )'h', 
        (char_u )'\000'};
static struct Completion *first_match  =    (struct Completion *)((void *)0);
static struct Completion *curr_match  =    (struct Completion *)((void *)0);
static struct Completion *shown_match  =    (struct Completion *)((void *)0);
static int started_completion  =    0;
static char_u *complete_pat  =    (char_u *)((void *)0);
static int complete_direction  =    1;
static int shown_direction  =    1;
static int completion_pending  =    0;
static FPOS initial_pos  ;
static colnr_t complete_col  =    (colnr_t )0;
static int save_sm  ;
static char_u *original_text  =    (char_u *)((void *)0);
static int continue_mode  =    0;
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) ;
static int ins_compl_make_cyclic(void) ;
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) ;
static void ins_compl_free(void) ;
static void ins_compl_clear(void) ;
static int ins_compl_prep(int c ) ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) ;
static int ins_compl_get_exp(FPOS *ini , int dir ) ;
static void ins_compl_delete(void) ;
static void ins_compl_insert(void) ;
static int ins_compl_next(int allow_get_expansion ) ;
static int ins_complete(int c ) ;
static int quote_meta(char_u *dest , char_u *src , int len___0 ) ;
static void edit_putchar(int c , int highlight ) ;
static void undisplay_dollar(void) ;
static void insert_special(int c , int allow_modmask , int ctrlv ) ;
static void redo_literal(int c ) ;
static void start_arrow(FPOS *end_insert_pos ) ;
static void stop_insert(FPOS *end_insert_pos ) ;
static int echeck_abbr(int c ) ;
static void replace_push_off(int c ) ;
static int replace_pop(void) ;
static void replace_join(int off___0 ) ;
static void replace_pop_ins(void) ;
static void replace_flush(void) ;
static void replace_do_bs(void) ;
static int ins_reg(void) ;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) ;
static void ins_shift(int c , int lastc___1 ) ;
static void ins_del(void) ;
static int ins_bs(int c , int mode , int *inserted_space_p ) ;
static void ins_mouse(int c ) ;
static void ins_mousescroll(int up ) ;
static void ins_left(void) ;
static void ins_home(void) ;
static void ins_end(void) ;
static void ins_s_left(void) ;
static void ins_right(void) ;
static void ins_s_right(void) ;
static void ins_up(void) ;
static void ins_pageup(void) ;
static void ins_down(void) ;
static void ins_pagedown(void) ;
static int ins_tab(void) ;
static int ins_eol(int c ) ;
static int ins_digraph(void) ;
static int ins_copychar(linenr_t lnum ) ;
static void ins_try_si(int c ) ;
static colnr_t get_nolist_virtcol(void) ;
static colnr_t Insstart_textlen  ;
static colnr_t Insstart_blank_vcol  ;
static char_u *last_insert  =    (char_u *)((void *)0);
static int last_insert_skip  ;
static int new_insert_skip  ;
static int can_cindent  ;
static int old_indent  =    0;
static linenr_t o_lnum  =    (linenr_t )0;
static int o_eol  =    0;
int edit(int cmdchar , int startln , long count___2 ) 
{ 
  int c ;
  char_u *ptr ;
  int lastc___1 ;
  colnr_t mincol ;
  int need_redraw ;
  int i___0 ;
  int did_backspace ;
  int line_is_white ;
  linenr_t old_topline___0 ;
  int inserted_space ;
  int has_startsel ;
  int replaceState ;
  int did_restart_edit ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char_u buf___3[4] ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  long tw_save ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  {
  c = 0;
  need_redraw = 0;
  did_backspace = 1;
  line_is_white = 0;
  old_topline___0 = (linenr_t )0;
  inserted_space = 0;
  replaceState = 528;
  did_restart_edit = restart_edit;
  check_for_delay(1);
  }
  if (sandbox != 0) {
    {

    }

  }
  {
  ins_compl_clear();
  }
  if (where_paste_started.lnum != 0L) {

  } else {
    Insstart = curwin->w_cursor;
    if (startln) {

    }
  }
  {
  tmp = ml_get_curline();
  tmp___0 = linetabsize(tmp);
  Insstart_textlen = (colnr_t )tmp___0;
  Insstart_blank_vcol = (colnr_t )2147483647;
  }
  if (! did_ai) {
    ai_col = (colnr_t )0;
  }
  if (cmdchar != 0) {
    if (! restart_edit) {
      {
      ResetRedobuff();
      AppendNumberToRedobuff(count___2);
      }
      if (cmdchar == 86) {

      } else { //Added block
      if (cmdchar == 118) {
        _L: ;
        {

        }





        {

        }
      } else {
        {
        AppendCharToRedobuff(cmdchar);
        }
        if (cmdchar == 103) {
          {

          }
        } else { //Added block
        if (cmdchar == 114) {

        }
        }
      }
      }
    }
  }
  if (cmdchar == 82) {

  } else { //Added block
  if (cmdchar == 86) {





  } else { //Added block
  if (cmdchar == 118) {





  } else {
    State = 16;
  }
  }
  }
  {
  curs_columns(1);
  setmouse();
  clear_showcmd();
  tmp___2 = vim_strchr(p_km, 'a');
  has_startsel = (unsigned long )tmp___2 != (unsigned long )((void *)0);
  }
  if (restart_edit) {
    {

    }




































  } else {
    arrow_used = 0;
    o_eol = 0;
  }
  where_paste_started.lnum = (linenr_t )0;
  can_cindent = 1;
  i___0 = 0;
  if (p_smd) {
    {

    }
  }
  if (! p_im) {
    if (! did_restart_edit) {
      {
      change_warning(i___0 + 1);
      }
    }
  }
  {
  do_digraph(-1);
  ptr = get_inserted();
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {

  } else {
    {
    tmp___5 = strlen((char const   *)((char *)ptr));
    new_insert_skip = (int )tmp___5;
    vim_free((void *)ptr);
    }
  }
  old_indent = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (arrow_used) {

    }
    if (! arrow_used) {
      curwin->w_set_curswant = 1;
    }
    msg_scroll = 0;
    if (need_redraw) {
      if (curwin->w_p_wrap) {
        if (! did_backspace) {
          if (curwin->w_topline == old_topline___0) {
            {
            mincol = (colnr_t )curwin->w_wcol;
            validate_cursor_col();
            }
            if ((long )curwin->w_wcol < (long )((int )mincol) - curbuf->b_p_ts) {



















            } else {
              {
              update_topline();
              }
            }
          } else {
            {

            }
          }
        } else {
          {
          update_topline();
          }
        }
      } else {
        {

        }
      }
    } else {
      {
      update_topline();
      }
    }
    {
    did_backspace = 0;
    validate_cursor();
    }
    if (need_redraw) {
      goto _L___2;
    } else { //Added block
    if (must_redraw) {
      _L___2: ;
      {
      update_screenline();
      }
      if (curwin->w_redr_status == 1) {
        {

        }
      }
      need_redraw = 0;
    } else { //Added block
    if (clear_cmdline) {
      {

      }
    } else { //Added block
    if (redraw_cmdline) {
      {

      }
    }
    }
    }
    }
    if (curwin->w_p_scb) {
      {

      }
    }
    {
    showruler(0);
    setcursor();
    update_curswant();
    emsg_on_display = 0;
    old_topline___0 = curwin->w_topline;
    lastc___1 = c;
    c = safe_vgetc();
    tmp___6 = ins_compl_prep(c);
    need_redraw |= tmp___6;
    }
    if (c == 28) {
      {

      }









    }
    {
    c = do_digraph(c);
    }
    if (c == 22) {

    } else { //Added block
    if (c == 17) {
      _L___3: ;
      {

      }










      {







      }

    }
    }
    if (curbuf->b_p_cin) {





















    }
    if (has_startsel) {
      {











































      case_exp: ;/* CIL Label */ 
      case_exp___0: ;/* CIL Label */ 
      case_exp___1: ;/* CIL Label */ 
      case_exp___2: ;/* CIL Label */ 
      case_exp___3: ;/* CIL Label */ 
      case_exp___4: ;/* CIL Label */ 
      case_exp___5: ;/* CIL Label */ 
      case_exp___6: ;/* CIL Label */ 



      case_exp___7: ;/* CIL Label */ 
      case_exp___8: ;/* CIL Label */ 
      case_exp___9: ;/* CIL Label */ 
      case_exp___10: ;/* CIL Label */ 
      case_exp___11: ;/* CIL Label */ 
      case_exp___12: ;/* CIL Label */ 
      {


      }























      switch_break: ;/* CIL Label */ ;
      }
    }
    {
    if (c == 107 + (73 << 8)) {

    }
    if (c == 253 + (69 << 8)) {

    }
    if (c == 24) {

    }
    if (c == 245 + (88 << 8)) {

    }
    if (c == 26) {

    }
    if (c == 15) {

    }
    if (c == 37 + (49 << 8)) {

    }
    if (c == 107 + (49 << 8)) {

    }
    if (c == 253 + (55 << 8)) {

    }
    if (c == 27) {
      goto case_27;
    }
    if (c == 3) {

    }
    if (c == 255 + (88 << 8)) {

    }
    if (c == 0) {

    }
    if (c == 1) {

    }
    if (c == 18) {

    }
    if (c == 4) {

    }
    if (c == 20) {

    }
    if (c == 107 + (68 << 8)) {

    }
    if (c == 253 + (70 << 8)) {

    }
    if (c == 107 + (98 << 8)) {

    }
    if (c == 8) {
      goto case_exp___22;
    }
    if (c == 23) {

    }
    if (c == 21) {

    }
    if (c == 253 + (42 << 8)) {

    }
    if (c == 253 + (61 << 8)) {

    }
    if (c == 253 + (43 << 8)) {

    }
    if (c == 253 + (44 << 8)) {

    }
    if (c == 253 + (62 << 8)) {

    }
    if (c == 253 + (45 << 8)) {

    }
    if (c == 253 + (46 << 8)) {

    }
    if (c == 253 + (47 << 8)) {

    }
    if (c == 253 + (48 << 8)) {

    }
    if (c == 253 + (49 << 8)) {

    }
    if (c == 253 + (50 << 8)) {

    }
    if (c == 253 + (51 << 8)) {

    }
    if (c == 253 + (67 << 8)) {

    }
    if (c == 253 + (68 << 8)) {

    }
    if (c == 107 + (104 << 8)) {

    }
    if (c == 75 + (49 << 8)) {

    }
    if (c == 253 + (60 << 8)) {

    }
    if (c == 35 + (50 << 8)) {

    }
    if (c == 64 + (55 << 8)) {

    }
    if (c == 75 + (52 << 8)) {

    }
    if (c == 253 + (59 << 8)) {

    }
    if (c == 42 + (55 << 8)) {

    }
    if (c == 107 + (108 << 8)) {

    }
    if (c == 35 + (52 << 8)) {

    }
    if (c == 107 + (114 << 8)) {

    }
    if (c == 37 + (105 << 8)) {

    }
    if (c == 107 + (117 << 8)) {

    }
    if (c == 253 + (4 << 8)) {

    }
    if (c == 107 + (80 << 8)) {

    }
    if (c == 75 + (51 << 8)) {

    }
    if (c == 107 + (100 << 8)) {

    }
    if (c == 253 + (5 << 8)) {

    }
    if (c == 107 + (78 << 8)) {

    }
    if (c == 75 + (53 << 8)) {

    }
    if (c == 75 + (54 << 8)) {

    }
    if (c == 75 + (55 << 8)) {

    }
    if (c == 75 + (56 << 8)) {

    }
    if (c == 75 + (57 << 8)) {

    }
    if (c == 253 + (53 << 8)) {

    }
    if (c == 9) {
      goto case_9;
    }
    if (c == 75 + (65 << 8)) {

    }
    if (c == 13) {
      goto case_13;
    }
    if (c == 10) {

    }
    if (c == 11) {

    }
    if (c == 29) {

    }
    if (c == 6) {

    }
    if (c == 12) {

    }
    if (c == 16) {

    }
    if (c == 14) {

    }
    if (c == 25) {

    }
    if (c == 5) {

    }
    goto switch_default;
    case_exp___13: ;/* CIL Label */ 
    case_exp___14: ;/* CIL Label */ 





    {


    }

    case_24: ;/* CIL Label */ 





    {



    }

    case_exp___15: ;/* CIL Label */ 

    case_26: ;/* CIL Label */ 



    {


    }
    case_15: ;/* CIL Label */ 
    {

    }













    {



    }

    case_exp___16: ;/* CIL Label */ 
    case_exp___17: ;/* CIL Label */ 
    case_exp___18: ;/* CIL Label */ 
    {

    }






    case_27: ;/* CIL Label */ 
    {
    tmp___14 = echeck_abbr(283);
    }
    if (tmp___14) {
      goto switch_break___0;
    }
    do_intr: ;
    case_3: ;/* CIL Label */ 
    {
    tmp___15 = goto_im();
    }
    if (tmp___15) {











    }
    doESCkey: ;
    {
    tmp___16 = ins_esc(& count___2, need_redraw, cmdchar);
    }
    if (tmp___16) {
      return (c == 15);
    }

    case_exp___19: ;/* CIL Label */ 
    case_0: ;/* CIL Label */ 
    case_1: ;/* CIL Label */ 
    {

    }









    case_18: ;/* CIL Label */ 
    {



    }

    case_4: ;/* CIL Label */ 



    case_20: ;/* CIL Label */ 
    {



    }

    case_exp___20: ;/* CIL Label */ 
    case_exp___21: ;/* CIL Label */ 
    {


    }

    case_exp___22: ;/* CIL Label */ 
    case_8: ;/* CIL Label */ 
    {
    did_backspace = ins_bs(c, 1, & inserted_space);
    need_redraw = 1;
    }
    goto switch_break___0;
    case_23: ;/* CIL Label */ 
    {


    }

    case_21: ;/* CIL Label */ 
    {



    }

    case_exp___23: ;/* CIL Label */ 
    case_exp___24: ;/* CIL Label */ 
    case_exp___25: ;/* CIL Label */ 
    case_exp___26: ;/* CIL Label */ 
    case_exp___27: ;/* CIL Label */ 
    case_exp___28: ;/* CIL Label */ 
    case_exp___29: ;/* CIL Label */ 
    case_exp___30: ;/* CIL Label */ 
    case_exp___31: ;/* CIL Label */ 
    case_exp___32: ;/* CIL Label */ 
    case_exp___33: ;/* CIL Label */ 
    {

    }

    case_exp___34: ;/* CIL Label */ 

    case_exp___35: ;/* CIL Label */ 
    {

    }

    case_exp___36: ;/* CIL Label */ 
    {

    }

    case_exp___37: ;/* CIL Label */ 
    case_exp___38: ;/* CIL Label */ 
    case_exp___39: ;/* CIL Label */ 
    case_exp___40: ;/* CIL Label */ 
    {

    }

    case_exp___41: ;/* CIL Label */ 
    case_exp___42: ;/* CIL Label */ 
    case_exp___43: ;/* CIL Label */ 
    case_exp___44: ;/* CIL Label */ 
    {

    }

    case_exp___45: ;/* CIL Label */ 










    case_exp___46: ;/* CIL Label */ 
    {

    }

    case_exp___47: ;/* CIL Label */ 










    case_exp___48: ;/* CIL Label */ 
    {

    }

    case_exp___49: ;/* CIL Label */ 
    {

    }

    case_exp___50: ;/* CIL Label */ 
    case_exp___51: ;/* CIL Label */ 
    case_exp___52: ;/* CIL Label */ 
    {

    }

    case_exp___53: ;/* CIL Label */ 
    {

    }

    case_exp___54: ;/* CIL Label */ 
    case_exp___55: ;/* CIL Label */ 
    case_exp___56: ;/* CIL Label */ 
    {

    }

    case_exp___57: ;/* CIL Label */ 


    case_exp___58: ;/* CIL Label */ 


    case_exp___59: ;/* CIL Label */ 


    case_exp___60: ;/* CIL Label */ 


    case_exp___61: ;/* CIL Label */ 

    case_9: ;/* CIL Label */ 
    if (ctrl_x_mode == 262) {

    }
    {
    inserted_space = 0;
    tmp___19 = ins_tab();
    }
    if (tmp___19) {
      goto normalchar;
    }


    case_exp___62: ;/* CIL Label */ 

    case_13: ;/* CIL Label */ 
    case_10: ;/* CIL Label */ 
    {
    tmp___20 = ins_eol(c);
    }
    if (tmp___20) {



    }
    inserted_space = 0;
    goto switch_break___0;
    case_11: ;/* CIL Label */ 














    {

    }





    case_29: ;/* CIL Label */ 




    case_6: ;/* CIL Label */ 




    case_12: ;/* CIL Label */ 












    case_16: ;/* CIL Label */ 
    case_14: ;/* CIL Label */ 







    docomplete: ;
    {

    }






    case_25: ;/* CIL Label */ 
    case_5: ;/* CIL Label */ 










































    switch_default: ;/* CIL Label */ 
    if (c == intr_char) {

    }
    normalchar: ;
    {
    ins_try_si(c);
    }
    if (c == 32) {
      {
      inserted_space = 1;
      tmp___24 = inindent(0);
      }
      if (tmp___24) {
        can_cindent = 0;
      }
      if (Insstart_blank_vcol == 2147483647U) {
        if (curwin->w_cursor.lnum == Insstart.lnum) {
          {
          Insstart_blank_vcol = get_nolist_virtcol();
          }
        }
      }
    }
    {
    tmp___25 = vim_iswordc(c);
    }
    if (tmp___25) {
      {
      insert_special(c, 0, 0);
      need_redraw = 1;
      }
    } else {
      {
      tmp___26 = echeck_abbr(c);
      }
      if (! tmp___26) {
        {
        insert_special(c, 0, 0);
        need_redraw = 1;
        }
      }
    }
    goto switch_break___0;
    switch_break___0: ;/* CIL Label */ ;
    }
    if (arrow_used) {

    }
    if (curbuf->b_p_cin) {















    }
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
}
}
static void edit_putchar(int c , int highlight ) 
{



















}
void display_dollar(colnr_t col ) 
{

























}
static void undisplay_dollar(void) 
{











}
void change_indent(int type , int amount , int round , int replaced ) 
{







































































































































































































































}
void truncate_spaces(char_u *line ) 
{






































}
void backspace_until_column(int col ) 
{






























}
int vim_is_ctrl_x_key(int c ) 
{ 


  {
  {
  if (ctrl_x_mode == 0) {
    goto case_0;
  }

























  case_0: ;/* CIL Label */ 
  if (c == 14) {

  } else { //Added block
  if (c == 16) {

  } else { //Added block
  if (c == 24) {

  }
  }
  }
  goto switch_break;
  case_1: ;/* CIL Label */ 








































  case_2: ;/* CIL Label */ 








  case_3: ;/* CIL Label */ 












  case_4: ;/* CIL Label */ 












  case_265: ;/* CIL Label */ 












  case_261: ;/* CIL Label */ 












  case_262: ;/* CIL Label */ 








  case_263: ;/* CIL Label */ 












  switch_default: ;/* CIL Label */ 
  {

  }

  switch_break: ;/* CIL Label */ ;
  }
  return (0);
}
}
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) 
{

























































































































}
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) 
{

































































































































}
static int ins_compl_make_cyclic(void) 
{



























}
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) 
{

















































































































































































}
static void ins_compl_free(void) 
{





































}
static void ins_compl_clear(void) 
{ 


  {
  continue_status = 0;
  started_completion = 0;
  complete_pat = (char_u *)((void *)0);
  save_sm = -1;
  return;
}
}
static int ins_compl_prep(int c ) 
{ 
  char_u *ptr ;
  char_u *tmp_ptr ;
  int temp ;
  linenr_t lnum ;
  int need_redraw ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  need_redraw = 0;
  if (c == 245 + (88 << 8)) {

  }
  if (ctrl_x_mode == 1) {
    {


































    case_5: ;/* CIL Label */ 
    case_25: ;/* CIL Label */ 






    {

    }

    case_12: ;/* CIL Label */ 


    case_6: ;/* CIL Label */ 


    case_11: ;/* CIL Label */ 


    case_29: ;/* CIL Label */ 


    case_9: ;/* CIL Label */ 
    case_exp: ;/* CIL Label */ 


    case_4: ;/* CIL Label */ 


    case_16: ;/* CIL Label */ 
    case_14: ;/* CIL Label */ 







    switch_default: ;/* CIL Label */ 







    {



    }

    switch_break: ;/* CIL Label */ ;
    }
  } else { //Added block
  if (ctrl_x_mode) {
    {

    }








    {

    }
  }
  }
  if (started_completion) {

  } else { //Added block
  if (ctrl_x_mode == 8) {
    _L___2: ;
    {

    }













































































































































  }
  }
  {
  tmp___1 = vim_is_ctrl_x_key(c);
  }
  if (! tmp___1) {
    continue_mode = 0;
    continue_status = continue_mode;
  }
  return (need_redraw);
}
}
static WIN *w  ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) 
{


















































}
static FPOS first_match_pos  ;
static FPOS last_match_pos  ;
static char_u *e_cpt  =    (char_u *)"";
static int found_all  =    0;
static BUF *ins_buf  =    (BUF *)((void *)0);
static int ins_compl_get_exp(FPOS *ini , int dir ) 
{






























































































































































































































































































































































































































































































































































































































































}
static void ins_compl_delete(void) 
{
















}
static void ins_compl_insert(void) 
{
























}
static int ins_compl_next(int allow_get_expansion ) 
{








































































}
static int count  =    0;
void ins_compl_check_keys(void) 
{





























































}
static int ins_complete(int c ) 
{





































































































































































































































































































































































































































































































































}
static int quote_meta(char_u *dest , char_u *src , int len___0 ) 
{











































































}
int get_literal(void) 
{ 
  int cc___0 ;
  int nc ;
  int i___0 ;
  int hexmode ;
  int octalmode ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  hexmode = 0;
  octalmode = 0;
  if (got_int) {

  }
  no_mapping ++;
  cc___0 = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      nc = safe_vgetc();
      }
      if (! (nc == 253 + (51 << 8))) {
        if (! (nc == 249 + (88 << 8))) {
          if (! (nc == 248 + (88 << 8))) {
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (! (State & 8)) {
      {

      }
    }
    if (nc == 120) {

    } else { //Added block
    if (nc == 88) {

    } else { //Added block
    if (nc == 111) {

    } else { //Added block
    if (nc == 79) {

    } else {
      if (hexmode) {
        {

        }








        {

        }






      } else { //Added block
      if (octalmode) {
        {

        }








      } else {
        {
        tmp___2 = vim_isdigit(nc);
        }
        if (! tmp___2) {
          goto while_break;
        }

      }
      }
      i___0 ++;
    }
    }
    }
    }
    if (cc___0 > 255) {

    }











  }
  while_break: ;/* CIL Label */ ;
  }
  if (i___0 == 0) {
    if (nc == 255 + (88 << 8)) {


    } else {
      cc___0 = nc;
      nc = 0;
    }
  }
  if (cc___0 == 0) {

  }
  no_mapping --;
  if (nc) {
    {

    }
  }
  got_int = 0;
  return (cc___0);
}
}
static void insert_special(int c , int allow_modmask , int ctrlv ) 
{ 
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;

  {
  if (c >= 512) {

  } else { //Added block
  if (mod_mask) {

















  }
  }
  {
  insertchar((unsigned int )c, 0, -1, ctrlv);
  }
  return;
}
}
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) 
{ 
  int haveto_redraw ;
  int textwidth ;
  colnr_t leader_len ;
  int first_line ;
  int fo_ins_blank ;
  int save_char ;
  int cc___0 ;
  char_u *p___0 ;
  int startcol ;
  int wantcol ;
  int foundcol ;
  int end_foundcol ;
  int orig_col ;
  colnr_t len___0 ;
  colnr_t virtcol ;
  char_u *saved_text ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *line ;
  char_u lead_end[50] ;
  int middle_len ;
  int end_len ;
  int i___0 ;
  int old_fo_do_comments ;
  char_u *tmp___13 ;
  char_u buf___3[101] ;
  int i___1 ;
  colnr_t virtcol___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
  haveto_redraw = 0;
  first_line = 1;
  save_char = '\000';
  stop_arrow();
  textwidth = comp_textwidth(force_formatting);
  fo_ins_blank = has_format_option('b');
  }
  if (textwidth) {
    if (force_formatting) {

    } else { //Added block
    if (! (c == 32U)) {
      if (! (c == 9U)) {
        if (State == 528) {
          {

          }



        } else { //Added block
        _L___5: ;
        if (curwin->w_cursor.lnum != Insstart.lnum) {

        } else {
          {

          }





































































































































































































































































































        }
        }
      }
    }
    }
  }
  if (c == 0U) {

  }
  if (did_ai) {










































































































  }
  end_comment_pending = '\000';
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  if (c < 32U) {
    goto _L___11;
  } else { //Added block
  if (c >= 127U) {

  } else { //Added block
  if (c == 48U) {

  } else { //Added block
  if (c == 94U) {
    _L___11: ;
    {
    ins_char((int )c);
    }
    if (ctrlv) {
      {

      }
    } else {
      {
      AppendCharToRedobuff((int )c);
      }
    }
  } else {
    {
    tmp___20 = vpeekc();
    }
    if (tmp___20 != 0) {
      if (State != 528) {
        if (State != 784) {
          if (! curbuf->b_p_cin) {
            virtcol___0 = (colnr_t )0;
            buf___3[0] = (char_u )c;
            i___1 = 1;
            if (textwidth) {
              {

              }
            }
            {
            while (1) {
              while_continue___9: ;/* CIL Label */ ;
              {
              tmp___16 = vpeekc();
              c = (unsigned int )tmp___16;
              }
              if (c != 0U) {
                if (c < 32U) {
                  goto while_break___9;
                } else { //Added block
                if (c >= 127U) {

                } else { //Added block
                if (c == 48U) {

                } else { //Added block
                if (c == 94U) {

                } else { //Added block
                if (i___1 < 100) {
                  if (textwidth == 0) {
                    goto _L___6;
                  } else {
                    {


                    }
                    if (virtcol___0 < (colnr_t )textwidth) {
                      _L___6: ;
                      if (! no_abbr) {
                        {
                        tmp___18 = vim_iswordc((int )c);
                        }
                        if (! tmp___18) {
                          {

                          }



                        }
                      }
                    } else {

                    }
                  }
                } else {

                }
                }
                }
                }
                }
              } else {

              }
              {
              tmp___14 = i___1;
              i___1 ++;
              tmp___15 = vgetc();
              buf___3[tmp___14] = (char_u )tmp___15;
              }
            }
            while_break___9: ;/* CIL Label */ ;
            }
            {
            do_digraph(-1);
            do_digraph((int )buf___3[i___1 - 1]);
            buf___3[i___1] = (char_u )'\000';
            ins_str(buf___3);
            }
            if (ctrlv) {
              {


              }
            } else {
              i___1 = 0;
            }
            if ((int )buf___3[i___1] != 0) {
              {
              AppendToRedobuff(buf___3 + i___1);
              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  }
  }
  }
  }
  return;
}
}
int comp_textwidth(int ff ) 
{ 
  int textwidth ;

  {
  textwidth = (int )curbuf->b_p_tw;
  if (textwidth == 0) {
    if (curbuf->b_p_wm) {

    }
  }
  if (textwidth < 0) {

  }
  if (ff) {






  }
  return (textwidth);
}
}
static void redo_literal(int c ) 
{




















}
static void start_arrow(FPOS *end_insert_pos ) 
{












}
void stop_arrow(void) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  if (arrow_used) {
    {






    }





    {



    }
  }
  return;
}
}
static void stop_insert(FPOS *end_insert_pos ) 
{ 
  int cc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  stop_redo_ins();
  replace_flush();
  vim_free((void *)last_insert);
  last_insert = get_inserted();
  last_insert_skip = new_insert_skip;
  }
  if (did_ai) {






























































  }
  did_ai = 0;
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  curbuf->b_op_start = Insstart;
  curbuf->b_op_end = *end_insert_pos;
  return;
}
}
void set_last_insert(int c ) 
{ 
  unsigned short const   **tmp___0 ;

  {
  {
  vim_free((void *)last_insert);
  last_insert = alloc(4U);
  }
  if ((unsigned long )last_insert != (unsigned long )((void *)0)) {
    {
    *(last_insert + 0) = (char_u )22;
    *(last_insert + 1) = (char_u )c;
    *(last_insert + 2) = (char_u )'\033';
    *(last_insert + 3) = (char_u )'\000';
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + c) & 2048) {

    } else {
      last_insert_skip = 0;
    }
  }
  return;
}
}
void beginline(int flags___0 ) 
{ 
  char_u *ptr ;

  {
  if (flags___0 & 2) {
    if (! p_sol) {
      {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
    curwin->w_cursor.col = (colnr_t )0;
    if (flags___0 & 3) {
      {
      ptr = ml_get_curline();
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if ((int )*ptr == 32) {
          goto _L;
        } else { //Added block
        if ((int )*ptr == 9) {
          _L: ;
          if (flags___0 & 4) {
            if ((int )*(ptr + 1) == 0) {

            }
          }
        } else {
          goto while_break;
        }
        }
        (curwin->w_cursor.col) ++;
        ptr ++;
      }
      while_break: ;/* CIL Label */ ;
      }
    }
    curwin->w_set_curswant = 1;
  }
  return;
}
}
int oneright(void) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  ptr = ml_get_cursor();
  tmp = ptr;
  ptr ++;
  }
  if ((int )*tmp == 0) {
    return (0);
  } else { //Added block
  if ((int )*ptr == 0) {
    return (0);
  }
  }
  curwin->w_set_curswant = 1;
  (curwin->w_cursor.col) ++;
  return (1);
}
}
int oneleft(void) 
{ 


  {
  if (curwin->w_cursor.col == 0U) {
    return (0);
  }
  curwin->w_set_curswant = 1;
  (curwin->w_cursor.col) --;
  return (1);
}
}
int cursor_up(long n , int upd_topline ) 
{ 


  {
  if (n != 0L) {
    if (curwin->w_cursor.lnum <= 1L) {
      return (0);
    }
    if (n >= curwin->w_cursor.lnum) {

    } else {
      curwin->w_cursor.lnum -= n;
    }
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (upd_topline) {
    {
    update_topline();
    }
  }
  return (1);
}
}
int cursor_down(long n , int upd_topline ) 
{ 


  {
  if (n != 0L) {
    if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count) {
      return (0);
    }
    curwin->w_cursor.lnum += n;
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    }
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (upd_topline) {
    {
    update_topline();
    }
  }
  return (1);
}
}
int stuff_inserted(int c , long count___2 , int no_esc ) 
{

































































































}
char_u *get_last_insert(void) 
{ 


  {
  if ((unsigned long )last_insert == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }

}
}
char_u *get_last_insert_save(void) 
{
























}
static int echeck_abbr(int c ) 
{ 
  colnr_t tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  if (p_paste) {

  } else { //Added block
  if (no_abbr) {
    return (0);
  } else { //Added block
  if (arrow_used) {

  }
  }
  }
  if (curwin->w_cursor.lnum == Insstart.lnum) {
    tmp = Insstart.col;
  } else {

  }
  {
  tmp___0 = ml_get_curline();
  tmp___1 = check_abbr(c, tmp___0, (int )curwin->w_cursor.col, (int )tmp);
  }
  return (tmp___1);
}
}
char_u *replace_stack  =    (char_u *)((void *)0);
long replace_stack_nr  =    0L;
long replace_stack_len  =    0L;
void replace_push(int c ) 
{

































}
static void replace_push_off(int c ) 
{

























}
static int replace_pop(void) 
{










}
static void replace_join(int off___0 ) 
{





























}
static void replace_pop_ins(void) 
{

























}
static void replace_flush(void) 
{ 


  {
  {
  vim_free((void *)replace_stack);
  replace_stack = (char_u *)((void *)0);
  replace_stack_len = 0L;
  replace_stack_nr = 0L;
  }
  return;
}
}
static void replace_do_bs(void) 
{




















}
int get_replace_stack_virtcol(void) 
{


































































}
void fixthisline(int (*get_the_indent)(void) ) 
{














}
int in_cinkeys(int keytyped , int when , int line_is_empty ) 
{














































































































































































































































}
static int ins_reg(void) 
{








































































































}
static int disabled_redraw  =    0;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) 
{ 
  int temp ;
  int tmp ;

  {
  temp = (int )curwin->w_cursor.col;
  if (disabled_redraw) {


  }
  if (! arrow_used) {
    if (cmdchar != 114) {
      if (cmdchar != 118) {
        {
        AppendToRedobuff((char_u *)"\033");
        }
      }
    }
    if (*count___2) {
      {
      line_breakcheck();
      }
      if (got_int) {

      }
    }
    (*count___2) --;
    if (*count___2 > 0L) {
      {



      }

    }
    {
    stop_insert(& curwin->w_cursor);
    }
    if (dollar_vcol) {








    }
  }
  if (need_redraw) {
    {

    }
  }
  if (! restart_edit) {
    if ((colnr_t )temp == curwin->w_cursor.col) {
      curwin->w_set_curswant = 1;
    }
  }
  if (curwin->w_cursor.col != 0U) {
    if (! restart_edit) {
      (curwin->w_cursor.col) --;
    } else {
      {

      }





    }
  }
  {
  changed_cline_bef_curs();
  State = 1;
  setmouse();
  }
  if (Recording) {
    {

    }
  } else { //Added block
  if (restart_edit) {
    {

    }
  } else { //Added block
  if (p_smd) {
    {

    }
  }
  }
  }
  return (1);
}
}
static void ins_shift(int c , int lastc___1 ) 
{


























































}
static void ins_del(void) 
{
































































}
static int ins_bs(int c , int mode , int *inserted_space_p ) 
{ 
  linenr_t lnum ;
  int cc___0 ;
  int temp ;
  colnr_t mincol ;
  int did_backspace ;
  int in_indent ;
  int oldState ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ts ;
  colnr_t vcol ;
  int want_vcol ;
  int extra ;
  char_u *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  char_u *tmp___13 ;

  {
  temp = 0;
  did_backspace = 0;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {

    }








  } else { //Added block
  _L___4: ;
  if (curwin->w_cursor.lnum == 1L) {
    if (curwin->w_cursor.col <= 0U) {
      {

      }

    } else {
      goto _L___3;
    }
  } else {
    _L___3: ;
    {
    tmp___0 = can_bs('s');
    }
    if (tmp___0) {
      _L___2: ;
      {
      tmp___1 = can_bs('i');
      }
      if (tmp___1) {
        _L___1: ;
        {
        tmp___2 = can_bs('o');
        }
        if (! tmp___2) {
          if (curwin->w_cursor.col == 0U) {
            {

            }

          }
        }
      } else { //Added block
      if (! arrow_used) {
        if (ai_col > 0U) {








        } else {
          goto _L___1;
        }
      } else {

      }
      }
    } else { //Added block
    if (arrow_used) {
      {

      }

    } else { //Added block
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      if (curwin->w_cursor.col <= Insstart.col) {
        {

        }

      } else {
        goto _L___2;
      }
    } else {

    }
    }
    }
  }
  }
  {
  stop_arrow();
  in_indent = inindent(0);
  }
  if (in_indent) {

  }
  end_comment_pending = '\000';
  if (curwin->w_cursor.col <= 0U) {





























































































  } else {
    mincol = (colnr_t )0;
    if (mode == 4) {










    }
    if (mode == 1) {
      if (p_sta) {





      } else { //Added block
      _L___15: ;
      if (curbuf->b_p_sts) {
        {

        }
        if ((int )*(tmp___12 - 1) == 9) {

        } else {
          {

          }






















































































































        }
      } else {
        goto _L___11;
      }
      }
    } else {
      _L___11: ;
      {
      while (1) {
        while_continue___2: ;/* CIL Label */ ;
        {
        dec_cursor();
        }
        if (mode == 2) {
          {


          }









        } else { //Added block
        _L___10: ;
        if (mode == 3) {
          {


          }
          if (tmp___8) {
            {

            }

          } else {
            {

            }






          }
        }
        }
        if (State == 528) {
          {

          }
        } else { //Added block
        if (State == 784) {
          {

          }
        } else {
          {
          del_char(0);
          }
        }
        }
        if (mode == 1) {
          goto while_break___2;
        }









      }
      while_break___2: ;/* CIL Label */ ;
      }
    }
    did_backspace = 1;
  }
  did_si = 0;
  can_si = 0;
  can_si_back = 0;
  if (curwin->w_cursor.col <= 1U) {
    did_ai = 0;
  }
  {
  AppendCharToRedobuff(c);
  }
  if (curwin->w_cursor.lnum == Insstart.lnum) {
    if (curwin->w_cursor.col < Insstart.col) {

    }
  }
  return (did_backspace);
}
}
static void ins_mouse(int c ) 
{



























}
static void ins_mousescroll(int up ) 
{































}
static void ins_left(void) 
{







































}
static void ins_home(void) 
{

















}
static void ins_end(void) 
{

















}
static void ins_s_left(void) 
{



























}
static void ins_right(void) 
{







































}
static void ins_s_right(void) 
{






























}
static void ins_up(void) 
{




























}
static void ins_pageup(void) 
{





















}
static void ins_down(void) 
{




























}
static void ins_pagedown(void) 
{





















}
static int ins_tab(void) 
{ 
  int ind ;
  int i___0 ;
  int temp ;
  int tmp ;
  colnr_t tmp___0 ;
  char_u *ptr ;
  char_u *saved_line ;
  FPOS fpos ;
  FPOS pos___0 ;
  FPOS *cursor ;
  colnr_t want_vcol ;
  colnr_t vcol ;
  colnr_t tab_vcol ;
  int change_col ;
  int ts ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  if (Insstart_blank_vcol == 2147483647U) {
    if (curwin->w_cursor.lnum == Insstart.lnum) {
      {
      Insstart_blank_vcol = get_nolist_virtcol();
      }
    }
  }
  {
  tmp = echeck_abbr(265);
  }
  if (tmp) {

  }
  {
  ind = inindent(0);
  }
  if (ind) {
    can_cindent = 0;
  }
  if (! curbuf->b_p_et) {
    if (p_sta) {







    } else { //Added block
    _L___0: ;
    if (! curbuf->b_p_sts) {
      return (1);
    }
    }
  }
  {






  }














  {



  }
  {





















  while_break: ;/* CIL Label */ ;
  }

















































































































































}
}
static int ins_eol(int c ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = echeck_abbr(c + 256);
  }
  if (tmp) {

  }
  {
  stop_arrow();
  }
  if (State == 528) {
    {

    }
  }
  {
  AppendToRedobuff((char_u *)"\n");
  tmp___0 = has_format_option('r');
  }
  if (tmp___0) {

  }
  {
  i___0 = open_line(1, 1, 0, old_indent);
  old_indent = 0;
  fo_do_comments = 0;
  can_cindent = 1;
  }
  return (! i___0);
}
}
static int ins_digraph(void) 
{
























































































}
static int ins_copychar(linenr_t lnum ) 
{























































}
static void ins_try_si(int c ) 
{ 
  FPOS *pos___0 ;
  FPOS old_pos ;
  char_u *ptr ;
  int i___0 ;
  int temp ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (did_si) {

  } else { //Added block
  if (can_si_back) {
    _L___2: ;





  } else { //Added block
  _L___1: ;
  if (can_si) {








































































































  }
  }
  }
  if (curwin->w_cursor.col > 0U) {
    if (can_si) {






    }
  }
  if (ai_col > curwin->w_cursor.col) {

  }
  return;
}
}
static colnr_t get_nolist_virtcol(void) 
{ 
  colnr_t virtcol ;
  char_u *tmp ;

  {
  if (curwin->w_p_list) {
    {

    }








  }
  {
  validate_virtcol();
  }
  return (curwin->w_virtcol);
}
}
#pragma merger("0","/tmp/cil-7getv7z7.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
char_u *term_strings[51]  ;
long Rows ;
int expand_context ;
char_u *expand_pattern ;
int msg_didout ;
int emsg_off ;
int did_emsg  ;
int need_wait_return ;
int didset_vim ;
int didset_vimruntime ;
int lines_left ;
int did_filetype ;
int starting ;
int KeyTyped  ;
char_u e_invarg2[21] ;
char_u e_invexpr2[23] ;
char_u e_letunexp[33] ;
char_u e_readonlyvar[35] ;
long p_mfd  ;
long p_verbose  ;
void mch_get_host_name(char_u *s , int len___0 ) ;
int mch_isFullName(char_u *fname ) ;
int mch_isdir(char_u *name___1 ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) ;
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) ;
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) ;
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) ;
void do_let(EXARG *eap ) ;
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) ;
void do_call(EXARG *eap ) ;
void do_unlet(char_u *arg , int forceit ) ;
char_u *get_user_var_name(int idx ) ;
char_u *get_function_name(int idx ) ;
char_u *get_expr_name(int idx ) ;
void set_vim_var_nr(int idx , long val ) ;
void set_vim_var_string(int idx , char_u *val ) ;
void do_echo(EXARG *eap , int echo ) ;
void do_echohl(char_u *arg ) ;
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
char_u *get_user_func_name(int idx ) ;
void do_delfunction(char_u *arg ) ;
void *save_funccal(void) ;
void restore_funccal(void *fc ) ;
void do_return(EXARG *eap ) ;
char_u *get_func_line(int c , void *cookie , int indent ) ;
int func_has_ended(void *cookie ) ;
int func_has_abort(void *cookie ) ;
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_varlist(FILE *fp___0 ) ;
int store_session_globals(FILE *fd ) ;
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) ;
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) ;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) ;
int ends_excmd(int c ) ;
char_u *check_nextcmd(char_u *p___0 ) ;
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) ;
int put_eol(FILE *fd ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) ;
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) ;
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) ;
int get_histtype(char_u *name___1 ) ;
void add_to_history(int histype , char_u *new_entry , int in_map ) ;
int get_history_idx(int histype ) ;
char_u *get_history_entry(int histype , int idx ) ;
int clr_history(int histype ) ;
int del_history_entry(int histype , char_u *str___1 ) ;
int del_history_idx(int histype , int idx ) ;
int vim_rename(char_u *from , char_u *to ) ;
char_u *vim_tempname(int extra_char ) ;
void saveRedobuff(void) ;
void restoreRedobuff(void) ;
int get_map_mode(char_u **cmdp , int forceit ) ;
char_u *check_map(char_u *keys___0 , int mode , int exact ) ;
FPOS *getmark(int c , int changefile ) ;
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) ;
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) ;
void msg_start(void) ;
void msg_starthere(void) ;
void msg_putchar_attr(int c , int attr ) ;
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) ;
char_u *str2special(char_u **sp , int from ) ;
void msg_prt_line(char_u *s ) ;
void msg_puts_attr(char_u *s , int attr ) ;
void msg_clr_eos(void) ;
int msg_end(void) ;
void msg_advance(int col ) ;
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) ;
void init_homedir(void) ;
char_u *expand_env_save(char_u *src ) ;
void vim_setenv(char_u *name___1 , char_u *val ) ;
char_u *get_past_head(char_u *path ) ;
int vim_ispathsep(int c ) ;
char_u *get_cmd_output(char_u *cmd , int flags___0 ) ;
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) ;
void ga_clear(struct growarray *gap ) ;
void ga_clear_strings(struct growarray *gap ) ;
void ga_init(struct growarray *gap ) ;
void ga_init2(struct growarray *gap , int itemsize , int growsize ) ;
int ga_grow(struct growarray *gap , int n ) ;
void ga_concat(struct growarray *gap , char_u *s ) ;
void ga_append(struct growarray *gap , int c ) ;
int trans_special(char_u **srcp , char_u *dst , int keycode ) ;
char_u *get_reg_contents(int regname___0 ) ;
void write_reg_contents(int name___1 , char_u *str___1 ) ;
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) ;
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) ;
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) ;
void redraw_curbuf_later(int type ) ;
void update_curbuf(int type ) ;
void changed_line_abv_curs(void) ;
void approximate_botline(void) ;
void save_search_patterns(void) ;
void restore_search_patterns(void) ;
int syn_get_id(long line , long col , int trans___0 ) ;
char_u *highlight_has_attr(int id , int flag , int modec ) ;
char_u *highlight_color(int id , char_u *what , int modec ) ;
int syn_name2id(char_u *name___1 ) ;
int highlight_exists(char_u *name___1 ) ;
int syn_id2attr(int hl_id ) ;
int syn_get_final_id(int hl_id ) ;
char_u *get_highlight_name(int idx ) ;
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) ;
int u_savesub(linenr_t lnum ) ;
struct growarray variables  =    {0, 0, (int )sizeof(var ), 4, (void *)0};
static int echo_attr  =    0;
struct ufunc *firstfunc  =    (struct ufunc *)((void *)0);
struct funccall *current_funccal  =    (struct funccall *)((void *)0);
struct vimvar vimvars[8]  = 
  {      {(char *)"count", (int )(sizeof("count") - 1UL), (char_u *)((void *)0), (char)1,
      (char)3}, 
        {(char *)"count1", (int )(sizeof("count1") - 1UL), (char_u *)((void *)0), (char)1,
      (char)2}, 
        {(char *)"errmsg", (int )(sizeof("errmsg") - 1UL), (char_u *)((void *)0), (char)2,
      (char)1}, 
        {(char *)"warningmsg", (int )(sizeof("warningmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"statusmsg", (int )(sizeof("statusmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"shell_error", (int )(sizeof("shell_error") - 1UL), (char_u *)((void *)0),
      (char)1, (char)3}, 
        {(char *)"this_session", (int )(sizeof("this_session") - 1UL), (char_u *)((void *)0),
      (char)2, (char)1}, 
        {(char *)"version", (int )(sizeof("version") - 1UL), (char_u *)508, (char)1,
      (char)3}};
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) ;
static int eval1(char_u **arg , VAR retvar , int evaluate ) ;
static int eval2(char_u **arg , VAR retvar , int evaluate ) ;
static int eval3(char_u **arg , VAR retvar , int evaluate ) ;
static int eval4(char_u **arg , VAR retvar , int evaluate ) ;
static int eval5(char_u **arg , VAR retvar , int evaluate ) ;
static int eval6(char_u **arg , VAR retvar , int evaluate ) ;
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) ;
static int find_internal_func(char_u *name___1 ) ;
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) ;
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) ;
static void f_append(VAR argvars , VAR retvar ) ;
static void f_argc(VAR argvars , VAR retvar ) ;
static void f_argv(VAR argvars , VAR retvar ) ;
static void f_browse(VAR argvars , VAR retvar ) ;
static BUF *find_buffer(VAR avar ) ;
static void f_bufexists(VAR argvars , VAR retvar ) ;
static void f_bufloaded(VAR argvars , VAR retvar ) ;
static BUF *get_buf_var(VAR avar ) ;
static void f_bufname(VAR argvars , VAR retvar ) ;
static void f_bufnr(VAR argvars , VAR retvar ) ;
static void f_bufwinnr(VAR argvars , VAR retvar ) ;
static void f_byte2line(VAR argvars , VAR retvar ) ;
static void f_char2nr(VAR argvars , VAR retvar ) ;
static void f_col(VAR argvars , VAR retvar ) ;
static void f_confirm(VAR argvars , VAR retvar ) ;
static void f_delete(VAR argvars , VAR retvar ) ;
static void f_did_filetype(VAR argvars , VAR retvar ) ;
static void f_escape(VAR argvars , VAR retvar ) ;
static void f_exists(VAR argvars , VAR retvar ) ;
static void f_expand(VAR argvars , VAR retvar ) ;
static void f_filereadable(VAR argvars , VAR retvar ) ;
static void f_fnamemodify(VAR argvars , VAR retvar ) ;
static void f_getcwd(VAR argvars , VAR retvar ) ;
static void f_getftime(VAR argvars , VAR retvar ) ;
static void f_getline(VAR argvars , VAR retvar ) ;
static void f_getwinposx(VAR argvars , VAR retvar ) ;
static void f_getwinposy(VAR argvars , VAR retvar ) ;
static void f_glob(VAR argvars , VAR retvar ) ;
static void f_has(VAR argvars , VAR retvar ) ;
static void f_histadd(VAR argvars , VAR retvar ) ;
static void f_histdel(VAR argvars , VAR retvar ) ;
static void f_histget(VAR argvars , VAR retvar ) ;
static void f_histnr(VAR argvars , VAR retvar ) ;
static void f_hlexists(VAR argvars , VAR retvar ) ;
static void f_hlID(VAR argvars , VAR retvar ) ;
static void f_hostname(VAR argvars , VAR retvar ) ;
static void f_isdirectory(VAR argvars , VAR retvar ) ;
static void f_input(VAR argvars , VAR retvar ) ;
static void f_last_buffer_nr(VAR argvars , VAR retvar ) ;
static void f_libcall(VAR argvars , VAR retvar ) ;
static void f_line(VAR argvars , VAR retvar ) ;
static void f_line2byte(VAR argvars , VAR retvar ) ;
static void f_localtime(VAR argvars , VAR retvar ) ;
static void f_maparg(VAR argvars , VAR retvar ) ;
static void f_mapcheck(VAR argvars , VAR retvar ) ;
static void get_maparg(VAR argvars , VAR retvar , int exact ) ;
static void f_match(VAR argvars , VAR retvar ) ;
static void f_matchend(VAR argvars , VAR retvar ) ;
static void f_matchstr(VAR argvars , VAR retvar ) ;
static void f_nr2char(VAR argvars , VAR retvar ) ;
static void f_rename(VAR argvars , VAR retvar ) ;
static void f_setline(VAR argvars , VAR retvar ) ;
static void f_some_match(VAR argvars , VAR retvar , int type ) ;
static void f_strftime(VAR argvars , VAR retvar ) ;
static void f_strlen(VAR argvars , VAR retvar ) ;
static void f_strpart(VAR argvars , VAR retvar ) ;
static void f_strtrans(VAR argvars , VAR retvar ) ;
static void f_synID(VAR argvars , VAR retvar ) ;
static void f_synIDattr(VAR argvars , VAR retvar ) ;
static void f_synIDtrans(VAR argvars , VAR retvar ) ;
static void f_system(VAR argvars , VAR retvar ) ;
static void f_substitute(VAR argvars , VAR retvar ) ;
static void f_tempname(VAR argvars , VAR retvar ) ;
static void f_virtcol(VAR argvars , VAR retvar ) ;
static void f_visualmode(VAR argvars , VAR retvar ) ;
static void f_winbufnr(VAR argvars , VAR retvar ) ;
static void f_winheight(VAR argvars , VAR retvar ) ;
static void f_winnr(VAR argvars , VAR retvar ) ;
static WIN *find_win_by_nr(VAR vp ) ;
static FPOS *var2fpos(VAR varp ) ;
static int get_env_len(char_u **arg ) ;
static int get_id_len(char_u **arg ) ;
static int eval_isnamec(int c ) ;
static int find_vim_var(char_u *name___1 , int len___0 ) ;
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) ;
static VAR alloc_var(void) ;
static VAR alloc_string_var(char_u *s ) ;
static void free_var(VAR varp ) ;
static void clear_var(VAR varp ) ;
static long get_var_number(VAR varp ) ;
static char_u *get_var_string(VAR varp ) ;
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) ;
static VAR find_var(char_u *name___1 , int writing ) ;
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) ;
static void var_free_one(VAR v ) ;
static void list_one_var(VAR v , char_u *prefix ) ;
static void list_vim_var(int i___0 ) ;
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) ;
static void set_var(char_u *name___1 , VAR varp ) ;
static char_u *find_option_end(char_u *p___0 ) ;
static void list_func_head(struct ufunc *fp___0 ) ;
static struct ufunc *find_func(char_u *name___1 ) ;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) 
{




















}
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) 
{






























}
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) 
{




















}
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) 
{













}
void do_let(EXARG *eap ) 
{
































































































































































































































































































































































































}
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) 
{

















































































































































}
void do_call(EXARG *eap ) 
{




















































































}
void do_unlet(char_u *arg , int forceit ) 
{







































}
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) ;
static char_u *varnamebuf  =    (char_u *)((void *)0);
static int varnamebuflen  =    0;
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) 
{



























}
static int gidx  ;
static int bidx  ;
static int widx  ;
static int vidx  ;
char_u *get_user_var_name(int idx ) 
{




































































































}
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) 
{



































}
static int eval1(char_u **arg , VAR retvar , int evaluate ) 
{


















































































}
static int eval2(char_u **arg , VAR retvar , int evaluate ) 
{


















































































}
static int eval3(char_u **arg , VAR retvar , int evaluate ) 
{























































































































































































































































































}
static int eval4(char_u **arg , VAR retvar , int evaluate ) 
{






















































































}
static int eval5(char_u **arg , VAR retvar , int evaluate ) 
{





































































}
static int eval6(char_u **arg , VAR retvar , int evaluate ) 
{

































































































































































































































































}
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) 
{






























































}
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) 
{












































































































































































































































}
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) 
{


























}
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) 
{


















































}
static struct fst functions[70]  = 
  {      {(char *)"append", (char)2, (char)2, & f_append}, 
        {(char *)"argc", (char)0, (char)0, & f_argc}, 
        {(char *)"argv", (char)1, (char)1, & f_argv}, 
        {(char *)"browse", (char)4, (char)4, & f_browse}, 
        {(char *)"bufexists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_exists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_name", (char)1, (char)1, & f_bufname}, 
        {(char *)"buffer_number", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufloaded", (char)1, (char)1, & f_bufloaded}, 
        {(char *)"bufname", (char)1, (char)1, & f_bufname}, 
        {(char *)"bufnr", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufwinnr", (char)1, (char)1, & f_bufwinnr}, 
        {(char *)"byte2line", (char)1, (char)1, & f_byte2line}, 
        {(char *)"char2nr", (char)1, (char)1, & f_char2nr}, 
        {(char *)"col", (char)1, (char)1, & f_col}, 
        {(char *)"confirm", (char)2, (char)4, & f_confirm}, 
        {(char *)"delete", (char)1, (char)1, & f_delete}, 
        {(char *)"did_filetype", (char)0, (char)0, & f_did_filetype}, 
        {(char *)"escape", (char)2, (char)2, & f_escape}, 
        {(char *)"exists", (char)1, (char)1, & f_exists}, 
        {(char *)"expand", (char)1, (char)2, & f_expand}, 
        {(char *)"file_readable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"filereadable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"fnamemodify", (char)2, (char)2, & f_fnamemodify}, 
        {(char *)"getcwd", (char)0, (char)0, & f_getcwd}, 
        {(char *)"getftime", (char)1, (char)1, & f_getftime}, 
        {(char *)"getline", (char)1, (char)1, & f_getline}, 
        {(char *)"getwinposx", (char)0, (char)0, & f_getwinposx}, 
        {(char *)"getwinposy", (char)0, (char)0, & f_getwinposy}, 
        {(char *)"glob", (char)1, (char)1, & f_glob}, 
        {(char *)"has", (char)1, (char)1, & f_has}, 
        {(char *)"highlightID", (char)1, (char)1, & f_hlID}, 
        {(char *)"highlight_exists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"histadd", (char)2, (char)2, & f_histadd}, 
        {(char *)"histdel", (char)1, (char)2, & f_histdel}, 
        {(char *)"histget", (char)1, (char)2, & f_histget}, 
        {(char *)"histnr", (char)1, (char)1, & f_histnr}, 
        {(char *)"hlID", (char)1, (char)1, & f_hlID}, 
        {(char *)"hlexists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"hostname", (char)0, (char)0, & f_hostname}, 
        {(char *)"input", (char)1, (char)1, & f_input}, 
        {(char *)"isdirectory", (char)1, (char)1, & f_isdirectory}, 
        {(char *)"last_buffer_nr", (char)0, (char)0, & f_last_buffer_nr}, 
        {(char *)"libcall", (char)3, (char)3, & f_libcall}, 
        {(char *)"line", (char)1, (char)1, & f_line}, 
        {(char *)"line2byte", (char)1, (char)1, & f_line2byte}, 
        {(char *)"localtime", (char)0, (char)0, & f_localtime}, 
        {(char *)"maparg", (char)1, (char)2, & f_maparg}, 
        {(char *)"mapcheck", (char)1, (char)2, & f_mapcheck}, 
        {(char *)"match", (char)2, (char)2, & f_match}, 
        {(char *)"matchend", (char)2, (char)2, & f_matchend}, 
        {(char *)"matchstr", (char)2, (char)2, & f_matchstr}, 
        {(char *)"nr2char", (char)1, (char)1, & f_nr2char}, 
        {(char *)"rename", (char)2, (char)2, & f_rename}, 
        {(char *)"setline", (char)2, (char)2, & f_setline}, 
        {(char *)"strftime", (char)1, (char)2, & f_strftime}, 
        {(char *)"strlen", (char)1, (char)1, & f_strlen}, 
        {(char *)"strpart", (char)3, (char)3, & f_strpart}, 
        {(char *)"strtrans", (char)1, (char)1, & f_strtrans}, 
        {(char *)"substitute", (char)4, (char)4, & f_substitute}, 
        {(char *)"synID", (char)3, (char)3, & f_synID}, 
        {(char *)"synIDattr", (char)2, (char)3, & f_synIDattr}, 
        {(char *)"synIDtrans", (char)1, (char)1, & f_synIDtrans}, 
        {(char *)"system", (char)1, (char)1, & f_system}, 
        {(char *)"tempname", (char)0, (char)0, & f_tempname}, 
        {(char *)"virtcol", (char)1, (char)1, & f_virtcol}, 
        {(char *)"visualmode", (char)0, (char)0, & f_visualmode}, 
        {(char *)"winbufnr", (char)1, (char)1, & f_winbufnr}, 
        {(char *)"winheight", (char)1, (char)1, & f_winheight}, 
        {(char *)"winnr", (char)0, (char)0, & f_winnr}};
static int intidx  =    -1;
char_u *get_function_name(int idx ) 
{








































}
static int intidx___0  =    -1;
char_u *get_expr_name(int idx ) 
{





















}
static int find_internal_func(char_u *name___1 ) 
{
































}
static char *errors[4]  = {      (char *)"Invalid arguments for function %s",      (char *)"Unknown function: %s",      (char *)"Too many arguments for function: %s",      (char *)"Not enough arguments for function: %s"};
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) 
{


















































































































































}
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) 
{















}
static void f_append(VAR argvars , VAR retvar ) 
{





































}
static void f_argc(VAR argvars , VAR retvar ) 
{






}
static void f_argv(VAR argvars , VAR retvar ) 
{






















}
static void f_browse(VAR argvars , VAR retvar ) 
{







}
static BUF *find_buffer(VAR avar ) 
{
























}
static void f_bufexists(VAR argvars , VAR retvar ) 
{









}
static void f_bufloaded(VAR argvars , VAR retvar ) 
{



















}
static BUF *get_buf_var(VAR avar ) 
{









































}
static void f_bufname(VAR argvars , VAR retvar ) 
{






















}
static void f_bufnr(VAR argvars , VAR retvar ) 
{















}
static void f_bufwinnr(VAR argvars , VAR retvar ) 
{

































}
static void f_byte2line(VAR argvars , VAR retvar ) 
{




















}
static void f_char2nr(VAR argvars , VAR retvar ) 
{









}
static void f_col(VAR argvars , VAR retvar ) 
{
















}
static void f_confirm(VAR argvars , VAR retvar ) 
{







































































}
static void f_libcall(VAR argvars , VAR retvar ) 
{







}
static void f_delete(VAR argvars , VAR retvar ) 
{









}
static void f_did_filetype(VAR argvars , VAR retvar ) 
{






}
static void f_escape(VAR argvars , VAR retvar ) 
{













}
static void f_exists(VAR argvars , VAR retvar ) 
{

















































































}
static void f_expand(VAR argvars , VAR retvar ) 
{





















































}
static void f_filereadable(VAR argvars , VAR retvar ) 
{


































}
static void f_fnamemodify(VAR argvars , VAR retvar ) 
{































}
static void f_getcwd(VAR argvars , VAR retvar ) 
{

















}
static void f_getftime(VAR argvars , VAR retvar ) 
{
















}
static void f_getline(VAR argvars , VAR retvar ) 
{
























}
static void f_getwinposx(VAR argvars , VAR retvar ) 
{






}
static void f_getwinposy(VAR argvars , VAR retvar ) 
{






}
static void f_glob(VAR argvars , VAR retvar ) 
{











}
static char *has_list[49]  = 
  {      (char *)"unix",      (char *)"fname_case",      (char *)"autocmd",      (char *)"builtin_terms", 
        (char *)"byte_offset",      (char *)"cindent",      (char *)"clipboard",      (char *)"cmdline_compl", 
        (char *)"comments",      (char *)"cryptv",      (char *)"dialog_con",      (char *)"digraphs", 
        (char *)"eval",      (char *)"ex_extra",      (char *)"extra_search",      (char *)"file_in_path", 
        (char *)"find_in_path",      (char *)"fork",      (char *)"insert_expand",      (char *)"linebreak", 
        (char *)"lispindent",      (char *)"menu",      (char *)"mksession",      (char *)"modify_fname", 
        (char *)"mouse",      (char *)"mouse_xterm",      (char *)"quickfix",      (char *)"scrollbind", 
        (char *)"showcmd",      (char *)"cmdline_info",      (char *)"smartindent",      (char *)"statusline", 
        (char *)"syntax",      (char *)"tag_binary",      (char *)"tag_old_static",      (char *)"terminfo", 
        (char *)"textobjects",      (char *)"tgetent",      (char *)"title",      (char *)"user-commands", 
        (char *)"user_commands",      (char *)"viminfo",      (char *)"visualextra",      (char *)"wildignore", 
        (char *)"wildmenu",      (char *)"writebackup",      (char *)"xterm_clipboard",      (char *)"X11", 
        (char *)((void *)0)};
static void f_has(VAR argvars , VAR retvar ) 
{


















































}
static void f_histadd(VAR argvars , VAR retvar ) 
{
























}
static void f_histdel(VAR argvars , VAR retvar ) 
{





































}
static void f_histget(VAR argvars , VAR retvar ) 
{




























}
static void f_histnr(VAR argvars , VAR retvar ) 
{






















}
static void f_hlexists(VAR argvars , VAR retvar ) 
{









}
static void f_hlID(VAR argvars , VAR retvar ) 
{









}
static void f_hostname(VAR argvars , VAR retvar ) 
{










}
static void f_input(VAR argvars , VAR retvar ) 
{








































}
static void f_isdirectory(VAR argvars , VAR retvar ) 
{









}
static void f_last_buffer_nr(VAR argvars , VAR retvar ) 
{






















}
static void f_line(VAR argvars , VAR retvar ) 
{






















}
static void f_line2byte(VAR argvars , VAR retvar ) 
{
























}
static void f_localtime(VAR argvars , VAR retvar ) 
{









}
static void f_maparg(VAR argvars , VAR retvar ) 
{








}
static void f_mapcheck(VAR argvars , VAR retvar ) 
{








}
static void get_maparg(VAR argvars , VAR retvar , int exact ) 
{


























































}
static void f_match(VAR argvars , VAR retvar ) 
{








}
static void f_matchend(VAR argvars , VAR retvar ) 
{








}
static void f_matchstr(VAR argvars , VAR retvar ) 
{








}
static void f_some_match(VAR argvars , VAR retvar , int type ) 
{
















































}
static void f_nr2char(VAR argvars , VAR retvar ) 
{












}
static void f_rename(VAR argvars , VAR retvar ) 
{












}
static void f_setline(VAR argvars , VAR retvar ) 
{




































}
static void f_strftime(VAR argvars , VAR retvar ) 
{





























}
static void f_strlen(VAR argvars , VAR retvar ) 
{











}
static void f_strpart(VAR argvars , VAR retvar ) 
{







































}
static void f_strtrans(VAR argvars , VAR retvar ) 
{










}
static void f_synID(VAR argvars , VAR retvar ) 
{




































}
static void f_synIDattr(VAR argvars , VAR retvar ) 
{





























































































































}
static void f_synIDtrans(VAR argvars , VAR retvar ) 
{


















}
static void f_system(VAR argvars , VAR retvar ) 
{












}
static void f_substitute(VAR argvars , VAR retvar ) 
{



















}
static int x  =    'A';
static void f_tempname(VAR argvars , VAR retvar ) 
{














}
static void f_virtcol(VAR argvars , VAR retvar ) 
{

















}
static void f_visualmode(VAR argvars , VAR retvar ) 
{











}
static void f_winbufnr(VAR argvars , VAR retvar ) 
{













}
static void f_winheight(VAR argvars , VAR retvar ) 
{













}
static void f_winnr(VAR argvars , VAR retvar ) 
{




















}
static WIN *find_win_by_nr(VAR vp ) 
{





























}
static FPOS *var2fpos(VAR varp ) 
{


















}
static int get_env_len(char_u **arg ) 
{


























}
static int get_id_len(char_u **arg ) 
{




























}
static int eval_isnamec(int c ) 
{






























}
static int find_vim_var(char_u *name___1 , int len___0 ) 
{













































}
void set_vim_var_nr(int idx , long val ) 
{ 


  {
  vimvars[idx].val = (char_u *)val;
  return;
}
}
void set_vim_var_string(int idx , char_u *val ) 
{ 


  {
  {
  vim_free((void *)vimvars[idx].val);
  }
  if ((unsigned long )val == (unsigned long )((void *)0)) {

  } else {
    {
    vimvars[idx].val = vim_strsave(val);
    }
  }
  return;
}
}
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) 
{



























































}
static VAR alloc_var(void) 
{








}
static VAR alloc_string_var(char_u *s ) 
{
















}
static void free_var(VAR varp ) 
{
















}
static void clear_var(VAR varp ) 
{















}
static long get_var_number(VAR varp ) 
{





















}
static char_u mybuf[30]  ;
static char_u *get_var_string(VAR varp ) 
{








}
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) 
{

















}
static VAR find_var(char_u *name___1 , int writing ) 
{







































































































}
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) 
{



























}
void var_init(struct growarray *gap ) 
{ 


  {
  {
  ga_init2(gap, (int )sizeof(var ), 4);
  }
  return;
}
}
void var_clear(struct growarray *gap ) 
{ 
  int i___0 ;

  {
  i___0 = gap->ga_len;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {

    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  ga_clear(gap);
  }
  return;
}
}
static void var_free_one(VAR v ) 
{















}
static void list_one_var(VAR v , char_u *prefix ) 
{









}
static void list_vim_var(int i___0 ) 
{























}
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) 
{





























}
static void set_var(char_u *name___1 , VAR varp ) 
{
































































































}
void do_echo(EXARG *eap , int echo ) 
{
































































































































}
void do_echohl(char_u *arg ) 
{















}
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{
































































































}
static char_u *find_option_end(char_u *p___0 ) 
{




















}
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{



















































































































































































































































































































































































































































































































}
static void list_func_head(struct ufunc *fp___0 ) 
{










































}
static struct ufunc *find_func(char_u *name___1 ) 
{























}
static struct ufunc *fp  =    (struct ufunc *)((void *)0);
char_u *get_user_func_name(int idx ) 
{













}
void do_delfunction(char_u *arg ) 
{
















































}
static int depth  =    0;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) 
{

























































































































}
void *save_funccal(void) 
{







}
void restore_funccal(void *fc ) 
{






}
void do_return(EXARG *eap ) 
{






















































}
char_u *get_func_line(int c , void *cookie , int indent ) 
{
















































}
int func_has_ended(void *cookie ) 
{





















}
int func_has_abort(void *cookie ) 
{





}
static VAR_FLAVOUR var_flavour(char_u *varname ) ;
static VAR_FLAVOUR var_flavour(char_u *varname ) 
{































}
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) 
{



































































}
void write_viminfo_varlist(FILE *fp___0 ) 
{ 
  struct growarray *gap ;
  VAR this_var ;
  int i___0 ;
  char_u *tmp ;
  char const   *tmp___0 ;
  char_u *tmp___1 ;
  VAR_FLAVOUR tmp___2 ;

  {
  {
  gap = & variables;
  tmp = find_viminfo_parameter('!');
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    return;
  }
  {


  }
  {


























  while_break: ;/* CIL Label */ ;
  }

}
}
int store_session_globals(FILE *fd ) 
{




























































}
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) 
{













































































































































































































































































































}
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) 
{































































































}
#pragma merger("0","/tmp/cil-U5alLrC_.i","-O0")
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
int msg_col  ;
int msg_scrolled  ;
char_u *keep_msg ;
int keep_msg_attr ;
int msg_didany ;
int no_wait_return ;
int highlight_match ;
int search_match_len  ;
int need_check_timestamps ;
int autocmd_busy ;
int exiting ;
int restricted ;
int secure ;
int silent_mode ;
int VIsual_reselect  ;
int exmode_active ;
int confirm ;
char_u msg_buf[80]  ;
int skip_redraw ;
char_u *use_viminfo ;
int bangredo ;
int need_start_insertmode ;
int g_do_tagpreview ;
char_u *help_save_isk ;
long help_save_ts ;
char_u e_backslash[34] ;
char_u e_curdir[65] ;
char_u e_exists[32] ;
char_u e_interr[12] ;
char_u e_invcmd[16] ;
char_u e_noname[13] ;
char_u e_nopresub[42] ;
char_u e_noprev[20] ;
char_u e_notcreate[21] ;
char_u e_notmp[25] ;
char_u e_notread[19] ;
char_u e_patnotf2[22] ;
char_u e_readonly[45] ;
char_u e_zerocount[11] ;
int p_confirm  ;
int p_ed  ;
char_u *p_ffs  ;
int p_gd  ;
char_u *p_hf  ;
long p_hh  ;
long p_report  ;
char_u *p_shq  ;
char_u *p_srr  ;
int p_warn  ;
int p_write  ;
int p_wa  ;
int mch_setperm(char_u *name___1 , long perm ) ;
void do_ascii(void) ;
void do_align(EXARG *eap ) ;
void do_retab(EXARG *eap ) ;
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) ;
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) ;
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) ;
void do_shell(char_u *cmd , int flags___0 ) ;
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) ;
int viminfo_error(char *message , char_u *line ) ;
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) ;
void write_viminfo(char_u *file , int forceit ) ;
void do_fixdel(void) ;
void print_line_no_prefix(linenr_t lnum , int use_number ) ;
void print_line(linenr_t lnum , int use_number ) ;
void do_file(char_u *arg , int forceit ) ;
int do_write(EXARG *eap ) ;
void do_wnext(EXARG *eap ) ;
void do_wqall(EXARG *eap ) ;
int not_writing(void) ;
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) ;
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) ;
void do_z(linenr_t line , char_u *arg ) ;
int check_restricted(void) ;
int check_secure(void) ;
void do_sub(EXARG *eap ) ;
void do_glob(EXARG *eap ) ;
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_sub_string(FILE *fp___0 ) ;
void prepare_tagpreview(void) ;
void do_help(EXARG *eap ) ;
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) ;
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) ;
void autowrite_all(void) ;
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) ;
int check_fname(void) ;
int buf_write_all(BUF *buf___3 ) ;
void not_exiting(void) ;
void do_argfile(EXARG *eap , int argn ) ;
void dialog_msg(char_u *buff , char *format , char_u *fname ) ;
void gotocmdline(int clr ) ;
void prepare_viminfo_history(int asklen ) ;
int read_viminfo_history(char_u *line , FILE *fp___0 ) ;
void finish_viminfo_history(void) ;
void write_viminfo_history(FILE *fp___0 ) ;
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) ;
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) ;
void write_lnum_adjust(linenr_t offset ) ;
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_filemarks(FILE *fp___0 ) ;
int write_viminfo_marks(FILE *fp_out ) ;
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) ;
int smsg_attr(int attr , char_u *s  , ...) ;
int ml_delete(linenr_t lnum , int message ) ;
void ml_setmarked(linenr_t lnum ) ;
linenr_t ml_firstmarked(void) ;
void ml_clearmarked(void) ;
void wait_return(int redraw ) ;
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) ;
void del_lines(long nlines , int dowindow , int undo ) ;
void msgmore(long n ) ;
int vim_fexists(char_u *fname ) ;
void adjust_cursor(void) ;
char_u *alloc_check(unsigned int size ) ;
void set_fileformat(int t ) ;
int default_fileformat(void) ;
int call_shell(char_u *cmd , int opt ) ;
void end_visual_mode(void) ;
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_registers(FILE *fp___0 ) ;
int get_viminfo_parameter(int type ) ;
void check_buf_options(BUF *buf___3 ) ;
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) ;
char_u *regtilde(char_u *source , int magic ) ;
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) ;
void windgoto(int row , int col ) ;
void invalidate_botline(void) ;
int botline_approximated(void) ;
int messaging(void) ;
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) ;
char_u *get_search_pat(void) ;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_search_pattern(FILE *fp___0 ) ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) ;
void starttermcap(void) ;
void stoptermcap(void) ;
int swapping_screen(void) ;
void cursor_on(void) ;
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) ;
char_u *find_termcode(char_u *name___1 ) ;
int u_inssub(linenr_t lnum ) ;
void u_clearline(void) ;
void win_init(WIN *wp ) ;
void win_setheight(int height ) ;
void check_lnums(int do_curwin ) ;
static int linelen(int *has_tab ) ;
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) ;
static char_u *viminfo_filename(char_u *file ) ;
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) ;
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) ;
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) ;
static int check_readonly(int *forceit , BUF *buf___3 ) ;
static void delbuf_msg(char_u *name___1 ) ;
static int do_sub_msg(void) ;
static int help_compare(void const   *s1 , void const   *s2 ) ;
void do_ascii(void) 
{ 
  int c ;
  char buf1[20] ;
  char buf2[20] ;
  char_u buf3[3] ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  c = gchar_cursor();
  }
  if (c == 0) {
    {

    }

  }
  if (c == 10) {

  }
  {
  tmp = vim_isprintc(c);
  }
  if (tmp) {
    if (c < 32) {
      {



      }
    } else { //Added block
    if (c > 126) {
      {



      }
    } else {
      buf1[0] = (char )'\000';
    }
    }
  } else {

  }
  if (c >= 128) {
    {



    }
  } else {
    buf2[0] = (char )'\000';
  }
  {
  tmp___1 = transchar(c);
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"<%s>%s%s  %d,  Hex %02x,  Octal %03o",
          tmp___1, buf1, buf2, c, c, c);
  msg(IObuff);
  }
  return;
}
}
void do_align(EXARG *eap ) 
{























































































































































}
static int linelen(int *has_tab ) 
{













































}
void do_retab(EXARG *eap ) 
{










































































































































































































































}
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) 
{




















































































































}
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) 
{



























































}
static char_u *prevcmd  =    (char_u *)((void *)0);
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) 
{ 
  char_u *newcmd ;
  int free_newcmd ;
  int ins_prevcmd ;
  char_u *t ;
  char_u *p___0 ;
  char_u *trailarg ;
  int len___0 ;
  int scroll_save ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char_u *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
  newcmd = (char_u *)((void *)0);
  free_newcmd = 0;
  scroll_save = msg_scroll;
  tmp = check_restricted();
  }
  if (tmp) {

  } else {
    {
    tmp___0 = check_secure();
    }
    if (tmp___0) {

    }
  }
  if (addr_count == 0) {
    {
    msg_scroll = 0;
    autowrite_all();
    msg_scroll = scroll_save;
    }
  }
  ins_prevcmd = forceit;
  trailarg = arg;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp___1 = strlen((char const   *)((char *)trailarg));
    len___0 = (int )(tmp___1 + 1UL);
    }
    if ((unsigned long )newcmd != (unsigned long )((void *)0)) {
      {


      }
    }
    if (ins_prevcmd) {







      {


      }
    }
    {
    t = alloc((unsigned int )len___0);
    }
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      {

      }

    }
    *t = (char_u )'\000';
    if ((unsigned long )newcmd != (unsigned long )((void *)0)) {
      {

      }
    }
    if (ins_prevcmd) {
      {

      }
    }
    {
    tmp___4 = strlen((char const   *)((char *)t));
    p___0 = t + tmp___4;
    strcat((char * __restrict  )((char *)t), (char const   * __restrict  )((char *)trailarg));
    vim_free((void *)newcmd);
    newcmd = t;
    trailarg = (char_u *)((void *)0);
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! *p___0) {
        goto while_break___0;
      }
      if ((int )*p___0 == 33) {
        if ((unsigned long )p___0 > (unsigned long )newcmd) {









        } else {
          _L: ;






        }
      }
      p___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (! ((unsigned long )trailarg != (unsigned long )((void *)0))) {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)prevcmd);
  prevcmd = newcmd;
  }
  if (bangredo) {
    {



    }
  }
  if ((int )*p_shq != 0) {
    {



    }



    {




    }
  }
  if (addr_count == 0) {
    {
    msg_start();
    msg_putchar(':');
    msg_putchar('!');
    msg_outtrans(newcmd);
    msg_clr_eos();
    windgoto(msg_row, msg_col);
    do_shell(newcmd, 0);
    }
  } else {
    {

    }
  }
  if (free_newcmd) {
    {

    }
  }
  return;
}
}
void do_shell(char_u *cmd , int flags___0 ) 
{ 
  BUF *buf___3 ;
  int save_nwr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = check_restricted();
  }
  if (tmp) {
    {

    }

  } else {
    {
    tmp___0 = check_secure();
    }
    if (tmp___0) {
      {

      }

    }
  }
  {
  msg_putchar('\r');
  }
  if (! autocmd_busy) {
    {
    stoptermcap();
    }
  }
  {
  msg_putchar('\n');
  }
  if (p_warn) {
    if (! autocmd_busy) {
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! buf___3) {
          goto while_break;
        }
        {
        tmp___1 = buf_changed(buf___3);
        }
        if (tmp___1) {
          {

          }

        }
        buf___3 = buf___3->b_next;
      }
      while_break: ;/* CIL Label */ ;
      }
    }
  }
  {
  tmp___2 = swapping_screen();
  }
  if (! tmp___2) {
    {

    }
  }
  {
  cursor_on();
  call_shell(cmd, 4 | flags___0);
  need_check_timestamps = 1;
  tmp___3 = swapping_screen();
  }
  if (! tmp___3) {


  }
  if (autocmd_busy) {

  } else {
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {


    } else {
      {
      save_nwr = no_wait_return;
      tmp___4 = swapping_screen();
      }
      if (tmp___4) {
        no_wait_return = 0;
      }
      {
      wait_return(1);
      no_wait_return = save_nwr;
      }
    }
    {
    starttermcap();
    }
  }
  {
  fflush(stderr);
  }
  return;
}
}
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) 
{


















































































































































































































}
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) 
{













































































}
static int no_viminfo(void) ;
static int viminfo_errcnt  ;
static int no_viminfo(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )use_viminfo != (unsigned long )((void *)0)) {
    {

    }





  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int viminfo_error(char *message , char_u *line ) 
{




















}
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) 
{ 
  FILE *fp___0 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = no_viminfo();
  }
  if (tmp) {

  }
  {
  file = viminfo_filename(file);
  fp___0 = fopen((char const   * __restrict  )((char *)file), (char const   * __restrict  )"r");
  }
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {

  }
  if (p_verbose > 0L) {










    {

    }
  }
  {
  viminfo_errcnt = 0;
  do_viminfo(fp___0, (FILE *)((void *)0), want_info, want_marks, forceit);
  fclose(fp___0);
  }
  return (1);
}
}
void write_viminfo(char_u *file , int forceit ) 
{ 
  FILE *fp_in ;
  FILE *fp_out ;
  char_u *tempname ;
  struct stat st_new ;
  char_u *wp ;
  mode_t umask_save ;
  int shortname ;
  struct stat st_old ;
  int tmp ;
  int tmp___0 ;
  int tt ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  unsigned int tmp___5 ;
  __gid_t tmp___6 ;
  unsigned int tmp___7 ;
  __uid_t tmp___8 ;
  size_t tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;

  {
  {
  fp_in = (FILE *)((void *)0);
  fp_out = (FILE *)((void *)0);
  tempname = (char_u *)((void *)0);
  shortname = 0;
  tmp = no_viminfo();
  }
  if (tmp) {

  }
  {
  file = viminfo_filename(file);
  file = vim_strsave(file);
  }
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
    fp_in = fopen((char const   * __restrict  )((char *)file), (char const   * __restrict  )"r");
    }
    if ((unsigned long )fp_in == (unsigned long )((void *)0)) {
      {

      }



      {



      }
    } else {
      {
      st_old.st_ino = (__ino_t )0;
      st_old.st_dev = st_old.st_ino;
      st_old.st_mode = (__mode_t )384;
      tmp___1 = stat((char const   * __restrict  )((char *)file), (struct stat * __restrict  )(& st_old));
      }
      if (tmp___1 == 0) {
        {
        tmp___2 = getuid();
        }
        if (tmp___2) {
          {

          }





















        }
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        {
        tempname = buf_modname(shortname, file, (char_u *)".tmp", 0);
        }
        if ((unsigned long )tempname == (unsigned long )((void *)0)) {

        }
        {
        tmp___12 = stat((char const   * __restrict  )((char *)tempname), (struct stat * __restrict  )(& st_new));
        }
        if (tmp___12 == 0) {












          {



          }






          {

















          while_break___0: ;/* CIL Label */ ;
          }
        }
        goto while_break;
        __Cont: ;;
      }
      while_break: ;/* CIL Label */ ;
      }
      if ((unsigned long )tempname != (unsigned long )((void *)0)) {
        {
        fp_out = fopen((char const   * __restrict  )((char *)tempname), (char const   * __restrict  )"w");
        }
        if ((unsigned long )fp_out == (unsigned long )((void *)0)) {
          {


          }





        }
        if ((unsigned long )fp_out != (unsigned long )((void *)0)) {
          {
          mch_setperm(tempname, (long )((st_old.st_mode & 511U) | 384U));
          chown((char const   *)((char *)tempname), st_old.st_uid, st_old.st_gid);
          }
        }
      }
    }
  }
  if ((unsigned long )file == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )fp_out == (unsigned long )((void *)0)) {
    _L: ;










    {

    }






  }
  }
  if (p_verbose > 0L) {
    {

    }
  }
  {
  viminfo_errcnt = 0;
  do_viminfo(fp_in, fp_out, ! forceit, ! forceit, 0);
  fclose(fp_out);
  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    {
    fclose(fp_in);
    }
    if (viminfo_errcnt) {
      {

      }
    } else {
      {
      tmp___15 = vim_rename(tempname, file);
      }
      if (tmp___15 == -1) {
        {

        }
      }
    }
  }
  end: ;
  {
  vim_free((void *)file);
  vim_free((void *)tempname);
  }
  return;
}
}
static char_u *viminfo_filename(char_u *file ) 
{ 


  {
  if ((unsigned long )file == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*file == 0) {
    _L: ;














    {

    }

  }
  }
  return (file);
}
}
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) 
{ 
  int count___2 ;
  int eof ;
  char_u *line ;

  {
  {
  count___2 = 0;
  eof = 0;
  line = alloc(512U);
  }
  if ((unsigned long )line == (unsigned long )((void *)0)) {

  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    if (want_info) {
      {
      eof = read_viminfo_up_to_marks(line, fp_in, force_read, (unsigned long )fp_out != (unsigned long )((void *)0));
      }
    } else {
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        {
        eof = vim_fgets(line, 512, fp_in);
        }
        if (eof) {
          goto while_break;
        } else { //Added block
        if (! ((int )*(line + 0) != 62)) {

        }
        }
      }
      while_break: ;/* CIL Label */ ;
      }
    }
  }
  if ((unsigned long )fp_out != (unsigned long )((void *)0)) {
    {
    fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"# This viminfo file was generated by vim\n");
    fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"# You may edit it if you\'re careful!\n\n");
    write_viminfo_search_pattern(fp_out);
    write_viminfo_sub_string(fp_out);
    write_viminfo_history(fp_out);
    write_viminfo_registers(fp_out);
    write_viminfo_varlist(fp_out);
    write_viminfo_filemarks(fp_out);
    write_viminfo_bufferlist(fp_out);
    count___2 = write_viminfo_marks(fp_out);
    }
  }
  if ((unsigned long )fp_in != (unsigned long )((void *)0)) {
    if (want_marks) {
      {
      copy_viminfo_marks(line, fp_in, fp_out, count___2, eof);
      }
    }
  }
  {
  vim_free((void *)line);
  }
  return;
}
}
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) 
{ 
  int eof ;
  int tmp ;
  int tmp___0 ;

  {
  if (forceit) {
    tmp = 9999;
  } else {
    tmp = 0;
  }
  {
  prepare_viminfo_history(tmp);
  eof = vim_fgets(line, 512, fp___0);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! eof) {
      if (! ((int )*(line + 0) != 62)) {

      }
    } else {
      goto while_break;
    }
    {
    if ((int )*(line + 0) == 43) {

    }
    if ((int )*(line + 0) == 124) {

    }
    if ((int )*(line + 0) == 45) {

    }
    if ((int )*(line + 0) == 94) {

    }
    if ((int )*(line + 0) == 42) {

    }
    if ((int )*(line + 0) == 60) {

    }
    if ((int )*(line + 0) == 0) {

    }
    if ((int )*(line + 0) == 13) {

    }
    if ((int )*(line + 0) == 10) {
      goto case_43;
    }
    if ((int )*(line + 0) == 35) {
      goto case_43;
    }
    if ((int )*(line + 0) == 33) {

    }
    if ((int )*(line + 0) == 37) {

    }
    if ((int )*(line + 0) == 34) {

    }
    if ((int )*(line + 0) == 47) {

    }
    if ((int )*(line + 0) == 38) {

    }
    if ((int )*(line + 0) == 126) {

    }
    if ((int )*(line + 0) == 36) {

    }
    if ((int )*(line + 0) == 58) {

    }
    if ((int )*(line + 0) == 63) {

    }
    if ((int )*(line + 0) == 61) {

    }
    if ((int )*(line + 0) == 64) {

    }
    if ((int )*(line + 0) == 39) {
      goto case_39;
    }

    case_43: ;/* CIL Label */ 
    case_124: ;/* CIL Label */ 
    case_45: ;/* CIL Label */ 
    case_94: ;/* CIL Label */ 
    case_42: ;/* CIL Label */ 
    case_60: ;/* CIL Label */ 
    case_0: ;/* CIL Label */ 
    case_13: ;/* CIL Label */ 
    case_10: ;/* CIL Label */ 
    case_35: ;/* CIL Label */ 
    {
    eof = vim_fgets(line, 512, fp___0);
    }
    goto switch_break;
    case_33: ;/* CIL Label */ 
    {

    }

    case_37: ;/* CIL Label */ 
    {

    }

    case_34: ;/* CIL Label */ 
    {

    }

    case_47: ;/* CIL Label */ 
    case_38: ;/* CIL Label */ 
    case_126: ;/* CIL Label */ 
    {

    }

    case_36: ;/* CIL Label */ 
    {

    }

    case_58: ;/* CIL Label */ 
    case_63: ;/* CIL Label */ 
    case_61: ;/* CIL Label */ 
    case_64: ;/* CIL Label */ 
    {

    }

    case_39: ;/* CIL Label */ 
    {
    eof = read_viminfo_filemark(line, fp___0, forceit);
    }
    goto switch_break;
    switch_default: ;/* CIL Label */ 
    {

    }








    switch_break: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  finish_viminfo_history();
  }
  return (eof);
}
}
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) 
{ 
  char_u *retval ;
  char_u *s ;
  char_u *d ;
  long len___0 ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  if ((int )*(p___0 + 0) == 22) {
    {

    }


















  } else {
    _L: ;
    {
    retval = vim_strsave(p___0);
    }
    if ((unsigned long )retval == (unsigned long )((void *)0)) {

    }
    s = retval;
  }
  d = retval;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((int )*s != 0) {
      if (! ((int )*s != 10)) {
        goto while_break;
      }
    } else {

    }
    if ((int )*(s + 0) == 22) {


















    } else {
      tmp___2 = d;
      d ++;
      tmp___3 = s;
      s ++;
      *tmp___2 = *tmp___3;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  *d = (char_u )'\000';
  return (retval);
}
}
void viminfo_writestring(FILE *fd , char_u *p___0 ) 
{ 
  int c ;
  char_u *s ;
  int len___0 ;
  char_u *tmp ;

  {
  len___0 = 0;
  s = p___0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*s != 0)) {
      goto while_break;
    }
    if ((int )*s == 22) {

    } else { //Added block
    if ((int )*s == 10) {

    }
    }
    len___0 ++;
    s ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (len___0 > 256) {
    {

    }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    tmp = p___0;
    p___0 ++;
    c = (int )*tmp;
    if (! (c != 0)) {
      goto while_break___0;
    }
    if (c == 22) {

    } else { //Added block
    if (c == 10) {
      _L: ;
      {

      }



    }
    }
    {
    _IO_putc(c, fd);
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  _IO_putc('\n', fd);
  }
  return;
}
}
void do_fixdel(void) 
{





















}
void print_line_no_prefix(linenr_t lnum , int use_number ) 
{ 
  char_u numbuf[20] ;
  char_u *tmp ;

  {
  if (curwin->w_p_nu) {
    {



    }
  } else { //Added block
  if (use_number) {
    {



    }
  }
  }
  {
  tmp = ml_get(lnum);
  msg_prt_line(tmp);
  }
  return;
}
}
void print_line(linenr_t lnum , int use_number ) 
{ 
  int save_silent ;

  {
  {
  save_silent = silent_mode;
  silent_mode = 0;
  msg_start();
  print_line_no_prefix(lnum, use_number);
  }
  if (save_silent) {
    {




    }
  }
  return;
}
}
void do_file(char_u *arg , int forceit ) 
{ 
  char_u *fname ;
  char_u *sfname ;
  char_u *xfname ;
  BUF *buf___3 ;
  int tmp ;

  {
  if ((int )*arg != 0) {
    {
    buf___3 = curbuf;
    apply_autocmds((EVENT_T )4, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {

    }
    {
    fname = curbuf->b_ffname;
    sfname = curbuf->b_sfname;
    xfname = curbuf->b_fname;
    curbuf->b_ffname = (char_u *)((void *)0);
    curbuf->b_sfname = (char_u *)((void *)0);
    tmp = setfname(arg, (char_u *)((void *)0), 1);
    }
    if (tmp == 0) {



    }
    {
    curbuf->b_flags |= 8;
    buf___3 = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);
    }
    if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
      curwin->w_alt_fnum = buf___3->b_fnum;
    }
    {
    vim_free((void *)fname);
    vim_free((void *)sfname);
    apply_autocmds((EVENT_T )3, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
  }
  {
  fileinfo(0, 0, forceit);
  }
  return;
}
}
int do_write(EXARG *eap ) 
{ 
  int other ;
  char_u *fname ;
  char_u *ffname ;
  int retval ;
  char_u *free_fname ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  fname = (char_u *)((void *)0);
  retval = 0;
  free_fname = (char_u *)((void *)0);
  tmp = not_writing();
  }
  if (tmp) {

  }
  ffname = eap->arg;
  if ((int )*ffname == 0) {
    other = 0;
  } else {
    {
    fname = ffname;
    free_fname = fix_fname(ffname);
    }
    if ((unsigned long )free_fname != (unsigned long )((void *)0)) {
      ffname = free_fname;
    }
    {
    other = otherfile(ffname);
    }
  }
  if (other) {
    {
    tmp___0 = vim_strchr(p_cpo, 'A');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      setaltfname(ffname, fname, (linenr_t )1);
      }
    }
  }
  if (! other) {
    {
    tmp___1 = check_fname();
    }
    if (tmp___1 == 0) {

    } else {
      {
      tmp___2 = check_readonly(& eap->forceit, curbuf);
      }
      if (tmp___2) {

      }
    }
  }
  if (! other) {
    ffname = curbuf->b_ffname;
    fname = curbuf->b_fname;
    if (eap->line1 != 1L) {

    } else { //Added block
    if (eap->line2 != curbuf->b_ml.ml_line_count) {
      _L___0: ;
      if (! eap->forceit) {
        if (! eap->append) {
          if (! p_wa) {
            if (p_confirm) {

            } else { //Added block
















            }
          }
        }
      }
    }
    }
  }
  {
  tmp___4 = check_overwrite(eap, curbuf, fname, ffname, other);
  }
  if (tmp___4 == 1) {
    {
    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2, eap->append,
                       eap->forceit, 1, 0);
    }
  }
  theend: ;
  {
  vim_free((void *)free_fname);
  }
  return (retval);
}
}
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) 
{ 
  int tmp ;
  char_u buff[1025] ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  if (other) {
    goto _L___0;
  } else { //Added block
  if (buf___3->b_flags & 8) {
    goto _L___0;
  } else { //Added block
  if (buf___3->b_flags & 16) {
    {
    tmp___1 = vim_strchr(p_cpo, 'O');
    }
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {

    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: ;
  if (buf___3->b_flags & 64) {
    _L___0: ;
    if (! eap->forceit) {
      if (! eap->append) {
        if (! p_wa) {
          {
          tmp___2 = vim_fexists(ffname);
          }
          if (tmp___2) {
            {

            }






            if (p_confirm) {

            } else { //Added block
















            }
          }
        }
      }
    }
  }
  }
  }
  }
  return (1);
}
}
void do_wnext(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;

  {
  if ((int )*(eap->cmd + 1) == 110) {
    i___0 = curwin->w_arg_idx + (int )eap->line2;
  } else {

  }
  {
  eap->line1 = (linenr_t )1;
  eap->line2 = curbuf->b_ml.ml_line_count;
  tmp = do_write(eap);
  }
  if (tmp != 0) {
    {
    do_argfile(eap, i___0);
    }
  }
  return;
}
}
void do_wqall(EXARG *eap ) 
{ 
  BUF *buf___3 ;
  int error ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  error = 0;
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp___4 = buf_changed(buf___3);
    }
    if (tmp___4) {
      {
      tmp = not_writing();
      }
      if (tmp) {


      }
      if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
        {


        }
      } else {
        {
        tmp___2 = check_readonly(& eap->forceit, buf___3);
        }
        if (tmp___2) {

        } else {
          {
          tmp___3 = check_overwrite(eap, buf___3, buf___3->b_fname, buf___3->b_ffname,
                                    0);
          }
          if (tmp___3 == 0) {

          } else {
            {
            tmp___0 = buf_write_all(buf___3);
            }
            if (tmp___0 == 0) {

            }
            {
            tmp___1 = buf_valid(buf___3);
            }
            if (! tmp___1) {

            }
          }
        }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (exiting) {





    {

    }
  }
  return;
}
}
int not_writing(void) 
{ 


  {
  if (p_write) {
    return (0);
  }
  {

  }

}
}
static int check_readonly(int *forceit , BUF *buf___3 ) 
{ 
  char_u buff[1025] ;
  int tmp ;

  {
  if (! *forceit) {
    if (buf___3->b_p_ro) {





























    }
  }
  return (0);
}
}
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) 
{




























































































}
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) 
{ 
  int other_file ;
  int oldbuf ;
  int auto_buf ;
  char_u *new_name ;
  BUF *buf___3 ;
  BUF *old_curbuf ;
  char_u *free_fname ;
  int retval ;
  long n ;
  linenr_t lnum ;
  linenr_t topline ;
  int newcol ;
  int solcol ;
  FPOS *pos___0 ;
  linenr_t tmp ;
  int tmp___0 ;
  linenr_t tlnum ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  auto_buf = 0;
  new_name = (char_u *)((void *)0);
  old_curbuf = curbuf;
  free_fname = (char_u *)((void *)0);
  retval = 0;
  topline = (linenr_t )0;
  newcol = -1;
  solcol = -1;
  if (fnum != 0) {




  } else {
    if ((unsigned long )sfname == (unsigned long )((void *)0)) {
      sfname = ffname;
    }
    if (flags___0 & 16) {
      if ((unsigned long )ffname == (unsigned long )((void *)0)) {

      } else { //Added block



      }
    }
    if ((unsigned long )ffname == (unsigned long )((void *)0)) {

    } else { //Added block
    if ((int )*ffname == 0) {
      if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {

      } else {
        goto _L;
      }
    } else {
      _L: ;
      if ((int )*ffname == 0) {
        ffname = curbuf->b_ffname;
        sfname = curbuf->b_fname;
      }
      {
      free_fname = fix_fname(ffname);
      }
      if ((unsigned long )free_fname != (unsigned long )((void *)0)) {
        ffname = free_fname;
      }
      {
      other_file = otherfile(ffname);
      }
    }
    }
  }
  if (! other_file) {
    if (! (flags___0 & 4)) {
      goto _L___0;
    } else {

    }
  } else { //Added block
  _L___1: ;
  if (curbuf->b_nwindows == 1) {
    if (! (flags___0 & 17)) {
      _L___0: ;
      {
      tmp___0 = check_changed(curbuf, 0, ! other_file, flags___0 & 8, 0);
      }
      if (tmp___0) {















      }
    }
  }
  }
  if (VIsual_active) {
    {


    }
  }
  if (other_file) {
    if (! (flags___0 & 16)) {
      {
      curwin->w_alt_fnum = curbuf->b_fnum;
      buflist_altfpos();
      }
    }
    if (fnum) {
      {

      }
    } else {
      if (flags___0 & 16) {









        {

        }

      }
      {
      buf___3 = buflist_new(ffname, sfname, 0L, 1);
      }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {

    }
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      oldbuf = 0;
      buf___3->b_nwindows = 0;
    } else {
      {


      }
    }
    if (oldbuf) {









    } else { //Added block
    _L___2: ;
    if (newlnum == -1L) {
      {
      pos___0 = buflist_findfpos(buf___3);
      newlnum = pos___0->lnum;
      solcol = (int )pos___0->col;
      }
    }
    }
    if ((unsigned long )buf___3 != (unsigned long )curbuf) {
      if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
        {
        new_name = vim_strsave(buf___3->b_fname);
        }
      }
      {
      au_new_curbuf = buf___3;
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      tmp___1 = buf_valid(buf___3);
      }
      if (! tmp___1) {
        {

        }

      }
      if ((unsigned long )buf___3 == (unsigned long )curbuf) {

      } else {
        if ((unsigned long )curbuf == (unsigned long )old_curbuf) {
          {
          buf_copy_options(curbuf, buf___3, 1);
          }
        }
        {
        close_buffer(curwin, curbuf, ! (flags___0 & 1), 0);
        tmp___2 = buf_valid(buf___3);
        }
        if (! tmp___2) {
          {

          }

        }
        if ((unsigned long )buf___3 == (unsigned long )curbuf) {

        } else {
          curwin->w_buffer = buf___3;
          curbuf = buf___3;
          (curbuf->b_nwindows) ++;
          if (*p_ffs) {






          }
        }
      }
      {
      vim_free((void *)new_name);
      au_new_curbuf = (BUF *)((void *)0);
      }
    } else {

    }
    curwin->w_pcmark.lnum = (linenr_t )1;
    curwin->w_pcmark.col = (colnr_t )0;
  } else {
    if (flags___0 & 16) {

    } else {
      {
      tmp___4 = check_fname();
      }
      if (tmp___4 == 0) {

      }
    }
    oldbuf = flags___0 & 4;
  }
  if (flags___0 & 2) {


  }
  if (! other_file) {
    if (! oldbuf) {
      {
      set_last_cursor(curwin);
      }
      if (newlnum == -1L) {
        newlnum = curwin->w_cursor.lnum;
        solcol = (int )curwin->w_cursor.col;
      } else { //Added block
      if (newlnum == 0L) {
        newlnum = curwin->w_cursor.lnum;
        solcol = (int )curwin->w_cursor.col;
      }
      }
      buf___3 = curbuf;
      if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
        {
        new_name = vim_strsave(buf___3->b_fname);
        }
      } else {

      }
      {
      buf_freeall(curbuf, 0);
      tmp___5 = buf_valid(buf___3);
      }
      if (! tmp___5) {
        {

        }

      }
      {
      vim_free((void *)new_name);
      }
      if ((unsigned long )buf___3 != (unsigned long )curbuf) {

      }
      {
      buf_clear(curbuf);
      curbuf->b_op_start.lnum = (linenr_t )0;
      curbuf->b_op_end.lnum = (linenr_t )0;
      }
    }
  }
  {
  RedrawingDisabled ++;
  retval = 1;
  adjust_cursor();
  check_arg_idx(curwin);
  }
  if (! auto_buf) {
    {
    win_init(curwin);
    lnum = curwin->w_cursor.lnum;
    topline = curwin->w_topline;
    }
    if (! oldbuf) {
      {
      swap_exists_action = 1;
      curbuf->b_flags |= 2;
      open_buffer(0);
      }
      if (swap_exists_action == 2) {
        {



        }













        {


        }
      } else { //Added block
      if (swap_exists_action == 3) {
        {




        }
      }
      }
      swap_exists_action = 0;
    } else {
      {


      }
    }
    {
    check_arg_idx(curwin);
    }
    if (curwin->w_cursor.lnum != lnum) {


    }
    if (curwin->w_topline == topline) {
      topline = (linenr_t )0;
    }
    {
    maketitle();
    }
  }
  if ((unsigned long )command == (unsigned long )((void *)0)) {
    if (newcol >= 0) {
      {



      }
    } else { //Added block
    if (newlnum > 0L) {
      {
      curwin->w_cursor.lnum = newlnum;
      check_cursor_lnum();
      }
      if (solcol >= 0) {
        if (! p_sol) {
          {


          }
        } else {
          {
          beginline(6);
          }
        }
      } else {
        {
        beginline(6);
        }
      }
    } else {
      if (exmode_active) {

      }
      {
      beginline(5);
      }
    }
    }
  }
  {
  check_lnums(0);
  }
  if (oldbuf) {





  }
  if ((unsigned long )command != (unsigned long )((void *)0)) {
    {


    }
  }
  RedrawingDisabled --;
  if (! skip_redraw) {
    n = p_so;
    if (topline == 0L) {
      if ((unsigned long )command == (unsigned long )((void *)0)) {
        p_so = 999L;
      }
    }
    {
    update_topline();
    curwin->w_scbind_pos = curwin->w_topline;
    p_so = n;
    update_curbuf(40);
    }
  }
  if (p_im) {

  }
  theend: ;
  {
  vim_free((void *)free_fname);
  }
  return (retval);
}
}
static void delbuf_msg(char_u *name___1 ) 
{















}
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) 
{



























































































}
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) 
{




































}
void do_z(linenr_t line , char_u *arg ) 
{



































































































































































}
int check_restricted(void) 
{ 


  {
  if (restricted) {
    {

    }

  }
  return (0);
}
}
int check_secure(void) 
{ 


  {
  if (secure) {
    {


    }

  }
  if (sandbox != 0) {
    {

    }

  }
  return (0);
}
}
static char_u *old_sub  =    (char_u *)((void *)0);
static int global_need_beginline  ;
static long sub_nsubs  ;
static linenr_t sub_nlines  ;
static int do_all  =    0;
static int do_ask  =    0;
void do_sub(EXARG *eap ) 
{
































































































































































































































































































































































































































































































































































































































































































































}
static int do_sub_msg(void) 
{




















































}
void do_glob(EXARG *eap ) 
{





















































































































































































































}
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) 
{


























}
void write_viminfo_sub_string(FILE *fp___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = get_viminfo_parameter('/');
  }
  if (tmp != 0) {
    if ((unsigned long )old_sub != (unsigned long )((void *)0)) {
      {


      }
    }
  }
  return;
}
}
void prepare_tagpreview(void) 
{












































}
void do_help(EXARG *eap ) 
{ 
  char_u *arg ;
  FILE *helpfd ;
  int n ;
  WIN *wp ;
  int num_matches___0 ;
  char_u **matches___0 ;
  int need_free ;
  char_u *tmp ;
  int tmp___0 ;

  {
  need_free = 0;
  if ((unsigned long )eap != (unsigned long )((void *)0)) {
    arg = eap->arg;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! *arg) {
        goto while_break;
      }
      if ((int )*arg == 10) {





      } else { //Added block
      if ((int )*arg == 13) {





      } else { //Added block
      if ((int )*arg == 124) {







      }
      }
      }
      arg ++;
    }
    while_break: ;/* CIL Label */ ;
    }
    arg = eap->arg;
    if (eap->skip) {

    }
  } else {

  }
  if ((int )*arg != 0) {
    {
    n = find_help_tags(arg, & num_matches___0, & matches___0);
    }
    if (num_matches___0 == 0) {
      {
      emsg2((char_u *)"Sorry, no help for %s", arg);
      }
      return;
    } else { //Added block






    }
    {



    }
  }
  if (! (curwin->w_buffer)->b_help) {
    wp = firstwin;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      if ((unsigned long )wp->w_buffer != (unsigned long )((void *)0)) {
        if ((wp->w_buffer)->b_help) {

        }
      }
      wp = wp->w_next;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((unsigned long )wp != (unsigned long )((void *)0)) {







    } else {
      _L: ;
      {
      helpfd = fopen((char const   * __restrict  )((char *)p_hf), (char const   * __restrict  )"r");
      }
      if ((unsigned long )helpfd == (unsigned long )((void *)0)) {
        {
        smsg((char_u *)"Sorry, help file \"%s\" not found", p_hf);
        }
        goto erret;
      }
      {


      }








      {











      }
    }
  }
  if (! p_im) {

  }









  {

  }
  erret: ;
  if (need_free) {
    {

    }
  }
  return;
}
}
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) 
{



























































}
static int help_compare(void const   *s1 , void const   *s2 ) 
{
















}
static char *mtable[20]  = 
  {      (char *)"*",      (char *)"g*",      (char *)"[*",      (char *)"]*", 
        (char *)":*",      (char *)"/*",      (char *)"/\\*",      (char *)"\"*", 
        (char *)"/\\(\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"[count]", 
        (char *)"[quotex]",      (char *)"[range]",      (char *)"[pattern]",      (char *)"\\|"};
static char *rtable[20]  = 
  {      (char *)"star",      (char *)"gstar",      (char *)"[star",      (char *)"]star", 
        (char *)":star",      (char *)"/star",      (char *)"/\\\\star",      (char *)"quotestar", 
        (char *)"/\\\\(\\\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"\\[count]", 
        (char *)"\\[quotex]",      (char *)"\\[range]",      (char *)"\\[pattern]",      (char *)"\\\\bar"};
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) 
{ 
  char_u *s ;
  char_u *d ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  int tmp___11 ;

  {
  d = IObuff;
  i___0 = (int )(sizeof(mtable) / sizeof(char *));
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)((char *)arg), (char const   *)mtable[i___0]);
    }
    if (tmp == 0) {
      {
      strcpy((char * __restrict  )((char *)d), (char const   * __restrict  )rtable[i___0]);
      }
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (i___0 < 0) {
    if ((int )*(arg + 0) == 92) {












    } else {
      _L___3: ;
      if ((int )*(arg + 0) == 91) {
        if ((int )*(arg + 1) == 58) {



        }
      }
      s = arg;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! *s) {
          goto while_break___0;
        }
        if (d - IObuff > 1015L) {

        }
        {
        if ((int )*s == 124) {

        }
        if ((int )*s == 34) {

        }
        if ((int )*s == 42) {

        }
        if ((int )*s == 63) {

        }
        if ((int )*s == 36) {

        }
        if ((int )*s == 46) {

        }
        if ((int )*s == 126) {

        }
        goto switch_break;
        case_124: ;/* CIL Label */ 
        {


        }

        case_34: ;/* CIL Label */ 
        {


        }

        case_42: ;/* CIL Label */ 




        case_63: ;/* CIL Label */ 




        case_36: ;/* CIL Label */ 
        case_46: ;/* CIL Label */ 
        case_126: ;/* CIL Label */ 




        switch_break: ;/* CIL Label */ ;
        }
        if ((int )*s < 32) {

        } else { //Added block
        if ((int )*s == 94) {






































        } else { //Added block
        _L___1: ;
        if ((int )*s == 94) {



        } else { //Added block
        if ((int )*(s + 0) == 92) {









        }
        }
        }
        }
        tmp___10 = d;
        d ++;
        *tmp___10 = *s;
        if ((int )*s == 39) {
          if ((unsigned long )s > (unsigned long )arg) {



          }
        }
        __Cont: ;
        s ++;
      }
      while_break___0: ;/* CIL Label */ ;
      }
      *d = (char_u )'\000';
    }
  }
  {
  *matches___0 = (char_u **)"";
  *num_matches___0 = 0;
  tmp___11 = find_tags(IObuff, num_matches___0, matches___0, 39, 2147483647);
  }
  if (tmp___11 == 1) {
    {
    qsort((void *)*matches___0, (size_t )*num_matches___0, sizeof(char_u *), & help_compare);
    }
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-bQYL8qc0.i","-O0")
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
int exec_from_reg ;
int expand_set_path ;
int vgetc_busy ;
int did_syncbind ;
int ex_no_reprint ;
int searchcmdlen  ;
char_u *last_cmdline ;
char_u *new_last_cmdline ;
char_u *autocmd_fname ;
int autocmd_bufnr ;
char_u *autocmd_match ;
int postponed_split ;
char_u *escape_chars ;
FILE *redir_fd ;
int redir_reg ;
char_u e_argreq[18] ;
char_u e_failed[15] ;
char_u e_invaddr[16] ;
char_u e_invarg[17] ;
char_u e_invrange[14] ;
char_u e_noabbr[21] ;
char_u e_nobang[13] ;
char_u e_nogvim[49] ;
char_u e_nomap[16] ;
char_u e_nomatch[9] ;
char_u e_norange[17] ;
char_u e_notopen[19] ;
char_u e_unknown[8] ;
char_u e_write[20] ;
int p_aw  ;
int p_cp  ;
char_u *p_ef  ;
char_u *p_efm  ;
char_u *p_gefm  ;
char_u *p_gp  ;
char_u *p_mef  ;
char_u *p_mp  ;
long p_mmd  ;
long p_pvh  ;
char_u *p_sessopt  ;
char_u *p_sp  ;
char_u *p_viminfo  ;
void mch_restore_title(int which ) ;
long mch_get_pid(void) ;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) ;
long mch_getperm(char_u *name___1 ) ;
int mch_screenmode(char_u *arg ) ;
int mch_has_wildcard(char_u *p___0 ) ;
void do_exmode(void) ;
char_u *set_one_cmd_context(char_u *buff ) ;
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) ;
void separate_nextcmd(EXARG *eap ) ;
void dialog_changed(BUF *buf___3 , int checkall ) ;
int check_changed_any(int hidden ) ;
int rem_backslash(char_u *str___1 ) ;
void backslash_halve(char_u *p___0 ) ;
char_u *backslash_halve_save(char_u *p___0 ) ;
char_u *find_nextcmd(char_u *p___0 ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) ;
char_u *getsourceline(int c , void *cookie , int indent ) ;
char_u *get_command_name(int idx ) ;
char_u *get_user_commands(int idx ) ;
char_u *get_user_cmd_flags(int idx ) ;
char_u *get_user_cmd_nargs(int idx ) ;
char_u *get_user_cmd_complete(int idx ) ;
char_u *expand_sfile(char_u *arg ) ;
char_u *getexline(int c , void *dummy , int indent ) ;
char_u *getexmodeline(int c , void *dummy , int indent ) ;
void do_history(char_u *arg ) ;
void shorten_fnames(int force ) ;
void do_augroup(char_u *arg ) ;
void do_autocmd(char_u *arg , int forceit ) ;
int do_doautocmd(char_u *arg , int do_msg ) ;
void do_autoall(char_u *arg ) ;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) ;
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) ;
int typebuf_typed(void) ;
int openscript(char_u *name___1 ) ;
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) ;
void map_clear(char_u *cmdp , int forceit , int abbr ) ;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) ;
int makemap(FILE *fd ) ;
int setmark(int c ) ;
void checkpcmark(void) ;
int check_mark(FPOS *pos___0 ) ;
void do_marks(char_u *arg ) ;
void do_jumps(void) ;
void ml_preserve(BUF *buf___3 , int message ) ;
void goto_byte(long cnt ) ;
void do_menu(EXARG *eap ) ;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) ;
void execute_menu(char_u *path_name ) ;
void ex_messages(void) ;
int msg_outtrans_attr(char_u *str___1 , int attr ) ;
void msg_make(char_u *arg ) ;
void msg_puts_title(char_u *s ) ;
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) ;
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) ;
int ask_yesno(char_u *str___1 , int direct ) ;
void beep_flush(void) ;
void del_trailing_spaces(char_u *ptr ) ;
int vim_chdirfile(char_u *fname ) ;
char_u *get_crypt_key(int store ) ;
void normal_cmd(OPARG *oap , int toplevel ) ;
int find_ident_under_cursor(char_u **string___0 , int find_type ) ;
void op_shift(OPARG *oap , int curs_top , int amount ) ;
void set_expr_line(char_u *new_line ) ;
int valid_yank_reg(int regname___0 , int writing ) ;
int do_execreg(int regname___0 , int colon , int addcr ) ;
int op_delete(OPARG *oap ) ;
int op_yank(OPARG *oap , int deleting , int mess ) ;
void do_dis(char_u *arg ) ;
void do_do_join(long count___2 , int insert_space , int redraw ) ;
void clear_oparg(OPARG *oap ) ;
int makeset(FILE *fd ) ;
void set_context_in_set_cmd(char_u *arg ) ;
void vimrc_found(void) ;
int qf_init(char_u *efile , char_u *errorformat ) ;
void qf_jump(int dir , int errornr , int forceit ) ;
void qf_list(char_u *arg , int all ) ;
void qf_older(int count___2 ) ;
void qf_newer(int count___2 ) ;
void redraw_all_later(int type ) ;
void cursor_correct(void) ;
int cursor_valid(void) ;
void scrolldown(long line_count ) ;
void scrollup(long line_count ) ;
void do_intro(void) ;
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) ;
void do_syntax(EXARG *eap , char_u **cmdlinep ) ;
void set_context_in_syntax_cmd(char_u *arg ) ;
void do_highlight(char_u *line , int forceit , int init ) ;
void set_context_in_highlight_cmd(char_u *arg ) ;
void do_tags(void) ;
void out_char(unsigned int c ) ;
void term_set_winpos(int x___0 , int y ) ;
void set_winsize(int width , int height , int mustset ) ;
void settmode(int tmode ) ;
void scroll_start(void) ;
char_u *translate_mapping(char_u *str___1 , int expmap ) ;
void ui_suspend(void) ;
void u_undo(int count___2 ) ;
void u_redo(int count___2 ) ;
void do_version(char_u *arg ) ;
char_u *file_name_at_cursor(int options___0 , long count___2 ) ;
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) ;
int only_one_window(void) ;
static struct cmdname cmdnames[299]  = 
  {      {(char_u *)"append", (long_u )4355}, 
        {(char_u *)"abbreviate", (long_u )10500}, 
        {(char_u *)"abclear", (long_u )256}, 
        {(char_u *)"all", (long_u )17665}, 
        {(char_u *)"amenu", (long_u )30981}, 
        {(char_u *)"anoremenu", (long_u )30981}, 
        {(char_u *)"args", (long_u )33102}, 
        {(char_u *)"argument", (long_u )50439}, 
        {(char_u *)"ascii", (long_u )256}, 
        {(char_u *)"autocmd", (long_u )10246}, 
        {(char_u *)"augroup", (long_u )276}, 
        {(char_u *)"aunmenu", (long_u )10500}, 
        {(char_u *)"buffer", (long_u )83207}, 
        {(char_u *)"bNext", (long_u )17667}, 
        {(char_u *)"ball", (long_u )17665}, 
        {(char_u *)"badd", (long_u )33180}, 
        {(char_u *)"bdelete", (long_u )83207}, 
        {(char_u *)"behave", (long_u )404}, 
        {(char_u *)"blast", (long_u )259}, 
        {(char_u *)"bmodified", (long_u )17667}, 
        {(char_u *)"bnext", (long_u )17667}, 
        {(char_u *)"bprevious", (long_u )17667}, 
        {(char_u *)"brewind", (long_u )259}, 
        {(char_u *)"break", (long_u )262400}, 
        {(char_u *)"browse", (long_u )2180}, 
        {(char_u *)"buffers", (long_u )256}, 
        {(char_u *)"bunload", (long_u )83207}, 
        {(char_u *)"change", (long_u )1283}, 
        {(char_u *)"cNext", (long_u )17667}, 
        {(char_u *)"cabbrev", (long_u )10500}, 
        {(char_u *)"cabclear", (long_u )256}, 
        {(char_u *)"call", (long_u )264325}, 
        {(char_u *)"cc", (long_u )17667}, 
        {(char_u *)"cd", (long_u )348}, 
        {(char_u *)"center", (long_u )261}, 
        {(char_u *)"cfile", (long_u )286}, 
        {(char_u *)"chdir", (long_u )348}, 
        {(char_u *)"checkpath", (long_u )258}, 
        {(char_u *)"clist", (long_u )262}, 
        {(char_u *)"clast", (long_u )17667}, 
        {(char_u *)"close", (long_u )258}, 
        {(char_u *)"cmap", (long_u )10500}, 
        {(char_u *)"cmapclear", (long_u )256}, 
        {(char_u *)"cmenu", (long_u )30981}, 
        {(char_u *)"cnext", (long_u )17667}, 
        {(char_u *)"cnewer", (long_u )17665}, 
        {(char_u *)"cnfile", (long_u )17667}, 
        {(char_u *)"cnoremap", (long_u )10500}, 
        {(char_u *)"cnoreabbrev", (long_u )10500}, 
        {(char_u *)"cnoremenu", (long_u )30981}, 
        {(char_u *)"copy", (long_u )261}, 
        {(char_u *)"colder", (long_u )17665}, 
        {(char_u *)"command", (long_u )10246}, 
        {(char_u *)"comclear", (long_u )256}, 
        {(char_u *)"continue", (long_u )262400}, 
        {(char_u *)"confirm", (long_u )2180}, 
        {(char_u *)"cprevious", (long_u )17667}, 
        {(char_u *)"cquit", (long_u )258}, 
        {(char_u *)"crewind", (long_u )17667}, 
        {(char_u *)"cscope", (long_u )2052}, 
        {(char_u *)"cstag", (long_u )278}, 
        {(char_u *)"cunmap", (long_u )10500}, 
        {(char_u *)"cunabbrev", (long_u )10500}, 
        {(char_u *)"cunmenu", (long_u )10500}, 
        {(char_u *)"delete", (long_u )1793}, 
        {(char_u *)"delcommand", (long_u )404}, 
        {(char_u *)"delfunction", (long_u )404}, 
        {(char_u *)"display", (long_u )2308}, 
        {(char_u *)"digraphs", (long_u )260}, 
        {(char_u *)"djump", (long_u )39}, 
        {(char_u *)"dlist", (long_u )39}, 
        {(char_u *)"doautocmd", (long_u )260}, 
        {(char_u *)"doautoall", (long_u )260}, 
        {(char_u *)"dsearch", (long_u )39}, 
        {(char_u *)"dsplit", (long_u )39}, 
        {(char_u *)"edit", (long_u )33054}, 
        {(char_u *)"echo", (long_u )264196}, 
        {(char_u *)"echohl", (long_u )262404}, 
        {(char_u *)"echon", (long_u )264196}, 
        {(char_u *)"else", (long_u )262400}, 
        {(char_u *)"elseif", (long_u )264196}, 
        {(char_u *)"emenu", (long_u )2436}, 
        {(char_u *)"endif", (long_u )262400}, 
        {(char_u *)"endfunction", (long_u )256}, 
        {(char_u *)"endwhile", (long_u )262400}, 
        {(char_u *)"ex", (long_u )33054}, 
        {(char_u *)"execute", (long_u )264196}, 
        {(char_u *)"exit", (long_u )319}, 
        {(char_u *)"file", (long_u )286}, 
        {(char_u *)"files", (long_u )256}, 
        {(char_u *)"filetype", (long_u )404}, 
        {(char_u *)"find", (long_u )33054}, 
        {(char_u *)"fixdel", (long_u )256}, 
        {(char_u *)"function", (long_u )6}, 
        {(char_u *)"global", (long_u )39}, 
        {(char_u *)"goto", (long_u )279809}, 
        {(char_u *)"grep", (long_u )2444}, 
        {(char_u *)"gui", (long_u )33102}, 
        {(char_u *)"gvim", (long_u )33102}, 
        {(char_u *)"help", (long_u )2052}, 
        {(char_u *)"helpfind", (long_u )2052}, 
        {(char_u *)"highlight", (long_u )262406}, 
        {(char_u *)"hide", (long_u )258}, 
        {(char_u *)"history", (long_u )260}, 
        {(char_u *)"insert", (long_u )259}, 
        {(char_u *)"iabbrev", (long_u )10500}, 
        {(char_u *)"iabclear", (long_u )256}, 
        {(char_u *)"if", (long_u )264196}, 
        {(char_u *)"ijump", (long_u )39}, 
        {(char_u *)"ilist", (long_u )39}, 
        {(char_u *)"imap", (long_u )10500}, 
        {(char_u *)"imapclear", (long_u )256}, 
        {(char_u *)"imenu", (long_u )30981}, 
        {(char_u *)"inoremap", (long_u )10500}, 
        {(char_u *)"inoreabbrev", (long_u )10500}, 
        {(char_u *)"inoremenu", (long_u )30981}, 
        {(char_u *)"intro", (long_u )256}, 
        {(char_u *)"isearch", (long_u )39}, 
        {(char_u *)"isplit", (long_u )39}, 
        {(char_u *)"iunmap", (long_u )10500}, 
        {(char_u *)"iunabbrev", (long_u )10500}, 
        {(char_u *)"iunmenu", (long_u )10500}, 
        {(char_u *)"join", (long_u )1283}, 
        {(char_u *)"jumps", (long_u )256}, 
        {(char_u *)"k", (long_u )262421}, 
        {(char_u *)"list", (long_u )1281}, 
        {(char_u *)"last", (long_u )33030}, 
        {(char_u *)"left", (long_u )261}, 
        {(char_u *)"let", (long_u )264196}, 
        {(char_u *)"ls", (long_u )256}, 
        {(char_u *)"move", (long_u )261}, 
        {(char_u *)"mark", (long_u )262421}, 
        {(char_u *)"make", (long_u )2316}, 
        {(char_u *)"map", (long_u )10502}, 
        {(char_u *)"mapclear", (long_u )258}, 
        {(char_u *)"marks", (long_u )260}, 
        {(char_u *)"menu", (long_u )30983}, 
        {(char_u *)"messages", (long_u )256}, 
        {(char_u *)"mkexrc", (long_u )286}, 
        {(char_u *)"mksession", (long_u )286}, 
        {(char_u *)"mkvimrc", (long_u )286}, 
        {(char_u *)"mode", (long_u )276}, 
        {(char_u *)"next", (long_u )49487}, 
        {(char_u *)"new", (long_u )49439}, 
        {(char_u *)"nmap", (long_u )10500}, 
        {(char_u *)"nmapclear", (long_u )256}, 
        {(char_u *)"nmenu", (long_u )30981}, 
        {(char_u *)"nnoremap", (long_u )10500}, 
        {(char_u *)"nnoremenu", (long_u )30981}, 
        {(char_u *)"noremap", (long_u )10502}, 
        {(char_u *)"nohlsearch", (long_u )262400}, 
        {(char_u *)"noreabbrev", (long_u )10500}, 
        {(char_u *)"noremenu", (long_u )30983}, 
        {(char_u *)"normal", (long_u )272519}, 
        {(char_u *)"number", (long_u )1281}, 
        {(char_u *)"nunmap", (long_u )10500}, 
        {(char_u *)"nunmenu", (long_u )10500}, 
        {(char_u *)"open", (long_u )256}, 
        {(char_u *)"omap", (long_u )10500}, 
        {(char_u *)"omapclear", (long_u )256}, 
        {(char_u *)"omenu", (long_u )30981}, 
        {(char_u *)"only", (long_u )258}, 
        {(char_u *)"onoremap", (long_u )10500}, 
        {(char_u *)"onoremenu", (long_u )30981}, 
        {(char_u *)"options", (long_u )256}, 
        {(char_u *)"ounmap", (long_u )10500}, 
        {(char_u *)"ounmenu", (long_u )10500}, 
        {(char_u *)"print", (long_u )1281}, 
        {(char_u *)"pclose", (long_u )258}, 
        {(char_u *)"perl", (long_u )262309}, 
        {(char_u *)"perldo", (long_u )262309}, 
        {(char_u *)"pop", (long_u )21763}, 
        {(char_u *)"ppop", (long_u )21763}, 
        {(char_u *)"preserve", (long_u )256}, 
        {(char_u *)"previous", (long_u )50439}, 
        {(char_u *)"promptfind", (long_u )2052}, 
        {(char_u *)"promptrepl", (long_u )2052}, 
        {(char_u *)"ptag", (long_u )20759}, 
        {(char_u *)"ptNext", (long_u )20739}, 
        {(char_u *)"ptjump", (long_u )278}, 
        {(char_u *)"ptlast", (long_u )258}, 
        {(char_u *)"ptnext", (long_u )20739}, 
        {(char_u *)"ptprevious", (long_u )20739}, 
        {(char_u *)"ptrewind", (long_u )20739}, 
        {(char_u *)"ptselect", (long_u )278}, 
        {(char_u *)"put", (long_u )4867}, 
        {(char_u *)"pwd", (long_u )256}, 
        {(char_u *)"python", (long_u )262277}, 
        {(char_u *)"pyfile", (long_u )262301}, 
        {(char_u *)"quit", (long_u )258}, 
        {(char_u *)"qall", (long_u )258}, 
        {(char_u *)"read", (long_u )4447}, 
        {(char_u *)"recover", (long_u )286}, 
        {(char_u *)"redo", (long_u )256}, 
        {(char_u *)"redir", (long_u )270}, 
        {(char_u *)"registers", (long_u )2308}, 
        {(char_u *)"resize", (long_u )276}, 
        {(char_u *)"retab", (long_u )311}, 
        {(char_u *)"return", (long_u )264196}, 
        {(char_u *)"rewind", (long_u )33030}, 
        {(char_u *)"right", (long_u )261}, 
        {(char_u *)"rviminfo", (long_u )286}, 
        {(char_u *)"substitute", (long_u )5}, 
        {(char_u *)"sNext", (long_u )50439}, 
        {(char_u *)"sargument", (long_u )50439}, 
        {(char_u *)"sall", (long_u )17665}, 
        {(char_u *)"sbuffer", (long_u )83207}, 
        {(char_u *)"sbNext", (long_u )17665}, 
        {(char_u *)"sball", (long_u )17665}, 
        {(char_u *)"sblast", (long_u )256}, 
        {(char_u *)"sbmodified", (long_u )17665}, 
        {(char_u *)"sbnext", (long_u )17665}, 
        {(char_u *)"sbprevious", (long_u )17665}, 
        {(char_u *)"sbrewind", (long_u )256}, 
        {(char_u *)"set", (long_u )260}, 
        {(char_u *)"sfind", (long_u )49439}, 
        {(char_u *)"shell", (long_u )256}, 
        {(char_u *)"sleep", (long_u )17669}, 
        {(char_u *)"slast", (long_u )33030}, 
        {(char_u *)"smagic", (long_u )5}, 
        {(char_u *)"snext", (long_u )49487}, 
        {(char_u *)"sniff", (long_u )260}, 
        {(char_u *)"snomagic", (long_u )5}, 
        {(char_u *)"source", (long_u )262494}, 
        {(char_u *)"split", (long_u )49439}, 
        {(char_u *)"sprevious", (long_u )50439}, 
        {(char_u *)"srewind", (long_u )33030}, 
        {(char_u *)"stop", (long_u )258}, 
        {(char_u *)"stag", (long_u )20759}, 
        {(char_u *)"startinsert", (long_u )258}, 
        {(char_u *)"stjump", (long_u )278}, 
        {(char_u *)"stselect", (long_u )278}, 
        {(char_u *)"sunhide", (long_u )17665}, 
        {(char_u *)"suspend", (long_u )258}, 
        {(char_u *)"sview", (long_u )33183}, 
        {(char_u *)"swapname", (long_u )256}, 
        {(char_u *)"syntax", (long_u )2052}, 
        {(char_u *)"syncbind", (long_u )256}, 
        {(char_u *)"t", (long_u )261}, 
        {(char_u *)"tNext", (long_u )20739}, 
        {(char_u *)"tag", (long_u )20759}, 
        {(char_u *)"tags", (long_u )256}, 
        {(char_u *)"tcl", (long_u )262277}, 
        {(char_u *)"tcldo", (long_u )262309}, 
        {(char_u *)"tclfile", (long_u )262301}, 
        {(char_u *)"tearoff", (long_u )2436}, 
        {(char_u *)"tjump", (long_u )278}, 
        {(char_u *)"tlast", (long_u )258}, 
        {(char_u *)"tmenu", (long_u )30981}, 
        {(char_u *)"tnext", (long_u )20739}, 
        {(char_u *)"tprevious", (long_u )20739}, 
        {(char_u *)"trewind", (long_u )20739}, 
        {(char_u *)"tselect", (long_u )278}, 
        {(char_u *)"tunmenu", (long_u )10500}, 
        {(char_u *)"undo", (long_u )256}, 
        {(char_u *)"unabbreviate", (long_u )10500}, 
        {(char_u *)"unhide", (long_u )17665}, 
        {(char_u *)"unlet", (long_u )262534}, 
        {(char_u *)"unmap", (long_u )10502}, 
        {(char_u *)"unmenu", (long_u )10502}, 
        {(char_u *)"update", (long_u )319}, 
        {(char_u *)"vglobal", (long_u )37}, 
        {(char_u *)"version", (long_u )260}, 
        {(char_u *)"visual", (long_u )33055}, 
        {(char_u *)"view", (long_u )33055}, 
        {(char_u *)"vmap", (long_u )10500}, 
        {(char_u *)"vmapclear", (long_u )256}, 
        {(char_u *)"vmenu", (long_u )30981}, 
        {(char_u *)"vnoremap", (long_u )10500}, 
        {(char_u *)"vnoremenu", (long_u )30981}, 
        {(char_u *)"vunmap", (long_u )10500}, 
        {(char_u *)"vunmenu", (long_u )10500}, 
        {(char_u *)"write", (long_u )319}, 
        {(char_u *)"wNext", (long_u )16671}, 
        {(char_u *)"wall", (long_u )258}, 
        {(char_u *)"while", (long_u )264196}, 
        {(char_u *)"winsize", (long_u )388}, 
        {(char_u *)"winpos", (long_u )260}, 
        {(char_u *)"wnext", (long_u )16671}, 
        {(char_u *)"wprevious", (long_u )16671}, 
        {(char_u *)"wq", (long_u )319}, 
        {(char_u *)"wqall", (long_u )318}, 
        {(char_u *)"wviminfo", (long_u )286}, 
        {(char_u *)"xit", (long_u )319}, 
        {(char_u *)"xall", (long_u )258}, 
        {(char_u *)"yank", (long_u )1793}, 
        {(char_u *)"z", (long_u )261}, 
        {(char_u *)"!", (long_u )79}, 
        {(char_u *)"#", (long_u )1281}, 
        {(char_u *)"&", (long_u )5}, 
        {(char_u *)"*", (long_u )261}, 
        {(char_u *)"<", (long_u )1281}, 
        {(char_u *)"=", (long_u )257}, 
        {(char_u *)">", (long_u )1281}, 
        {(char_u *)"@", (long_u )261}, 
        {(char_u *)"Next", (long_u )50439}, 
        {(char_u *)"Print", (long_u )1281}, 
        {(char_u *)"X", (long_u )256}, 
        {(char_u *)"~", (long_u )5}};
static int quitmore  =    0;
static int ex_pressedreturn  =    0;
struct growarray ucmds  =    {0, 0, (int )sizeof(UCMD ), 4, (void *)0};
static void do_ucmd(UCMD *cmd , EXARG *eap ) ;
static void do_command(EXARG *eap ) ;
static void do_comclear(void) ;
static void do_delcommand(EXARG *eap ) ;
static char_u *get_user_command_name(int idx ) ;
static void free_cmdlines(struct growarray *gap ) ;
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) ;
static char_u *getargcmd(char_u **argp ) ;
static char_u *skip_cmd_arg(char_u *p___0 ) ;
static void do_make(char_u *arg , char_u *errorformat ) ;
static char_u *get_mef_name(int newname ) ;
static void do_cfile(EXARG *eap ) ;
static int do_arglist(char_u *str___1 ) ;
static int check_more(int message , int forceit ) ;
static linenr_t get_address(char_u **ptr , int skip ) ;
static char_u *invalid_range(EXARG *eap ) ;
static void correct_range(EXARG *eap ) ;
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) ;
static void do_quit(EXARG *eap ) ;
static void do_quit_all(int forceit ) ;
static void do_close(EXARG *eap , WIN *win ) ;
static void do_pclose(EXARG *eap ) ;
static void do_suspend(int forceit ) ;
static void do_exit(EXARG *eap ) ;
static void do_print(EXARG *eap ) ;
static void do_next(EXARG *eap ) ;
static void do_recover(EXARG *eap ) ;
static void do_args(EXARG *eap ) ;
static void do_resize(EXARG *eap ) ;
static void do_splitview(EXARG *eap ) ;
static void do_find(EXARG *eap ) ;
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) ;
static void do_swapname(void) ;
static void do_syncbind(void) ;
static void do_read(EXARG *eap ) ;
static void do_cd(EXARG *eap ) ;
static void do_pwd(void) ;
static void do_sleep(EXARG *eap ) ;
static void do_exmap(EXARG *eap , int isabbrev ) ;
static void do_winsize(char_u *arg ) ;
static void do_winpos(char_u *arg ) ;
static void do_exops(EXARG *eap ) ;
static void do_copymove(EXARG *eap ) ;
static void do_exjoin(EXARG *eap ) ;
static void do_exat(EXARG *eap ) ;
static void do_redir(EXARG *eap ) ;
static void close_redir(void) ;
static void do_mkrc(EXARG *eap , char_u *defname ) ;
static FILE *open_exfile(EXARG *eap , char *mode ) ;
static void do_setmark(EXARG *eap ) ;
static void do_normal(EXARG *eap ) ;
static char_u *do_findpat(EXARG *eap , int action ) ;
static void do_ex_tag(EXARG *eap , int dt , int preview ) ;
static char_u *do_if(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_else(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_while(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_continue(struct condstack *cstack ) ;
static char_u *do_break(struct condstack *cstack ) ;
static char_u *do_endwhile(struct condstack *cstack ) ;
static int has_while_cmd(char_u *p___0 ) ;
static int did_endif  =    0;
static int makeopens(FILE *fd ) ;
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) ;
static int ses_fname(FILE *fd , BUF *buf___3 ) ;
static void cmd_source(char_u *fname , int forceit ) ;
static void ex_behave(char_u *arg ) ;
static void ex_filetype(char_u *arg ) ;
static void ex_options(void) ;
CMDIDX cmdidxs[27]  = 
  {      (CMDIDX )0,      (CMDIDX )12,      (CMDIDX )27,      (CMDIDX )64, 
        (CMDIDX )75,      (CMDIDX )88,      (CMDIDX )94,      (CMDIDX )99, 
        (CMDIDX )104,      (CMDIDX )122,      (CMDIDX )124,      (CMDIDX )125, 
        (CMDIDX )130,      (CMDIDX )142,      (CMDIDX )157,      (CMDIDX )167, 
        (CMDIDX )189,      (CMDIDX )191,      (CMDIDX )202,      (CMDIDX )238, 
        (CMDIDX )254,      (CMDIDX )261,      (CMDIDX )272,      (CMDIDX )283, 
        (CMDIDX )285,      (CMDIDX )286,      (CMDIDX )287};
void do_exmode(void) 
{ 
  int save_msg_scroll ;
  int prev_msg_row ;
  linenr_t prev_line ;

  {
  {
  save_msg_scroll = msg_scroll;
  RedrawingDisabled ++;
  no_wait_return ++;
  settmode(0);
  State = 1;
  exmode_active = 1;
  msg((char_u *)"Entering Ex mode.  Type \"visual\" to go to Normal mode.");
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! exmode_active) {
      goto while_break;
    }
    {
    msg_scroll = 1;
    need_wait_return = 0;
    ex_pressedreturn = 0;
    ex_no_reprint = 0;
    prev_msg_row = msg_row;
    prev_line = curwin->w_cursor.lnum;
    do_cmdline((char_u *)((void *)0), & getexmodeline, (void *)0, 2);
    lines_left = (int )(Rows - 1L);
    }
    if (prev_line != curwin->w_cursor.lnum) {















    } else { //Added block
    _L: ;
    if (ex_pressedreturn) {
      {

      }
    }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  settmode(2);
  RedrawingDisabled --;
  no_wait_return --;
  update_screen(50);
  need_wait_return = 0;
  msg_scroll = save_msg_scroll;
  }
  return;
}
}
static int recursive  =    0;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) 
{ 
  char_u *next_cmdline ;
  char_u *cmdline_copy ;
  int msg_didout_before_start ;
  int count___2 ;
  int did_inc ;
  int retval ;
  int save_confirm ;
  struct condstack cstack ;
  struct growarray lines_ga ;
  int current_line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  cmdline_copy = (char_u *)((void *)0);
  msg_didout_before_start = 0;
  count___2 = 0;
  did_inc = 0;
  retval = 1;
  save_confirm = confirm;
  current_line = 0;
  cstack.cs_idx = -1;
  cstack.cs_whilelevel = 0;
  cstack.cs_had_while = (char)0;
  cstack.cs_had_endwhile = (char)0;
  cstack.cs_had_continue = (char)0;
  ga_init2(& lines_ga, (int )sizeof(char_u *), 10);
  confirm = 0;
  did_emsg = 0;
  }
  if ((unsigned long )getline___0 != (unsigned long )(& getexline)) {
    KeyTyped = 0;
  }
  next_cmdline = cmdline;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      if (cstack.cs_idx < 0) {
        did_emsg = 0;
      }
    }
    if (cstack.cs_whilelevel) {
















    }
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      if (count___2 == 1) {



      }
      if ((unsigned long )getline___0 == (unsigned long )((void *)0)) {

      } else {
        if (cstack.cs_idx < 0) {
          tmp___0 = 0;
        } else {

        }
        {
        next_cmdline = (*getline___0)(':', cookie, tmp___0);
        }
        if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
          _L: ;





        }
      }
    } else { //Added block
    if ((unsigned long )cmdline_copy == (unsigned long )((void *)0)) {
      {
      next_cmdline = vim_strsave(next_cmdline);
      }
      if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {


      }
    }
    }
    cmdline_copy = next_cmdline;
    if (current_line == lines_ga.ga_len) {
      if (cstack.cs_whilelevel) {

      } else {
        {
        tmp___1 = has_while_cmd(next_cmdline);
        }
        if (tmp___1) {
          _L___0: ;
          {

          }







        }
      }
    }
    did_endif = 0;
    tmp___3 = count___2;
    count___2 ++;
    if (tmp___3 == 0) {
      if (! (flags___0 & 2)) {
        if (! recursive) {
          {
          msg_didout_before_start = msg_didout;
          msg_didany = 0;
          msg_start();
          msg_scroll = 1;
          no_wait_return ++;
          RedrawingDisabled ++;
          did_inc = 1;
          }
        }
      }
    }
    {
    recursive ++;
    next_cmdline = do_one_cmd(& cmdline_copy, flags___0 & 1, & cstack, getline___0,
                              cookie);
    recursive --;
    }
    if ((unsigned long )next_cmdline == (unsigned long )((void *)0)) {
      {
      vim_free((void *)cmdline_copy);
      cmdline_copy = (char_u *)((void *)0);
      }
      if ((unsigned long )getline___0 == (unsigned long )(& getexline)) {
        if ((unsigned long )new_last_cmdline != (unsigned long )((void *)0)) {
          {
          vim_free((void *)last_cmdline);
          last_cmdline = new_last_cmdline;
          new_last_cmdline = (char_u *)((void *)0);
          }
        }
      }
    } else {
      {
      tmp___4 = strlen((char const   *)((char *)next_cmdline));
      memmove((void *)((char *)cmdline_copy), (void const   *)((char *)next_cmdline),
              tmp___4 + 1UL);
      next_cmdline = cmdline_copy;
      }
    }
    if (did_emsg) {
      if ((unsigned long )getline___0 == (unsigned long )(& get_func_line)) {
        {

        }



      }
    }
    if (cstack.cs_whilelevel) {















































    }
    if (! cstack.cs_whilelevel) {
      {
      free_cmdlines(& lines_ga);
      current_line = 0;
      }
    }
    if (! got_int) {
      if (did_emsg) {
        if ((unsigned long )getline___0 == (unsigned long )(& getexmodeline)) {
          goto while_break;
        } else { //Added block
        if ((unsigned long )getline___0 == (unsigned long )(& getexline)) {
          goto while_break;
        } else {

        }
        }
      } else { //Added block
      _L___6: ;
      if (! ((unsigned long )next_cmdline != (unsigned long )((void *)0))) {
        if (! (cstack.cs_idx >= 0)) {
          if (! (flags___0 & 4)) {
            goto while_break;
          }
        }
      }
      }
    } else {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)cmdline_copy);
  free_cmdlines(& lines_ga);
  ga_clear(& lines_ga);
  }
  if (cstack.cs_idx >= 0) {





















  }
  if (did_inc) {
    RedrawingDisabled --;
    no_wait_return --;
    msg_scroll = 0;
    if (retval == 0) {
      {



      }
    } else { //Added block
    if (did_endif) {













    } else { //Added block
    _L___9: ;
    if (need_wait_return) {
      {
      msg_didout = msg_didout_before_start;
      wait_return(0);
      }
    }
    }
    }
  }
  confirm = save_confirm;
  return (retval);
}
}
static void free_cmdlines(struct growarray *gap ) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! gap->ga_len) {
      goto while_break;
    }
    {



    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  linenr_t lnum ;
  long n ;
  char_u *errormsg ;
  EXARG ea ;
  int tmp ;
  FPOS *fp___0 ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  UCMD *cmd ;
  int j ;
  int k ;
  int matchlen ;
  int found ;
  int possible ;
  char_u *cp ;
  char_u *np___0 ;
  unsigned short const   **tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  char_u *new_cmdline ;
  char_u *program ;
  char_u *pos___0 ;
  char_u *ptr ;
  int len___0 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char_u *tmp___18 ;
  char_u *tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  char_u *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;

  {
  {
  errormsg = (char_u *)((void *)0);
  memset((void *)(& ea), 0, sizeof(ea));
  ea.line1 = (linenr_t )1;
  ea.line2 = (linenr_t )1;
  }
  if (quitmore) {
    if ((unsigned long )getline___0 != (unsigned long )(& get_func_line)) {
      quitmore --;
    }
  }
  ea.cmd = *cmdlinep;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*(ea.cmd) == 32)) {
      if (! ((int )*(ea.cmd) == 9)) {
        if (! ((int )*(ea.cmd) == 58)) {
          goto while_break;
        }
      }
    }
    (ea.cmd) ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*(ea.cmd) == 0) {






  }
  if ((int )*(ea.cmd) == 34) {

  } else { //Added block
  if ((int )*(ea.cmd) == 0) {

  }
  }
  if (did_emsg) {

  } else { //Added block
  if (cstack->cs_idx >= 0) {





  } else {
    tmp = 0;
  }
  }
  ea.skip = tmp;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    {
    ea.line1 = ea.line2;
    ea.line2 = curwin->w_cursor.lnum;
    ea.cmd = skipwhite(ea.cmd);
    lnum = get_address(& ea.cmd, ea.skip);
    }
    if ((unsigned long )ea.cmd == (unsigned long )((void *)0)) {
      goto doend;
    }
    if (lnum == 2147483647L) {
      if ((int )*(ea.cmd) == 37) {




      } else { //Added block
      if ((int )*(ea.cmd) == 42) {
        {

        }






















      }
      }
    } else {
      ea.line2 = lnum;
    }
    (ea.addr_count) ++;
    if ((int )*(ea.cmd) == 59) {
      if (! ea.skip) {
        curwin->w_cursor.lnum = ea.line2;
      }
    } else { //Added block
    if ((int )*(ea.cmd) != 44) {
      goto while_break___0;
    }
    }
    (ea.cmd) ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (ea.addr_count == 1) {
    ea.line1 = ea.line2;
    if (lnum == 2147483647L) {
      ea.addr_count = 0;
    }
  }
  {
  check_cursor_lnum();
  ea.cmd = skipwhite(ea.cmd);
  }
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! ((int )*(ea.cmd) == 58)) {
      goto while_break___1;
    }
    {

    }
  }
  while_break___1: ;/* CIL Label */ ;
  }
  if ((int )*(ea.cmd) == 0) {
    goto _L;
  } else { //Added block
  if ((int )*(ea.cmd) == 34) {

  } else {
    {
    ea.nextcmd = check_nextcmd(ea.cmd);
    }
    if ((unsigned long )ea.nextcmd != (unsigned long )((void *)0)) {
      _L: ;
      if (ea.skip) {

      }
      if ((int )*(ea.cmd) == 124) {
        {



        }






      } else { //Added block
      if (ea.addr_count != 0) {
        if (ea.line2 < 0L) {
          {

          }
        } else { //Added block
        if (ea.line2 == 0L) {

        } else { //Added block
        if (ea.line2 > curbuf->b_ml.ml_line_count) {

        } else {
          curwin->w_cursor.lnum = ea.line2;
        }
        }
        }
        {
        beginline(6);
        }
      }
      }
      goto doend;
    }
  }
  }
  if ((int )*(ea.cmd) == 107) {


  } else { //Added block
  if ((int )*(ea.cmd + 0) == 115) {
    if ((int )*(ea.cmd + 1) == 99) {


    } else { //Added block
    if ((int )*(ea.cmd + 1) == 103) {


    } else { //Added block
    if ((int )*(ea.cmd + 1) == 105) {






    } else { //Added block
    _L___3: ;
    if ((int )*(ea.cmd + 1) == 73) {


    } else { //Added block
    if ((int )*(ea.cmd + 1) == 114) {






    } else {
      goto _L___2;
    }
    }
    }
    }
    }
  } else {
    _L___2: ;
    p___0 = ea.cmd;
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      {
      tmp___3 = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp___3 + (int )*p___0) & 1024)) {
        goto while_break___2;
      }
      p___0 ++;
    }
    while_break___2: ;/* CIL Label */ ;
    }
    if ((unsigned long )p___0 == (unsigned long )ea.cmd) {
      {
      tmp___4 = vim_strchr((char_u *)"@*!=><&~#", (int )*p___0);
      }
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        p___0 ++;
      }
    }
    i___0 = (int )(p___0 - ea.cmd);
    if ((int )*(ea.cmd) >= 97) {
      if ((int )*(ea.cmd) <= 122) {
        ea.cmdidx = cmdidxs[(int )*(ea.cmd) - 97];
      } else {

      }
    } else {
      ea.cmdidx = cmdidxs[26];
    }
    {
    while (1) {
      while_continue___3: ;/* CIL Label */ ;
      if (! ((int )ea.cmdidx < 299)) {

      }
      {
      tmp___5 = strncmp((char const   *)((char *)cmdnames[(int )ea.cmdidx].cmd_name),
                        (char const   *)((char *)ea.cmd), (size_t )i___0);
      }
      if (tmp___5 == 0) {
        goto while_break___3;
      }
      ea.cmdidx = (CMDIDX )((int )ea.cmdidx + 1);
    }
    while_break___3: ;/* CIL Label */ ;
    }
    if ((int )ea.cmdidx == 299) {




































































































    }
    if (i___0 == 0) {

    } else { //Added block
    if ((int )ea.cmdidx == 299) {
      _L___1: ;














    }
    }
  }
  }
  if ((int )*p___0 == 33) {
    if ((int )ea.cmdidx != 202) {
      p___0 ++;
      ea.forceit = 1;
    } else {

    }
  } else {
    ea.forceit = 0;
  }
  if ((int )ea.cmdidx != -1) {
    ea.argt = (long )cmdnames[(int )ea.cmdidx].cmd_argt;
  }
  if (sandbox != 0) {




  }
  if (! (ea.argt & 1L)) {
    if (ea.addr_count) {


    }
  }
  if (! (ea.argt & 2L)) {
    if (ea.forceit) {





    }
  }
  if (! ea.skip) {
    if (! global_busy) {
      if (ea.line1 > ea.line2) {














      }
    }
    {
    errormsg = invalid_range(& ea);
    }
    if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
      goto doend;
    }
  }
  if (ea.argt & 16384L) {
    if (ea.addr_count == 0) {
      ea.line2 = (linenr_t )1;
    }
  }
  {
  correct_range(& ea);
  }
  if ((int )ea.cmdidx == 132) {

  } else { //Added block
  if ((int )ea.cmdidx == 96) {
    _L___4: ;





    {



    }


































































    {




    }
  }
  }
  if ((int )ea.cmdidx == 287) {
    ea.arg = p___0;
  } else {
    {
    ea.arg = skipwhite(p___0);
    }
  }
  if ((int )ea.cmdidx == 272) {
    goto _L___5;
  } else { //Added block
  if ((int )ea.cmdidx == 260) {
    _L___5: ;
    if ((int )*(ea.arg) == 62) {
      (ea.arg) ++;
      if ((int )*(ea.arg) != 62) {


      }
      {
      ea.arg = skipwhite(ea.arg + 1);
      ea.append = 1;
      }
    } else { //Added block
    if ((int )*(ea.arg) == 33) {




    }
    }
  }
  }
  if ((int )ea.cmdidx == 191) {









  }
  if ((int )ea.cmdidx == 291) {

  } else { //Added block
  if ((int )ea.cmdidx == 293) {
    _L___6: ;

    {








    while_break___9: ;/* CIL Label */ ;
    }
    {

    }
  }
  }
  if (ea.argt & 32768L) {
    if (! ea.usefilter) {
      {
      ea.do_ecmd_cmd = getargcmd(& ea.arg);
      }
    }
  }
  if (ea.argt & 256L) {
    if (! ea.usefilter) {
      {
      separate_nextcmd(& ea);
      }
    } else {

    }
  } else { //Added block
  _L___9: ;
  if ((int )ea.cmdidx == 287) {
    goto _L___8;
  } else { //Added block
  if (ea.usefilter) {
    _L___8: ;
    p___0 = ea.arg;
    {
    while (1) {
      while_continue___10: ;/* CIL Label */ ;
      if (! *p___0) {
        goto while_break___10;
      }
      if ((int )*p___0 == 92) {





      } else { //Added block
      _L___7: ;
      if ((int )*p___0 == 10) {



      }
      }
      p___0 ++;
    }
    while_break___10: ;/* CIL Label */ ;
    }
  }
  }
  }
  if (ea.argt & 32L) {
    if (ea.addr_count == 0) {
      ea.line1 = (linenr_t )1;
      ea.line2 = curbuf->b_ml.ml_line_count;
    }
  }
  if (ea.argt & 512L) {

















































  }
  if (ea.argt & 1024L) {
    {
    tmp___24 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___24 + (int )*(ea.arg)) & 2048) {
      if (! (ea.argt & 65536L)) {
        goto _L___13;
      } else {
        {

        }
        if ((int )*p___0 == 0) {

        } else { //Added block
        if ((int )*p___0 == 32) {

        } else { //Added block
        if ((int )*p___0 == 9) {
          _L___13: ;
          {
          n = getdigits(& ea.arg);
          ea.arg = skipwhite(ea.arg);
          }
          if (n <= 0L) {


          }
          if (ea.argt & 16384L) {
            ea.line2 = n;
            if (ea.addr_count == 0) {
              ea.addr_count = 1;
            }
          } else {
            ea.line1 = ea.line2;
            ea.line2 += n - 1L;
            (ea.addr_count) ++;
            if (ea.line2 > curbuf->b_ml.ml_line_count) {

            }
          }
        }
        }
        }
      }
    }
  }
  if (! (ea.argt & 4L)) {
    if ((int )*(ea.arg) != 0) {
      {
      tmp___25 = vim_strchr((char_u *)"|\"", (int )*(ea.arg));
      }
      if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
        errormsg = e_trailing;
        goto doend;
      }
    }
  }
  if (ea.argt & 128L) {
    if ((int )*(ea.arg) == 0) {


    }
  }
  if (ea.argt & 8L) {
    {
    tmp___26 = expand_filename(& ea, cmdlinep, & errormsg);
    }
    if (tmp___26 == 0) {
      goto doend;
    }
  }
  if (ea.skip) {
    {





















































































    case_275: ;/* CIL Label */ 
    case_84: ;/* CIL Label */ 
    case_107: ;/* CIL Label */ 
    case_80: ;/* CIL Label */ 
    case_79: ;/* CIL Label */ 
    case_82: ;/* CIL Label */ 
    case_93: ;/* CIL Label */ 

    case_31: ;/* CIL Label */ 
    case_69: ;/* CIL Label */ 
    case_70: ;/* CIL Label */ 
    case_73: ;/* CIL Label */ 
    case_74: ;/* CIL Label */ 
    case_76: ;/* CIL Label */ 
    case_78: ;/* CIL Label */ 
    case_86: ;/* CIL Label */ 
    case_99: ;/* CIL Label */ 
    case_108: ;/* CIL Label */ 
    case_109: ;/* CIL Label */ 
    case_117: ;/* CIL Label */ 
    case_118: ;/* CIL Label */ 
    case_128: ;/* CIL Label */ 
    case_198: ;/* CIL Label */ 
    case_202: ;/* CIL Label */ 
    case_219: ;/* CIL Label */ 
    case_222: ;/* CIL Label */ 
    case_236: ;/* CIL Label */ 
    case_289: ;/* CIL Label */ 
    case_298: ;/* CIL Label */ 

    switch_default: ;/* CIL Label */ 

    switch_break: ;/* CIL Label */ ;
    }
  }
  if (ea.argt & 65536L) {

















































  }
  {
  if ((int )ea.cmdidx == 189) {
    goto case_189;
  }
  if ((int )ea.cmdidx == 190) {
    goto case_190;
  }
  if ((int )ea.cmdidx == 40) {

  }
  if ((int )ea.cmdidx == 168) {

  }
  if ((int )ea.cmdidx == 102) {

  }
  if ((int )ea.cmdidx == 161) {

  }
  if ((int )ea.cmdidx == 227) {

  }
  if ((int )ea.cmdidx == 233) {

  }
  if ((int )ea.cmdidx == 87) {

  }
  if ((int )ea.cmdidx == 283) {
    goto case_87;
  }
  if ((int )ea.cmdidx == 280) {
    goto case_87;
  }
  if ((int )ea.cmdidx == 284) {

  }
  if ((int )ea.cmdidx == 281) {

  }
  if ((int )ea.cmdidx == 274) {
    goto case_274;
  }
  if ((int )ea.cmdidx == 173) {

  }
  if ((int )ea.cmdidx == 192) {

  }
  if ((int )ea.cmdidx == 6) {
    goto case_6;
  }
  if ((int )ea.cmdidx == 278) {
    goto case_278;
  }
  if ((int )ea.cmdidx == 273) {

  }
  if ((int )ea.cmdidx == 279) {

  }
  if ((int )ea.cmdidx == 142) {
    goto case_142;
  }
  if ((int )ea.cmdidx == 220) {
    goto case_142;
  }
  if ((int )ea.cmdidx == 174) {

  }
  if ((int )ea.cmdidx == 225) {

  }
  if ((int )ea.cmdidx == 295) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 203) {
    goto case_174;
  }
  if ((int )ea.cmdidx == 199) {
    goto case_199;
  }
  if ((int )ea.cmdidx == 226) {

  }
  if ((int )ea.cmdidx == 126) {
    goto case_126;
  }
  if ((int )ea.cmdidx == 218) {
    goto case_126;
  }
  if ((int )ea.cmdidx == 7) {

  }
  if ((int )ea.cmdidx == 204) {
    goto case_7;
  }
  if ((int )ea.cmdidx == 3) {
    goto case_3;
  }
  if ((int )ea.cmdidx == 205) {

  }
  if ((int )ea.cmdidx == 12) {

  }
  if ((int )ea.cmdidx == 206) {

  }
  if ((int )ea.cmdidx == 19) {

  }
  if ((int )ea.cmdidx == 210) {

  }
  if ((int )ea.cmdidx == 20) {

  }
  if ((int )ea.cmdidx == 211) {

  }
  if ((int )ea.cmdidx == 13) {

  }
  if ((int )ea.cmdidx == 21) {

  }
  if ((int )ea.cmdidx == 207) {

  }
  if ((int )ea.cmdidx == 212) {

  }
  if ((int )ea.cmdidx == 22) {

  }
  if ((int )ea.cmdidx == 213) {

  }
  if ((int )ea.cmdidx == 18) {

  }
  if ((int )ea.cmdidx == 209) {

  }
  if ((int )ea.cmdidx == 26) {

  }
  if ((int )ea.cmdidx == 16) {

  }
  if ((int )ea.cmdidx == 256) {

  }
  if ((int )ea.cmdidx == 232) {

  }
  if ((int )ea.cmdidx == 14) {

  }
  if ((int )ea.cmdidx == 208) {

  }
  if ((int )ea.cmdidx == 25) {

  }
  if ((int )ea.cmdidx == 89) {
    goto case_25;
  }
  if ((int )ea.cmdidx == 129) {

  }
  if ((int )ea.cmdidx == 260) {
    goto case_260;
  }
  if ((int )ea.cmdidx == 272) {
    goto case_272;
  }
  if ((int )ea.cmdidx == 141) {
    goto case_141;
  }
  if ((int )ea.cmdidx == 196) {

  }
  if ((int )ea.cmdidx == 234) {

  }
  if ((int )ea.cmdidx == 224) {

  }
  if ((int )ea.cmdidx == 143) {

  }
  if ((int )ea.cmdidx == 215) {

  }
  if ((int )ea.cmdidx == 75) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 85) {

  }
  if ((int )ea.cmdidx == 263) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 264) {
    goto case_75;
  }
  if ((int )ea.cmdidx == 15) {

  }
  if ((int )ea.cmdidx == 91) {

  }
  if ((int )ea.cmdidx == 98) {

  }
  if ((int )ea.cmdidx == 97) {

  }
  if ((int )ea.cmdidx == 81) {

  }
  if ((int )ea.cmdidx == 17) {

  }
  if ((int )ea.cmdidx == 90) {

  }
  if ((int )ea.cmdidx == 24) {

  }
  if ((int )ea.cmdidx == 55) {

  }
  if ((int )ea.cmdidx == 88) {
    goto case_88;
  }
  if ((int )ea.cmdidx == 235) {

  }
  if ((int )ea.cmdidx == 237) {

  }
  if ((int )ea.cmdidx == 191) {

  }
  if ((int )ea.cmdidx == 33) {
    goto case_33;
  }
  if ((int )ea.cmdidx == 36) {

  }
  if ((int )ea.cmdidx == 186) {
    goto case_186;
  }
  if ((int )ea.cmdidx == 292) {

  }
  if ((int )ea.cmdidx == 125) {
    goto case_125;
  }
  if ((int )ea.cmdidx == 154) {

  }
  if ((int )ea.cmdidx == 288) {

  }
  if ((int )ea.cmdidx == 167) {
    goto case_154;
  }
  if ((int )ea.cmdidx == 296) {

  }
  if ((int )ea.cmdidx == 95) {

  }
  if ((int )ea.cmdidx == 216) {

  }
  if ((int )ea.cmdidx == 217) {

  }
  if ((int )ea.cmdidx == 177) {

  }
  if ((int )ea.cmdidx == 228) {

  }
  if ((int )ea.cmdidx == 240) {

  }
  if ((int )ea.cmdidx == 184) {

  }
  if ((int )ea.cmdidx == 231) {

  }
  if ((int )ea.cmdidx == 252) {

  }
  if ((int )ea.cmdidx == 179) {

  }
  if ((int )ea.cmdidx == 230) {

  }
  if ((int )ea.cmdidx == 246) {

  }
  if ((int )ea.cmdidx == 171) {

  }
  if ((int )ea.cmdidx == 249) {

  }
  if ((int )ea.cmdidx == 239) {

  }
  if ((int )ea.cmdidx == 250) {

  }
  if ((int )ea.cmdidx == 251) {

  }
  if ((int )ea.cmdidx == 247) {

  }
  if ((int )ea.cmdidx == 172) {

  }
  if ((int )ea.cmdidx == 181) {

  }
  if ((int )ea.cmdidx == 178) {

  }
  if ((int )ea.cmdidx == 182) {

  }
  if ((int )ea.cmdidx == 183) {

  }
  if ((int )ea.cmdidx == 180) {

  }
  if ((int )ea.cmdidx == 241) {

  }
  if ((int )ea.cmdidx == 135) {
    goto case_135;
  }
  if ((int )ea.cmdidx == 123) {
    goto case_123;
  }
  if ((int )ea.cmdidx == 8) {

  }
  if ((int )ea.cmdidx == 37) {

  }
  if ((int )ea.cmdidx == 68) {

  }
  if ((int )ea.cmdidx == 214) {
    goto case_214;
  }
  if ((int )ea.cmdidx == 92) {

  }
  if ((int )ea.cmdidx == 10) {

  }
  if ((int )ea.cmdidx == 9) {

  }
  if ((int )ea.cmdidx == 72) {

  }
  if ((int )ea.cmdidx == 71) {

  }
  if ((int )ea.cmdidx == 1) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 151) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 255) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 29) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 48) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 62) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 105) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 114) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 120) {
    goto case_1;
  }
  if ((int )ea.cmdidx == 133) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 144) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 265) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 158) {

  }
  if ((int )ea.cmdidx == 41) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 110) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 149) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 147) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 268) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 162) {

  }
  if ((int )ea.cmdidx == 47) {
    goto case_133;
  }
  if ((int )ea.cmdidx == 113) {

  }
  if ((int )ea.cmdidx == 258) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 155) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 270) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 165) {

  }
  if ((int )ea.cmdidx == 61) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 119) {
    goto case_258;
  }
  if ((int )ea.cmdidx == 134) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 145) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 266) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 159) {

  }
  if ((int )ea.cmdidx == 42) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 111) {
    goto case_134;
  }
  if ((int )ea.cmdidx == 2) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 106) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 30) {
    goto case_2;
  }
  if ((int )ea.cmdidx == 136) {

  }
  if ((int )ea.cmdidx == 152) {

  }
  if ((int )ea.cmdidx == 259) {

  }
  if ((int )ea.cmdidx == 4) {

  }
  if ((int )ea.cmdidx == 5) {

  }
  if ((int )ea.cmdidx == 11) {

  }
  if ((int )ea.cmdidx == 146) {

  }
  if ((int )ea.cmdidx == 148) {

  }
  if ((int )ea.cmdidx == 156) {

  }
  if ((int )ea.cmdidx == 267) {

  }
  if ((int )ea.cmdidx == 269) {

  }
  if ((int )ea.cmdidx == 271) {

  }
  if ((int )ea.cmdidx == 160) {

  }
  if ((int )ea.cmdidx == 163) {

  }
  if ((int )ea.cmdidx == 166) {

  }
  if ((int )ea.cmdidx == 112) {

  }
  if ((int )ea.cmdidx == 115) {

  }
  if ((int )ea.cmdidx == 121) {

  }
  if ((int )ea.cmdidx == 43) {

  }
  if ((int )ea.cmdidx == 49) {

  }
  if ((int )ea.cmdidx == 63) {

  }
  if ((int )ea.cmdidx == 248) {

  }
  if ((int )ea.cmdidx == 253) {

  }
  if ((int )ea.cmdidx == 67) {

  }
  if ((int )ea.cmdidx == 195) {
    goto case_67;
  }
  if ((int )ea.cmdidx == 99) {
    goto case_99___0;
  }
  if ((int )ea.cmdidx == 262) {

  }
  if ((int )ea.cmdidx == 103) {

  }
  if ((int )ea.cmdidx == 137) {

  }
  if ((int )ea.cmdidx == 276) {

  }
  if ((int )ea.cmdidx == 277) {

  }
  if ((int )ea.cmdidx == 64) {

  }
  if ((int )ea.cmdidx == 285) {

  }
  if ((int )ea.cmdidx == 293) {

  }
  if ((int )ea.cmdidx == 291) {

  }
  if ((int )ea.cmdidx == 185) {

  }
  if ((int )ea.cmdidx == 238) {

  }
  if ((int )ea.cmdidx == 50) {

  }
  if ((int )ea.cmdidx == 130) {

  }
  if ((int )ea.cmdidx == 289) {

  }
  if ((int )ea.cmdidx == 298) {

  }
  if ((int )ea.cmdidx == 202) {

  }
  if ((int )ea.cmdidx == 219) {

  }
  if ((int )ea.cmdidx == 222) {

  }
  if ((int )ea.cmdidx == 122) {

  }
  if ((int )ea.cmdidx == 94) {

  }
  if ((int )ea.cmdidx == 261) {

  }
  if ((int )ea.cmdidx == 290) {

  }
  if ((int )ea.cmdidx == 294) {

  }
  if ((int )ea.cmdidx == 287) {
    goto case_287;
  }
  if ((int )ea.cmdidx == 254) {

  }
  if ((int )ea.cmdidx == 193) {

  }
  if ((int )ea.cmdidx == 223) {

  }
  if ((int )ea.cmdidx == 201) {
    goto case_201;
  }
  if ((int )ea.cmdidx == 282) {
    goto case_282;
  }
  if ((int )ea.cmdidx == 194) {
    goto case_194;
  }
  if ((int )ea.cmdidx == 139) {

  }
  if ((int )ea.cmdidx == 140) {
    goto case_140;
  }
  if ((int )ea.cmdidx == 138) {
    goto case_138;
  }
  if ((int )ea.cmdidx == 32) {

  }
  if ((int )ea.cmdidx == 35) {

  }
  if ((int )ea.cmdidx == 38) {

  }
  if ((int )ea.cmdidx == 58) {

  }
  if ((int )ea.cmdidx == 39) {

  }
  if ((int )ea.cmdidx == 44) {

  }
  if ((int )ea.cmdidx == 46) {

  }
  if ((int )ea.cmdidx == 51) {

  }
  if ((int )ea.cmdidx == 45) {

  }
  if ((int )ea.cmdidx == 28) {

  }
  if ((int )ea.cmdidx == 56) {

  }
  if ((int )ea.cmdidx == -1) {

  }
  if ((int )ea.cmdidx == 52) {

  }
  if ((int )ea.cmdidx == 53) {

  }
  if ((int )ea.cmdidx == 65) {

  }
  if ((int )ea.cmdidx == 57) {
    goto case_57;
  }
  if ((int )ea.cmdidx == 131) {
    goto case_131;
  }
  if ((int )ea.cmdidx == 124) {

  }
  if ((int )ea.cmdidx == 34) {

  }
  if ((int )ea.cmdidx == 200) {

  }
  if ((int )ea.cmdidx == 127) {

  }
  if ((int )ea.cmdidx == 197) {

  }
  if ((int )ea.cmdidx == 153) {
    goto case_153;
  }

























































































































  case_189: ;/* CIL Label */ 
  {
  do_quit(& ea);
  }
  goto switch_break___0;
  case_190: ;/* CIL Label */ 
  {
  do_quit_all(ea.forceit);
  }
  goto switch_break___0;
  case_40: ;/* CIL Label */ 
  {

  }

  case_168: ;/* CIL Label */ 
  {

  }

  case_102: ;/* CIL Label */ 
  {

  }

  case_161: ;/* CIL Label */ 
  {

  }

  case_227: ;/* CIL Label */ 
  case_233: ;/* CIL Label */ 
  {

  }

  case_87: ;/* CIL Label */ 
  case_283: ;/* CIL Label */ 
  case_280: ;/* CIL Label */ 
  {
  do_exit(& ea);
  }
  goto switch_break___0;
  case_284: ;/* CIL Label */ 
  case_281: ;/* CIL Label */ 

  case_274: ;/* CIL Label */ 
  {
  do_wqall(& ea);
  }
  goto switch_break___0;
  case_173: ;/* CIL Label */ 
  {

  }

  case_192: ;/* CIL Label */ 
  {

  }

  case_6: ;/* CIL Label */ 
  {
  do_args(& ea);
  }
  goto switch_break___0;
  case_278: ;/* CIL Label */ 
  case_273: ;/* CIL Label */ 
  case_279: ;/* CIL Label */ 
  {
  do_wnext(& ea);
  }
  goto switch_break___0;
  case_142: ;/* CIL Label */ 
  case_220: ;/* CIL Label */ 
  {
  do_next(& ea);
  }
  goto switch_break___0;
  case_174: ;/* CIL Label */ 
  case_225: ;/* CIL Label */ 
  case_295: ;/* CIL Label */ 
  case_203: ;/* CIL Label */ 
  if (curwin->w_arg_idx - (int )ea.line2 >= arg_file_count) {
    {

    }
  } else {
    {
    do_argfile(& ea, curwin->w_arg_idx - (int )ea.line2);
    }
  }
  goto switch_break___0;
  case_199: ;/* CIL Label */ 
  case_226: ;/* CIL Label */ 
  {
  do_argfile(& ea, 0);
  }
  goto switch_break___0;
  case_126: ;/* CIL Label */ 
  case_218: ;/* CIL Label */ 
  {
  do_argfile(& ea, arg_file_count - 1);
  }
  goto switch_break___0;
  case_7: ;/* CIL Label */ 
  case_204: ;/* CIL Label */ 
  if (ea.addr_count) {
    i___0 = (int )(ea.line2 - 1L);
  } else {
    i___0 = curwin->w_arg_idx;
  }
  {
  do_argfile(& ea, i___0);
  }
  goto switch_break___0;
  case_3: ;/* CIL Label */ 
  case_205: ;/* CIL Label */ 
  if (ea.addr_count == 0) {
    ea.line2 = (linenr_t )9999;
  }
  {
  do_arg_all((int )ea.line2, ea.forceit);
  }
  goto switch_break___0;
  case_12: ;/* CIL Label */ 
  case_206: ;/* CIL Label */ 














  case_19: ;/* CIL Label */ 
  case_210: ;/* CIL Label */ 
  {

  }

  case_20: ;/* CIL Label */ 
  case_211: ;/* CIL Label */ 
  {

  }

  case_13: ;/* CIL Label */ 
  case_21: ;/* CIL Label */ 
  case_207: ;/* CIL Label */ 
  case_212: ;/* CIL Label */ 
  {

  }

  case_22: ;/* CIL Label */ 
  case_213: ;/* CIL Label */ 
  {

  }

  case_18: ;/* CIL Label */ 
  case_209: ;/* CIL Label */ 
  {

  }

  case_26: ;/* CIL Label */ 
  case_16: ;/* CIL Label */ 





  {


  }

  case_256: ;/* CIL Label */ 
  case_232: ;/* CIL Label */ 



  {

  }

  case_14: ;/* CIL Label */ 
  case_208: ;/* CIL Label */ 



  {

  }

  case_25: ;/* CIL Label */ 
  case_89: ;/* CIL Label */ 
  case_129: ;/* CIL Label */ 
  {
  buflist_list();
  }
  goto switch_break___0;
  case_260: ;/* CIL Label */ 
  {
  tmp___30 = curbuf_changed();
  }
  if (tmp___30) {
    {
    do_write(& ea);
    }
  }
  goto switch_break___0;
  case_272: ;/* CIL Label */ 
  if (ea.usefilter) {
    {

    }
  } else {
    {
    do_write(& ea);
    }
  }
  goto switch_break___0;
  case_141: ;/* CIL Label */ 
  if ((int )*(ea.arg) == 0) {
    {

    }
  } else {
    {
    tmp___31 = mch_screenmode(ea.arg);
    }
    if (tmp___31 != 0) {
      {

      }
    }
  }
  goto switch_break___0;
  case_196: ;/* CIL Label */ 
  {

  }

  case_234: ;/* CIL Label */ 
  case_224: ;/* CIL Label */ 
  case_143: ;/* CIL Label */ 
  case_215: ;/* CIL Label */ 
  {

  }

  case_75: ;/* CIL Label */ 
  case_85: ;/* CIL Label */ 
  case_263: ;/* CIL Label */ 
  case_264: ;/* CIL Label */ 
  case_15: ;/* CIL Label */ 
  {
  do_exedit(& ea, (WIN *)((void *)0));
  }
  goto switch_break___0;
  case_91: ;/* CIL Label */ 
  {

  }

  case_98: ;/* CIL Label */ 
  case_97: ;/* CIL Label */ 
  {

  }

  case_81: ;/* CIL Label */ 
  {

  }

  case_17: ;/* CIL Label */ 
  {

  }

  case_90: ;/* CIL Label */ 
  {

  }

  case_24: ;/* CIL Label */ 


  case_55: ;/* CIL Label */ 



  case_88: ;/* CIL Label */ 
  {
  do_file(ea.arg, ea.forceit);
  }
  goto switch_break___0;
  case_235: ;/* CIL Label */ 
  {

  }

  case_237: ;/* CIL Label */ 
  {

  }

  case_191: ;/* CIL Label */ 
  {

  }

  case_33: ;/* CIL Label */ 
  case_36: ;/* CIL Label */ 
  {
  do_cd(& ea);
  }
  goto switch_break___0;
  case_186: ;/* CIL Label */ 
  {
  do_pwd();
  }
  goto switch_break___0;
  case_292: ;/* CIL Label */ 
  {

  }

  case_125: ;/* CIL Label */ 
  {
  i___0 = curwin->w_p_list;
  curwin->w_p_list = 1;
  do_print(& ea);
  curwin->w_p_list = i___0;
  }
  goto switch_break___0;
  case_154: ;/* CIL Label */ 
  case_288: ;/* CIL Label */ 
  case_167: ;/* CIL Label */ 
  case_296: ;/* CIL Label */ 
  {
  do_print(& ea);
  }
  goto switch_break___0;
  case_95: ;/* CIL Label */ 
  {

  }

  case_216: ;/* CIL Label */ 
  {

  }

  case_217: ;/* CIL Label */ 
  {

  }

  case_177: ;/* CIL Label */ 

  case_228: ;/* CIL Label */ 

  case_240: ;/* CIL Label */ 





  {

  }

  case_184: ;/* CIL Label */ 

  case_231: ;/* CIL Label */ 

  case_252: ;/* CIL Label */ 
  {

  }

  case_179: ;/* CIL Label */ 

  case_230: ;/* CIL Label */ 

  case_246: ;/* CIL Label */ 
  {

  }

  case_171: ;/* CIL Label */ 
  {

  }

  case_249: ;/* CIL Label */ 
  {

  }

  case_239: ;/* CIL Label */ 
  case_250: ;/* CIL Label */ 
  {

  }

  case_251: ;/* CIL Label */ 
  {

  }

  case_247: ;/* CIL Label */ 
  {

  }

  case_172: ;/* CIL Label */ 
  {

  }

  case_181: ;/* CIL Label */ 
  {

  }

  case_178: ;/* CIL Label */ 
  case_182: ;/* CIL Label */ 
  {

  }

  case_183: ;/* CIL Label */ 
  {

  }

  case_180: ;/* CIL Label */ 
  {

  }

  case_241: ;/* CIL Label */ 
  {

  }

  case_135: ;/* CIL Label */ 
  {
  do_marks(ea.arg);
  }
  goto switch_break___0;
  case_123: ;/* CIL Label */ 
  {
  do_jumps();
  }
  goto switch_break___0;
  case_8: ;/* CIL Label */ 
  {

  }

  case_37: ;/* CIL Label */ 





  {


  }

  case_68: ;/* CIL Label */ 










  case_214: ;/* CIL Label */ 
  {
  do_set(ea.arg, 0);
  }
  goto switch_break___0;
  case_92: ;/* CIL Label */ 
  {

  }

  case_10: ;/* CIL Label */ 
  case_9: ;/* CIL Label */ 















  case_72: ;/* CIL Label */ 
  {

  }

  case_71: ;/* CIL Label */ 
  {


  }

  case_1: ;/* CIL Label */ 
  case_151: ;/* CIL Label */ 
  case_255: ;/* CIL Label */ 
  case_29: ;/* CIL Label */ 
  case_48: ;/* CIL Label */ 
  case_62: ;/* CIL Label */ 
  case_105: ;/* CIL Label */ 
  case_114: ;/* CIL Label */ 
  case_120: ;/* CIL Label */ 
  {
  do_exmap(& ea, 1);
  }
  goto switch_break___0;
  case_133: ;/* CIL Label */ 
  case_144: ;/* CIL Label */ 
  case_265: ;/* CIL Label */ 
  case_158: ;/* CIL Label */ 
  case_41: ;/* CIL Label */ 
  case_110: ;/* CIL Label */ 
  case_149: ;/* CIL Label */ 
  case_147: ;/* CIL Label */ 
  case_268: ;/* CIL Label */ 
  case_162: ;/* CIL Label */ 
  case_47: ;/* CIL Label */ 
  case_113: ;/* CIL Label */ 
  if (secure) {
    {



    }
  }
  case_258: ;/* CIL Label */ 
  case_155: ;/* CIL Label */ 
  case_270: ;/* CIL Label */ 
  case_165: ;/* CIL Label */ 
  case_61: ;/* CIL Label */ 
  case_119: ;/* CIL Label */ 
  {
  do_exmap(& ea, 0);
  }
  goto switch_break___0;
  case_134: ;/* CIL Label */ 
  case_145: ;/* CIL Label */ 
  case_266: ;/* CIL Label */ 
  case_159: ;/* CIL Label */ 
  case_42: ;/* CIL Label */ 
  case_111: ;/* CIL Label */ 
  {
  map_clear(ea.cmd, ea.forceit, 0);
  }
  goto switch_break___0;
  case_2: ;/* CIL Label */ 
  case_106: ;/* CIL Label */ 
  case_30: ;/* CIL Label */ 
  {
  map_clear(ea.cmd, 1, 1);
  }
  goto switch_break___0;
  case_136: ;/* CIL Label */ 
  case_152: ;/* CIL Label */ 
  case_259: ;/* CIL Label */ 
  case_4: ;/* CIL Label */ 
  case_5: ;/* CIL Label */ 
  case_11: ;/* CIL Label */ 
  case_146: ;/* CIL Label */ 
  case_148: ;/* CIL Label */ 
  case_156: ;/* CIL Label */ 
  case_267: ;/* CIL Label */ 
  case_269: ;/* CIL Label */ 
  case_271: ;/* CIL Label */ 
  case_160: ;/* CIL Label */ 
  case_163: ;/* CIL Label */ 
  case_166: ;/* CIL Label */ 
  case_112: ;/* CIL Label */ 
  case_115: ;/* CIL Label */ 
  case_121: ;/* CIL Label */ 
  case_43: ;/* CIL Label */ 
  case_49: ;/* CIL Label */ 
  case_63: ;/* CIL Label */ 
  case_248: ;/* CIL Label */ 
  case_253: ;/* CIL Label */ 
  {

  }

  case_67: ;/* CIL Label */ 
  case_195: ;/* CIL Label */ 
  {
  do_dis(ea.arg);
  }
  goto switch_break___0;
  case_99___0: ;/* CIL Label */ 
  {
  do_help(& ea);
  }
  goto switch_break___0;
  case_262: ;/* CIL Label */ 
  {

  }

  case_103: ;/* CIL Label */ 
  {

  }

  case_137: ;/* CIL Label */ 
  {

  }

  case_276: ;/* CIL Label */ 
  {

  }

  case_277: ;/* CIL Label */ 
  {

  }

  case_64: ;/* CIL Label */ 
  case_285: ;/* CIL Label */ 
  case_293: ;/* CIL Label */ 
  case_291: ;/* CIL Label */ 
  {

  }

  case_185: ;/* CIL Label */ 










  {

  }

  case_238: ;/* CIL Label */ 
  case_50: ;/* CIL Label */ 
  case_130: ;/* CIL Label */ 
  {

  }

  case_289___0: ;/* CIL Label */ 
  case_298___0: ;/* CIL Label */ 
  case_202___0: ;/* CIL Label */ 
  {

  }

  case_219___0: ;/* CIL Label */ 
  {




  }

  case_222___0: ;/* CIL Label */ 
  {




  }

  case_122: ;/* CIL Label */ 
  {

  }

  case_94: ;/* CIL Label */ 



  case_261: ;/* CIL Label */ 
  {

  }

  case_290: ;/* CIL Label */ 
  case_294: ;/* CIL Label */ 
  {

  }

  case_287: ;/* CIL Label */ 
  {
  do_bang(ea.addr_count, ea.line1, ea.line2, ea.forceit, ea.arg, 1, 1);
  }
  goto switch_break___0;
  case_254: ;/* CIL Label */ 
  {

  }

  case_193: ;/* CIL Label */ 
  {

  }

  case_223: ;/* CIL Label */ 
  {

  }

  case_201: ;/* CIL Label */ 
  p___0 = p_viminfo;
  if ((int )*p_viminfo == 0) {
    p_viminfo = (char_u *)"\'100";
  }
  {
  tmp___35 = read_viminfo(ea.arg, 1, 1, ea.forceit);
  }
  if (tmp___35 == 0) {
    {

    }
  }
  p_viminfo = p___0;
  goto switch_break___0;
  case_282: ;/* CIL Label */ 
  p___0 = p_viminfo;
  if ((int )*p_viminfo == 0) {
    p_viminfo = (char_u *)"\'100";
  }
  {
  write_viminfo(ea.arg, ea.forceit);
  p_viminfo = p___0;
  }
  goto switch_break___0;
  case_194: ;/* CIL Label */ 
  {
  do_redir(& ea);
  }
  goto switch_break___0;
  case_139: ;/* CIL Label */ 
  {

  }

  case_140: ;/* CIL Label */ 
  {
  do_mkrc(& ea, (char_u *)".vimrc");
  }
  goto switch_break___0;
  case_138: ;/* CIL Label */ 
  {
  do_mkrc(& ea, (char_u *)".exrc");
  }
  goto switch_break___0;
  case_32: ;/* CIL Label */ 





  {

  }

  case_35: ;/* CIL Label */ 
  {

  }

  case_38: ;/* CIL Label */ 
  {

  }

  case_58: ;/* CIL Label */ 





  {

  }

  case_39: ;/* CIL Label */ 





  {

  }

  case_44: ;/* CIL Label */ 





  {

  }

  case_46: ;/* CIL Label */ 





  {

  }

  case_51: ;/* CIL Label */ 





  {

  }

  case_45: ;/* CIL Label */ 





  {

  }

  case_28: ;/* CIL Label */ 
  case_56: ;/* CIL Label */ 





  {

  }

  case_neg_1: ;/* CIL Label */ 
  {

  }

  case_52: ;/* CIL Label */ 
  {

  }

  case_53: ;/* CIL Label */ 
  {

  }

  case_65: ;/* CIL Label */ 
  {

  }

  case_57: ;/* CIL Label */ 
  {
  getout(1);
  }
  case_131: ;/* CIL Label */ 
  case_124: ;/* CIL Label */ 
  {
  do_setmark(& ea);
  }
  goto switch_break___0;
  case_34: ;/* CIL Label */ 
  case_200: ;/* CIL Label */ 
  case_127: ;/* CIL Label */ 
  {

  }

  case_197: ;/* CIL Label */ 
  {

  }

  case_153: ;/* CIL Label */ 
  {
  do_normal(& ea);
  }
  goto switch_break___0;
  case_96: ;/* CIL Label */ 
  {

  }

  case_132: ;/* CIL Label */ 
  {

  }

  case_117___0: ;/* CIL Label */ 
  case_73___0: ;/* CIL Label */ 
  {

  }

  case_109___0: ;/* CIL Label */ 
  case_70___0: ;/* CIL Label */ 
  {

  }

  case_108___0: ;/* CIL Label */ 
  case_69___0: ;/* CIL Label */ 
  {

  }

  case_118___0: ;/* CIL Label */ 
  case_74___0: ;/* CIL Label */ 
  {

  }

  case_236___0: ;/* CIL Label */ 
  {

  }

  case_101: ;/* CIL Label */ 
  {

  }

  case_76___0: ;/* CIL Label */ 
  case_78___0: ;/* CIL Label */ 
  {

  }

  case_77: ;/* CIL Label */ 
  {

  }

  case_86___0: ;/* CIL Label */ 
  {

  }

  case_31___0: ;/* CIL Label */ 
  {

  }

  case_107___0: ;/* CIL Label */ 
  {

  }

  case_80___0: ;/* CIL Label */ 
  case_79___0: ;/* CIL Label */ 
  {

  }

  case_82___0: ;/* CIL Label */ 











  case_275___0: ;/* CIL Label */ 
  {

  }

  case_54: ;/* CIL Label */ 
  {

  }

  case_23: ;/* CIL Label */ 
  {

  }

  case_84___0: ;/* CIL Label */ 
  {

  }

  case_128___0: ;/* CIL Label */ 
  {

  }

  case_257: ;/* CIL Label */ 
  {

  }

  case_93___0: ;/* CIL Label */ 
  {

  }

  case_66: ;/* CIL Label */ 
  {

  }

  case_198___0: ;/* CIL Label */ 
  {

  }

  case_83: ;/* CIL Label */ 
  {

  }

  case_104: ;/* CIL Label */ 
  {


  }

  case_0: ;/* CIL Label */ 
  {


  }

  case_27: ;/* CIL Label */ 
  {


  }

  case_286: ;/* CIL Label */ 
  {


  }

  case_116: ;/* CIL Label */ 
  {

  }

  case_150: ;/* CIL Label */ 
  {


  }

  case_229: ;/* CIL Label */ 









  case_297: ;/* CIL Label */ 
  {

  }

  case_164: ;/* CIL Label */ 
  {

  }

  switch_default___0: ;/* CIL Label */ 



  switch_break___0: ;/* CIL Label */ ;
  }
  doend: ;
  if (curwin->w_cursor.lnum == 0L) {

  }
  if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
    if ((int )*errormsg != 0) {
      if (! did_emsg) {
        if (sourcing) {






          {




          }
        }
        {
        emsg(errormsg);
        }
      }
    }
  }
  if (ea.nextcmd) {



  }
  return (ea.nextcmd);
}
}
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) 
{
























































}
char_u *set_one_cmd_context(char_u *buff ) 
{





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static linenr_t get_address(char_u **ptr , int skip ) 
{ 
  int c ;
  int i___0 ;
  long n ;
  char_u *cmd ;
  FPOS pos___0 ;
  FPOS *fp___0 ;
  linenr_t lnum ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char_u *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  {
  cmd = skipwhite(*ptr);
  lnum = (linenr_t )2147483647;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    if ((int )*cmd == 46) {
      goto case_46;
    }
    if ((int )*cmd == 36) {
      goto case_36;
    }
    if ((int )*cmd == 39) {

    }
    if ((int )*cmd == 47) {
      goto case_47;
    }
    if ((int )*cmd == 63) {
      goto case_47;
    }
    if ((int )*cmd == 92) {

    }
    goto switch_default;
    case_46: ;/* CIL Label */ 
    cmd ++;
    lnum = curwin->w_cursor.lnum;
    goto switch_break;
    case_36: ;/* CIL Label */ 
    cmd ++;
    lnum = curbuf->b_ml.ml_line_count;
    goto switch_break;
    case_39: ;/* CIL Label */ 




















    case_47: ;/* CIL Label */ 
    case_63: ;/* CIL Label */ 
    tmp___0 = cmd;
    cmd ++;
    c = (int )*tmp___0;
    if (skip) {
      {

      }



    } else {
      pos___0 = curwin->w_cursor;
      if (lnum != 2147483647L) {

      }
      if (c == 47) {
        curwin->w_cursor.col = (colnr_t )2147483647;
      } else {
        curwin->w_cursor.col = (colnr_t )0;
      }
      {
      searchcmdlen = 0;
      tmp___1 = do_search((OPARG *)((void *)0), c, cmd, 1L, 300);
      }
      if (! tmp___1) {
        curwin->w_cursor = pos___0;
        cmd = (char_u *)((void *)0);
        goto error;
      }
      lnum = curwin->w_cursor.lnum;
      curwin->w_cursor = pos___0;
      cmd += searchcmdlen;
    }
    goto switch_break;
    case_92: ;/* CIL Label */ 














































    switch_default: ;/* CIL Label */ 
    {
    tmp___4 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___4 + (int )*cmd) & 2048) {
      {
      lnum = getdigits(& cmd);
      }
    }
    switch_break: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      cmd = skipwhite(cmd);
      }
      if ((int )*cmd != 45) {
        if ((int )*cmd != 43) {
          {
          tmp___5 = __ctype_b_loc();
          }
          if (! ((int const   )*(*tmp___5 + (int )*cmd) & 2048)) {
            goto while_break___0;
          }
        }
      }
      if (lnum == 2147483647L) {
        lnum = curwin->w_cursor.lnum;
      }
      {
      tmp___7 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___7 + (int )*cmd) & 2048) {

      } else {
        tmp___6 = cmd;
        cmd ++;
        i___0 = (int )*tmp___6;
      }
      {
      tmp___8 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___8 + (int )*cmd) & 2048) {
        {
        n = getdigits(& cmd);
        }
      } else {

      }
      if (i___0 == 45) {
        lnum -= n;
      } else {
        lnum += n;
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (! ((int )*cmd == 47)) {
      if (! ((int )*cmd == 63)) {
        goto while_break;
      }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  error: ;
  *ptr = cmd;
  return (lnum);
}
}
static char_u *invalid_range(EXARG *eap ) 
{ 


  {
  if (eap->line1 < 0L) {
    return (e_invrange);
  } else { //Added block
  if (eap->line2 < 0L) {

  } else { //Added block
  if (eap->line1 > eap->line2) {

  } else { //Added block
  if (eap->argt & 1L) {
    if (! (eap->argt & 16384L)) {
      if (eap->line2 > curbuf->b_ml.ml_line_count) {

      }
    }
  }
  }
  }
  }
  return ((char_u *)((void *)0));
}
}
static void correct_range(EXARG *eap ) 
{ 


  {
  if (! (eap->argt & 4096L)) {
    if (eap->line1 == 0L) {

    }
    if (eap->line2 == 0L) {

    }
  }
  return;
}
}
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) 
{ 
  int has_wildcards ;
  char_u *repl ;
  int srclen ;
  char_u *p___0 ;
  int n ;
  char_u *tmp ;
  char_u *l ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  {
  has_wildcards = mch_has_wildcard(eap->arg);
  p___0 = eap->arg;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = vim_strchr((char_u *)"%#<", (int )*p___0);
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      p___0 ++;
      goto __Cont;
    }
    {

    }





































    {


    }



    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (eap->argt & 16L) {
    if (! eap->usefilter) {
      n = 1;
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (! (n <= 2)) {
          goto while_break___1;
        }
        if (n == 2) {
          if (! has_wildcards) {
            p___0 = eap->arg;
            {
            while (1) {
              while_continue___2: ;/* CIL Label */ ;
              if (! *p___0) {
                goto while_break___2;
              }
              if (*(p___0 + 1)) {
                if ((int )*p___0 == 92) {

                } else { //Added block
                if ((int )*p___0 == 22) {

                } else {
                  goto _L;
                }
                }
              } else { //Added block
              _L: ;
              if ((int )*p___0 == 32) {
                *errormsgp = (char_u *)"Only one file name allowed";
                return (0);
              } else { //Added block
              if ((int )*p___0 == 9) {


              }
              }
              }
              p___0 ++;
            }
            while_break___2: ;/* CIL Label */ ;
            }
          }
          if (! has_wildcards) {
            {
            backslash_halve(eap->arg);
            }
          }
        }
        if (has_wildcards) {












































        }
        n ++;
      }
      while_break___1: ;/* CIL Label */ ;
      }
    }
  }
  return (1);
}
}
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) 
{























































}
void separate_nextcmd(EXARG *eap ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;

  {
  p___0 = eap->arg;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 22) {










    } else { //Added block
    if ((int )*p___0 == 34) {


















    } else { //Added block
    _L___3: ;
    if ((int )*p___0 == 124) {
      goto _L___0;
    } else { //Added block
    if ((int )*p___0 == 10) {
      _L___0: ;
      {
      tmp___0 = vim_strchr(p_cpo, 'b');
      }
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {

      } else { //Added block
      if (! (eap->argt & 8192L)) {
        _L: ;
        if ((int )*(p___0 - 1) == 92) {
          {
          tmp = strlen((char const   *)((char *)p___0));
          memmove((void *)((char *)(p___0 - 1)), (void const   *)((char *)p___0),
                  tmp + 1UL);
          p___0 --;
          }
        } else {
          {


          }

        }
      } else {
        {


        }

      }
      }
    }
    }
    }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (! (eap->argt & 2048L)) {
    {
    del_trailing_spaces(eap->arg);
    }
  }
  return;
}
}
int autowrite(BUF *buf___3 , int forceit ) 
{




























}
void autowrite_all(void) 
{ 
  BUF *buf___3 ;
  int tmp ;
  int tmp___0 ;

  {
  if (! p_aw) {
    return;
  } else { //Added block



  }

  {





















  while_break: ;/* CIL Label */ ;
  }

}
}
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) 
{ 
  BUF *buf2 ;
  int count___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! forceit) {
    {
    tmp___1 = buf_changed(buf___3);
    }
    if (tmp___1) {

























































    }
  }
  return (0);
}
}
void dialog_changed(BUF *buf___3 , int checkall ) 
{



























































































}
int can_abandon(BUF *buf___3 , int forceit ) 
{


































}
int check_changed_any(int hidden ) 
{ 
  BUF *buf___3 ;
  int save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! hidden) {
      {
      tmp___0 = buf_changed(curbuf);
      }
      if (tmp___0) {
        buf___3 = curbuf;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        if (! hidden) {
          goto _L;
        } else { //Added block
        if (buf___3->b_nwindows == 0) {
          _L: ;
          {
          tmp = buf_changed(buf___3);
          }
          if (tmp) {

          }
        }
        }
        buf___3 = buf___3->b_next;
      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      return (0);
    }
    if (p_confirm) {

    } else { //Added block
    if (confirm) {
      _L___1: ;
      {

      }



    } else {
      goto while_break;
    }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  exiting = 0;
  if (! p_confirm) {
    if (! confirm) {
      if (vgetc_busy) {



      }
      if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {

      } else {
        tmp___2 = buf___3->b_fname;
      }
      {
      tmp___3 = emsg2((char_u *)"No write since last change for buffer \"%s\"", tmp___2);
      }
      if (tmp___3) {
        {
        save = no_wait_return;
        no_wait_return = 0;
        wait_return(0);
        no_wait_return = save;
        }
      }
    }
  }
  {
  do_buffer(0, 1, 1, buf___3->b_fnum, 0);
  }
  return (1);
}
}
int check_fname(void) 
{ 


  {
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {

    }

  }
  return (1);
}
}
int buf_write_all(BUF *buf___3 ) 
{ 
  int retval ;
  BUF *old_curbuf ;

  {
  {
  old_curbuf = curbuf;
  retval = buf_write(buf___3, buf___3->b_ffname, buf___3->b_fname, (linenr_t )1, buf___3->b_ml.ml_line_count,
                     0, 0, 1, 0);
  }
  if ((unsigned long )curbuf != (unsigned long )old_curbuf) {
    {

    }
  }
  return (retval);
}
}
static char_u *getargcmd(char_u **argp ) 
{ 
  char_u *arg ;
  char_u *command ;
  char_u *tmp ;
  int tmp___0 ;

  {
  arg = *argp;
  command = (char_u *)((void *)0);
  if ((int )*arg == 43) {
    {


    }













    {


    }
  }
  return (command);
}
}
static char_u *skip_cmd_arg(char_u *p___0 ) 
{



























}
int rem_backslash(char_u *str___1 ) 
{ 
  int tmp ;

  {
  if ((int )*(str___1 + 0) == 92) {





  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void backslash_halve(char_u *p___0 ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp = rem_backslash(p___0);
    }
    if (tmp) {
      {

      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
char_u *backslash_halve_save(char_u *p___0 ) 
{ 
  char_u *res ;

  {
  {
  res = vim_strsave(p___0);
  }
  if ((unsigned long )res == (unsigned long )((void *)0)) {

  }
  {
  backslash_halve(res);
  }
  return (res);
}
}
static void do_make(char_u *arg , char_u *errorformat ) 
{














































































}
static int start  =    -1;
static int off  =    0;
static char_u *get_mef_name(int newname ) 
{















































































}
static void do_cfile(EXARG *eap ) 
{


















}
static int do_arglist(char_u *str___1 ) 
{ 
  int new_count ;
  char_u **new_files ;
  int exp_count ;
  char_u **exp_files ;
  char_u **t ;
  char_u *p___0 ;
  int inquote ;
  int inbacktick ;
  int i___0 ;
  WIN *win ;
  char_u *tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  new_count = 0;
  new_files = (char_u **)((void *)0);
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    {
    tmp = lalloc(sizeof(char_u *) * (unsigned long )(new_count + 1), 1);
    t = (char_u **)tmp;
    }
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      i___0 = new_count;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        i___0 --;
        if (! (i___0 >= 0)) {
          goto while_break___0;
        }

      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    {
    vim_free((void *)new_files);
    }
    if ((unsigned long )t == (unsigned long )((void *)0)) {

    }
    new_files = t;
    tmp___0 = new_count;
    new_count ++;
    *(new_files + tmp___0) = str___1;
    inquote = 0;
    inbacktick = 0;
    p___0 = str___1;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! *str___1) {
        goto while_break___1;
      }
      {
      tmp___4 = rem_backslash(str___1);
      }
      if (tmp___4) {




      } else {
        if (! inquote) {
          if (! inbacktick) {
            {
            tmp___2 = vim_isspace((int )*str___1);
            }
            if (tmp___2) {

            }
          }
        }
        if (! inquote) {
          if ((int )*str___1 == 96) {

          }
        }
        if (! inbacktick) {
          if ((int )*str___1 == 34) {

          } else {
            tmp___3 = p___0;
            p___0 ++;
            *tmp___3 = *str___1;
          }
        } else {



        }
      }
      str___1 ++;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    {
    str___1 = skipwhite(str___1);
    *p___0 = (char_u )'\000';
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  i___0 = expand_wildcards(new_count, new_files, & exp_count, & exp_files, 15);
  vim_free((void *)new_files);
  }
  if (i___0 == 0) {

  }
  if (exp_count == 0) {
    {

    }

  }
  {
  FreeWild(arg_file_count, arg_files);
  arg_files = exp_files;
  arg_file_count = exp_count;
  arg_had_last = 0;
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (! (i___0 < arg_file_count)) {
      goto while_break___2;
    }
    {
    buflist_add(*(arg_files + i___0));
    i___0 ++;
    }
  }
  while_break___2: ;/* CIL Label */ ;
  }
  win = firstwin;
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___3;
    }
    {
    check_arg_idx(win);
    win = win->w_next;
    }
  }
  while_break___3: ;/* CIL Label */ ;
  }
  return (1);
}
}
void check_arg_idx(WIN *win ) 
{ 
  int tmp ;

  {
  if (arg_file_count > 1) {
    if ((unsigned long )(win->w_buffer)->b_ffname == (unsigned long )((void *)0)) {

    } else { //Added block
    if (win->w_arg_idx >= arg_file_count) {

    } else {
      {
      tmp = fullpathcmp(*(arg_files + win->w_arg_idx), (win->w_buffer)->b_ffname,
                        1);
      }
      if (tmp & 1) {
        win->w_arg_idx_invalid = 0;
      } else {

      }
    }
    }
  } else {
    win->w_arg_idx_invalid = 0;
  }
  return;
}
}
int ends_excmd(int c ) 
{ 
  int tmp ;

  {
  if (c == 0) {
    tmp = 1;
  } else { //Added block
  if (c == 124) {

  } else { //Added block
  if (c == 34) {

  } else { //Added block
  if (c == 10) {

  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
char_u *find_nextcmd(char_u *p___0 ) 
{






















}
char_u *check_nextcmd(char_u *p___0 ) 
{ 


  {
  {
  p___0 = skipwhite(p___0);
  }
  if ((int )*p___0 == 124) {

  } else { //Added block
  if ((int )*p___0 == 10) {

  } else {
    return ((char_u *)((void *)0));
  }
  }
}
}
static int check_more(int message , int forceit ) 
{ 
  int n ;
  char_u buff[1025] ;
  int tmp ;
  int tmp___0 ;

  {
  n = (arg_file_count - curwin->w_arg_idx) - 1;
  if (! forceit) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      if (arg_file_count > 1) {
        if (! arg_had_last) {
          if (n >= 0) {
            if (quitmore == 0) {
              if (message) {
                if (p_confirm) {

                } else { //Added block
                if (confirm) {
                  _L: ;











                }
                }
                {
                emsgn((char_u *)"%ld more files to edit", (long )n);
                quitmore = 2;
                }
              }
              return (0);
            }
          }
        }
      }
    }
  }
  return (1);
}
}
static char_u *get_one_sourceline(struct source_cookie *sp ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) 
{ 
  struct source_cookie cookie ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  char_u *p___0 ;
  char_u *fname_exp ;
  int retval ;
  void *save_funccalp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = 0;
  fname_exp = expand_env_save(fname);
  }
  if ((unsigned long )fname_exp == (unsigned long )((void *)0)) {

  }
  {
  cookie.fp = fopen((char const   * __restrict  )((char *)fname_exp), (char const   * __restrict  )"r");
  }
  if ((unsigned long )cookie.fp == (unsigned long )((void *)0)) {
    if (check_other) {
      {

      }




































    }
  }
  if ((unsigned long )cookie.fp == (unsigned long )((void *)0)) {
    if (p_verbose > 0L) {
      {

      }
    }
    goto theend;
  }










  {










  }





  {



  }





  theend: ;
  {
  vim_free((void *)fname_exp);
  }
  return (retval);
}
}
char_u *getsourceline(int c , void *cookie , int indent ) 
{






























































}
static char_u *get_one_sourceline(struct source_cookie *sp ) 
{
























































































}
char_u *get_command_name(int idx ) 
{











}
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) ;
static void uc_list(char_u *name___1 , size_t name_len ) ;
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) ;
static char_u *uc_split_args(char_u *arg , size_t *lenp ) ;
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) ;
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) 
{



































































































}
static void uc_list(char_u *name___1 , size_t name_len ) 
{

















































































































































































































































































































}
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) 
{























































































































































































































































































































}
static void do_command(EXARG *eap ) 
{





































































































}
static void do_comclear(void) 
{

























}
static void do_delcommand(EXARG *eap ) 
{












































}
static char_u *uc_split_args(char_u *arg , size_t *lenp ) 
{



















































































































































}
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) 
{






























































































































































































































































































































































}
static void do_ucmd(UCMD *cmd , EXARG *eap ) 
{
























































































}
static char_u *get_user_command_name(int idx ) 
{









}
char_u *get_user_commands(int idx ) 
{








}
static char *user_cmd_flags[6]  = {      (char *)"nargs",      (char *)"complete",      (char *)"range",      (char *)"count", 
        (char *)"bang",      (char *)"register"};
char_u *get_user_cmd_flags(int idx ) 
{








}
static char *user_cmd_nargs[5]  = {      (char *)"0",      (char *)"1",      (char *)"*",      (char *)"?", 
        (char *)"+"};
char_u *get_user_cmd_nargs(int idx ) 
{








}
static char *user_cmd_complete[13]  = 
  {      (char *)"augroup",      (char *)"buffer",      (char *)"command",      (char *)"dir", 
        (char *)"event",      (char *)"file",      (char *)"help",      (char *)"highlight", 
        (char *)"menu",      (char *)"option",      (char *)"tag",      (char *)"tag_listfiles", 
        (char *)"var"};
char_u *get_user_cmd_complete(int idx ) 
{








}
void not_exiting(void) 
{ 


  {
  {
  exiting = 0;
  settmode(2);
  }
  return;
}
}
static void do_quit(EXARG *eap ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = check_more(0, eap->forceit);
  }
  if (tmp == 1) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      exiting = 1;
    }
  }
  if (! p_hid) {
    {
    tmp___3 = check_changed(curbuf, 0, 0, eap->forceit, 0);
    }
    if (tmp___3) {
      {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
    {
    tmp___4 = check_more(1, eap->forceit);
    }
    if (tmp___4 == 0) {
      {
      not_exiting();
      }
    } else {
      {
      tmp___5 = only_one_window();
      }
      if (tmp___5) {
        {
        tmp___6 = check_changed_any(eap->forceit);
        }
        if (tmp___6) {
          {

          }
        } else {
          goto _L;
        }
      } else {
        _L: ;
        {
        tmp___1 = only_one_window();
        }
        if (tmp___1) {
          {
          getout(0);
          }
        }
        if (! p_hid) {
          tmp___2 = 1;
        } else { //Added block
        if (eap->forceit) {

        } else {
          tmp___2 = 0;
        }
        }
        {
        close_window(curwin, tmp___2);
        }
      }
    }
  }
  return;
}
}
static void do_quit_all(int forceit ) 
{ 
  int tmp ;

  {
  exiting = 1;
  if (forceit) {
    {

    }
  } else {
    {
    tmp = check_changed_any(0);
    }
    if (! tmp) {
      {

      }
    }
  }
  {
  not_exiting();
  }
  return;
}
}
static void do_close(EXARG *eap , WIN *win ) 
{




































































}
static void do_pclose(EXARG *eap ) 
{






















}
static void do_suspend(int forceit ) 
{






























}
static void do_exit(EXARG *eap ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = check_more(0, eap->forceit);
  }
  if (tmp == 1) {
    {
    tmp___0 = only_one_window();
    }
    if (tmp___0) {
      exiting = 1;
    }
  }
  if ((int )eap->cmdidx == 280) {
    goto _L___1;
  } else {
    {
    tmp___2 = curbuf_changed();
    }
    if (tmp___2) {
      _L___1: ;
      {
      tmp___3 = do_write(eap);
      }
      if (tmp___3 == 0) {
        {

        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: ;
      {
      tmp___4 = check_more(1, eap->forceit);
      }
      if (tmp___4 == 0) {
        {
        not_exiting();
        }
      } else {
        {
        tmp___5 = only_one_window();
        }
        if (tmp___5) {
          {
          tmp___6 = check_changed_any(eap->forceit);
          }
          if (tmp___6) {
            {

            }
          } else {
            goto _L;
          }
        } else {
          _L: ;
          {
          tmp___1 = only_one_window();
          }
          if (tmp___1) {
            {
            getout(0);
            }
          }
          {
          close_window(curwin, ! p_hid);
          }
        }
      }
    }
  }
  return;
}
}
static void do_print(EXARG *eap ) 
{ 
  int tmp ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (! got_int)) {

    }
    if ((int )eap->cmdidx == 154) {

    } else { //Added block
    if ((int )eap->cmdidx == 288) {

    } else {
      tmp = 0;
    }
    }
    {
    print_line(eap->line1, tmp);
    (eap->line1) ++;
    }
    if (eap->line1 > eap->line2) {
      goto while_break;
    }
    {
    out_flush();
    ui_breakcheck();
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  setpcmark();
  curwin->w_cursor.lnum = eap->line2;
  beginline(6);
  ex_no_reprint = 1;
  }
  return;
}
}
void do_argfile(EXARG *eap , int argn ) 
{ 
  int other ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (argn < 0) {

  } else { //Added block
  if (argn >= arg_file_count) {
    _L___0: ;















  } else {
    {
    setpcmark();
    }
    if ((int )*(eap->cmd) == 115) {
      {
      tmp = win_split(0, 0, 0);
      }
      if (tmp == 0) {

      }
    } else {
      other = 1;
      if (p_hid) {
        {



        }
      }
      if (! p_hid) {
        goto _L;
      } else { //Added block
      if (! other) {
        _L: ;
        {
        tmp___0 = check_changed(curbuf, 1, ! other, eap->forceit, 0);
        }
        if (tmp___0) {

        }
      }
      }
    }
    curwin->w_arg_idx = argn;
    if (argn == arg_file_count - 1) {
      arg_had_last = 1;
    }
    if (p_hid) {

    } else {
      tmp___1 = 0;
    }
    if (eap->forceit) {
      tmp___2 = 8;
    } else {
      tmp___2 = 0;
    }
    {
    do_ecmd(0, *(arg_files + curwin->w_arg_idx), (char_u *)((void *)0), eap->do_ecmd_cmd,
            (linenr_t )-1, tmp___1 + tmp___2);
    }
  }
  }
  return;
}
}
static void do_next(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (p_hid) {

  } else { //Added block
  if ((int )eap->cmdidx == 220) {
    goto _L;
  } else {
    {
    tmp___0 = check_changed(curbuf, 1, 0, eap->forceit, 0);
    }
    if (! tmp___0) {
      _L: ;
      if ((int )*(eap->arg) != 0) {
        {
        tmp = do_arglist(eap->arg);
        }
        if (tmp == 0) {

        }
        i___0 = 0;
      } else {
        i___0 = curwin->w_arg_idx + (int )eap->line2;
      }
      {
      do_argfile(eap, i___0);
      }
    }
  }
  }
  return;
}
}
static void do_recover(EXARG *eap ) 
{

























}
static void do_args(EXARG *eap ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = ends_excmd((int )*(eap->arg));
  }
  if (tmp___0) {
    if (arg_file_count == 0) {
      {

      }





    } else {
      {
      gotocmdline(1);
      i___0 = 0;
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! (i___0 < arg_file_count)) {
          goto while_break;
        }
        if (i___0 == curwin->w_arg_idx) {
          {
          msg_putchar('[');
          }
        }
        {
        msg_outtrans(*(arg_files + i___0));
        }
        if (i___0 == curwin->w_arg_idx) {
          {
          msg_putchar(']');
          }
        }
        {
        msg_putchar(' ');
        i___0 ++;
        }
      }
      while_break: ;/* CIL Label */ ;
      }
    }
  } else {
    {

    }
  }
  return;
}
}
static void do_splitview(EXARG *eap ) 
{






































}
static void do_resize(EXARG *eap ) 
{
























}
static void do_find(EXARG *eap ) 
{

















}
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) 
{ 
  int n ;
  int need_hide ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if (exmode_active) {
    if ((int )eap->cmdidx == 263) {
      goto _L;
    } else { //Added block
    if ((int )eap->cmdidx == 264) {
      _L: ;
      exmode_active = 0;
      if ((int )*(eap->arg) == 0) {
        return;
      }
    }
    }
  }
  if ((int )eap->cmdidx == 143) {
















  } else { //Added block
  _L___2: ;
  if ((int )eap->cmdidx != 224) {
    goto _L___1;
  } else { //Added block
  if ((int )*(eap->arg) != 0) {
    _L___1: ;
    n = readonlymode;
    if ((int )eap->cmdidx == 264) {

    } else { //Added block
    if ((int )eap->cmdidx == 234) {

    }
    }
    {
    setpcmark();
    }
    if (p_hid) {

    } else {
      tmp___3 = 0;
    }
    if (eap->forceit) {
      tmp___4 = 8;
    } else {

    }
    if ((int )eap->cmdidx == 15) {

    } else {
      tmp___5 = 0;
    }
    {
    tmp___6 = do_ecmd(0, eap->arg, (char_u *)((void *)0), eap->do_ecmd_cmd, eap->do_ecmd_lnum,
                      (tmp___3 + tmp___4) + tmp___5);
    }
    if (tmp___6 == 0) {


































    }
    readonlymode = n;
  } else {






    {


    }





    {

    }
  }
  }
  }
  if ((int )eap->cmdidx == 143) {

  } else { //Added block
  if ((int )eap->cmdidx == 224) {
    _L___3: ;












  }
  }
  ex_no_reprint = 1;
  return;
}
}
static void do_swapname(void) 
{




















}
static void do_syncbind(void) 
{




















































































}
static void do_read(EXARG *eap ) 
{






















































}
static char_u *prev_dir  =    (char_u *)((void *)0);
static void do_cd(EXARG *eap ) 
{ 
  char_u *new_dir ;
  char_u *tofree ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  new_dir = eap->arg;
  tmp = strcmp((char const   *)((char *)eap->arg), (char const   *)((char *)"-"));
  }
  if (tmp == 0) {







  }
  {
  tofree = prev_dir;
  tmp___0 = mch_dirname(NameBuff, 1024);
  }
  if (tmp___0 == 1) {
    {
    prev_dir = vim_strsave(NameBuff);
    }
  } else {

  }
  if ((int )*new_dir == 0) {
    {


    }
  }
  if ((unsigned long )new_dir == (unsigned long )((void *)0)) {
    {

    }
  } else {
    {
    tmp___1 = chdir((char const   *)((char *)new_dir));
    }
    if (tmp___1) {
      {

      }
    } else {
      {
      shorten_fnames(1);
      }
    }
  }
  {
  vim_free((void *)tofree);
  }
  return;
}
}
static void do_pwd(void) 
{ 
  int tmp ;

  {
  {
  tmp = mch_dirname(NameBuff, 1024);
  }
  if (tmp == 1) {
    {
    msg(NameBuff);
    }
  } else {
    {

    }
  }
  return;
}
}
static void do_sleep(EXARG *eap ) 
{






























}
static void do_exmap(EXARG *eap , int isabbrev ) 
{ 
  int mode ;
  char_u *cmdp ;
  char_u *ambigstr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  cmdp = eap->cmd;
  if (eap->forceit) {
    tmp = 1;
  } else { //Added block
  if (isabbrev) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  {
  mode = get_map_mode(& cmdp, tmp);
  }
  if ((int )*cmdp == 110) {
    tmp___0 = 2;
  } else {
    tmp___0 = (int )*cmdp == 117;
  }
  {
  tmp___1 = do_map(tmp___0, eap->arg, mode, isabbrev, & ambigstr);
  }
  {
  if (tmp___1 == 1) {

  }
  if (tmp___1 == 2) {

  }
  if (tmp___1 == 3) {

  }
  goto switch_break;
  case_1: ;/* CIL Label */ 
  {

  }

  case_2: ;/* CIL Label */ 





  {

  }

  case_3: ;/* CIL Label */ 
  {

  }









  {

  }
  switch_break: ;/* CIL Label */ ;
  }
  return;
}
}
static void do_winsize(char_u *arg ) 
{
















}
static void do_winpos(char_u *arg ) 
{


























}
static void do_exops(EXARG *eap ) 
{




















































}
static void do_copymove(EXARG *eap ) 
{


















































}
static void do_exjoin(EXARG *eap ) 
{






















}
static void do_exat(EXARG *eap ) 
{
















































}
static void do_redir(EXARG *eap ) 
{ 
  char *mode ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = strcasecmp((char const   *)((char *)eap->arg), (char const   *)((char *)"END"));
  }
  if (tmp___1 == 0) {
    {
    close_redir();
    }
  } else { //Added block
  if ((int )*(eap->arg) == 62) {
    (eap->arg) ++;
    if ((int )*(eap->arg) == 62) {
      (eap->arg) ++;
      mode = (char *)"a";
    } else {

    }
    {
    eap->arg = skipwhite(eap->arg);
    close_redir();
    redir_fd = open_exfile(eap, mode);
    }
  } else { //Added block




























  }
  }
  return;
}
}
static void close_redir(void) 
{ 


  {
  if ((unsigned long )redir_fd != (unsigned long )((void *)0)) {
    {
    fclose(redir_fd);
    redir_fd = (FILE *)((void *)0);
    }
  }
  redir_reg = 0;
  return;
}
}
static void do_mkrc(EXARG *eap , char_u *defname ) 
{ 
  FILE *fd ;
  int failed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u dirnow[1024] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u tbuf[1024] ;
  int tmp___6 ;

  {
  if ((int )*(eap->arg) == 0) {

  }
  {
  fd = open_exfile(eap, (char *)"w");
  }
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    if ((int )eap->cmdidx == 140) {
      {
      fputs((char const   * __restrict  )"version 5.0", (FILE * __restrict  )fd);
      put_eol(fd);
      }
    } else { //Added block
    if ((int )eap->cmdidx == 139) {
      {


      }
    }
    }
    if (p_cp) {
      {
      fputs((char const   * __restrict  )"set compatible", (FILE * __restrict  )fd);
      }
    } else {
      {

      }
    }
    {
    put_eol(fd);
    failed = 0;
    }
    if ((int )eap->cmdidx != 139) {
      goto _L;
    } else {
      {

      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        _L: ;
        {
        tmp = makemap(fd);
        }
        if (tmp == 0) {

        } else {
          {
          tmp___0 = makeset(fd);
          }
          if (tmp___0 == 0) {

          } else {
            tmp___1 = 0;
          }
        }
        failed = tmp___1;
      }
    }
    if ((int )eap->cmdidx == 139) {




















    }
    {
    tmp___5 = fclose(fd);
    failed |= tmp___5;
    }
    if (failed) {
      {

      }
    } else { //Added block
    if ((int )eap->cmdidx == 139) {
      {

      }





    }
    }
  }
  return;
}
}
static FILE *open_exfile(EXARG *eap , char *mode ) 
{ 
  FILE *fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = mch_isdir(eap->arg);
  }
  if (tmp) {
    {

    }

  }
  if (! eap->forceit) {
    if ((int )*mode != 97) {
      {
      tmp___0 = vim_fexists(eap->arg);
      }
      if (tmp___0) {
        {

        }

      }
    }
  }
  {
  fd = fopen((char const   * __restrict  )((char *)eap->arg), (char const   * __restrict  )mode);
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {

    }
  }
  return (fd);
}
}
static void do_setmark(EXARG *eap ) 
{ 
  FPOS pos___0 ;
  int tmp ;

  {
  if ((int )*(eap->arg) == 0) {
    {
    emsg(e_argreq);
    }
  } else { //Added block
  if ((int )*(eap->arg + 1) != 0) {
    {
    emsg(e_trailing);
    }
  } else {
    {




    }






  }
  }
  return;
}
}
static int depth___0  =    0;
static void do_normal(EXARG *eap ) 
{ 
  OPARG oa ;
  int len___0 ;
  int save_msg_scroll ;
  int save_restart_edit ;
  int save_msg_didout ;
  linenr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  save_msg_scroll = msg_scroll;
  save_restart_edit = restart_edit;
  save_msg_didout = msg_didout;
  if ((long )depth___0 >= p_mmd) {
    {

    }

  }
  if (vgetc_busy) {
    {

    }

  }
  depth___0 ++;
  msg_scroll = 0;
  restart_edit = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    clear_oparg(& oa);
    }
    if (eap->addr_count != 0) {




    }
    len___0 = typelen;
    if (eap->forceit) {

    } else {
      tmp___0 = 0;
    }
    {
    ins_typebuf(eap->arg, tmp___0, 0, 1);
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      tmp___1 = stuff_empty();
      }
      if (tmp___1) {
        {
        tmp___2 = typebuf_typed();
        }
        if (tmp___2) {
          goto while_break___0;
        } else { //Added block
        if (typelen > len___0) {
          _L: ;
          if (! (! got_int)) {

          }
        } else {

        }
        }
      } else {

      }
      {
      adjust_cursor();
      update_topline();
      }
      if (! curwin->w_p_wrap) {
        {

        }
      }
      {
      update_curswant();
      normal_cmd(& oa, 0);
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (eap->addr_count > 0) {







    } else {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  depth___0 --;
  msg_scroll = save_msg_scroll;
  restart_edit = save_restart_edit;
  msg_didout |= save_msg_didout;
  return;
}
}
static char_u *do_findpat(EXARG *eap , int action ) 
{




























































}
static void do_ex_tag(EXARG *eap , int dt , int preview ) 
{
















}
static char_u *do_if(EXARG *eap , struct condstack *cstack ) 
{





































}
static char_u *do_else(EXARG *eap , struct condstack *cstack ) 
{


























































}
static char_u *do_while(EXARG *eap , struct condstack *cstack ) 
{









































}
static char_u *do_continue(struct condstack *cstack ) 
{





























}
static char_u *do_break(struct condstack *cstack ) 
{






























}
static char_u *do_endwhile(struct condstack *cstack ) 
{
































}
static int has_while_cmd(char_u *p___0 ) 
{ 


  {
  {
  p___0 = skipwhite(p___0);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*p___0 == 58)) {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  p___0 = skipwhite(p___0);
  }
  if ((int )*(p___0 + 0) == 119) {
    if ((int )*(p___0 + 1) == 104) {

    }
  }
  return (0);
}
}
static char *spec_str[9]  = 
  {      (char *)"%",      (char *)"#",      (char *)"<cword>",      (char *)"<cWORD>", 
        (char *)"<cfile>",      (char *)"<sfile>",      (char *)"<afile>",      (char *)"<abuf>", 
        (char *)"<amatch>"};
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) 
{




























































































































































































































}
char_u *expand_sfile(char_u *arg ) 
{


















































































}
static int makeopens(FILE *fd ) 
{










































































































































































































































































































































































































































































































































































































































}
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) 
{



























}
static int ses_fname(FILE *fd , BUF *buf___3 ) 
{
















































}
int put_eol(FILE *fd ) 
{ 
  int tmp ;

  {
  {
  tmp = _IO_putc('\n', fd);
  }
  if (tmp < 0) {

  }
  return (1);
}
}
static void cmd_source(char_u *fname , int forceit ) 
{

























}
void dialog_msg(char_u *buff , char *format , char_u *fname ) 
{






























}
static void ex_behave(char_u *arg ) 
{

































}
static void ex_filetype(char_u *arg ) 
{



























}
static void ex_options(void) 
{








}
#pragma merger("0","/tmp/cil-18TzbvMo.i","-O0")
int cmdline_crypt ;
int quit_more ;
int msg_no_more ;
int mouse_row  ;
int mouse_col  ;
int maptick ;
int redir_off ;
int save_p_ls ;
int wild_menu_showing ;
char_u wim_flags[4]  ;
char_u e_nomatch2[13] ;
char_u e_toomany[20] ;
long p_hi  ;
int p_is  ;
long p_ls  ;
long p_wc  ;
long p_wcm  ;
int p_wmnu  ;
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) ;
void redrawcmdline(void) ;
void compute_cmdrow(void) ;
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) ;
void remove_key_from_history(void) ;
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) ;
char_u *get_augroup_name(int idx ) ;
char_u *get_event_name(int idx ) ;
int inchar(char_u *buf___3 , int maxlen , long wait_time ) ;
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) ;
char_u *get_menu_name(int idx ) ;
char_u *get_menu_names(int idx ) ;
int msg_outtrans_len(char_u *str___1 , int len___0 ) ;
void msg_puts_long_attr(char_u *longstr , int attr ) ;
void msg_check(void) ;
int match_suffix(char_u *fname ) ;
void vim_strncpy(char_u *to , char_u *from , int len___0 ) ;
int cmdline_paste(int regname___0 , int literally ) ;
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) ;
int ExpandOldSetting(int *num_file , char_u ***file ) ;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) ;
void screen_down(void) ;
char_u *get_syntax_name(int idx ) ;
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) ;
void last_status(void) ;
static struct cmdline_info ccline  ;
static int cmd_numfiles  =    -1;
static char_u **cmd_files  =    (char_u **)((void *)0);
static struct hist_entry *history[4]  = {      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0)};
static int hisidx[4]  = {      -1,      -1,      -1,      -1};
static int hisnum[4]  = {      0,      0,      0,      0};
static int hislen  =    0;
static int hist_char2type(int c ) ;
static void init_history(void) ;
static int in_history(int type , char_u *str___1 , int move_to_front ) ;
static int calc_hist_idx(int histype , int num ) ;
static int cmdline_charsize(int idx ) ;
static void set_cmdspos(void) ;
static void set_cmdspos_cursor(void) ;
static void alloc_cmdbuff(int len___0 ) ;
static int realloc_cmdbuff(int len___0 ) ;
static void putcmdline(int c ) ;
static void cmdline_del(int from ) ;
static void redrawcmdprompt(void) ;
static void redrawcmd(void) ;
static void cursorcmd(void) ;
static int ccheck_abbr(int c ) ;
static int nextwild(int type , int options___0 ) ;
static int showmatches(int wildmenu ) ;
static void set_expand_context(void) ;
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) 
{ 
  int c ;
  int cc___0 ;
  int i___0 ;
  int j ;
  char_u *p___0 ;
  int hiscnt ;
  char_u *lookfor ;
  int gotesc ;
  int do_abbr ;
  int histype ;
  FPOS old_cursor ;
  colnr_t old_curswant ;
  colnr_t old_leftcol___0 ;
  linenr_t old_topline___0 ;
  linenr_t old_botline ;
  int did_incsearch ;
  int incsearch_postponed ;
  int did_wild_list ;
  int wim_index ;
  int res ;
  int save_msg_scroll ;
  int save_State ;
  int some_key_typed ;
  int ignore_drag_release ;
  int break_ctrl_c ;
  int tmp ;
  int skt ;
  int found ;
  char_u upseg[5] ;
  int found___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int found___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  int p_wmnu_save ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  struct cmdline_info save_ccline ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char_u *tmp___32 ;
  int tmp___33 ;

  {
  lookfor = (char_u *)((void *)0);
  gotesc = 0;
  did_incsearch = 0;
  incsearch_postponed = 0;
  did_wild_list = 0;
  wim_index = 0;
  save_msg_scroll = msg_scroll;
  save_State = State;
  some_key_typed = 0;
  ignore_drag_release = 1;
  break_ctrl_c = 0;
  if (firstc == -1) {


  }
  ccline.overstrike = 0;
  old_cursor = curwin->w_cursor;
  old_curswant = curwin->w_curswant;
  old_leftcol___0 = curwin->w_leftcol;
  old_topline___0 = curwin->w_topline;
  old_botline = curwin->w_botline;
  if (firstc == 64) {

  } else {
    ccline.cmdfirstc = firstc;
  }
  ccline.cmdindent = indent;
  if (exmode_active) {

  } else {
    tmp = 0;
  }
  {
  alloc_cmdbuff(tmp);
  }
  if ((unsigned long )ccline.cmdbuff == (unsigned long )((void *)0)) {

  }
  {
  ccline.cmdpos = 0;
  ccline.cmdlen = ccline.cmdpos;
  redir_off = 1;
  i___0 = msg_scrolled;
  msg_scrolled = 0;
  gotocmdline(1);
  msg_scrolled += i___0;
  redrawcmdprompt();
  set_cmdspos();
  expand_context = 0;
  msg_scroll = 0;
  State = 8;
  setmouse();
  init_history();
  hiscnt = hislen;
  histype = hist_char2type(firstc);
  do_digraph(-1);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    quit_more = 0;
    cursorcmd();
    c = safe_vgetc();
    }
    if (KeyTyped) {
      some_key_typed = 1;
    }
    if (c == 3) {

    } else { //Added block
    if (c == intr_char) {
      _L: ;







    }
    }
    if (lookfor) {



































    }
    if ((long )c != p_wc) {
      if (c == 253 + (53 << 8)) {



      }
    }
    if (did_wild_list) {









    }
    if (expand_context == 21) {



















    }
    if (cmd_numfiles != -1) {


























































    }
    if (expand_context == 21) {

















































    }
    if (expand_context == 2) {














































































































































    }
    if (c == 28) {
      {

      }









    }
    {
    c = do_digraph(c);
    }
    if (c == 10) {
      goto _L___6;
    } else { //Added block
    if (c == 13) {
      goto _L___6;
    } else { //Added block
    if (c == 75 + (65 << 8)) {

    } else { //Added block
    if (c == 27) {
      if (! KeyTyped) {

      } else {
        {
        tmp___7 = vim_strchr(p_cpo, 'x');
        }
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
          _L___6: ;
          {
          gotesc = 0;
          tmp___6 = ccheck_abbr(c + 256);
          }
          if (tmp___6) {
            goto cmdline_changed;
          }
          {
          windgoto(msg_row, 0);
          out_flush();
          }
          goto while_break;
        }
      }
    }
    }
    }
    }
    if ((long )c == p_wc) {









    } else { //Added block
    _L___11: ;
    if ((long )c == p_wcm) {
      _L___9: ;


























































































































    }
    }
    gotesc = 0;
    if (c == 253 + (53 << 8)) {
      if (KeyTyped) {
        {

        }
        if (tmp___9 == 1) {
          {

          }
          if (tmp___10 == 1) {
            {

            }



          }
        }
      }
    }
    if (c == 0) {

    } else { //Added block
    if (c == 255 + (88 << 8)) {

    }
    }
    do_abbr = 1;
    {
    if (c == 107 + (98 << 8)) {

    }
    if (c == 8) {
      goto case_exp;
    }
    if (c == 107 + (68 << 8)) {

    }
    if (c == 253 + (70 << 8)) {

    }
    if (c == 23) {

    }
    if (c == 107 + (73 << 8)) {

    }
    if (c == 253 + (69 << 8)) {

    }
    if (c == 21) {

    }
    if (c == 27) {

    }
    if (c == 3) {

    }
    if (c == 18) {

    }
    if (c == 4) {

    }
    if (c == 107 + (114 << 8)) {

    }
    if (c == 37 + (105 << 8)) {

    }
    if (c == 107 + (108 << 8)) {

    }
    if (c == 35 + (52 << 8)) {

    }
    if (c == 253 + (51 << 8)) {

    }
    if (c == 253 + (46 << 8)) {

    }
    if (c == 253 + (47 << 8)) {

    }
    if (c == 253 + (45 << 8)) {

    }
    if (c == 253 + (43 << 8)) {

    }
    if (c == 253 + (44 << 8)) {

    }
    if (c == 253 + (49 << 8)) {

    }
    if (c == 253 + (50 << 8)) {

    }
    if (c == 253 + (42 << 8)) {

    }
    if (c == 253 + (48 << 8)) {

    }
    if (c == 253 + (67 << 8)) {

    }
    if (c == 253 + (68 << 8)) {

    }
    if (c == 245 + (88 << 8)) {

    }
    if (c == 2) {

    }
    if (c == 107 + (104 << 8)) {

    }
    if (c == 75 + (49 << 8)) {

    }
    if (c == 253 + (60 << 8)) {

    }
    if (c == 35 + (50 << 8)) {

    }
    if (c == 5) {

    }
    if (c == 64 + (55 << 8)) {

    }
    if (c == 75 + (52 << 8)) {

    }
    if (c == 253 + (59 << 8)) {

    }
    if (c == 42 + (55 << 8)) {

    }
    if (c == 1) {

    }
    if (c == 12) {

    }
    if (c == 14) {

    }
    if (c == 16) {

    }
    if (c == 107 + (117 << 8)) {

    }
    if (c == 107 + (100 << 8)) {

    }
    if (c == 253 + (4 << 8)) {

    }
    if (c == 253 + (5 << 8)) {

    }
    if (c == 107 + (80 << 8)) {

    }
    if (c == 75 + (51 << 8)) {

    }
    if (c == 107 + (78 << 8)) {

    }
    if (c == 75 + (53 << 8)) {

    }
    if (c == 22) {
      goto case_22;
    }
    if (c == 17) {

    }
    if (c == 11) {

    }
    if (c == 75 + (54 << 8)) {

    }
    if (c == 75 + (55 << 8)) {

    }
    if (c == 75 + (56 << 8)) {

    }
    if (c == 75 + (57 << 8)) {

    }
    goto switch_default;
    case_exp: ;/* CIL Label */ 
    case_8: ;/* CIL Label */ 
    case_exp___0: ;/* CIL Label */ 
    case_exp___1: ;/* CIL Label */ 
    case_23: ;/* CIL Label */ 
    if (c == 253 + (70 << 8)) {

    }
    if (c == 107 + (68 << 8)) {



    }
    if (ccline.cmdpos > 0) {
      j = ccline.cmdpos;
      if (c == 23) {
        {














        while_break___3: ;/* CIL Label */ ;
        }
        {

        }
        {





















        while_break___4: ;/* CIL Label */ ;
        }
      } else {
        (ccline.cmdpos) --;
      }
      ccline.cmdlen -= j - ccline.cmdpos;
      i___0 = ccline.cmdpos;
      {
      while (1) {
        while_continue___5: ;/* CIL Label */ ;
        if (! (i___0 < ccline.cmdlen)) {
          goto while_break___5;
        }





      }
      while_break___5: ;/* CIL Label */ ;
      }
      {
      redrawcmd();
      }
    } else { //Added block
    if (ccline.cmdlen == 0) {
      if (c != 23) {
        if ((unsigned long )ccline.cmdprompt == (unsigned long )((void *)0)) {










        }
      }
    }
    }
    goto cmdline_changed;
    case_exp___2: ;/* CIL Label */ 
    case_exp___3: ;/* CIL Label */ 


    case_21: ;/* CIL Label */ 
    {



    }

    case_27: ;/* CIL Label */ 
    case_3: ;/* CIL Label */ 


    case_18: ;/* CIL Label */ 
    {




    }



























    {

    }

    case_4: ;/* CIL Label */ 
    {

    }



    {

    }

    case_exp___4: ;/* CIL Label */ 
    case_exp___5: ;/* CIL Label */ 
    {




























    while_break___6: ;/* CIL Label */ ;
    }

    case_exp___6: ;/* CIL Label */ 
    case_exp___7: ;/* CIL Label */ 
    {























    while_break___7: ;/* CIL Label */ ;
    }

    case_exp___8: ;/* CIL Label */ 
    case_exp___9: ;/* CIL Label */ 
    case_exp___10: ;/* CIL Label */ 

    case_exp___11: ;/* CIL Label */ 
    {

    }



    {


    }

    case_exp___12: ;/* CIL Label */ 
    case_exp___13: ;/* CIL Label */ 
    case_exp___14: ;/* CIL Label */ 
    case_exp___15: ;/* CIL Label */ 



    case_exp___16: ;/* CIL Label */ 
    case_exp___17: ;/* CIL Label */ 









    {

    }



    {


    }
    {
















    while_break___8: ;/* CIL Label */ ;
    }

    case_exp___18: ;/* CIL Label */ 
    case_exp___19: ;/* CIL Label */ 

    case_exp___20: ;/* CIL Label */ 

    case_2: ;/* CIL Label */ 
    case_exp___21: ;/* CIL Label */ 
    case_exp___22: ;/* CIL Label */ 
    case_exp___23: ;/* CIL Label */ 
    case_exp___24: ;/* CIL Label */ 
    {


    }

    case_5: ;/* CIL Label */ 
    case_exp___25: ;/* CIL Label */ 
    case_exp___26: ;/* CIL Label */ 
    case_exp___27: ;/* CIL Label */ 
    case_exp___28: ;/* CIL Label */ 
    {



    }

    case_1: ;/* CIL Label */ 
    {

    }




    case_12: ;/* CIL Label */ 
    {

    }




    case_14: ;/* CIL Label */ 
    case_16: ;/* CIL Label */ 














    case_exp___29: ;/* CIL Label */ 
    case_exp___30: ;/* CIL Label */ 
    case_exp___31: ;/* CIL Label */ 
    case_exp___32: ;/* CIL Label */ 
    case_exp___33: ;/* CIL Label */ 
    case_exp___34: ;/* CIL Label */ 
    case_exp___35: ;/* CIL Label */ 
    case_exp___36: ;/* CIL Label */ 


















    {


    }
    {



















































































    while_break___9: ;/* CIL Label */ ;
    }

























    {

    }

    case_22: ;/* CIL Label */ 
    case_17: ;/* CIL Label */ 
    {
    ignore_drag_release = 1;
    putcmdline('^');
    c = get_literal();
    do_abbr = 0;
    }
    goto switch_break;
    case_11: ;/* CIL Label */ 
    {







    }


























    {

    }

    case_exp___37: ;/* CIL Label */ 


    case_exp___38: ;/* CIL Label */ 


    case_exp___39: ;/* CIL Label */ 


    case_exp___40: ;/* CIL Label */ 


    switch_default: ;/* CIL Label */ 
    if (c == intr_char) {


    }
    if (! (c >= 512)) {
      mod_mask = 0;
    }
    goto switch_break;
    switch_break: ;/* CIL Label */ ;
    }
    if (do_abbr) {
      if (c >= 512) {

      } else {
        {
        tmp___30 = vim_iswordc(c);
        }
        if (! tmp___30) {
          _L___17: ;
          {
          tmp___31 = ccheck_abbr(c);
          }
          if (tmp___31) {

          }
        }
      }
    }
    if (c >= 512) {
      {


      }
    } else { //Added block
    if (mod_mask != 0) {
      {


      }
    } else {
      {
      *(IObuff + 0) = (char_u )c;
      put_on_cmdline(IObuff, 1, 1);
      }
    }
    }
    goto cmdline_changed;
    cmdline_not_changed: ;



    cmdline_changed: ;
    if (p_is) {
      if (firstc == 47) {

      } else { //Added block
      if (firstc == 63) {
        _L___18: ;
        {

        }






















        {











        }
      }
      }
    }
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
  returncmd: ;
  if (did_incsearch) {
    {








    }
  }
  if ((unsigned long )ccline.cmdbuff != (unsigned long )((void *)0)) {
    *(ccline.cmdbuff + ccline.cmdlen) = (char_u )'\000';
    if (ccline.cmdlen) {
      if (firstc) {
        if (some_key_typed) {
          goto _L___19;
        } else { //Added block
        if (histype == 1) {
          _L___19: ;
          {
          add_to_history(histype, ccline.cmdbuff, 1);
          }
          if (firstc == 58) {
            {
            vim_free((void *)new_last_cmdline);
            new_last_cmdline = vim_strsave(ccline.cmdbuff);
            }
          }
        }
        }
      }
    }
    if (gotesc) {
      {




      }
    }
  }
  {
  msg_check();
  msg_scroll = save_msg_scroll;
  redir_off = 0;
  }
  if (some_key_typed) {
    need_wait_return = 0;
  }
  {
  State = save_State;
  setmouse();
  }
  return (ccline.cmdbuff);
}
}
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) 
{














}
static int cmdline_charsize(int idx ) 
{











}
static void set_cmdspos(void) 
{ 


  {
  if (ccline.cmdfirstc) {
    ccline.cmdspos = 1 + ccline.cmdindent;
  } else {

  }
  return;
}
}
static void set_cmdspos_cursor(void) 
{ 
  int i___0 ;
  int m ;
  int c ;

  {
  {
  set_cmdspos();
  }
  if (KeyTyped) {

  } else {
    m = 2147483647;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (i___0 < ccline.cmdlen) {
      if (! (i___0 < ccline.cmdpos)) {

      }
    } else {
      goto while_break;
    }
    if (cmdline_crypt) {

    } else {
      {
      c = charsize((int )*(ccline.cmdbuff + i___0));
      }
    }
    ccline.cmdspos += c;
    if (ccline.cmdspos >= m) {



    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
char_u *getexline(int c , void *dummy , int indent ) 
{ 
  int tmp ;
  char_u *tmp___0 ;

  {
  if (exec_from_reg) {
    {

    }





  }
  {
  tmp___0 = getcmdline(c, 1L, indent);
  }
  return (tmp___0);
}
}
char_u *getexmodeline(int c , void *dummy , int indent ) 
{ 
  struct growarray line_ga ;
  int len___0 ;
  int off___0 ;
  char_u *p___0 ;
  int finished ;
  int tmp ;
  int tmp___0 ;

  {
  {
  off___0 = 0;
  finished = 0;
  cursor_on();
  compute_cmdrow();
  }
  if (msg_col) {
    {
    msg_putchar('\n');
    }
  }
  if (c == 58) {
    {
    msg_putchar(':');
    }
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      tmp = indent;
      indent --;
      if (! (tmp > 0)) {
        goto while_break;
      }
      {

      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  {
  ga_init2(& line_ga, 1, 30);
  got_int = 0;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! got_int) {
      if (! (! finished)) {
        goto while_break___0;
      }
    } else {

    }
    {
    tmp___0 = ga_grow(& line_ga, 40);
    }
    if (tmp___0 == 0) {

    }
    {
    p___0 = (char_u *)line_ga.ga_data + line_ga.ga_len;
    len___0 = inchar(p___0 + off___0, 3, -1L);
    }
    if (len___0 < 0) {

    }
    if ((int )*p___0 == 128) {

    } else { //Added block
    if ((int )*p___0 == 155) {
      _L: ;




    }
    }
    len___0 += off___0;
    off___0 = 0;
    line_ga.ga_len += len___0;
    line_ga.ga_room -= len___0;
    p___0 = (char_u *)line_ga.ga_data + line_ga.ga_len;
    if (line_ga.ga_len) {
      if ((int )*(p___0 + -1) == 10) {
        finished = 1;
        (line_ga.ga_len) --;
        p___0 --;
        *p___0 = (char_u )'\000';
      }
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  screen_down();
  msg_didout = 0;
  msg_col = 0;
  }
  if ((long )msg_row < Rows - 1L) {

  }
  emsg_on_display = 0;
  if (got_int) {
    {

    }
  }
  return ((char_u *)line_ga.ga_data);
}
}
static void alloc_cmdbuff(int len___0 ) 
{ 


  {
  if (len___0 < 80) {
    len___0 = 100;
  } else {

  }
  {
  ccline.cmdbuff = alloc((unsigned int )len___0);
  ccline.cmdbufflen = len___0;
  }
  return;
}
}
static int realloc_cmdbuff(int len___0 ) 
{

















}
static void putcmdline(int c ) 
{ 
  char_u buf___3[1] ;

  {
  {
  msg_no_more = 1;
  buf___3[0] = (char_u )c;
  msg_outtrans_len(buf___3, 1);
  msg_outtrans_len(ccline.cmdbuff + ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);
  msg_no_more = 0;
  cursorcmd();
  }
  return;
}
}
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) 
{ 
  int retval ;
  int i___0 ;
  int m ;
  int c ;
  size_t tmp ;

  {
  if (len___0 < 0) {
    {


    }
  }
  if ((ccline.cmdlen + len___0) + 1 >= ccline.cmdbufflen) {
    {

    }
  } else {
    retval = 1;
  }
  if (retval == 1) {
    if (! ccline.overstrike) {
      {
      memmove((void *)((char *)((ccline.cmdbuff + ccline.cmdpos) + len___0)), (void const   *)((char *)(ccline.cmdbuff + ccline.cmdpos)),
              (size_t )(ccline.cmdlen - ccline.cmdpos));
      ccline.cmdlen += len___0;
      }
    } else { //Added block



    }
    {
    memmove((void *)((char *)(ccline.cmdbuff + ccline.cmdpos)), (void const   *)((char *)str___1),
            (size_t )len___0);
    }
    if (redraw) {
      if (cmdline_crypt) {

        {










        while_break: ;/* CIL Label */ ;
        }
      } else {
        {
        msg_no_more = 1;
        msg_outtrans_len(ccline.cmdbuff + ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);
        msg_no_more = 0;
        }
      }
    }
    if (KeyTyped) {
      m = (int )(Columns * Rows);
    } else {
      m = 2147483647;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (i___0 < len___0)) {
        goto while_break___0;
      }
      if (cmdline_crypt) {

      } else {
        {
        c = charsize((int )*(str___1 + i___0));
        }
      }
      if (ccline.cmdspos + c >= m) {

      }
      (ccline.cmdpos) ++;
      ccline.cmdspos += c;
      i___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  if (redraw) {
    {
    msg_check();
    }
  }
  return (retval);
}
}
static void cmdline_del(int from ) 
{











}
void redrawcmdline(void) 
{











}
static void redrawcmdprompt(void) 
{ 
  int i___0 ;

  {
  if (ccline.cmdfirstc) {
    {
    msg_putchar(ccline.cmdfirstc);
    }
  }
  if ((unsigned long )ccline.cmdprompt != (unsigned long )((void *)0)) {
    {


    }
  } else {
    i___0 = ccline.cmdindent;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (i___0 > 0)) {
        goto while_break;
      }
      {


      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  return;
}
}
static void redrawcmd(void) 
{ 
  int i___0 ;

  {
  {
  msg_start();
  redrawcmdprompt();
  }
  if (cmdline_crypt) {

    {










    while_break: ;/* CIL Label */ ;
    }
    {

    }
  } else {
    {
    msg_no_more = 1;
    msg_outtrans_len(ccline.cmdbuff, ccline.cmdlen);
    msg_clr_eos();
    msg_no_more = 0;
    }
  }
  {
  set_cmdspos_cursor();
  msg_scroll = 0;
  skip_redraw = 0;
  }
  return;
}
}
void compute_cmdrow(void) 
{ 


  {
  if (exmode_active) {
    cmdline_row = (int )(Rows - 1L);
  } else { //Added block
  if (msg_scrolled) {

  } else {
    cmdline_row = (lastwin->w_winpos + lastwin->w_height) + lastwin->w_status_height;
  }
  }
  return;
}
}
static void cursorcmd(void) 
{ 


  {
  msg_row = cmdline_row + ccline.cmdspos / (int )Columns;
  msg_col = ccline.cmdspos % (int )Columns;
  if ((long )msg_row >= Rows) {

  }
  {
  windgoto(msg_row, msg_col);
  }
  return;
}
}
void gotocmdline(int clr ) 
{ 


  {
  {
  msg_start();
  msg_col = 0;
  }
  if (clr) {
    {
    msg_clr_eos();
    }
  }
  {
  windgoto(cmdline_row, 0);
  }
  return;
}
}
static int ccheck_abbr(int c ) 
{ 
  int tmp ;

  {
  if (p_paste) {
    return (0);
  } else { //Added block
  if (no_abbr) {
    return (0);
  }
  }
  {
  tmp = check_abbr(c, ccline.cmdbuff, ccline.cmdpos, 0);
  }
  return (tmp);
}
}
static int nextwild(int type , int options___0 ) 
{














































































































































}
static int findex  ;
static char_u *orig_save  =    (char_u *)((void *)0);
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) 
{








































































































































































































































































































































































}
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) 
{


































}
static int showmatches(int wildmenu ) 
{


























































































































































































































}
char_u *addstar(char_u *fname , int len___0 , int context ) 
{
















































































































































}
static void set_expand_context(void) 
{





























}
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) 
{












































































































































































































































}
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) 
{















































































}
static int hist_char2type(int c ) 
{ 


  {
  if (c == 58) {
    return (0);
  }
  if (c == 61) {

  }
  if (c == 64) {

  }
  return (1);
}
}
static char *history_names[5]  = {      (char *)"cmd",      (char *)"search",      (char *)"expr",      (char *)"input", 
        (char *)((void *)0)};
static void init_history(void) 
{ 
  int newlen ;
  struct hist_entry *temp ;
  int i___0 ;
  int j ;
  int type ;
  char_u *tmp ;

  {
  newlen = (int )p_hi;
  if (newlen != hislen) {
    type = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (type < 4)) {
        goto while_break;
      }
      if (newlen) {
        {
        tmp = lalloc((unsigned long )newlen * sizeof(struct hist_entry ), 1);
        temp = (struct hist_entry *)tmp;
        }
        if ((unsigned long )temp == (unsigned long )((void *)0)) {







        }
      } else {

      }
      if (newlen == 0) {

      } else { //Added block
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        _L: ;
        if (hisidx[type] < 0) {
          i___0 = 0;
          {
          while (1) {
            while_continue___0: ;/* CIL Label */ ;
            if (! (i___0 < newlen)) {
              goto while_break___0;
            }
            (temp + i___0)->hisnum = 0;
            (temp + i___0)->hisstr = (char_u *)((void *)0);
            i___0 ++;
          }
          while_break___0: ;/* CIL Label */ ;
          }
        } else { //Added block
































































        }
        {
        vim_free((void *)history[type]);
        history[type] = temp;
        }
      }
      }
      __Cont: ;
      type ++;
    }
    while_break: ;/* CIL Label */ ;
    }
    hislen = newlen;
  }
  return;
}
}
static int in_history(int type , char_u *str___1 , int move_to_front ) 
{ 
  int i___0 ;
  int last_i ;
  int tmp ;

  {
  last_i = -1;
  if (hisidx[type] < 0) {
    return (0);
  }
  i___0 = hisidx[type];
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((unsigned long )(history[type] + i___0)->hisstr == (unsigned long )((void *)0)) {
      return (0);
    }
    {
    tmp = strcmp((char const   *)((char *)str___1), (char const   *)((char *)(history[type] + i___0)->hisstr));
    }
    if (tmp == 0) {





    }
    i___0 --;
    if (i___0 < 0) {
      i___0 = hislen - 1;
    }
    if (! (i___0 != hisidx[type])) {

    }
  }
  while_break: ;/* CIL Label */ ;
  }























}
}
int get_histtype(char_u *name___1 ) 
{











































}
static int last_maptick  =    -1;
void add_to_history(int histype , char_u *new_entry , int in_map ) 
{ 
  struct hist_entry *hisptr ;
  int tmp ;

  {
  if (hislen == 0) {
    return;
  }
  if (histype == 1) {
















  }
  {
  tmp = in_history(histype, new_entry, 1);
  }
  if (! tmp) {
    (hisidx[histype]) ++;
    if (hisidx[histype] == hislen) {

    }
    {
    hisptr = history[histype] + hisidx[histype];
    vim_free((void *)hisptr->hisstr);
    hisptr->hisstr = vim_strsave(new_entry);
    (hisnum[histype]) ++;
    hisptr->hisnum = hisnum[histype];
    }
    if (histype == 1) {



    }
  }
  return;
}
}
int get_history_idx(int histype ) 
{




















}
static int calc_hist_idx(int histype , int num ) 
{

























































}
char_u *get_history_entry(int histype , int idx ) 
{












}
int clr_history(int histype ) 
{





































}
int del_history_entry(int histype , char_u *str___1 ) 
{













































































}
int del_history_idx(int histype , int idx ) 
{










































}
void remove_key_from_history(void) 
{










































































}
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) 
{























































}
void do_history(char_u *arg ) 
{


























































































































































































}
static char_u **viminfo_history[4]  = {      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0)};
static int viminfo_hisidx[4]  = {      0,      0,      0,      0};
static int viminfo_hislen[4]  = {      0,      0,      0,      0};
static int viminfo_add_at_front  =    0;
static int hist_type2char(int type , int use_question ) ;
static int hist_type2char(int type , int use_question ) 
{


















}
void prepare_viminfo_history(int asklen ) 
{ 
  int i___0 ;
  int num ;
  int type ;
  int len___0 ;
  char_u *tmp ;

  {
  {
  init_history();
  viminfo_add_at_front = asklen != 0;
  }
  if (asklen > hislen) {
    asklen = hislen;
  }
  type = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (type < 4)) {
      goto while_break;
    }
    i___0 = 0;
    num = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (i___0 < hislen)) {
        goto while_break___0;
      }




    }
    while_break___0: ;/* CIL Label */ ;
    }
    len___0 = asklen;
    if (num > len___0) {

    }
    if (len___0 <= 0) {
      viminfo_history[type] = (char_u **)((void *)0);
    } else {
      {


      }
    }
    if ((unsigned long )viminfo_history[type] == (unsigned long )((void *)0)) {
      len___0 = 0;
    }
    viminfo_hislen[type] = len___0;
    viminfo_hisidx[type] = 0;
    type ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
int read_viminfo_history(char_u *line , FILE *fp___0 ) 
{


































}
void finish_viminfo_history(void) 
{ 
  int idx ;
  int i___0 ;
  int type ;
  int tmp ;

  {
  type = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (type < 4)) {

    }
    if ((unsigned long )history[type] == (unsigned long )((void *)0)) {
      return;
    }






































    {















    while_break___1: ;/* CIL Label */ ;
    }



    {












    while_break___2: ;/* CIL Label */ ;
    }
    {



    }
  }
  while_break: ;/* CIL Label */ ;
  }

}
}
void write_viminfo_history(FILE *fp___0 ) 
{ 
  int i___0 ;
  int type ;
  int num_saved ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  init_history();
  }
  if (hislen == 0) {
    return;
  }

  {

































































  while_break: ;/* CIL Label */ ;
  }

}
}
#pragma merger("0","/tmp/cil-t_UM_gnV.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
int recoverymode ;
int p_bk  ;
char_u *p_bdir  ;
char_u *p_bex  ;
char_u *p_ei  ;
char_u *p_pm  ;
int p_wb  ;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) ;
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) ;
void check_timestamps(int focus ) ;
void vim_deltempdir(void) ;
int check_ei(void) ;
int has_cursorhold(void) ;
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) ;
void mf_fullname(MEMFILE *mfp ) ;
void check_need_swap(int newfile ) ;
char_u *get_file_in_dir(char_u *fname , char_u *dname ) ;
char_u *msg_may_trunc(int force , char_u *s ) ;
void add_pathsep(char_u *p___0 ) ;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
void do_outofmem_msg(void) ;
int decrypt_byte(void) ;
int update_keys(int c ) ;
void crypt_init_keys(char_u *passwd ) ;
void screenclear(void) ;
void u_unchanged(BUF *buf___3 ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
static void aucmd_prepbuf(struct aco_save *aco ) ;
static void aucmd_restbuf(struct aco_save *aco ) ;
static void check_marks_read(void) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) ;
static void msg_add_fname(BUF *buf___3 , char_u *fname ) ;
static int msg_add_fileformat(int eol_type ) ;
static void msg_add_lines(int insert_space , long lnum , long nchars ) ;
static void msg_add_eol(void) ;
static int check_mtime(BUF *buf___3 , struct stat *st ) ;
static int time_differs(long t1 , long t2 ) ;
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) ;
static linenr_t write_no_eol_lnum  =    (linenr_t )0;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) 
{ 
  int msg_scroll_save ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  msg_add_fname(buf___3, name___1);
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s));
  msg_scroll_save = msg_scroll;
  tmp = shortmess('O');
  }
  if (tmp) {

  }
  if (! msg_scroll) {
    {

    }
  }
  {
  msg_start();
  msg_scroll = msg_scroll_save;
  tmp___0 = msg_may_trunc(0, IObuff);
  msg_outtrans_attr(tmp___0, attr);
  msg_clr_eos();
  out_flush();
  }
  return;
}
}
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) 
{ 
  int fd ;
  int newfile ;
  int check_readonly___0 ;
  int filtering ;
  int read_stdin ;
  char_u c ;
  linenr_t lnum ;
  char_u *ptr ;
  char_u *buffer ;
  char_u *new_buffer ;
  char_u *line_start ;
  int wasempty ;
  colnr_t len___0 ;
  long size ;
  char_u *p___0 ;
  long filesize ;
  char_u *cryptkey ;
  int split ;
  linenr_t linecnt ;
  int error ;
  int ff_error ;
  long linerest ;
  int perm ;
  int fileformat ;
  struct stat st ;
  int file_readonly ;
  linenr_t skip_count ;
  linenr_t read_count ;
  int msg_save ;
  linenr_t read_no_eol_lnum ;
  int try_mac ;
  char_u *tmp ;
  int try_dos ;
  char_u *tmp___0 ;
  int try_unix ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int m ;
  int n ;
  BUF *old_curbuf ;
  int tmp___12 ;
  int tmp___13 ;
  char_u tmp___14 ;
  int tmp___15 ;
  linenr_t tmp___16 ;
  __off_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int m___0 ;
  int n___0 ;

  {
  {
  newfile = flags___0 & 1;
  filtering = flags___0 & 2;
  read_stdin = flags___0 & 4;
  lnum = from;
  ptr = (char_u *)((void *)0);
  buffer = (char_u *)((void *)0);
  new_buffer = (char_u *)((void *)0);
  line_start = (char_u *)((void *)0);
  cryptkey = (char_u *)((void *)0);
  split = 0;
  error = 0;
  ff_error = -1;
  perm = 0;
  msg_save = msg_scroll;
  read_no_eol_lnum = (linenr_t )0;
  tmp = vim_strchr(p_ffs, 'm');
  try_mac = (unsigned long )tmp != (unsigned long )((void *)0);
  tmp___0 = vim_strchr(p_ffs, 'd');
  try_dos = (unsigned long )tmp___0 != (unsigned long )((void *)0);
  tmp___1 = vim_strchr(p_ffs, 'x');
  try_unix = (unsigned long )tmp___1 != (unsigned long )((void *)0);
  write_no_eol_lnum = (linenr_t )0;
  }
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {















  }
  {
  tmp___4 = shortmess('o');
  }
  if (tmp___4) {

  } else { //Added block
  if (curbuf->b_help) {

  } else {
    msg_scroll = 1;
  }
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {

  }
  fname = sfname;
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    if ((int )*fname != 0) {
      {
      tmp___5 = strlen((char const   *)((char *)fname));
      tmp___6 = vim_ispathsep((int )*((fname + tmp___5) - 1));
      }
      if (tmp___6) {
        {



        }

      }
    }
  }
  if (! read_stdin) {
    {
    tmp___7 = mch_getperm(fname);
    perm = (int )tmp___7;
    }
    if (perm >= 0) {
      if (! ((perm & 61440) == 32768)) {
        if (! ((perm & 61440) == 4096)) {
















        }
      }
    }
  }
  if (newfile) {
    if (*p_ffs) {
      {


      }
    }
  }
  if (newfile) {
    if (curbuf->b_flags & 2) {
      tmp___9 = 1;
    } else {

    }
  } else {

  }
  check_readonly___0 = tmp___9;
  if (check_readonly___0) {
    if (! readonlymode) {
      curbuf->b_p_ro = 0;
    }
  }
  if (newfile) {
    if (! read_stdin) {
      {
      tmp___10 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
      }
      if (tmp___10 >= 0) {
        curbuf->b_mtime = st.st_mtim.tv_sec;
        curbuf->b_mtime_read = st.st_mtim.tv_sec;
        if ((unsigned long )(curbuf->b_ml.ml_mfp)->mf_fname != (unsigned long )((void *)0)) {
          {

          }
        }
      } else {
        curbuf->b_mtime = 0L;
        curbuf->b_mtime_read = 0L;
      }
      curbuf->b_flags &= -49;
    }
  }
  file_readonly = 0;
  if (read_stdin) {

  } else {
    if (! (perm & 146)) {

    } else {
      {
      tmp___11 = access((char const   *)((char *)fname), 2);
      }
      if (tmp___11) {
        file_readonly = 1;
      }
    }
    {
    fd = open((char const   *)((char *)fname), 0, 0);
    }
  }
  if (fd < 0) {
    msg_scroll = msg_save;
    if (newfile) {
      if (perm < 0) {
        {
        curbuf->b_flags |= 16;
        check_need_swap(newfile);
        filemess(curbuf, sfname, (char_u *)"[New File]", 0);
        check_marks_read();
        apply_autocmds((EVENT_T )6, sfname, sfname, 0, curbuf);
        curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
        }
        return (1);
      } else {
        {

        }
      }
    }
    return (0);
  }
  if (check_readonly___0) {
    if (file_readonly) {

    } else {
      goto _L;
    }
  } else { //Added block
  _L: ;
  if (curbuf->b_help) {

  }
  }
  if (newfile) {
    curbuf->b_p_eol = 1;
  }
  {
  check_need_swap(newfile);
  }
  if (swap_exists_action == 2) {
    {

    }

  }
  no_wait_return ++;
  if (from == 0L) {
    curbuf->b_op_start.lnum = (linenr_t )1;
  } else {

  }
  curbuf->b_op_start.col = (colnr_t )0;
  m = msg_scroll;
  n = msg_scrolled;
  old_curbuf = curbuf;
  if (! read_stdin) {
    {
    close(fd);
    }
  }
  msg_scroll = 1;
  if (filtering) {
    {

    }
  } else { //Added block
  if (read_stdin) {
    {

    }
  } else { //Added block
  if (newfile) {
    {
    apply_autocmds((EVENT_T )8, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else {
    {

    }
  }
  }
  }
  if (msg_scrolled == n) {
    msg_scroll = m;
  }
  if (! read_stdin) {
    if ((unsigned long )curbuf != (unsigned long )old_curbuf) {

    } else {
      {
      fd = open((char const   *)((char *)fname), 0, 0);
      }
      if (fd < 0) {
        _L___0: ;












      }
    }
  }
  wasempty = curbuf->b_ml.ml_flags & 1;
  if (! recoverymode) {
    if (! filtering) {
      if (read_stdin) {
        {

        }
      } else {
        {
        filemess(curbuf, sfname, (char_u *)"", 0);
        }
      }
    }
  }
  msg_scroll = 0;
  if (curbuf->b_p_bin) {

  } else { //Added block
  if ((int )*p_ffs == 0) {
    {
    fileformat = get_fileformat(curbuf);
    }
  } else {

  }
  }
  linecnt = curbuf->b_ml.ml_line_count;
  retry: ;
  linerest = 0L;
  filesize = 0L;
  skip_count = lines_to_skip;
  read_count = lines_to_read;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! error) {
      if (! (! got_int)) {

      }
    } else {

    }
    size = 65536L;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (size >= 10L)) {

      }
      {
      new_buffer = lalloc((long_u )((size + linerest) + 1L), 0);
      }
      if ((unsigned long )new_buffer != (unsigned long )((void *)0)) {
        goto while_break___0;
      }

    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
      {


      }

    }
    if (linerest) {
      {


      }
    }
    {
    vim_free((void *)buffer);
    buffer = new_buffer;
    ptr = buffer + linerest;
    line_start = buffer;
    size = read(fd, (void *)((char *)ptr), (size_t )size);
    }
    if (size <= 0L) {
      if (size < 0L) {

      }
      goto while_break;
    }
    if (filesize == 0L) {
      {
      tmp___12 = strncmp((char const   *)((char *)ptr), (char const   *)((char *)"VimCrypt~01!"),
                         (size_t )12);
      }
      if (tmp___12 == 0) {



























      } else { //Added block
      if (newfile) {
        if (*(curbuf->b_p_key)) {





        }
      }
      }
    }
    if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {

      {













      while_break___1: ;/* CIL Label */ ;
      }
    }
    filesize += size;
    if (fileformat == -1) {






























































































    }
    if (fileformat == 2) {

      {













































      while_break___5: ;/* CIL Label */ ;
      }
    } else {
      ptr --;
      {
      while (1) {
        while_continue___6: ;/* CIL Label */ ;
        ptr ++;
        size --;
        if (! (size >= 0L)) {
          goto while_break___6;
        }
        c = *ptr;
        if ((int )c != 0) {
          if ((int )c != 10) {
            goto while_continue___6;
          }
        }
        if ((int )c == 0) {

        } else {
          if (skip_count == 0L) {
            *ptr = (char_u )'\000';
            len___0 = (colnr_t )((ptr - line_start) + 1L);
            if (fileformat == 1) {











































            }
            {
            tmp___18 = ml_append(lnum, line_start, len___0, newfile);
            }
            if (tmp___18 == 0) {


            }
            lnum ++;
            read_count --;
            if (read_count == 0L) {



            }
          } else {

          }
          line_start = ptr + 1;
        }
      }
      while_break___6: ;/* CIL Label */ ;
      }
    }
    {
    linerest = ptr - line_start;
    ui_breakcheck();
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (error) {



  }
  if (! error) {
    if (! got_int) {
      if (linerest != 0L) {





























      }
    }
  }
  if (lnum != from) {
    if (! newfile) {
      {

      }
    }
  }
  {
  invalidate_botline();
  changed_line_abv_curs();
  }
  if (newfile) {
    curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  }
  if ((unsigned long )cryptkey != (unsigned long )curbuf->b_p_key) {
    {
    vim_free((void *)cryptkey);
    }
  }
  {
  close(fd);
  vim_free((void *)buffer);
  no_wait_return --;
  }
  if (! recoverymode) {
    if (newfile) {
      if (wasempty) {
        if (! (curbuf->b_ml.ml_flags & 1)) {
          {
          ml_delete(curbuf->b_ml.ml_line_count, 0);
          linecnt --;
          }
        }
      }
    }
    linecnt = curbuf->b_ml.ml_line_count - linecnt;
    if (filesize == 0L) {

    }
    if (! newfile) {
      {

      }
    }
    if (read_stdin) {
      {



      }
    }
    if (got_int) {
      {



      }

    }
    if (! filtering) {
      {
      msg_add_fname(curbuf, sfname);
      c = (char_u )0;
      }
      if ((perm & 61440) == 4096) {
        {


        }
      }
      if (curbuf->b_p_ro) {
        {

        }





        {


        }
      }
      if (read_no_eol_lnum) {
        {


        }
      }
      if (ff_error == 1) {
        {


        }
      }
      if (ff_error == 2) {
        {


        }
      }
      if (split) {
        {


        }
      }
      if ((unsigned long )cryptkey != (unsigned long )((void *)0)) {
        {


        }
      }
      if (error) {
        {


        }
      }
      {
      tmp___23 = msg_add_fileformat(fileformat);
      }
      if (tmp___23) {

      }
      {
      msg_add_lines((int )c, linecnt, filesize);
      keep_msg = msg_trunc_attr(IObuff, 0, 0);
      keep_msg_attr = 0;
      }
      if (read_stdin) {

      } else { //Added block
      if (restart_edit != 0) {
        _L___5: ;










      } else {
        keep_msg = (char_u *)((void *)0);
      }
      }
    }
    if (error) {



    }
    {
    u_clearline();
    }
    if (exmode_active) {

    } else {
      curwin->w_cursor.lnum = from + 1L;
    }
    {
    check_cursor_lnum();
    beginline(5);
    curbuf->b_op_start.lnum = from + 1L;
    curbuf->b_op_start.col = (colnr_t )0;
    curbuf->b_op_end.lnum = from + linecnt;
    curbuf->b_op_end.col = (colnr_t )0;
    }
  }
  {
  msg_scroll = msg_save;
  check_marks_read();
  m___0 = msg_scroll;
  n___0 = msg_scrolled;
  write_no_eol_lnum = read_no_eol_lnum;
  msg_scroll = 1;
  }
  if (filtering) {
    {

    }
  } else { //Added block
  if (read_stdin) {
    {

    }
  } else { //Added block
  if (newfile) {
    {
    apply_autocmds((EVENT_T )7, (char_u *)((void *)0), sfname, 0, curbuf);
    }
  } else {
    {

    }
  }
  }
  }
  if (msg_scrolled == n___0) {
    msg_scroll = m___0;
  }
  if (recoverymode) {



  }
  return (1);
}
}
static void check_marks_read(void) 
{ 
  int tmp ;

  {
  if (! curbuf->b_marks_read) {
    {
    tmp = get_viminfo_parameter('\'');
    }
    if (tmp > 0) {
      {


      }
    }
  }
  return;
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) 
{ 
  struct utimbuf buf___3 ;

  {
  {
  buf___3.actime = atime;
  buf___3.modtime = mtime;
  utime((char const   *)((char *)fname), (struct utimbuf  const  *)(& buf___3));
  }
  return;
}
}
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) 
{ 
  int fd ;
  char_u *backup ;
  char_u *ffname ;
  char_u *s ;
  char_u *ptr ;
  char_u c ;
  int len___0 ;
  linenr_t lnum ;
  long nchars ;
  char_u *errmsg ;
  char_u *buffer ;
  char_u smallbuf[256] ;
  char_u *backup_ext ;
  int bufsize ;
  long perm ;
  int retval ;
  int newfile ;
  int msg_save ;
  int overwriting ;
  int no_eol ;
  struct stat st_old ;
  int made_writable ;
  int whole ;
  int tmp ;
  linenr_t old_line_count ;
  int attr ;
  int fileformat ;
  int encrypted ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aco_save aco ;
  BUF *save_buf ;
  int buf_ffname ;
  int buf_sfname ;
  int buf_fname_f ;
  int buf_fname_s ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int bfd ;
  int buflen ;
  char_u copybuf[8193] ;
  char_u *wp ;
  int some_error ;
  struct stat st_new ;
  char_u *dirp ;
  char_u *rootname ;
  int did_set_shortname ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  int tmp___16 ;
  __uid_t tmp___17 ;
  char_u *tmp___18 ;
  int tmp___19 ;
  __uid_t tmp___20 ;
  __gid_t tmp___21 ;
  char_u *tmp___22 ;
  struct stat st ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  char_u *tmp___30 ;
  char_u *tmp___31 ;
  int tmp___32 ;
  char_u *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char_u copybuf___0[8193] ;
  int bfd___0 ;
  int buflen___0 ;
  int tmp___37 ;
  ssize_t tmp___38 ;
  int tmp___39 ;
  char const   *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char *org ;
  int tmp___48 ;
  char_u *tmp___49 ;
  struct stat st___0 ;
  int tmp___50 ;
  int empty_fd ;
  long tmp___51 ;
  int tmp___52 ;
  struct aco_save aco___0 ;
  BUF *save_buf___0 ;
  int tmp___53 ;

  {
  backup = (char_u *)((void *)0);
  errmsg = (char_u *)((void *)0);
  retval = 1;
  newfile = 0;
  msg_save = msg_scroll;
  no_eol = 0;
  made_writable = 0;
  if (start___0 == 1L) {
    if (end == buf___3->b_ml.ml_line_count) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {

  }
  whole = tmp;
  old_line_count = buf___3->b_ml.ml_line_count;
  encrypted = 0;
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*fname == 0) {

  }
  }
  if (reset_changed) {
    if (whole) {
      if ((unsigned long )buf___3 == (unsigned long )curbuf) {
        if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {



















        }
      }
    }
  }
  if ((unsigned long )sfname == (unsigned long )((void *)0)) {

  }
  ffname = fname;
  fname = sfname;
  if ((int )*p_bex == 0) {

  } else {
    backup_ext = p_bex;
  }
  if ((unsigned long )buf___3->b_ffname != (unsigned long )((void *)0)) {
    {
    tmp___2 = strcmp((char const   *)((char *)ffname), (char const   *)((char *)buf___3->b_ffname));
    }
    if (tmp___2 == 0) {
      overwriting = 1;
    } else {
      overwriting = 0;
    }
  } else {

  }
  {
  tmp___3 = check_secure();
  }
  if (tmp___3) {

  }
  if (exiting) {
    {
    settmode(0);
    }
  }
  no_wait_return ++;
  buf___3->b_op_start.lnum = start___0;
  buf___3->b_op_start.col = (colnr_t )0;
  buf___3->b_op_end.lnum = end;
  buf___3->b_op_end.col = (colnr_t )0;
  buf_ffname = 0;
  buf_sfname = 0;
  buf_fname_f = 0;
  buf_fname_s = 0;
  if ((unsigned long )ffname == (unsigned long )buf___3->b_ffname) {
    buf_ffname = 1;
  }
  if ((unsigned long )sfname == (unsigned long )buf___3->b_sfname) {
    buf_sfname = 1;
  }
  if ((unsigned long )fname == (unsigned long )buf___3->b_ffname) {

  }
  if ((unsigned long )fname == (unsigned long )buf___3->b_sfname) {
    buf_fname_s = 1;
  }
  {
  save_buf = curbuf;
  curbuf = buf___3;
  aucmd_prepbuf(& aco);
  }
  if (append) {
    {
    apply_autocmds((EVENT_T )14, fname, fname, 0, curbuf);
    }
  } else { //Added block
  if (filtering) {
    {

    }
  } else { //Added block
  if (reset_changed) {
    if (whole) {
      {
      apply_autocmds((EVENT_T )12, fname, fname, 0, curbuf);
      }
    } else {
      {
      apply_autocmds((EVENT_T )20, fname, fname, 0, curbuf);
      }
    }
  } else {
    {

    }
  }
  }
  }
  {
  aucmd_restbuf(& aco);
  tmp___4 = buf_valid(buf___3);
  }
  if (tmp___4) {
    if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
      {




      }

    }
  } else {
    {




    }

  }
  if ((unsigned long )curbuf == (unsigned long )buf___3) {
    {
    tmp___5 = buf_valid(save_buf);
    }
    if (tmp___5) {
      ((curwin->w_buffer)->b_nwindows) --;
      curbuf = save_buf;
      curwin->w_buffer = save_buf;
      (curbuf->b_nwindows) ++;
    } else {

    }
  } else {

  }
  if (buf___3->b_ml.ml_line_count != old_line_count) {
    if (whole) {

    } else { //Added block
    if (buf___3->b_ml.ml_line_count > old_line_count) {

    } else {









    }
    }
  }
  if (buf_ffname) {
    ffname = buf___3->b_ffname;
  }
  if (buf_sfname) {
    sfname = buf___3->b_sfname;
  }
  if (buf_fname_f) {

  }
  if (buf_fname_s) {
    fname = buf___3->b_sfname;
  }
  {
  tmp___6 = shortmess('o');
  }
  if (tmp___6) {

  } else {
    msg_scroll = 1;
  }
  if (! filtering) {
    {
    filemess(buf___3, fname, (char_u *)"", 0);
    }
  }
  {
  msg_scroll = 0;
  buffer = alloc(8192U);
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {


  } else {
    bufsize = 8192;
  }
  {
  st_old.st_ino = (__ino_t )0;
  st_old.st_dev = st_old.st_ino;
  perm = -1L;
  tmp___7 = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st_old));
  }
  if (tmp___7 < 0) {
    newfile = 1;
  } else {
    if (! ((st_old.st_mode & 61440U) == 32768U)) {






    }
    if (overwriting) {
      {
      retval = check_mtime(buf___3, & st_old);
      }
      if (retval == 0) {

      }
    }
    perm = (long )st_old.st_mode;
  }
  if (! append) {
    if (! filtering) {
      if (perm >= 0L) {
        if (p_wb) {
          goto _L___0;
        } else { //Added block
        if (p_bk) {

        } else { //Added block
        if ((int )*p_pm != 0) {
          _L___0: ;
          {
          fd = open((char const   *)((char *)fname), 0, 0);
          }
          if (fd >= 0) {
            some_error = 0;
            dirp = p_bdir;
            {
            while (1) {
              while_continue: ;/* CIL Label */ ;
              if (! *dirp) {

              }
              {
              st_new.st_ino = (__ino_t )0;
              st_new.st_dev = st_new.st_ino;
              st_new.st_gid = (__gid_t )0;
              copy_option_part(& dirp, copybuf, 8192, (char *)",");
              rootname = get_file_in_dir(fname, copybuf);
              }
              if ((unsigned long )rootname == (unsigned long )((void *)0)) {


              }
              did_set_shortname = 0;
              {
              while (1) {
                while_continue___0: ;/* CIL Label */ ;
                if (buf___3->b_p_sn) {
                  tmp___8 = 1;
                } else { //Added block
                if (buf___3->b_shortname) {

                } else {
                  tmp___8 = 0;
                }
                }
                {
                backup = buf_modname(tmp___8, rootname, backup_ext, 0);
                }
                if ((unsigned long )backup == (unsigned long )((void *)0)) {
                  {


                  }

                }
                {
                tmp___12 = stat((char const   * __restrict  )((char *)backup), (struct stat * __restrict  )(& st_new));
                }
                if (tmp___12 >= 0) {






















































                }
                goto while_break___0;
                __Cont: ;;
              }
              while_break___0: ;/* CIL Label */ ;
              }
              {
              vim_free((void *)rootname);
              }
              if ((unsigned long )backup != (unsigned long )((void *)0)) {
                {
                unlink((char const   *)((char *)backup));
                bfd = open((char const   *)((char *)backup), 193, 438);
                }
                if (bfd < 0) {
                  {


                  }
                } else {
                  {
                  mch_setperm(backup, perm & 511L);
                  }
                  if (st_new.st_gid != st_old.st_gid) {
                    {

                    }





                  }
                  {
                  while (1) {
                    while_continue___2: ;/* CIL Label */ ;
                    {
                    tmp___15 = read(fd, (void *)((char *)(copybuf)), (size_t )8192);
                    buflen = (int )tmp___15;
                    }
                    if (! (buflen > 0)) {
                      goto while_break___2;
                    }
                    {
                    tmp___14 = write_buf(bfd, copybuf, buflen, 0);
                    }
                    if (tmp___14 == 0) {


                    }
                  }
                  while_break___2: ;/* CIL Label */ ;
                  }
                  {
                  tmp___16 = close(bfd);
                  }
                  if (tmp___16 < 0) {



                  }
                  if (buflen < 0) {

                  }
                  {
                  set_file_time(backup, st_old.st_atim.tv_sec, st_old.st_mtim.tv_sec);
                  }
                  goto while_break;
                }
              }
            }
            while_break: ;/* CIL Label */ ;
            }
            nobackup: ;
            {
            close(fd);
            }
            if ((unsigned long )backup == (unsigned long )((void *)0)) {



            }
            if (some_error) {

            } else { //Added block
            if (errmsg) {
              _L: ;




            }
            }
            errmsg = (char_u *)((void *)0);
          }
        }
        }
        }
      }
    }
  }
  if (forceit) {
    {
    tmp___17 = getuid();
    }
    if (st_old.st_uid == tmp___17) {
      if (perm >= 0L) {
        if (! (perm & 128L)) {
          {

          }







        }
      }
    }
  }
  if (forceit) {
    if (overwriting) {
      buf___3->b_p_ro = 0;
    }
  }
  if (reset_changed) {
    if (! newfile) {
      {
      tmp___19 = otherfile(ffname);
      }
      if (! tmp___19) {
        if (exiting) {
          if (! ((unsigned long )backup != (unsigned long )((void *)0))) {
            {

            }
          }
        } else {
          {
          ml_preserve(buf___3, 0);
          }
        }
      }
    }
  }
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (append) {
      if (forceit) {
        tmp___25 = 1088;
      } else {
        tmp___25 = 1024;
      }
      tmp___26 = tmp___25;
    } else {
      tmp___26 = 576;
    }
    {
    fd = open((char const   *)((char *)fname), 1 | tmp___26, 438);
    }
    if (! (fd < 0)) {
      goto while_break___3;
    }




















































  }
  while_break___3: ;/* CIL Label */ ;
  }
  {
  errmsg = (char_u *)((void *)0);
  fileformat = get_fileformat(buf___3);
  }
  if (end > buf___3->b_ml.ml_line_count) {

  }
  len___0 = 0;
  s = buffer;
  nchars = 0L;
  if (buf___3->b_ml.ml_flags & 1) {
    start___0 = end + 1L;
  }
  if (*(buf___3->b_p_key)) {
    {



    }



  }
  lnum = start___0;
  {
  while (1) {
    while_continue___4: ;/* CIL Label */ ;
    if (! (lnum <= end)) {
      goto while_break___4;
    }
    {
    tmp___28 = ml_get_buf(buf___3, lnum, 0);
    ptr = tmp___28 - 1;
    }
    {
    while (1) {
      while_continue___5: ;/* CIL Label */ ;
      ptr ++;
      c = *ptr;
      if (! ((int )c != 0)) {
        goto while_break___5;
      }
      if ((int )c == 10) {

      } else { //Added block
      if ((int )c == 13) {





      } else {
        *s = c;
      }
      }
      s ++;
      len___0 ++;
      if (len___0 != bufsize) {
        goto while_continue___5;
      }
      {

      }







    }
    while_break___5: ;/* CIL Label */ ;
    }
    if (end == 0L) {



    } else { //Added block
    if (lnum == end) {
      if (buf___3->b_p_bin) {
        if (lnum == write_no_eol_lnum) {



        } else { //Added block
        if (lnum == buf___3->b_ml.ml_line_count) {
          if (! buf___3->b_p_eol) {



          }
        }
        }
      }
    }
    }
    if (fileformat == 0) {
      tmp___30 = s;
      s ++;
      *tmp___30 = (char_u )'\n';
    } else {
      tmp___31 = s;
      s ++;
      *tmp___31 = (char_u )'\r';
      if (fileformat == 1) {
        len___0 ++;
        if (len___0 == bufsize) {
          {

          }







        }
        tmp___33 = s;
        s ++;
        *tmp___33 = (char_u )'\n';
      }
    }
    len___0 ++;
    if (len___0 == bufsize) {












    }
    lnum ++;
  }
  while_break___4: ;/* CIL Label */ ;
  }
  if (len___0) {
    if (end) {
      {
      tmp___35 = write_buf(fd, buffer, len___0, encrypted);
      }
      if (tmp___35 == 0) {

      }
      nchars += (long )len___0;
    }
  }
  {
  tmp___36 = close(fd);
  }
  if (tmp___36 != 0) {


  }
  if (made_writable) {

  }
  if (perm >= 0L) {
    {
    mch_setperm(fname, perm);
    }
  }
  if (end == 0L) {












































  }
  lnum -= start___0;
  no_wait_return --;
  if (! filtering) {
    {
    msg_add_fname(buf___3, fname);
    c = (char_u )0;
    }
    if (newfile) {
      {
      tmp___42 = shortmess('n');
      }
      if (tmp___42) {

      } else {
        tmp___41 = "[New File]";
      }
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___41));
      c = (char_u )1;
      }
    }
    if (no_eol) {
      {


      }
    }
    {
    tmp___43 = msg_add_fileformat(fileformat);
    }
    if (tmp___43) {
      c = (char_u )1;
    }
    if (encrypted) {
      {


      }
    }
    {
    msg_add_lines((int )c, lnum, nchars);
    tmp___47 = shortmess('W');
    }
    if (! tmp___47) {
      {
      tmp___46 = shortmess('w');
      }
      if (tmp___46) {

      } else {
        tmp___45 = " written";
      }
      {
      strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___45));
      }
    }
    {
    keep_msg = msg_trunc_attr(IObuff, 0, 0);
    keep_msg_attr = 0;
    }
  }
  if (reset_changed) {
    if (whole) {
      {
      unchanged(buf___3, 1);
      u_unchanged(buf___3);
      }
    }
  }
  if (! exiting) {
    if (overwriting) {
      {
      ml_timestamp(buf___3);
      buf___3->b_flags &= -89;
      }
    }
  }
  if (*p_pm) {









    {


    }













































  }
  if (! p_bk) {
    if ((unsigned long )backup != (unsigned long )((void *)0)) {
      {
      tmp___52 = unlink((char const   *)((char *)backup));
      }
      if (tmp___52 != 0) {
        {

        }
      }
    }
  }
  goto nofail;
  fail: ;

  nofail: ;
  {
  vim_free((void *)backup);
  }
  if ((unsigned long )buffer != (unsigned long )(smallbuf)) {
    {
    vim_free((void *)buffer);
    }
  }
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
    {





    }








  }
  {
  msg_scroll = msg_save;
  write_no_eol_lnum = (linenr_t )0;
  save_buf___0 = curbuf;
  curbuf = buf___3;
  aucmd_prepbuf(& aco___0);
  }
  if (append) {
    {
    apply_autocmds((EVENT_T )13, fname, fname, 0, curbuf);
    }
  } else { //Added block
  if (filtering) {
    {

    }
  } else { //Added block
  if (reset_changed) {
    if (whole) {
      {
      apply_autocmds((EVENT_T )11, fname, fname, 0, curbuf);
      }
    } else {
      {
      apply_autocmds((EVENT_T )19, fname, fname, 0, curbuf);
      }
    }
  } else {
    {

    }
  }
  }
  }
  {
  aucmd_restbuf(& aco___0);
  }
  if ((unsigned long )curbuf == (unsigned long )buf___3) {
    {
    tmp___53 = buf_valid(save_buf___0);
    }
    if (tmp___53) {
      ((curwin->w_buffer)->b_nwindows) --;
      curbuf = save_buf___0;
      curwin->w_buffer = save_buf___0;
      (curbuf->b_nwindows) ++;
    } else {

    }
  } else {

  }
  return (retval);
}
}
static void msg_add_fname(BUF *buf___3 , char_u *fname ) 
{ 


  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  }
  {
  home_replace(buf___3, fname, IObuff + 1, 1024, 1);
  *(IObuff + 0) = (char_u )'\"';
  strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"\" "));
  }
  return;
}
}
static int msg_add_fileformat(int eol_type ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  if (eol_type == 1) {
    {
    tmp___1 = shortmess('x');
    }
    if (tmp___1) {

    } else {
      tmp___0 = "[dos format]";
    }
    {
    strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)tmp___0));
    }
    return (1);
  }
  if (eol_type == 2) {
    {

    }





    {

    }

  }
  return (0);
}
}
static void msg_add_lines(int insert_space , long lnum , long nchars ) 
{ 
  char_u *p___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = strlen((char const   *)((char *)IObuff));
  p___0 = IObuff + tmp;
  }
  if (insert_space) {
    tmp___0 = p___0;
    p___0 ++;
    *tmp___0 = (char_u )' ';
  }
  {
  tmp___3 = shortmess('l');
  }
  if (tmp___3) {
    {


    }
  } else {
    {
    tmp___1 = plural(nchars);
    tmp___2 = plural(lnum);
    sprintf((char * __restrict  )((char *)p___0), (char const   * __restrict  )"%ld line%s, %ld character%s",
            lnum, tmp___2, nchars, tmp___1);
    }
  }
  return;
}
}
static void msg_add_eol(void) 
{

















}
static int check_mtime(BUF *buf___3 , struct stat *st ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (buf___3->b_mtime_read != 0L) {
    {
    tmp___0 = time_differs(st->st_mtim.tv_sec, buf___3->b_mtime_read);
    }
    if (tmp___0) {
      {




      }




    }
  }
  return (1);
}
}
static int time_differs(long t1 , long t2 ) 
{ 
  int tmp ;

  {
  if (t1 - t2 > 1L) {

  } else { //Added block
  if (t2 - t1 > 1L) {

  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) 
{ 
  int wlen ;
  int ztemp ;
  int t ;
  int i___0 ;
  ssize_t tmp ;

  {
  if (docrypt) {

    {













    while_break: ;/* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! len___0) {
      goto while_break___0;
    }
    {
    tmp = write(fd, (void const   *)((char *)buf___3), (size_t )len___0);
    wlen = (int )tmp;
    }
    if (wlen <= 0) {

    }
    len___0 -= wlen;
    buf___3 += wlen;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  return (1);
}
}
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) 
{ 
  int len___0 ;
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )full_path == (unsigned long )((void *)0)) {

  }
  {
  tmp = strlen((char const   *)((char *)dir_name));
  len___0 = (int )tmp;
  tmp___1 = strncmp((char const   *)((char *)dir_name), (char const   *)((char *)full_path),
                    (size_t )len___0);
  }
  if (tmp___1 == 0) {
    {
    p___0 = full_path + len___0;
    tmp___0 = vim_ispathsep((int )*p___0);
    }
    if (tmp___0) {
      p___0 ++;
    } else {

    }
  } else {

  }
  return (p___0);
}
}
void shorten_fnames(int force ) 
{ 
  char_u dirname[1024] ;
  BUF *buf___3 ;
  char_u *p___0 ;
  int tmp ;

  {
  {
  mch_dirname(dirname, 1024);
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )buf___3->b_fname != (unsigned long )((void *)0)) {
      if (force) {
        goto _L;
      } else { //Added block
      if ((unsigned long )buf___3->b_sfname == (unsigned long )((void *)0)) {

      } else {
        {
        tmp = mch_isFullName(buf___3->b_sfname);
        }
        if (tmp) {
          _L: ;
          {
          vim_free((void *)buf___3->b_sfname);
          buf___3->b_sfname = (char_u *)((void *)0);
          p___0 = shorten_fname(buf___3->b_ffname, dirname);
          }
          if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
            {
            buf___3->b_sfname = vim_strsave(p___0);
            buf___3->b_fname = buf___3->b_sfname;
            }
          }
          if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

          } else { //Added block
          if ((unsigned long )buf___3->b_fname == (unsigned long )((void *)0)) {

          }
          }
          {
          mf_fullname(buf___3->b_ml.ml_mfp);
          }
        }
      }
      }
    }
    buf___3 = buf___3->b_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  status_redraw_all();
  }
  return;
}
}
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) 
{


















}
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) 
{ 
  char_u *retval ;
  char_u *s ;
  char_u *e ;
  char_u *ptr ;
  int fnamelen ;
  int extlen ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;

  {
  {
  tmp = strlen((char const   *)((char *)ext));
  extlen = (int )tmp;
  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*fname == 0) {
    _L: ;
    {

    }



    {

    }

















    {

    }







  } else {
    {
    tmp___4 = strlen((char const   *)((char *)fname));
    fnamelen = (int )tmp___4;
    retval = alloc((unsigned int )((fnamelen + extlen) + 3));
    }
    if ((unsigned long )retval == (unsigned long )((void *)0)) {

    }
    {
    strcpy((char * __restrict  )((char *)retval), (char const   * __restrict  )((char *)fname));
    }
  }
  }
  ptr = retval + fnamelen;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )ptr >= (unsigned long )retval)) {
      goto while_break;
    }
    if ((int )*ext == 46) {
      if (shortname) {



      }
    }
    {
    tmp___5 = vim_ispathsep((int )*ptr);
    }
    if (tmp___5) {
      goto while_break;
    }
    ptr --;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  ptr ++;
  tmp___6 = strlen((char const   *)((char *)ptr));
  }
  if (tmp___6 > 250UL) {

  }
  {
  tmp___7 = strlen((char const   *)((char *)ptr));
  s = ptr + tmp___7;
  }
  if (shortname) {
    if ((unsigned long )fname == (unsigned long )((void *)0)) {

    } else { //Added block
    if ((int )*fname == 0) {

    } else {
      {
      tmp___11 = strlen((char const   *)((char *)fname));
      tmp___12 = vim_ispathsep((int )*(fname + (tmp___11 - 1UL)));
      }
      if (tmp___12) {
        _L___0: ;





      } else { //Added block
      if ((int )*ext == 46) {




      } else {
        {
        e = vim_strchr(ptr, '.');
        }
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          tmp___9 = s;
          s ++;
          *tmp___9 = (char_u )'.';
        } else {
          {

          }



        }
      }
      }
    }
    }
  }
  {
  strcpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)ext));
  }
  if (prepend_dot) {
    if (! shortname) {
      {
      e = gettail(retval);
      }
      if ((int )*e != 46) {
        {
        tmp___13 = strlen((char const   *)((char *)e));
        memmove((void *)((char *)(e + 1)), (void const   *)((char *)e), tmp___13 + 1UL);
        *e = (char_u )'.';
        }
      }
    }
  }
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
    tmp___14 = strcmp((char const   *)((char *)fname), (char const   *)((char *)retval));
    }
    if (tmp___14 == 0) {
      {











      while_break___0: ;/* CIL Label */ ;
      }



    }
  }
  return (retval);
}
}
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) 
{ 
  char *eof ;
  char tbuf[200] ;

  {
  {
  *(buf___3 + (size - 2)) = (char_u )'\000';
  eof = fgets((char * __restrict  )((char *)buf___3), size, (FILE * __restrict  )fp___0);
  }
  if ((int )*(buf___3 + (size - 2)) != 0) {




















  }
  return ((unsigned long )eof == (unsigned long )((void *)0));
}
}
int vim_rename(char_u *from , char_u *to ) 
{ 
  int fd_in ;
  int fd_out ;
  int n ;
  char *errmsg ;
  char *buffer ;
  int tmp ;
  char_u *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
  errmsg = (char *)((void *)0);
  unlink((char const   *)((char *)to));
  tmp = rename((char const   *)((char *)from), (char const   *)((char *)to));
  }
  if (tmp == 0) {
    return (0);
  }
  {

  }



  {

  }






  {


  }







  {

















  while_break: ;/* CIL Label */ ;
  }
  {



  }















  {

  }

}
}
static int already_warned  =    0;
void check_timestamps(int focus ) 
{ 
  BUF *buf___3 ;
  int put_nl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  put_nl = 0;
  tmp___0 = stuff_empty();
  }
  if (tmp___0) {
    if (global_busy) {

    } else {
      {
      tmp___1 = typebuf_typed();
      }
      if (tmp___1) {
        if (autocmd_busy) {

        } else {
          no_wait_return ++;
          already_warned = 0;
          buf___3 = firstbuf;
          {
          while (1) {
            while_continue: ;/* CIL Label */ ;
            if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
              goto while_break;
            }
            {
            tmp = buf_check_timestamp(buf___3, focus);
            put_nl |= tmp;
            buf___3 = buf___3->b_next;
            }
          }
          while_break: ;/* CIL Label */ ;
          }
          no_wait_return --;
          need_check_timestamps = 0;
          if (need_wait_return) {






          }
        }
      } else {

      }
    }
  } else {

  }
  return;
}
}
int buf_check_timestamp(BUF *buf___3 , int focus ) 
{ 
  struct stat st ;
  int retval ;
  int message_put ;
  char_u *path ;
  char_u *tbuf ;
  char *mesg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  message_put = 0;
  mesg = (char *)((void *)0);
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {

  }
  }
  if (! (buf___3->b_flags & 8)) {
    if (buf___3->b_mtime != 0L) {
      {
      retval = stat((char const   * __restrict  )((char *)buf___3->b_ffname), (struct stat * __restrict  )(& st));
      }
      if (retval < 0) {

      } else { //Added block
      if (retval >= 0) {
        {
        tmp___1 = time_differs(st.st_mtim.tv_sec, buf___3->b_mtime);
        }
        if (tmp___1) {
          _L___0: ;





          {


          }







        } else {
          goto _L___1;
        }
      } else {

      }
      }
    } else {

    }
  } else { //Added block
  _L___1: ;
  if (buf___3->b_flags & 16) {









  }
  }
  if ((unsigned long )mesg != (unsigned long )((void *)0)) {
    {

    }













































  }
  return (message_put);
}
}
void write_lnum_adjust(linenr_t offset ) 
{








}
static char_u *vim_tempdir  =    (char_u *)((void *)0);
static long temp_count  =    0L;
void vim_deltempdir(void) 
{ 
  char_u **files ;
  int file_count ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )vim_tempdir != (unsigned long )((void *)0)) {
    {



    }



















    {





    }
  }
  return;
}
}
static char *tempdirs[4]  = {      (char *)"$TMPDIR",      (char *)"/tmp",      (char *)".",      (char *)"$HOME"};
char_u *vim_tempname(int extra_char ) 
{




















































































}
static struct event_name event_names[43]  = 
  {      {(char *)"BufCreate", (EVENT_T )0}, 
        {(char *)"BufDelete", (EVENT_T )1}, 
        {(char *)"BufEnter", (EVENT_T )2}, 
        {(char *)"BufFilePost", (EVENT_T )3}, 
        {(char *)"BufFilePre", (EVENT_T )4}, 
        {(char *)"BufHidden", (EVENT_T )10}, 
        {(char *)"BufLeave", (EVENT_T )5}, 
        {(char *)"BufNewFile", (EVENT_T )6}, 
        {(char *)"BufReadPost", (EVENT_T )7}, 
        {(char *)"BufReadPre", (EVENT_T )8}, 
        {(char *)"BufRead", (EVENT_T )7}, 
        {(char *)"BufUnload", (EVENT_T )9}, 
        {(char *)"BufWritePost", (EVENT_T )11}, 
        {(char *)"BufWritePre", (EVENT_T )12}, 
        {(char *)"BufWrite", (EVENT_T )12}, 
        {(char *)"CursorHold", (EVENT_T )39}, 
        {(char *)"FileAppendPost", (EVENT_T )13}, 
        {(char *)"FileAppendPre", (EVENT_T )14}, 
        {(char *)"FileChangedShell", (EVENT_T )15}, 
        {(char *)"FileEncoding", (EVENT_T )38}, 
        {(char *)"FileReadPost", (EVENT_T )16}, 
        {(char *)"FileReadPre", (EVENT_T )17}, 
        {(char *)"FileType", (EVENT_T )18}, 
        {(char *)"FileWritePost", (EVENT_T )19}, 
        {(char *)"FileWritePre", (EVENT_T )20}, 
        {(char *)"FilterReadPost", (EVENT_T )21}, 
        {(char *)"FilterReadPre", (EVENT_T )22}, 
        {(char *)"FilterWritePost", (EVENT_T )23}, 
        {(char *)"FilterWritePre", (EVENT_T )24}, 
        {(char *)"FocusGained", (EVENT_T )25}, 
        {(char *)"FocusLost", (EVENT_T )26}, 
        {(char *)"GUIEnter", (EVENT_T )27}, 
        {(char *)"StdinReadPost", (EVENT_T )28}, 
        {(char *)"StdinReadPre", (EVENT_T )29}, 
        {(char *)"Syntax", (EVENT_T )30}, 
        {(char *)"TermChanged", (EVENT_T )31}, 
        {(char *)"User", (EVENT_T )32}, 
        {(char *)"VimEnter", (EVENT_T )33}, 
        {(char *)"VimLeave", (EVENT_T )34}, 
        {(char *)"VimLeavePre", (EVENT_T )35}, 
        {(char *)"WinEnter", (EVENT_T )36}, 
        {(char *)"WinLeave", (EVENT_T )37}, 
        {(char *)((void *)0), (EVENT_T )0}};
static AutoPat *first_autopat[40]  = 
  {      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0)};
struct growarray augroups  =    {0, 0, (int )sizeof(char_u *), 10, (void *)0};
static int current_augroup  =    -1;
static int au_need_clean  =    0;
static void show_autocmd(AutoPat *ap , EVENT_T event ) ;
static void au_remove_pat(AutoPat *ap ) ;
static void au_remove_cmds(AutoPat *ap ) ;
static void au_cleanup(void) ;
static int au_new_group(char_u *name___1 ) ;
static int au_find_group(char_u *name___1 ) ;
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) ;
static char_u *event_nr2name(EVENT_T event ) ;
static char_u *find_end_event(char_u *arg ) ;
static int event_ignored(EVENT_T event ) ;
static int au_get_grouparg(char_u **argp ) ;
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) ;
static char_u *getnextac(int c , void *cookie , int indent ) ;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) ;
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) ;
static EVENT_T last_event  ;
static int last_group  ;
static void show_autocmd(AutoPat *ap , EVENT_T event ) 
{

















































































}
static void au_remove_pat(AutoPat *ap ) 
{










}
static void au_remove_cmds(AutoPat *ap ) 
{





















}
static void au_cleanup(void) 
{














































































}
static int au_new_group(char_u *name___1 ) 
{


























}
static int au_find_group(char_u *name___1 ) 
{


























}
void do_augroup(char_u *arg ) 
{














































}
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  p___0 = start___0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (*p___0) {
      if ((int )*p___0 == 32) {

      } else { //Added block
      if ((int )*p___0 == 9) {

      } else { //Added block
      if (! ((int )*p___0 != 44)) {
        goto while_break;
      }
      }
      }
    } else {
      goto while_break;
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )event_names[i___0].name != (unsigned long )((void *)0))) {

    }
    {
    tmp = strlen((char const   *)event_names[i___0].name);
    len___0 = (int )tmp;
    }
    if ((long )len___0 == p___0 - start___0) {
      {
      tmp___0 = strncasecmp((char const   *)event_names[i___0].name, (char const   *)((char *)start___0),
                            (size_t )len___0);
      }
      if (tmp___0 == 0) {
        goto while_break___0;
      }
    }
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if ((int )*p___0 == 44) {
    p___0 ++;
  }
  *end = p___0;
  if ((unsigned long )event_names[i___0].name == (unsigned long )((void *)0)) {

  }
  return (event_names[i___0].event);
}
}
static char_u *event_nr2name(EVENT_T event ) 
{



















}
static char_u *find_end_event(char_u *arg ) 
{

















































}
static int event_ignored(EVENT_T event ) 
{





























}
int check_ei(void) 
{ 
  char_u *p___0 ;
  int tmp ;
  EVENT_T tmp___0 ;

  {
  {
  p___0 = p_ei;
  tmp = strcasecmp((char const   *)((char *)p_ei), (char const   *)((char *)"all"));
  }
  if (tmp == 0) {
    return (1);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {
    tmp___0 = event_name2nr(p___0, & p___0);
    }
    if ((unsigned int )tmp___0 == 40U) {

    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
void do_autocmd(char_u *arg , int forceit ) 
{





















































































































































































}
static int au_get_grouparg(char_u **argp ) 
{


































}
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) 
{











































































































































































































































}
int do_doautocmd(char_u *arg , int do_msg ) 
{






























































}
void do_autoall(char_u *arg ) 
{
































}
static void aucmd_prepbuf(struct aco_save *aco ) 
{ 
  WIN *win ;

  {
  if ((unsigned long )curwin->w_buffer == (unsigned long )curbuf) {
    win = curwin;
  } else {

    {










    while_break: ;/* CIL Label */ ;
    }
  }
  if ((unsigned long )win != (unsigned long )((void *)0)) {
    aco->save_curwin = curwin;
    curwin = win;
  } else {










  }
  return;
}
}
static void aucmd_restbuf(struct aco_save *aco ) 
{ 
  int len___0 ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )aco->save_curwin != (unsigned long )((void *)0)) {
    {
    tmp = win_valid(aco->save_curwin);
    }
    if (tmp) {
      curwin = aco->save_curwin;
    }
  } else {
    {

    }




























  }
  return;
}
}
static int autocmd_nested  =    0;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) 
{ 
  int tmp ;

  {
  {
  tmp = apply_autocmds_group(event, fname, fname_io, force, -3, buf___3);
  }
  return (tmp);
}
}
int has_cursorhold(void) 
{





}
static int nesting  =    0;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) 
{ 
  char_u *sfname ;
  char_u *tail ;
  int temp ;
  int save_changed ;
  BUF *old_curbuf ;
  int retval ;
  char_u *save_sourcing_name ;
  linenr_t save_sourcing_lnum ;
  char_u *save_autocmd_fname ;
  int save_autocmd_bufnr ;
  char_u *save_autocmd_match ;
  int save_autocmd_busy ;
  int save_autocmd_nested ;
  AutoPatCmd patcmd ;
  AutoPat *ap ;
  void *save_funccalp ;
  int tmp ;

  {
  sfname = (char_u *)((void *)0);
  retval = 0;
  if ((unsigned long )first_autopat[(int )event] == (unsigned long )((void *)0)) {
    return (retval);
  }







  {

  }













































































































  {








  }












  {









  }




















  {













  }




























  {

  }

}
}
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) 
{
























































































}
static char_u *getnextac(int c , void *cookie , int indent ) 
{



































































}
char_u *get_augroup_name(int idx ) 
{














}
static int include_groups  =    0;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) 
{











































































}
char_u *get_event_name(int idx ) 
{















}
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) 
{


















































}
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) 
{






































































































































































































































































































}
#pragma merger("0","/tmp/cil-Pa4aaib1.i","-O0")
extern int _IO_getc(_IO_FILE *__fp ) ;
FPOS VIsual  ;
int VIsual_select ;
int redo_VIsual_busy ;
int Exec_reg ;
char_u *typebuf ;
int typebuflen  ;
int typeoff  ;
int KeyStuffed  ;
FILE *scriptin[15]  ;
int curscript ;
FILE *scriptout ;
int did_outofmem_msg ;
int did_swapwrite_msg ;
int undo_off ;
char_u e_nesting[24] ;
char_u e_toocompl[20] ;
char_u *p_pt  ;
int p_remap  ;
int p_timeout  ;
long p_tm  ;
int p_ttimeout  ;
long p_ttm  ;
long p_uc  ;
char_u *get_recorded(void) ;
void flush_buffers(int typeahead ) ;
void stuffnumReadbuff(long n ) ;
int start_redo(long count___2 , int old_redo ) ;
int typebuf_maplen(void) ;
void del_typebuf(int len___0 , int offset ) ;
int save_typebuf(void) ;
void updatescript(int c ) ;
int putescstr(FILE *fd , char_u *str___1 , int set ) ;
void check_map_keycodes(void) ;
void init_mappings(void) ;
void ml_sync_all(int check_file , int check_char ) ;
int msg_outtrans_special(char_u *str___1 , int from ) ;
int get_keystroke(void) ;
int get_real_state(void) ;
void push_showcmd(void) ;
void pop_showcmd(void) ;
void unshowmode(int force ) ;
int add_termcap_entry(char_u *name___1 , int force ) ;
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) ;
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
static struct buffheader stuffbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader recordbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static int block_redo  =    0;
static struct mapblock *maphash[256]  ;
static int maphash_valid  =    0;
static struct mapblock *first_abbr  =    (struct mapblock *)((void *)0);
static char_u *noremapbuf  =    (char_u *)((void *)0);
static char_u typebuf_init[265]  ;
static char_u noremapbuf_init[265]  ;
static int typemaplen  =    0;
static int no_abbr_cnt  =    0;
static int last_recorded_len  =    0;
static void free_buff(struct buffheader *buf___3 ) ;
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) ;
static void add_buff(struct buffheader *buf___3 , char_u *s ) ;
static void add_num_buff(struct buffheader *buf___3 , long n ) ;
static void add_char_buff(struct buffheader *buf___3 , int c ) ;
static int read_stuff(int advance ) ;
static void start_stuff(void) ;
static int read_redo(int init , int old_redo ) ;
static void copy_redo(int old_redo ) ;
static void init_typebuf(void) ;
static void gotchars(char_u *s , int len___0 ) ;
static void may_sync_undo(void) ;
static void closescript(void) ;
static int vgetorpeek(int advance ) ;
static void map_free(struct mapblock **mpp ) ;
static void validate_maphash(void) ;
static void showmap(struct mapblock *mp ) ;
static void free_buff(struct buffheader *buf___3 ) 
{ 
  struct bufblock *p___0 ;
  struct bufblock *np___0 ;

  {
  p___0 = buf___3->bh_first.b_next;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    np___0 = p___0->b_next;
    vim_free((void *)p___0);
    p___0 = np___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  buf___3->bh_first.b_next = (struct bufblock *)((void *)0);
  return;
}
}
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) 
{ 
  long_u count___2 ;
  char_u *p___0 ;
  char_u *p2 ;
  char_u *str___1 ;
  struct bufblock *bp___0 ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  count___2 = (long_u )0;
  p___0 = (char_u *)((void *)0);
  bp___0 = buffer->bh_first.b_next;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = strlen((char const   *)((char *)(bp___0->b_str)));
    count___2 += tmp;
    bp___0 = bp___0->b_next;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (count___2) {
    goto _L;
  } else { //Added block
  if (dozero) {
    _L: ;
    {
    p___0 = lalloc(count___2 + 1UL, 1);
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      p2 = p___0;
      bp___0 = buffer->bh_first.b_next;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! ((unsigned long )bp___0 != (unsigned long )((void *)0))) {
          goto while_break___0;
        }
        str___1 = bp___0->b_str;
        {
        while (1) {
          while_continue___1: ;/* CIL Label */ ;
          if (! *str___1) {
            goto while_break___1;
          }
          tmp___0 = p2;
          p2 ++;
          tmp___1 = str___1;
          str___1 ++;
          *tmp___0 = *tmp___1;
        }
        while_break___1: ;/* CIL Label */ ;
        }
        bp___0 = bp___0->b_next;
      }
      while_break___0: ;/* CIL Label */ ;
      }
      *p2 = (char_u )'\000';
    }
  }
  }
  return (p___0);
}
}
char_u *get_recorded(void) 
{






















}
char_u *get_inserted(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = get_bufcont(& redobuff, 0);
  }
  return (tmp);
}
}
static void add_buff(struct buffheader *buf___3 , char_u *s ) 
{ 
  struct bufblock *p___0 ;
  long_u n ;
  long_u len___0 ;
  char_u *tmp ;

  {
  {
  n = strlen((char const   *)((char *)s));
  }
  if (n == 0UL) {

  }
  if ((unsigned long )buf___3->bh_first.b_next == (unsigned long )((void *)0)) {
    buf___3->bh_space = 0;
    buf___3->bh_curr = & buf___3->bh_first;
  } else { //Added block
  if ((unsigned long )buf___3->bh_curr == (unsigned long )((void *)0)) {
    {

    }

  } else { //Added block
  if (buf___3->bh_index != 0) {
    {

    }
  }
  }
  }
  buf___3->bh_index = 0;
  if (buf___3->bh_space >= (int )n) {
    {
    strcat((char * __restrict  )((char *)((buf___3->bh_curr)->b_str)), (char const   * __restrict  )((char *)s));
    buf___3->bh_space = (int )((long_u )buf___3->bh_space - n);
    }
  } else {
    if (n < 20UL) {
      len___0 = (long_u )20;
    } else {
      len___0 = n;
    }
    {
    tmp = lalloc(sizeof(struct bufblock ) + len___0, 1);
    p___0 = (struct bufblock *)tmp;
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

    }
    {
    buf___3->bh_space = (int )(len___0 - n);
    strcpy((char * __restrict  )((char *)(p___0->b_str)), (char const   * __restrict  )((char *)s));
    p___0->b_next = (buf___3->bh_curr)->b_next;
    (buf___3->bh_curr)->b_next = p___0;
    buf___3->bh_curr = p___0;
    }
  }
  return;
}
}
static void add_num_buff(struct buffheader *buf___3 , long n ) 
{ 
  char_u number[32] ;

  {
  {
  sprintf((char * __restrict  )((char *)(number)), (char const   * __restrict  )"%ld",
          n);
  add_buff(buf___3, number);
  }
  return;
}
}
static void add_char_buff(struct buffheader *buf___3 , int c ) 
{ 
  char_u temp[4] ;
  int tmp ;

  {
  if (c >= 512) {

  } else { //Added block
  if (c == 128) {

  } else { //Added block
  if (c == 0) {
    _L: ;





















  } else {
    temp[0] = (char_u )c;
    temp[1] = (char_u )'\000';
  }
  }
  }
  {
  add_buff(buf___3, temp);
  }
  return;
}
}
static int read_stuff(int advance ) 
{ 
  char_u c ;
  struct bufblock *curr ;

  {
  if ((unsigned long )stuffbuff.bh_first.b_next == (unsigned long )((void *)0)) {
    return ('\000');
  }
  curr = stuffbuff.bh_first.b_next;
  c = curr->b_str[stuffbuff.bh_index];
  if (advance) {
    (stuffbuff.bh_index) ++;
    if ((int )curr->b_str[stuffbuff.bh_index] == 0) {
      {
      stuffbuff.bh_first.b_next = curr->b_next;
      vim_free((void *)curr);
      stuffbuff.bh_index = 0;
      }
    }
  }
  return ((int )c);
}
}
static void start_stuff(void) 
{ 


  {
  if ((unsigned long )stuffbuff.bh_first.b_next != (unsigned long )((void *)0)) {
    stuffbuff.bh_curr = & stuffbuff.bh_first;
    stuffbuff.bh_space = 0;
  }
  return;
}
}
int stuff_empty(void) 
{ 


  {
  return ((unsigned long )stuffbuff.bh_first.b_next == (unsigned long )((void *)0));
}
}
void flush_buffers(int typeahead ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  init_typebuf();
  start_stuff();
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = read_stuff(1);
    }
    if (! (tmp != 0)) {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (typeahead) {
    {









    while_break___0: ;/* CIL Label */ ;
    }


  } else {
    typeoff += typemaplen;
    typelen -= typemaplen;
  }
  typemaplen = 0;
  no_abbr_cnt = 0;
  return;
}
}
void ResetRedobuff(void) 
{ 


  {
  if (! block_redo) {
    {
    free_buff(& old_redobuff);
    old_redobuff = redobuff;
    redobuff.bh_first.b_next = (struct bufblock *)((void *)0);
    }
  }
  return;
}
}
static int save_level  =    0;
void saveRedobuff(void) 
{













}
void restoreRedobuff(void) 
{














}
void AppendToRedobuff(char_u *s ) 
{ 


  {
  if (! block_redo) {
    {
    add_buff(& redobuff, s);
    }
  }
  return;
}
}
void AppendCharToRedobuff(int c ) 
{ 


  {
  if (! block_redo) {
    {
    add_char_buff(& redobuff, c);
    }
  }
  return;
}
}
void AppendNumberToRedobuff(long n ) 
{ 


  {
  if (! block_redo) {
    {
    add_num_buff(& redobuff, n);
    }
  }
  return;
}
}
void stuffReadbuff(char_u *s ) 
{ 


  {
  {
  add_buff(& stuffbuff, s);
  }
  return;
}
}
void stuffcharReadbuff(int c ) 
{ 


  {
  {
  add_char_buff(& stuffbuff, c);
  }
  return;
}
}
void stuffnumReadbuff(long n ) 
{








}
static struct bufblock *bp  ;
static char_u *p  ;
static int read_redo(int init , int old_redo ) 
{









































}
static void copy_redo(int old_redo ) 
{




















}
int start_redo(long count___2 , int old_redo ) 
{
































































}
int start_redo_ins(void) 
{

















































}
void stop_redo_ins(void) 
{ 


  {
  block_redo = 0;
  return;
}
}
static void init_typebuf(void) 
{ 


  {
  if ((unsigned long )typebuf == (unsigned long )((void *)0)) {
    typebuf = typebuf_init;
    noremapbuf = noremapbuf_init;
    typebuflen = 265;
    typelen = 0;
    typeoff = 0;
  }
  return;
}
}
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) 
{ 
  char_u *s1 ;
  char_u *s2 ;
  int newlen ;
  int addlen ;
  int i___0 ;
  int newoff ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  init_typebuf();
  tmp = strlen((char const   *)((char *)str___1));
  addlen = (int )tmp;
  }
  if (offset == 0) {
    if (addlen <= typeoff) {
      {
      typeoff -= addlen;
      memmove((void *)((char *)(typebuf + typeoff)), (void const   *)((char *)str___1),
              (size_t )addlen);
      }
    } else {

    }
  } else {
    _L: ;









    {

    }



    {

    }






    {







    }





    {





    }







  }
  typelen += addlen;
  if (noremap < 0) {
    noremap = addlen;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < addlen)) {
      goto while_break;
    }
    tmp___0 = noremap;
    noremap --;
    *(noremapbuf + ((typeoff + i___0) + offset)) = (char_u )(tmp___0 > 0);
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (nottyped) {
    typemaplen += addlen;
  }
  if (no_abbr_cnt) {
    if (offset == 0) {
      no_abbr_cnt += addlen;
    }
  }
  return (1);
}
}
int typebuf_typed(void) 
{ 


  {
  return (typemaplen == 0);
}
}
int typebuf_maplen(void) 
{ 


  {
  return (typemaplen);
}
}
void del_typebuf(int len___0 , int offset ) 
{ 
  int i___0 ;

  {
  typelen -= len___0;
  if (offset == 0) {
    if (typebuflen - (typeoff + len___0) >= 153) {
      typeoff += len___0;
    } else {
      goto _L;
    }
  } else {
    _L: ;
    i___0 = typeoff + offset;
    if (typeoff > 50) {
      {
      memmove((void *)((char *)(typebuf + 50)), (void const   *)((char *)(typebuf + typeoff)),
              (size_t )offset);
      memmove((void *)((char *)(noremapbuf + 50)), (void const   *)((char *)(noremapbuf + typeoff)),
              (size_t )offset);
      typeoff = 50;
      }
    }
    {
    memmove((void *)((char *)((typebuf + typeoff) + offset)), (void const   *)((char *)((typebuf + i___0) + len___0)),
            (size_t )((typelen - offset) + 1));
    memmove((void *)((char *)((noremapbuf + typeoff) + offset)), (void const   *)((char *)((noremapbuf + i___0) + len___0)),
            (size_t )(typelen - offset));
    }
  }
  if (typemaplen > offset) {
    if (typemaplen < offset + len___0) {

    } else {
      typemaplen -= len___0;
    }
  }
  if (no_abbr_cnt > offset) {
    if (no_abbr_cnt < offset + len___0) {

    } else {
      no_abbr_cnt -= len___0;
    }
  }
  return;
}
}
static void gotchars(char_u *s , int len___0 ) 
{ 
  int c ;
  char_u buf___3[2] ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if (Recording) {

  }
  buf___3[1] = (char_u )'\000';
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___0 = len___0;
    len___0 --;
    if (! tmp___0) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    c = (int )*tmp;
    updatescript(c);
    }
    if (Recording) {
      {


      }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  may_sync_undo();
  maptick ++;
  }
  return;
}
}
static void may_sync_undo(void) 
{ 


  {
  if (! (State & 24)) {
    goto _L;
  } else { //Added block
  if (arrow_used) {
    _L: ;
    if ((unsigned long )scriptin[curscript] == (unsigned long )((void *)0)) {
      if (! no_u_sync) {
        {
        u_sync();
        }
      }
    }
  }
  }
  return;
}
}
static char_u *sv_typebuf[15]  ;
static char_u *sv_noremapbuf[15]  ;
static int sv_typebuflen[15]  ;
static int sv_typeoff[15]  ;
static int sv_typelen[15]  ;
static int sv_typemaplen[15]  ;
static int sv_no_abbr_cnt[15]  ;
int save_typebuf(void) 
{



































}
int openscript(char_u *name___1 ) 
{





























































}
static void closescript(void) 
{





















}
int using_script(void) 
{





}
static int count___0  =    0;
void updatescript(int c ) 
{ 


  {
  if (c) {
    if (scriptout) {
      {

      }
    }
  }
  if (c == 0) {
    {


    }
  } else { //Added block
  if (p_uc > 0L) {
    count___0 ++;
    if ((long )count___0 >= p_uc) {
      {


      }
    }
  }
  }
  return;
}
}
static int old_char  =    -1;
int vgetc(void) 
{ 
  int c ;
  int c2 ;
  int tmp ;

  {
  mod_mask = 0;
  last_recorded_len = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (mod_mask) {


    }
    {
    c = vgetorpeek(1);
    }
    if (mod_mask) {


    }
    if (c == 128) {
      {




      }














    }
    return (c);
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
}
}
int safe_vgetc(void) 
{ 
  int c ;

  {
  {
  c = vgetc();
  }
  if (c == 0) {
    {

    }
  }
  return (c);
}
}
int vpeekc(void) 
{ 
  int tmp ;

  {
  {
  tmp = vgetorpeek(0);
  }
  return (tmp);
}
}
int char_avail(void) 
{ 
  int retval ;

  {
  {
  no_mapping ++;
  retval = vgetorpeek(0);
  no_mapping --;
  }
  return (retval != 0);
}
}
void vungetc(int c ) 
{






}
static int vgetorpeek(int advance ) 
{ 
  int c ;
  int c1 ;
  int keylen ;
  char_u *s ;
  struct mapblock *mp ;
  int timedout ;
  int mapdepth ;
  int mode_deleted ;
  int local_State ;
  int mlen ;
  int max_mlen ;
  int i___0 ;
  int new_wcol ;
  int new_wrow ;
  int n ;
  int old_wcol ;
  int old_wrow ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  colnr_t col ;
  colnr_t vcol ;
  char_u *ptr ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;

  {
  timedout = 0;
  mapdepth = 0;
  mode_deleted = 0;
  if (vgetc_busy) {

  }
  {
  local_State = get_real_state();
  }
  if (old_char >= 0) {





  }
  vgetc_busy = 1;
  if (advance) {
    KeyStuffed = 0;
  }
  {
  init_typebuf();
  start_stuff();
  }
  if (advance) {
    if (typemaplen == 0) {
      Exec_reg = 0;
    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    c = read_stuff(advance);
    }
    if (c != 0) {
      if (! got_int) {
        if (advance) {
          KeyTyped = 0;
          KeyStuffed = 1;
        }
        if (no_abbr_cnt == 0) {
          no_abbr_cnt = 1;
        }
      } else {

      }
    } else {
      _L___9: ;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (typemaplen) {
          {
          line_breakcheck();
          }
        } else {
          {
          ui_breakcheck();
          }
        }
        keylen = 0;
        if (got_int) {
          {

          }














          {

          }

        } else { //Added block
        if (typelen > 0) {
          mp = (struct mapblock *)((void *)0);
          max_mlen = 0;
          if (! timedout) {
            if (no_mapping == 0) {
              if (maphash_valid) {
                if (typemaplen == 0) {
                  goto _L___4;
                } else { //Added block
                if (p_remap) {
                  if ((int )*(noremapbuf + typeoff) == 0) {
                    _L___4: ;
                    if (p_paste) {
                      if (! (State & 24)) {
                        goto _L___3;
                      }
                    } else { //Added block
                    _L___3: ;
                    if (State == 1537) {
                      if (! ((int )*(typebuf + typeoff) == 13)) {
                        if (! ((int )*(typebuf + typeoff) == 32)) {
                          goto _L___2;
                        }
                      }
                    } else { //Added block
                    _L___2: ;
                    if (State != 1792) {
                      if (State != 3072) {
                        if (ctrl_x_mode) {
                          {

                          }



                        } else {
                          _L___1: ;
                          c1 = (int )*(typebuf + typeoff);
                          if (local_State & 7) {
                            tmp = c1;
                          } else {
                            tmp = c1 ^ 128;
                          }
                          mp = maphash[tmp];
                          {
                          while (1) {
                            while_continue___1: ;/* CIL Label */ ;
                            if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
                              goto while_break___1;
                            }
                            if ((int )*(mp->m_keys + 0) == c1) {
                              if (mp->m_mode & local_State) {
                                mlen = 1;
                                {
                                while (1) {
                                  while_continue___2: ;/* CIL Label */ ;
                                  if (! (mlen < typelen)) {

                                  }
                                  if ((int )*(mp->m_keys + mlen) != (int )*(typebuf + (typeoff + mlen))) {
                                    goto while_break___2;
                                  }
                                  mlen ++;
                                }
                                while_break___2: ;/* CIL Label */ ;
                                }
                                keylen = mp->m_keylen;
                                if (mlen == keylen) {
                                  goto _L___0;
                                } else { //Added block
                                if (mlen == typelen) {
                                  if (typelen < keylen) {
                                    _L___0: ;
                                    s = noremapbuf + typeoff;
                                    n = mlen;
                                    {
                                    while (1) {
                                      while_continue___3: ;/* CIL Label */ ;
                                      n --;
                                      if (! (n >= 0)) {
                                        goto while_break___3;
                                      }
                                      tmp___0 = s;
                                      s ++;
                                      if (*tmp___0) {

                                      }
                                    }
                                    while_break___3: ;/* CIL Label */ ;
                                    }
                                    if (n >= 0) {

                                    }
                                    if (keylen > typelen) {

                                    }
                                    goto while_break___1;
                                  }
                                }
                                }
                                if (max_mlen < mlen) {
                                  max_mlen = mlen;
                                }
                              }
                            }
                            __Cont: ;
                            mp = mp->m_next;
                          }
                          while_break___1: ;/* CIL Label */ ;
                          }
                        }
                      }
                    }
                    }
                    }
                  }
                }
                }
              }
            }
          }
          if ((int )*p_pt != 0) {




















































          }
          if ((unsigned long )mp == (unsigned long )((void *)0)) {
            if (keylen != -2) {
              if (no_mapping == 0) {
                goto _L___6;
              } else { //Added block
              if (allow_keys != 0) {
                _L___6: ;
                if (typemaplen == 0) {
                  goto _L___5;
                } else { //Added block
                if (p_remap) {
                  if (! *(noremapbuf + typeoff)) {
                    _L___5: ;
                    if (! timedout) {
                      {
                      keylen = check_termcode(max_mlen + 1, (char_u *)((void *)0),
                                              0);
                      }
                      if (keylen < 0) {
                        if (typelen == typemaplen) {

                        }
                      }
                    } else {

                    }
                  } else {
                    keylen = 0;
                  }
                } else {

                }
                }
              } else {
                keylen = 0;
              }
              }
              if (keylen == 0) {
                c = (int )*(typebuf + typeoff) & 255;
                if (advance) {
                  if (typemaplen) {
                    KeyTyped = 0;
                  } else {
                    {
                    KeyTyped = 1;
                    gotchars(typebuf + typeoff, 1);
                    }
                  }
                  {
                  del_typebuf(1, 0);
                  }
                }
                goto while_break___0;
              }
              if (keylen > 0) {

              }
              keylen = -1;
            }
          }
          if (keylen >= 0) {
            if (keylen <= typelen) {
              if (keylen > typemaplen) {
                {
                gotchars((typebuf + typeoff) + typemaplen, keylen - typemaplen);
                }
              }
              {
              del_typebuf(keylen, 0);
              mapdepth ++;
              }
              if ((long )mapdepth >= p_mmd) {
                {

                }









                {



                }

              }
              if (VIsual_active) {
                if (VIsual_select) {
                  {


                  }
                }
              }
              if (mp->m_noremap) {
                tmp___5 = -1;
              } else {
                {
                tmp___4 = strncmp((char const   *)((char *)mp->m_str), (char const   *)((char *)mp->m_keys),
                                  (size_t )keylen);
                }
                if (tmp___4) {
                  tmp___3 = 0;
                } else {

                }
                tmp___5 = tmp___3;
              }
              {
              tmp___6 = ins_typebuf(mp->m_str, tmp___5, 0, 1);
              }
              if (tmp___6 == 0) {


              }
              goto __Cont___0;
            }
          }
        }
        }
        c = 0;
        new_wcol = curwin->w_wcol;
        new_wrow = curwin->w_wrow;
        if (advance) {
          if (typelen == 1) {
            if ((int )*(typebuf + typeoff) == 27) {
              if (! no_mapping) {
                if (typemaplen == 0) {
                  if (State & 16) {













































































                  }
                }
              }
            }
          }
        }
        if (c < 0) {

        }
        typelen += c;
        if (typelen >= typemaplen + 50) {


        }
        i___0 = 0;
        if (typelen > 0) {
          if (State & 17) {






























          }
        }
        if (! advance) {
          tmp___12 = 0L;
        } else {
          if (typelen == 0) {
            tmp___11 = -1L;
          } else { //Added block
          if (p_timeout) {
            goto _L___8;
          } else { //Added block
          if (p_ttimeout) {
            if (keylen == -1) {
              _L___8: ;
              if (keylen == -1) {
                if (p_ttm >= 0L) {

                } else {
                  tmp___10 = p_tm;
                }
              } else {

              }
              tmp___11 = tmp___10;
            } else {

            }
          } else {

          }
          }
          }
          tmp___12 = tmp___11;
        }
        {
        c = inchar((typebuf + typeoff) + typelen, ((typebuflen - typeoff) - typelen) - 1,
                   tmp___12);
        }
        if (i___0) {
          {

          }
        }
        if (c < 0) {

        }
        if (c == 0) {
          if (! advance) {
            goto while_break___0;
          }




        } else {
          {
          while (1) {
            while_continue___7: ;/* CIL Label */ ;
            if (! ((int )*(typebuf + (typeoff + typelen)) != 0)) {
              goto while_break___7;
            }
            tmp___13 = typelen;
            typelen ++;
            *(noremapbuf + (typeoff + tmp___13)) = (char_u )0;
          }
          while_break___7: ;/* CIL Label */ ;
          }
        }
        __Cont___0: ;;
      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    if (! (c < 0)) {
      if (advance) {
        if (! (c == 0)) {
          goto while_break;
        }
      } else {
        goto while_break;
      }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (advance) {
    if (p_smd) {
      if (State & 16) {










































      }
    }
  }
  vgetc_busy = 0;
  return (c);
}
}
int inchar(char_u *buf___3 , int maxlen , long wait_time ) 
{ 
  int len___0 ;
  int retesc ;
  int c ;
  int i___0 ;
  char_u dum[154] ;
  int tmp ;
  int tmp___0 ;

  {
  len___0 = 0;
  retesc = 0;
  if (wait_time == -1L) {
    {
    cursor_on();
    out_flush();
    }
  } else { //Added block
  if (wait_time > 100L) {
    {
    cursor_on();
    out_flush();
    }
  }
  }
  if (State != 1537) {
    did_outofmem_msg = 0;
    did_swapwrite_msg = 0;
  }
  undo_off = 0;
  c = -1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((unsigned long )scriptin[curscript] != (unsigned long )((void *)0)) {



    } else {
      goto while_break;
    }





















  }
  while_break: ;/* CIL Label */ ;
  }
  if (c < 0) {
    if (got_int) {
      {









      while_break___0: ;/* CIL Label */ ;
      }

    }
    {
    out_flush();
    len___0 = ui_inchar(buf___3, maxlen / 3, wait_time);
    }
  }
  i___0 = len___0;
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___1;
    }
    if ((int )*(buf___3 + 0) == 0) {

    } else { //Added block
    if ((int )*(buf___3 + 0) == 128) {





























    }
    }
    buf___3 ++;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  *buf___3 = (char_u )'\000';
  return (len___0);
}
}
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) 
{ 
  struct mapblock *mp ;
  struct mapblock **mpp ;
  char_u *arg ;
  char_u *p___0 ;
  int n ;
  int len___0 ;
  char_u *newstr ;
  int hasarg ;
  int haskey ;
  int did_it ;
  int round ;
  char_u *keys_buf ;
  char_u *arg_buf ;
  int retval ;
  int do_backslash ;
  int hash ;
  int new_hash ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  size_t tmp___10 ;

  {
  {
  len___0 = 0;
  did_it = 0;
  keys_buf = (char_u *)((void *)0);
  arg_buf = (char_u *)((void *)0);
  retval = 0;
  validate_maphash();
  p___0 = keys___0;
  tmp = vim_strchr(p_cpo, 'B');
  do_backslash = (unsigned long )tmp == (unsigned long )((void *)0);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (*p___0) {
      if (! (maptype == 1)) {
        if ((int )*p___0 == 32) {
          goto while_break;
        } else { //Added block
        if ((int )*p___0 == 9) {

        }
        }
      }
    } else {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 22) {

    } else { //Added block
    if (do_backslash) {
      if ((int )*(p___0 + 0) == 92) {
        _L: ;



      }
    }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*p___0 != 0) {
    tmp___0 = p___0;
    p___0 ++;
    *tmp___0 = (char_u )'\000';
  }
  {
  p___0 = skipwhite(p___0);
  arg = p___0;
  hasarg = (int )*arg != 0;
  haskey = (int )*keys___0 != 0;
  }
  if (maptype == 1) {
    if (! haskey) {


    }
  }
  if (haskey) {
    {
    keys___0 = replace_termcodes(keys___0, & keys_buf, 1, 1);
    }
  }
  if (hasarg) {
    {
    tmp___1 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"<nop>"));
    }
    if (tmp___1 == 0) {

    } else {
      {
      arg = replace_termcodes(arg, & arg_buf, 0, 1);
      }
    }
  }
  if (haskey) {
    {
    tmp___2 = strlen((char const   *)((char *)keys___0));
    len___0 = (int )tmp___2;
    }
    if (len___0 > 50) {


    }
    if (abbrev) {
      if (maptype != 1) {
        {
        tmp___5 = vim_iswordc((int )*(keys___0 + (len___0 - 1)));
        }
        if (tmp___5) {
          n = 0;
          {
          while (1) {
            while_continue___0: ;/* CIL Label */ ;
            if (! (n < len___0 - 2)) {
              goto while_break___0;
            }
            {
            tmp___3 = vim_iswordc((int )*(keys___0 + n));
            tmp___4 = vim_iswordc((int )*(keys___0 + (len___0 - 2)));
            }
            if (tmp___3 != tmp___4) {


            }
            n ++;
          }
          while_break___0: ;/* CIL Label */ ;
          }
        }
        n = 0;
        {
        while (1) {
          while_continue___1: ;/* CIL Label */ ;
          if (! (n < len___0)) {
            goto while_break___1;
          }
          if ((int )*(keys___0 + n) == 32) {


          } else { //Added block
          if ((int )*(keys___0 + n) == 9) {


          }
          }
          n ++;
        }
        while_break___1: ;/* CIL Label */ ;
        }
      }
    }
  }
  if (haskey) {
    if (hasarg) {
      if (abbrev) {
        no_abbr = 0;
      }
    }
  }
  if (! haskey) {
    {
    msg_start();
    }
  } else { //Added block
  if (maptype != 1) {
    if (! hasarg) {
      {
      msg_start();
      }
    }
  }
  }
  round = 0;
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (round == 0) {
      goto _L___0;
    } else { //Added block
    if (maptype == 1) {
      _L___0: ;
      if (round <= 1) {
        if (! did_it) {
          if (! (! got_int)) {

          }
        } else {
          goto while_break___2;
        }
      } else {
        goto while_break___2;
      }
    } else {
      goto while_break___2;
    }
    }
    hash = 0;
    {
    while (1) {
      while_continue___3: ;/* CIL Label */ ;
      if (hash < 256) {
        if (! (! got_int)) {

        }
      } else {
        goto while_break___3;
      }
      if (abbrev) {
        if (hash) {
          goto while_break___3;
        }
        mpp = & first_abbr;
      } else {
        mpp = & maphash[hash];
      }
      mp = *mpp;
      {
      while (1) {
        while_continue___4: ;/* CIL Label */ ;
        if ((unsigned long )mp != (unsigned long )((void *)0)) {
          if (! (! got_int)) {

          }
        } else {
          goto while_break___4;
        }
        if (! (mp->m_mode & mode)) {
          mpp = & mp->m_next;
          goto __Cont;
        }
        if (! haskey) {
          {
          showmap(mp);
          did_it = 1;
          }
        } else {
          if (round) {
            {
            tmp___6 = strlen((char const   *)((char *)mp->m_str));
            n = (int )tmp___6;
            p___0 = mp->m_str;
            }
          } else {
            n = mp->m_keylen;
            p___0 = mp->m_keys;
          }
          if (n < len___0) {
            tmp___7 = n;
          } else {
            tmp___7 = len___0;
          }
          {
          tmp___8 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)keys___0),
                            (size_t )tmp___7);
          }
          if (! tmp___8) {
            if (maptype == 1) {
              if (n != len___0) {
                mpp = & mp->m_next;
                goto __Cont;
              }
              mp->m_mode &= ~ mode;
              did_it = 1;
            } else { //Added block
            if (! hasarg) {
              {
              showmap(mp);
              did_it = 1;
              }
            } else { //Added block
            if (n != len___0) {
              if (abbrev) {
                mpp = & mp->m_next;
                goto __Cont;
              }





            } else {



















            }
            }
            }
            if (mp->m_mode == 0) {
              {
              map_free(mpp);
              }
              goto __Cont;
            }
            if (mp->m_mode & 7) {
              new_hash = (int )*(mp->m_keys + 0);
            } else {
              new_hash = (int )*(mp->m_keys + 0) ^ 128;
            }
            if (! abbrev) {
              if (new_hash != hash) {




              }
            }
          }
        }
        mpp = & mp->m_next;
        __Cont: ;
        mp = *mpp;
      }
      while_break___4: ;/* CIL Label */ ;
      }
      hash ++;
    }
    while_break___3: ;/* CIL Label */ ;
    }
    round ++;
  }
  while_break___2: ;/* CIL Label */ ;
  }
  if (maptype == 1) {
    if (! did_it) {

    }
    goto theend;
  }
  if (! haskey) {
    goto _L___1;
  } else { //Added block
  if (! hasarg) {
    _L___1: ;
    if (! did_it) {
      if (abbrev) {
        {
        msg((char_u *)"No abbreviation found");
        }
      } else {
        {
        msg((char_u *)"No mapping found");
        }
      }
    }
    goto theend;
  }
  }
  if (did_it) {

  }
  {
  tmp___9 = alloc((unsigned int )sizeof(struct mapblock ));
  mp = (struct mapblock *)tmp___9;
  }
  if ((unsigned long )mp == (unsigned long )((void *)0)) {


  }
  {
  mp->m_keys = vim_strsave(keys___0);
  mp->m_str = vim_strsave(arg);
  }
  if ((unsigned long )mp->m_keys == (unsigned long )((void *)0)) {
    {




    }

  } else { //Added block
  if ((unsigned long )mp->m_str == (unsigned long )((void *)0)) {
    {




    }

  }
  }
  {
  tmp___10 = strlen((char const   *)((char *)mp->m_keys));
  mp->m_keylen = (int )tmp___10;
  mp->m_noremap = maptype;
  mp->m_mode = mode;
  }
  if (abbrev) {
    mp->m_next = first_abbr;
    first_abbr = mp;
  } else {
    if (mp->m_mode & 7) {
      n = (int )*(mp->m_keys + 0);
    } else {
      n = (int )*(mp->m_keys + 0) ^ 128;
    }
    mp->m_next = maphash[n];
    maphash[n] = mp;
  }
  theend: ;
  {
  vim_free((void *)keys_buf);
  vim_free((void *)arg_buf);
  }
  return (retval);
}
}
static void map_free(struct mapblock **mpp ) 
{ 
  struct mapblock *mp ;

  {
  {
  mp = *mpp;
  vim_free((void *)mp->m_keys);
  vim_free((void *)mp->m_str);
  *mpp = mp->m_next;
  vim_free((void *)mp);
  }
  return;
}
}
static void validate_maphash(void) 
{ 


  {
  if (! maphash_valid) {
    {
    memset((void *)(maphash), 0, sizeof(maphash));
    maphash_valid = 1;
    }
  }
  return;
}
}
int get_map_mode(char_u **cmdp , int forceit ) 
{ 
  char_u *p___0 ;
  int modec ;
  int mode ;
  char_u *tmp ;

  {
  p___0 = *cmdp;
  tmp = p___0;
  p___0 ++;
  modec = (int )*tmp;
  if (modec == 105) {
    mode = 16;
  } else { //Added block
  if (modec == 99) {
    mode = 8;
  } else { //Added block
  if (modec == 110) {
    if ((int )*p___0 != 111) {
      mode = 1;
    } else {
      goto _L;
    }
  } else { //Added block
  _L: ;
  if (modec == 118) {
    mode = 2;
  } else { //Added block
  if (modec == 111) {

  } else {
    p___0 --;
    if (forceit) {
      mode = 24;
    } else {
      mode = 7;
    }
  }
  }
  }
  }
  }
  *cmdp = p___0;
  return (mode);
}
}
void map_clear(char_u *cmdp , int forceit , int abbr ) 
{ 
  struct mapblock *mp ;
  struct mapblock **mpp ;
  int mode ;
  int hash ;
  int new_hash ;

  {
  {
  validate_maphash();
  mode = get_map_mode(& cmdp, forceit);
  hash = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (hash < 256)) {
      goto while_break;
    }
    if (abbr) {
      if (hash) {
        goto while_break;
      }
      mpp = & first_abbr;
    } else {
      mpp = & maphash[hash];
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! ((unsigned long )*mpp != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      mp = *mpp;
      if (mp->m_mode & mode) {
        mp->m_mode &= ~ mode;
        if (mp->m_mode == 0) {
          {
          map_free(mpp);
          }
          goto while_continue___0;
        }
        if (mp->m_mode & 7) {
          new_hash = (int )*(mp->m_keys + 0);
        } else {
          new_hash = (int )*(mp->m_keys + 0) ^ 128;
        }
        if (! abbr) {
          if (new_hash != hash) {




          }
        }
      }
      mpp = & mp->m_next;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    hash ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static void showmap(struct mapblock *mp ) 
{ 
  int len___0 ;

  {
  len___0 = 1;
  if (msg_didout) {
    {
    msg_putchar('\n');
    }
  }
  if ((mp->m_mode & 24) == 24) {
    {
    msg_putchar('!');
    }
  } else { //Added block
  if (mp->m_mode & 16) {
    {
    msg_putchar('i');
    }
  } else { //Added block
  if (mp->m_mode & 8) {
    {
    msg_putchar('c');
    }
  } else { //Added block
  if ((mp->m_mode & 7) == 7) {
    {
    msg_putchar(' ');
    }
  } else {
    len___0 = 0;
    if (mp->m_mode & 1) {
      {
      msg_putchar('n');
      len___0 ++;
      }
    }
    if (mp->m_mode & 4) {
      {


      }
    }
    if (mp->m_mode & 2) {
      {
      msg_putchar('v');
      len___0 ++;
      }
    }
  }
  }
  }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    len___0 ++;
    if (! (len___0 <= 3)) {
      goto while_break;
    }
    {
    msg_putchar(' ');
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  len___0 = msg_outtrans_special(mp->m_keys, 1);
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    {
    msg_putchar(' ');
    len___0 ++;
    }
    if (! (len___0 < 12)) {
      goto while_break___0;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (mp->m_noremap) {
    {
    msg_puts_attr((char_u *)"*", highlight_attr[0]);
    }
  } else {
    {
    msg_putchar(' ');
    }
  }
  if ((int )*(mp->m_str) == 0) {
    {

    }
  } else {
    {
    msg_outtrans_special(mp->m_str, 0);
    }
  }
  {
  out_flush();
  }
  return;
}
}
static int expand_mapmodes  =    0;
static int expand_isabbrev  =    0;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) 
{








































}
static int compare_mkeys(void const   *s1 , void const   *s2 ) ;
static int compare_mkeys(void const   *s1 , void const   *s2 ) 
{








}
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) 
{












































































































































}
int check_abbr(int c , char_u *ptr , int col , int mincol ) 
{ 
  int len___0 ;
  int j ;
  char_u tb[4] ;
  struct mapblock *mp ;
  int is_id ;
  int vim_abbr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  is_id = 1;
  if (no_abbr_cnt) {
    return (0);
  }
  if (col == 0) {

  }
  {
  tmp = vim_iswordc((int )*(ptr + (col - 1)));
  }
  if (tmp) {
    vim_abbr = 0;
    if (col > 1) {
      {
      is_id = vim_iswordc((int )*(ptr + (col - 2)));
      }
    }
  } else {
    vim_abbr = 1;
  }
  len___0 = col - 1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (len___0 > 0) {
      {
      tmp___0 = vim_isspace((int )*(ptr + (len___0 - 1)));
      }
      if (tmp___0) {
        goto while_break;
      } else { //Added block
      if (! vim_abbr) {
        {
        tmp___1 = vim_iswordc((int )*(ptr + (len___0 - 1)));
        }
        if (! (is_id == tmp___1)) {

        }
      }
      }
    } else {
      goto while_break;
    }
    len___0 --;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (len___0 < mincol) {

  }
  if (len___0 < col) {
    ptr += len___0;
    len___0 = col - len___0;
    mp = first_abbr;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! mp) {
        goto while_break___0;
      }
      if (mp->m_mode & State) {
        if (mp->m_keylen == len___0) {
          {
          tmp___2 = strncmp((char const   *)((char *)mp->m_keys), (char const   *)((char *)ptr),
                            (size_t )len___0);
          }
          if (! tmp___2) {
            goto while_break___0;
          }
        }
      }
      mp = mp->m_next;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (mp) {
      j = 0;
      if (c != 29) {
        if (c >= 512) {

        } else { //Added block
        if (c == 128) {
          _L: ;
























        } else { //Added block
        if (c < 256) {











        }
        }
        }
        {
        tmp___7 = j;
        j ++;
        tb[tmp___7] = (char_u )c;
        tb[j] = (char_u )'\000';
        ins_typebuf(tb, 1, 0, 1);
        }
      }
      if (mp->m_noremap) {
        tmp___8 = -1;
      } else {
        tmp___8 = 0;
      }
      {
      ins_typebuf(mp->m_str, tmp___8, 0, 1);
      tmp___9 = strlen((char const   *)((char *)mp->m_str));
      no_abbr_cnt = (int )((size_t )no_abbr_cnt + ((tmp___9 + (size_t )j) + 1UL));
      tb[0] = (char_u )8;
      tb[1] = (char_u )'\000';
      }
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        tmp___10 = len___0;
        len___0 --;
        if (! tmp___10) {
          goto while_break___1;
        }
        {
        ins_typebuf(tb, 1, 0, 1);
        }
      }
      while_break___1: ;/* CIL Label */ ;
      }
      return (1);
    }
  }
  return (0);
}
}
int makemap(FILE *fd ) 
{ 
  struct mapblock *mp ;
  char_u c1 ;
  char_u c2 ;
  char_u *p___0 ;
  char *cmd ;
  int abbr ;
  int hash ;
  int did_cpo ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
  did_cpo = 0;
  validate_maphash();
  abbr = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (abbr < 2)) {
      goto while_break;
    }
    hash = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (hash < 256)) {
        goto while_break___0;
      }
      if (abbr) {
        if (hash) {
          goto while_break___0;
        }
        mp = first_abbr;
      } else {
        mp = maphash[hash];
      }
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (! mp) {
          goto while_break___1;
        }
        c1 = (char_u )'\000';
        c2 = (char_u )'\000';
        if (abbr) {

        } else {
          cmd = (char *)"map";
        }
        {
        if (mp->m_mode == 7) {
          goto case_7;
        }
        if (mp->m_mode == 1) {

        }
        if (mp->m_mode == 2) {

        }
        if (mp->m_mode == 4) {

        }
        if (mp->m_mode == 3) {

        }
        if (mp->m_mode == 6) {

        }
        if (mp->m_mode == 5) {

        }
        if (mp->m_mode == 24) {
          goto case_24;
        }







        case_7: ;/* CIL Label */ 
        goto switch_break;
        case_1: ;/* CIL Label */ 


        case_2: ;/* CIL Label */ 


        case_4: ;/* CIL Label */ 


        case_3: ;/* CIL Label */ 



        case_6: ;/* CIL Label */ 



        case_5: ;/* CIL Label */ 



        case_24: ;/* CIL Label */ 
        if (! abbr) {
          cmd = (char *)"map!";
        }
        goto switch_break;
        case_8: ;/* CIL Label */ 


        case_16: ;/* CIL Label */ 


        switch_default: ;/* CIL Label */ 
        {

        }

        switch_break: ;/* CIL Label */ ;
        }
        {
        while (1) {
          while_continue___2: ;/* CIL Label */ ;
          if (! did_cpo) {
            if ((int )*(mp->m_str) == 0) {

            } else {
              i___0 = 0;
              {
              while (1) {
                while_continue___3: ;/* CIL Label */ ;
                if (! (i___0 < 2)) {
                  goto while_break___3;
                }
                if (i___0) {
                  p___0 = mp->m_str;
                } else {
                  p___0 = mp->m_keys;
                }
                {
                while (1) {
                  while_continue___4: ;/* CIL Label */ ;
                  if (! *p___0) {
                    goto while_break___4;
                  }
                  if ((int )*p___0 == 128) {
                    did_cpo = 1;
                  } else { //Added block
                  if ((int )*p___0 == 10) {

                  }
                  }
                  p___0 ++;
                }
                while_break___4: ;/* CIL Label */ ;
                }
                i___0 ++;
              }
              while_break___3: ;/* CIL Label */ ;
              }
            }
            if (did_cpo) {
              {
              tmp = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"let cpo_save=&cpo");
              }
              if (tmp < 0) {

              } else {
                {
                tmp___0 = put_eol(fd);
                }
                if (tmp___0 < 0) {

                } else {
                  {
                  tmp___1 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"set cpo=B");
                  }
                  if (tmp___1 < 0) {

                  } else {
                    {
                    tmp___2 = put_eol(fd);
                    }
                    if (tmp___2 < 0) {

                    }
                  }
                }
              }
            }
          }
          if (c1) {
            {

            }



          }
          if (mp->m_noremap) {
            {

            }



          }
          {
          tmp___5 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )cmd);
          }
          if (tmp___5 < 0) {

          }
          {
          tmp___6 = _IO_putc(' ', fd);
          }
          if (tmp___6 < 0) {

          } else {
            {
            tmp___7 = putescstr(fd, mp->m_keys, 0);
            }
            if (tmp___7 == 0) {

            } else {
              {
              tmp___8 = _IO_putc(' ', fd);
              }
              if (tmp___8 < 0) {

              } else {
                {
                tmp___9 = putescstr(fd, mp->m_str, 0);
                }
                if (tmp___9 == 0) {

                } else {
                  {
                  tmp___10 = put_eol(fd);
                  }
                  if (tmp___10 < 0) {

                  }
                }
              }
            }
          }
          c1 = c2;
          c2 = (char_u )'\000';
          if (! c1) {
            goto while_break___2;
          }
        }
        while_break___2: ;/* CIL Label */ ;
        }
        mp = mp->m_next;
      }
      while_break___1: ;/* CIL Label */ ;
      }
      hash ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    abbr ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (did_cpo) {
    {
    tmp___11 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"let &cpo=cpo_save");
    }
    if (tmp___11 < 0) {

    } else {
      {
      tmp___12 = put_eol(fd);
      }
      if (tmp___12 < 0) {

      } else {
        {
        tmp___13 = fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"unlet cpo_save");
        }
        if (tmp___13 < 0) {

        } else {
          {
          tmp___14 = put_eol(fd);
          }
          if (tmp___14 < 0) {

          }
        }
      }
    }
  }
  return (1);
}
}
int putescstr(FILE *fd , char_u *str___1 , int set ) 
{ 
  int c ;
  int modifiers ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*str___1 == 0) {






  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *str___1) {
      goto while_break;
    }
    c = (int )*str___1;
    if (c == 128) {
      if (! set) {
        modifiers = 0;
        if ((int )*(str___1 + 1) == 252) {



        }
        if (c == 128) {
          if ((int )*(str___1 + 1) == 254) {

          } else {
            if ((int )*(str___1 + 1) == 255) {

            } else {
              tmp = (int )*(str___1 + 1) + ((int )*(str___1 + 2) << 8);
            }
            c = tmp;
          }
          str___1 += 2;
        }
        if (c >= 512) {
          {
          tmp___0 = get_special_key_name(c, modifiers);
          fprintf((FILE * __restrict  )fd, (char const   * __restrict  )((char *)tmp___0));
          }
          goto __Cont;
        } else { //Added block







        }
      }
    }






























































    {

    }



    __Cont: ;
    str___1 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
void check_map_keycodes(void) 
{































































































}
char_u *check_map(char_u *keys___0 , int mode , int exact ) 
{





























































}
static struct initmap initmappings[20]  = 
  {      {(char_u *)"<xF1> <F1>", 7}, 
        {(char_u *)"<xF1> <F1>", 24}, 
        {(char_u *)"<xF2> <F2>", 7}, 
        {(char_u *)"<xF2> <F2>", 24}, 
        {(char_u *)"<xF3> <F3>", 7}, 
        {(char_u *)"<xF3> <F3>", 24}, 
        {(char_u *)"<xF4> <F4>", 7}, 
        {(char_u *)"<xF4> <F4>", 24}, 
        {(char_u *)"<S-xF1> <S-F1>", 7}, 
        {(char_u *)"<S-xF1> <S-F1>", 24}, 
        {(char_u *)"<S-xF2> <S-F2>", 7}, 
        {(char_u *)"<S-xF2> <S-F2>", 24}, 
        {(char_u *)"<S-xF3> <S-F3>", 7}, 
        {(char_u *)"<S-xF3> <S-F3>", 24}, 
        {(char_u *)"<S-xF4> <S-F4>", 7}, 
        {(char_u *)"<S-xF4> <S-F4>", 24}, 
        {(char_u *)"<xEND> <END>", 7}, 
        {(char_u *)"<xEND> <END>", 24}, 
        {(char_u *)"<xHOME> <HOME>", 7}, 
        {(char_u *)"<xHOME> <HOME>", 24}};
void init_mappings(void) 
{ 
  char_u *cpo_save ;
  int i___0 ;
  char_u *s ;

  {
  cpo_save = p_cpo;
  p_cpo = (char_u *)"";
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )i___0 < sizeof(initmappings) / sizeof(struct initmap ))) {
      goto while_break;
    }
    {
    s = vim_strsave(initmappings[i___0].arg);
    }
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
      do_map(0, s, initmappings[i___0].mode, 0, (char_u **)((void *)0));
      vim_free((void *)s);
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  p_cpo = cpo_save;
  return;
}
}
#pragma merger("0","/tmp/cil-lsfeYdVO.i","-O0")
#pragma merger("0","/tmp/cil-Woe45Uju.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
long Rows  =    2L;
long Columns  =    12L;
char_u *NextScreen  =    (char_u *)((void *)0);
char_u **LinePointers  =    (char_u **)((void *)0);
int screen_Rows  =    0;
int screen_Columns  =    0;
int mod_mask  =    0;
int redraw_cmdline  =    0;
int clear_cmdline  =    0;
int cmdline_crypt  =    0;
int exec_from_reg  =    0;
int modified  =    0;
int tag_modified  =    0;
int screen_cleared  =    0;
colnr_t dollar_vcol  =    (colnr_t )0;
int expand_context  =    -2;
char_u *expand_pattern  =    (char_u *)((void *)0);
int expand_set_path  =    0;
int completion_length  =    0;
int continue_status  =    0;
int completion_interrupted  =    0;
char_u *keep_msg  =    (char_u *)((void *)0);
int keep_msg_attr  =    0;
int need_fileinfo  =    0;
int msg_scroll  =    0;
int msg_didout  =    0;
int msg_didany  =    0;
int msg_nowait  =    0;
int emsg_off  =    0;
int emsg_on_display  =    0;
int rc_did_emsg  =    0;
int no_wait_return  =    0;
int need_wait_return  =    0;
int quit_more  =    0;
int more_back  =    0;
int more_back_used  =    0;
int newline_on_exit  =    0;
int intr_char  =    0;
int vgetc_busy  =    0;
int didset_vim  =    0;
int didset_vimruntime  =    0;
int lines_left  =    -1;
int msg_no_more  =    0;
char_u *sourcing_name  =    (char_u *)((void *)0);
linenr_t sourcing_lnum  =    (linenr_t )0;
int scroll_region  =    0;
int highlight_match  =    0;
int no_smartcase  =    0;
int need_check_timestamps  =    0;
int highlight_user[9]  ;
int highlight_stlnc[9]  ;
int cterm_normal_fg_color  =    0;
int cterm_normal_fg_bold  =    0;
int cterm_normal_bg_color  =    0;
int autocmd_busy  =    0;
int autocmd_no_enter  =    0;
int autocmd_no_leave  =    0;
int did_filetype  =    0;
BUF *au_new_curbuf  =    (BUF *)((void *)0);
int mouse_past_bottom  =    0;
int mouse_past_eol  =    0;
int mouse_dragging  =    0;
VimMenu *root_menu  =    (VimMenu *)((void *)0);
int sys_menu  =    0;
VimClipboard clipboard  ;
BUF *firstbuf  =    (BUF *)((void *)0);
BUF *lastbuf  =    (BUF *)((void *)0);
BUF *curbuf  =    (BUF *)((void *)0);
int arg_had_last  =    0;
int ru_col  ;
int ru_wid  ;
int starting  =    2;
int exiting  =    0;
int full_screen  =    0;
int restricted  =    0;
int secure  =    0;
int sandbox  =    0;
int silent_mode  =    0;
int VIsual_active  =    0;
int VIsual_select  =    0;
int VIsual_mode  =    'v';
int redo_VIsual_busy  =    0;
int did_ai  =    0;
colnr_t ai_col  =    (colnr_t )0;
int end_comment_pending  =    '\000';
int did_syncbind  =    0;
int did_si  =    0;
int can_si  =    0;
int can_si_back  =    0;
int orig_line_count  =    0;
int vr_lines_changed  =    0;
colnr_t vr_virtcol  =    (colnr_t )2147483647;
int vr_virtoffset  =    0;
int State  =    1;
int exmode_active  =    0;
int ex_no_reprint  =    0;
int Recording  =    0;
int Exec_reg  =    0;
int finish_op  =    0;
int no_mapping  =    0;
int allow_keys  =    0;
int no_u_sync  =    0;
int restart_edit  =    0;
char_u *edit_submode  =    (char_u *)((void *)0);
char_u *edit_submode_extra  =    (char_u *)((void *)0);
int ctrl_x_mode  =    0;
int no_abbr  =    1;
int fo_do_comments  =    0;
int confirm  =    0;
int swap_exists_action  =    0;
int RedrawingDisabled  =    0;
int readonlymode  =    0;
int recoverymode  =    0;
char_u *typebuf  =    (char_u *)((void *)0);
int maptick  =    0;
int must_redraw  =    0;
int skip_redraw  =    0;
int do_redraw  =    0;
int need_highlight_changed  =    1;
char_u *use_viminfo  =    (char_u *)((void *)0);
int curscript  =    0;
FILE *scriptout  =    (FILE *)((void *)0);
int read_cmd_fd  =    0;
int got_int  =    0;
int termcap_active  =    0;
int bangredo  =    0;
int reg_ic  =    0;
int reg_syn  =    0;
int did_outofmem_msg  =    0;
int did_swapwrite_msg  =    0;
int undo_off  =    0;
int global_busy  =    0;
int need_start_insertmode  =    0;
char_u *last_cmdline  =    (char_u *)((void *)0);
char_u *new_last_cmdline  =    (char_u *)((void *)0);
char_u *autocmd_fname  =    (char_u *)((void *)0);
int autocmd_bufnr  =    0;
char_u *autocmd_match  =    (char_u *)((void *)0);
int postponed_split  =    0;
int g_do_tagpreview  =    0;
int replace_offset  =    0;
char_u *escape_chars  =    (char_u *)" \t\\\"|";
char_u *help_save_isk  =    (char_u *)((void *)0);
long help_save_ts  =    0L;
int keep_help_flag  =    0;
char_u *empty_option  =    (char_u *)"";
int redir_off  =    0;
FILE *redir_fd  =    (FILE *)((void *)0);
int redir_reg  =    0;
int save_p_ls  =    -1;
int wild_menu_showing  =    0;
char *longVersion ;
int lcs_eol  =    '$';
int lcs_ext  =    '\000';
int lcs_tab1  =    '\000';
int lcs_tab2  =    '\000';
int lcs_trail  =    '\000';
char_u no_lines_msg[23]  = 
  {      (char_u )'-',      (char_u )'-',      (char_u )'N',      (char_u )'o', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )'s',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )' ',      (char_u )'b',      (char_u )'u', 
        (char_u )'f',      (char_u )'f',      (char_u )'e',      (char_u )'r', 
        (char_u )'-',      (char_u )'-',      (char_u )'\000'};
int stl_syntax  =    0;
int no_hlsearch  =    0;
char *xterm_display  =    (char *)((void *)0);
Display *xterm_dpy  =    (Display *)((void *)0);
XtAppContext app_context  =    (XtAppContext )((void *)0);
char_u e_abort[16]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'o',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_argreq[18]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'r',      (char_u )'e',      (char_u )'q', 
        (char_u )'u',      (char_u )'i',      (char_u )'r',      (char_u )'e', 
        (char_u )'d',      (char_u )'\000'};
char_u e_backslash[34]  = 
  {      (char_u )'\\',      (char_u )' ',      (char_u )'s',      (char_u )'h', 
        (char_u )'o',      (char_u )'u',      (char_u )'l',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'y',      (char_u )' ', 
        (char_u )'/',      (char_u )',',      (char_u )' ',      (char_u )'?', 
        (char_u )' ',      (char_u )'o',      (char_u )'r',      (char_u )' ', 
        (char_u )'&',      (char_u )'\000'};
char_u e_curdir[65]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'r',      (char_u )'o',      (char_u )'m', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'r', 
        (char_u )'c',      (char_u )'/',      (char_u )'v',      (char_u )'i', 
        (char_u )'m',      (char_u )'r',      (char_u )'c',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'c', 
        (char_u )'u',      (char_u )'r',      (char_u )'r',      (char_u )'e', 
        (char_u )'n',      (char_u )'t',      (char_u )' ',      (char_u )'d', 
        (char_u )'i',      (char_u )'r',      (char_u )' ',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'t',      (char_u )'a', 
        (char_u )'g',      (char_u )' ',      (char_u )'s',      (char_u )'e', 
        (char_u )'a',      (char_u )'r',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_exists[32]  = 
  {      (char_u )'F',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'i', 
        (char_u )'s',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'(',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )' ',      (char_u )'!',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )' ',      (char_u )'o',      (char_u )'v', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'i', 
        (char_u )'d',      (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_failed[15]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'a',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_internal[15]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'n',      (char_u )'a',      (char_u )'l', 
        (char_u )' ',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'o',      (char_u )'r',      (char_u )'\000'};
char_u e_interr[12]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'u',      (char_u )'p', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_invaddr[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'d',      (char_u )'d',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'\000'};
char_u e_invarg[17]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )'\000'};
char_u e_invarg2[21]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_invexpr2[23]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )':',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_invrange[14]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'r',      (char_u )'a',      (char_u )'n',      (char_u )'g', 
        (char_u )'e',      (char_u )'\000'};
char_u e_invcmd[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_letunexp[33]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'e',      (char_u )'x', 
        (char_u )'p',      (char_u )'e',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'c', 
        (char_u )'h',      (char_u )'a',      (char_u )'r',      (char_u )'a', 
        (char_u )'c',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'s',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )'f',      (char_u )'o',      (char_u )'r',      (char_u )'e', 
        (char_u )' ',      (char_u )'\'',      (char_u )'=',      (char_u )'\'', 
        (char_u )'\000'};
char_u e_markinval[29]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'h',      (char_u )'a',      (char_u )'s', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )'v', 
        (char_u )'a',      (char_u )'l',      (char_u )'i',      (char_u )'d', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'u', 
        (char_u )'m',      (char_u )'b',      (char_u )'e',      (char_u )'r', 
        (char_u )'\000'};
char_u e_marknotset[13]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nesting[24]  = 
  {      (char_u )'S',      (char_u )'c',      (char_u )'r',      (char_u )'i', 
        (char_u )'p',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'n',      (char_u )'e',      (char_u )'s',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )'o',      (char_u )' ',      (char_u )'d', 
        (char_u )'e',      (char_u )'e',      (char_u )'p',      (char_u )'\000'};
char_u e_noalt[18]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'a', 
        (char_u )'l',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'n',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_noabbr[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'v',      (char_u )'i',      (char_u )'a', 
        (char_u )'t',      (char_u )'i',      (char_u )'o',      (char_u )'n', 
        (char_u )'\000'};
char_u e_nobang[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'!', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_nogvim[49]  = 
  {      (char_u )'G',      (char_u )'U',      (char_u )'I',      (char_u )' ', 
        (char_u )'c',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'b', 
        (char_u )'e',      (char_u )' ',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )'d',      (char_u )':',      (char_u )' ', 
        (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'a',      (char_u )'b', 
        (char_u )'l',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'c', 
        (char_u )'o',      (char_u )'m',      (char_u )'p',      (char_u )'i', 
        (char_u )'l',      (char_u )'e',      (char_u )' ',      (char_u )'t', 
        (char_u )'i',      (char_u )'m',      (char_u )'e',      (char_u )'\n', 
        (char_u )'\000'};
char_u e_nohebrew[52]  = 
  {      (char_u )'H',      (char_u )'e',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'w',      (char_u )' ',      (char_u )'c', 
        (char_u )'a',      (char_u )'n',      (char_u )'n',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'N', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'n',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'a', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'o', 
        (char_u )'m',      (char_u )'p',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'t',      (char_u )'i', 
        (char_u )'m',      (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_nofarsi[51]  = 
  {      (char_u )'F',      (char_u )'a',      (char_u )'r',      (char_u )'s', 
        (char_u )'i',      (char_u )' ',      (char_u )'c',      (char_u )'a', 
        (char_u )'n',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )'d', 
        (char_u )':',      (char_u )' ',      (char_u )'N',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'e',      (char_u )'n', 
        (char_u )'a',      (char_u )'b',      (char_u )'l',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'a',      (char_u )'t', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'m', 
        (char_u )'p',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'t',      (char_u )'i',      (char_u )'m', 
        (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_noinstext[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )'s',      (char_u )'e',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'e',      (char_u )'x',      (char_u )'t', 
        (char_u )' ',      (char_u )'y',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nolastcmd[25]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nomap[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'p',      (char_u )'p', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_nomatch[9]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_nomatch2[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_noname[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nopresub[42]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'s',      (char_u )'u',      (char_u )'b',      (char_u )'s', 
        (char_u )'t',      (char_u )'i',      (char_u )'t',      (char_u )'u', 
        (char_u )'t',      (char_u )'e',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'g',      (char_u )'u',      (char_u )'l', 
        (char_u )'a',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'r',      (char_u )'e', 
        (char_u )'s',      (char_u )'s',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )'\000'};
char_u e_noprev[20]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_noprevre[31]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'g',      (char_u )'u', 
        (char_u )'l',      (char_u )'a',      (char_u )'r',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )'\000'};
char_u e_norange[17]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'r', 
        (char_u )'a',      (char_u )'n',      (char_u )'g',      (char_u )'e', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_noroom[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'o',      (char_u )'u', 
        (char_u )'g',      (char_u )'h',      (char_u )' ',      (char_u )'r', 
        (char_u )'o',      (char_u )'o',      (char_u )'m',      (char_u )'\000'};
char_u e_notcreate[21]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_notmp[25]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'g',      (char_u )'e', 
        (char_u )'t',      (char_u )' ',      (char_u )'t',      (char_u )'e', 
        (char_u )'m',      (char_u )'p',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_notopen[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_notread[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'a',      (char_u )'d',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_nowrtmsg[47]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'w', 
        (char_u )'r',      (char_u )'i',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'s',      (char_u )'i',      (char_u )'n', 
        (char_u )'c',      (char_u )'e',      (char_u )' ',      (char_u )'l', 
        (char_u )'a',      (char_u )'s',      (char_u )'t',      (char_u )' ', 
        (char_u )'c',      (char_u )'h',      (char_u )'a',      (char_u )'n', 
        (char_u )'g',      (char_u )'e',      (char_u )' ',      (char_u )'(', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )' ', 
        (char_u )'!',      (char_u )' ',      (char_u )'t',      (char_u )'o', 
        (char_u )' ',      (char_u )'o',      (char_u )'v',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'i',      (char_u )'d', 
        (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_null[14]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'l',      (char_u )'l', 
        (char_u )' ',      (char_u )'a',      (char_u )'r',      (char_u )'g', 
        (char_u )'u',      (char_u )'m',      (char_u )'e',      (char_u )'n', 
        (char_u )'t',      (char_u )'\000'};
char_u e_number[16]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'m',      (char_u )'b', 
        (char_u )'e',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'e',      (char_u )'c', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_openerrf[24]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'f',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_outofmem[15]  = 
  {      (char_u )'O',      (char_u )'u',      (char_u )'t',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'m', 
        (char_u )'e',      (char_u )'m',      (char_u )'o',      (char_u )'r', 
        (char_u )'y',      (char_u )'!',      (char_u )'\000'};
char_u e_patnotf[18]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )'\000'};
char_u e_patnotf2[22]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'%', 
        (char_u )'s',      (char_u )'\000'};
char_u e_positive[26]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'m',      (char_u )'u',      (char_u )'s', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'p',      (char_u )'o',      (char_u )'s', 
        (char_u )'i',      (char_u )'t',      (char_u )'i',      (char_u )'v', 
        (char_u )'e',      (char_u )'\000'};
char_u e_quickfix[10]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'E', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'s',      (char_u )'\000'};
char_u e_re_damg[21]  = 
  {      (char_u )'D',      (char_u )'a',      (char_u )'m',      (char_u )'a', 
        (char_u )'g',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'t',      (char_u )'c', 
        (char_u )'h',      (char_u )' ',      (char_u )'s',      (char_u )'t', 
        (char_u )'r',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )'\000'};
char_u e_re_corr[25]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'r',      (char_u )'r', 
        (char_u )'u',      (char_u )'p',      (char_u )'t',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'g',      (char_u )'e',      (char_u )'x',      (char_u )'p', 
        (char_u )' ',      (char_u )'p',      (char_u )'r',      (char_u )'o', 
        (char_u )'g',      (char_u )'r',      (char_u )'a',      (char_u )'m', 
        (char_u )'\000'};
char_u e_readonly[45]  = 
  {      (char_u )'\'',      (char_u )'r',      (char_u )'e',      (char_u )'a', 
        (char_u )'d',      (char_u )'o',      (char_u )'n',      (char_u )'l', 
        (char_u )'y',      (char_u )'\'',      (char_u )' ',      (char_u )'o', 
        (char_u )'p',      (char_u )'t',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )' ',      (char_u )'i',      (char_u )'s', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )' ',      (char_u )'(',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )' ',      (char_u )'!',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )' ',      (char_u )'o', 
        (char_u )'v',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'i',      (char_u )'d',      (char_u )'e',      (char_u )')', 
        (char_u )'\000'};
char_u e_readonlyvar[35]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'s', 
        (char_u )'e',      (char_u )'t',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'d',      (char_u )'-', 
        (char_u )'o',      (char_u )'n',      (char_u )'l',      (char_u )'y', 
        (char_u )' ',      (char_u )'v',      (char_u )'a',      (char_u )'r', 
        (char_u )'i',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_readerrf[30]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'a',      (char_u )'d', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )' ', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_sandbox[23]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'s', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'b', 
        (char_u )'o',      (char_u )'x',      (char_u )'\000'};
char_u e_scroll[20]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'s',      (char_u )'c',      (char_u )'r',      (char_u )'o', 
        (char_u )'l',      (char_u )'l',      (char_u )' ',      (char_u )'s', 
        (char_u )'i',      (char_u )'z',      (char_u )'e',      (char_u )'\000'};
char_u e_tagformat[31]  = 
  {      (char_u )'F',      (char_u )'o',      (char_u )'r',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )' ', 
        (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )'s', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_tagstack[16]  = 
  {      (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )' ', 
        (char_u )'s',      (char_u )'t',      (char_u )'a',      (char_u )'c', 
        (char_u )'k',      (char_u )' ',      (char_u )'e',      (char_u )'m', 
        (char_u )'p',      (char_u )'t',      (char_u )'y',      (char_u )'\000'};
char_u e_toocompl[20]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'p', 
        (char_u )'l',      (char_u )'e',      (char_u )'x',      (char_u )'\000'};
char_u e_toombra[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )'(',      (char_u )'\000'};
char_u e_toomket[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )')',      (char_u )'\000'};
char_u e_toomsbra[11]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'[',      (char_u )'\000'};
char_u e_toomany[20]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'a', 
        (char_u )'m',      (char_u )'e',      (char_u )'s',      (char_u )'\000'};
char_u e_trailing[20]  = 
  {      (char_u )'T',      (char_u )'r',      (char_u )'a',      (char_u )'i', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )' ',      (char_u )'c',      (char_u )'h',      (char_u )'a', 
        (char_u )'r',      (char_u )'a',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'s',      (char_u )'\000'};
char_u e_umark[13]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )'\000'};
char_u e_unknown[8]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )'\000'};
char_u e_write[20]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'w',      (char_u )'r',      (char_u )'i',      (char_u )'t', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_zerocount[11]  = 
  {      (char_u )'Z',      (char_u )'e',      (char_u )'r',      (char_u )'o', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'u', 
        (char_u )'n',      (char_u )'t',      (char_u )'\000'};
char_u *p_bs  ;
char_u *p_bg  ;
char_u *p_bsdir  ;
char_u *p_breakat  ;
char_u *p_cb  ;
long p_ch  ;
char_u *p_def  ;
char_u *p_dir  ;
char_u *p_dy  ;
char_u *p_ep  ;
int p_eb  ;
int p_ek  ;
int p_exrc  ;
char_u *p_fp  ;
char_u *p_hl  ;
char_u *p_inc  ;
char_u *p_kp  ;
char_u *p_lcs  ;
int p_lz  ;
long p_mat  ;
long p_mm  ;
long p_mmt  ;
char_u *p_mouse  ;
char_u *p_mousem  ;
long p_mouset  ;
int p_more  ;
char_u *p_para  ;
char_u *p_path  ;
char_u *p_ruf  ;
long p_sj  ;
char_u *p_sbo  ;
char_u *p_sections  ;
int p_secure  ;
char_u *p_slm  ;
char_u *p_sh  ;
char_u *p_shcf  ;
char_u *p_sxq  ;
char_u *p_stl  ;
int p_sr  ;
char_u *p_shm  ;
int p_sc  ;
int p_sft  ;
long p_ss  ;
char_u *p_su  ;
char_u *p_sws  ;
int p_tbs  ;
long p_tl  ;
int p_tr  ;
char_u *p_tags  ;
int p_tgst  ;
int p_terse  ;
int p_ta  ;
int p_to  ;
char_u *p_titleold  ;
int p_tbi  ;
int p_tf  ;
long p_ttyscroll  ;
char_u *p_ttym  ;
long p_ul  ;
long p_ut  ;
int p_vb  ;
char_u *p_wig  ;
int p_wiv  ;
char_u *p_wim  ;
long p_wh  ;
long p_wmh  ;
long p_wd  ;
void mch_windinit(void) ;
void reset_signals(void) ;
int mch_check_win(int argc , char **argv ) ;
int mch_input_isatty(void) ;
void mch_windexit(int r ) ;
int process_env(char_u *env , int is_viminit ) ;
int recover_names(char_u **fname , int list , int nr ) ;
void init_yank(void) ;
void set_init_1(void) ;
void set_init_2(void) ;
void set_init_3(void) ;
void set_options_bin(int oldval , int newval ) ;
void change_compatible(int on ) ;
void screen_start(void) ;
void screenalloc(int clear ) ;
void init_highlight(int both ) ;
void termcapinit(char_u *name___1 ) ;
void scroll_region_reset(void) ;
int ui_get_winsize(void) ;
void clip_init(int can_use ) ;
void list_version(void) ;
int win_count(void) ;
int make_windows(int count___2 ) ;
void win_equal(WIN *next_curwin , int redraw ) ;
WIN *win_alloc(WIN *after ) ;
static void mainerr(int n , char_u *str___1 ) ;
static void main_msg(char *s ) ;
static void usage(void) ;
static int file_owned(char *fname ) ;
static int get_number_arg(char_u *p___0 , int *idx , int def ) ;
static char *errors___0[5]  = {      (char *)"Unknown option",      (char *)"Too many edit arguments",      (char *)"Argument missing after",      (char *)"Garbage after option", 
        (char *)"Too many \"+command\" or \"-c command\" arguments"};
static void mainerr(int n , char_u *str___1 ) 
{






















}
static void main_msg(char *s ) 
{










}
static char_u *use[4]  = {      (char_u *)"[file ..]       edit specified file(s)",      (char_u *)"-               read text from stdin",      (char_u *)"-t tag          edit file where tag is defined",      (char_u *)"-q [errorfile]  edit file with first error"};
static void usage(void) 
{





























































}
static int file_owned(char *fname ) 
{



































}
static void check_swap_exists_action(void) ;
static void check_swap_exists_action(void) 
{ 


  {
  if (swap_exists_action == 2) {
    {

    }
  }
  if (swap_exists_action == 3) {
    {





    }
  }
  return;
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
int main(int argc , char **argv ) 
{ 
  char_u *initstr ;
  char_u *term ;
  char_u *fname ;
  char_u *tagname ;
  char_u *use_vimrc ;
  char_u *use_ef ;
  int ask_for_key ;
  int n_commands ;
  char_u *commands[10] ;
  int no_swap_file ;
  int c ;
  int i___0 ;
  int bin_mode ;
  int window_count ;
  int arg_idx ;
  int had_minmin ;
  int argv_idx ;
  int want_full_screen ;
  int want_argument ;
  int edit_type ;
  int stdout_isatty ;
  int input_isatty ;
  OPARG oa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char_u *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
  {
  term = (char_u *)((void *)0);
  fname = (char_u *)((void *)0);
  tagname = (char_u *)((void *)0);
  use_vimrc = (char_u *)((void *)0);
  use_ef = (char_u *)((void *)0);
  ask_for_key = 0;
  n_commands = 0;
  no_swap_file = 0;
  bin_mode = 0;
  window_count = 1;
  arg_idx = 0;
  had_minmin = 0;
  want_full_screen = 1;
  edit_type = 0;
  setlocale(6, "");
  IObuff = alloc(1025U);
  }
  if ((unsigned long )IObuff == (unsigned long )((void *)0)) {
    {

    }
  } else {
    {
    NameBuff = alloc(1024U);
    }
    if ((unsigned long )NameBuff == (unsigned long )((void *)0)) {
      {

      }
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < argc)) {
      goto while_break;
    }
    {
    tmp = strcmp((char const   *)*(argv + i___0), (char const   *)((char *)"-display"));
    }
    if (tmp == 0) {


    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  clip_init(0);
  tmp___0 = mch_check_win(argc, argv);
  stdout_isatty = tmp___0 != 0;
  curwin = win_alloc((WIN *)((void *)0));
  }
  if ((unsigned long )curwin == (unsigned long )((void *)0)) {
    {

    }
  } else {
    {
    curbuf = buflist_new((char_u *)((void *)0), (char_u *)((void *)0), 1L, 0);
    }
    if ((unsigned long )curbuf == (unsigned long )((void *)0)) {
      {

      }
    }
  }
  {
  curwin->w_buffer = curbuf;
  curbuf->b_nwindows = 1;
  win_init(curwin);
  init_yank();
  init_homedir();
  set_init_1();
  initstr = gettail((char_u *)*(argv + 0));
  }
  if ((int )*(initstr + 0) == 114) {


  }
  if ((int )*(initstr + 0) == 103) {
    {


    }
  }
  {
  tmp___1 = strncmp((char const   *)((char *)initstr), (char const   *)((char *)"view"),
                    (size_t )4);
  }
  if (tmp___1 == 0) {



  }
  {
  tmp___2 = strncmp((char const   *)((char *)initstr), (char const   *)((char *)"ex"),
                    (size_t )2);
  }
  if (tmp___2 == 0) {
    {


    }
  }
  {
  argv ++;
  argc --;
  tmp___3 = alloc((unsigned int )(sizeof(char_u *) * (unsigned long )(argc + 1)));
  arg_files = (char_u **)tmp___3;
  }
  if ((unsigned long )arg_files == (unsigned long )((void *)0)) {
    {

    }
  }
  arg_file_count = 0;
  argv_idx = 1;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (argc > 0)) {
      goto while_break___0;
    }
    if ((int )*(*(argv + 0) + 0) == 43) {



















    } else { //Added block
    _L___0: ;
    if ((int )*(*(argv + 0) + 0) == 45) {
      if (! had_minmin) {
        want_argument = 0;
        tmp___6 = argv_idx;
        argv_idx ++;
        c = (int )*(*(argv + 0) + tmp___6);
        {
        if (c == 0) {

        }
        if (c == 45) {

        }
        if (c == 98) {

        }
        if (c == 67) {

        }
        if (c == 101) {

        }
        if (c == 102) {

        }
        if (c == 103) {

        }
        if (c == 70) {

        }
        if (c == 104) {

        }
        if (c == 72) {

        }
        if (c == 108) {

        }
        if (c == 109) {

        }
        if (c == 78) {

        }
        if (c == 110) {

        }
        if (c == 111) {

        }
        if (c == 113) {

        }
        if (c == 82) {

        }
        if (c == 114) {

        }
        if (c == 76) {

        }
        if (c == 115) {

        }
        if (c == 116) {

        }
        if (c == 86) {

        }
        if (c == 118) {

        }
        if (c == 119) {

        }
        if (c == 120) {

        }
        if (c == 90) {

        }
        if (c == 99) {

        }
        if (c == 100) {

        }
        if (c == 105) {

        }
        if (c == 84) {

        }
        if (c == 117) {
          goto case_99;
        }







        case_0: ;/* CIL Label */ 













        case_45: ;/* CIL Label */ 
        {

        }





        {

        }















        case_98: ;/* CIL Label */ 


        case_67: ;/* CIL Label */ 
        {

        }

        case_101: ;/* CIL Label */ 


        case_102: ;/* CIL Label */ 

        case_103: ;/* CIL Label */ 
        {


        }

        case_70: ;/* CIL Label */ 
        {


        }

        case_104: ;/* CIL Label */ 
        {

        }

        case_72: ;/* CIL Label */ 
        {


        }

        case_108: ;/* CIL Label */ 



        case_109: ;/* CIL Label */ 


        case_78: ;/* CIL Label */ 
        {

        }

        case_110: ;/* CIL Label */ 


        case_111: ;/* CIL Label */ 
        {

        }

        case_113: ;/* CIL Label */ 















        case_82: ;/* CIL Label */ 




        case_114: ;/* CIL Label */ 
        case_76: ;/* CIL Label */ 


        case_115: ;/* CIL Label */ 






        case_116: ;/* CIL Label */ 













        case_86: ;/* CIL Label */ 
        {


        }

        case_118: ;/* CIL Label */ 


        case_119: ;/* CIL Label */ 
        {

        }






        case_120: ;/* CIL Label */ 


        case_90: ;/* CIL Label */ 


        case_99: ;/* CIL Label */ 
        case_100: ;/* CIL Label */ 
        case_105: ;/* CIL Label */ 
        case_84: ;/* CIL Label */ 
        case_117: ;/* CIL Label */ 
        case_85: ;/* CIL Label */ 
        case_87: ;/* CIL Label */ 
        want_argument = 1;
        goto switch_break;
        switch_default: ;/* CIL Label */ 
        {

        }
        switch_break: ;/* CIL Label */ ;
        }
        if (want_argument) {
          if ((int )*(*(argv + 0) + argv_idx) != 0) {
            {

            }
          }
          argc --;
          if (argc < 1) {
            {

            }
          }
          argv ++;
          argv_idx = -1;
          {
          if (c == 99) {

          }
          if (c == 113) {

          }
          if (c == 105) {

          }
          if (c == 115) {

          }
          if (c == 116) {

          }
          if (c == 84) {

          }
          if (c == 117) {
            goto case_117___0;
          }










          case_99___0: ;/* CIL Label */ 









          case_113___0: ;/* CIL Label */ 


          case_105___0: ;/* CIL Label */ 


          case_115___0: ;/* CIL Label */ 















          {

          }











          {

          }






          case_116___0: ;/* CIL Label */ 


          case_84___0: ;/* CIL Label */ 


          case_117___0: ;/* CIL Label */ 
          use_vimrc = (char_u *)*(argv + 0);
          goto switch_break___0;
          case_85___0: ;/* CIL Label */ 

          case_119___0: ;/* CIL Label */ 
          case_87___0: ;/* CIL Label */ 




















          {

          }












          switch_break___0: ;/* CIL Label */ ;
          }
        }
      } else {

      }
    } else {
      _L: ;
      argv_idx = -1;
      if (edit_type != 0) {
        if (edit_type != 1) {
          {

          }
        }
      }
      {
      edit_type = 1;
      *(arg_files + arg_file_count) = vim_strsave((char_u *)*(argv + 0));
      }
      if ((unsigned long )*(arg_files + arg_file_count) != (unsigned long )((void *)0)) {
        arg_file_count ++;
      }
    }
    }
    if (argv_idx <= 0) {
      argc --;
      argv ++;
      argv_idx = 1;
    } else { //Added block





    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (arg_file_count > 0) {
    fname = *(arg_files + 0);
  }
  if (arg_file_count > 1) {
    {
    printf((char const   * __restrict  )"%d files to edit\n", arg_file_count);
    }
  }
  RedrawingDisabled = 1;
  if (recoverymode) {



  }
  {
  mch_windinit();
  input_isatty = mch_input_isatty();
  }
  if (exmode_active) {



  } else { //Added block
  if (want_full_screen) {
    if (! stdout_isatty) {

    } else { //Added block
    if (! input_isatty) {
      _L___1: ;










      {


      }
    }
    }
  }
  }
  if (want_full_screen) {
    {
    termcapinit(term);
    screen_start();
    }
  }
  {
  screenalloc(0);
  ui_get_winsize();
  screenalloc(0);
  set_init_2();
  firstwin->w_height = (int )(Rows - 1L);
  cmdline_row = (int )(Rows - 1L);
  }
  if (full_screen) {
    if (edit_type != 2) {
      {
      msg_start();
      }
    }
  }
  {
  msg_scroll = 1;
  no_wait_return = 1;
  init_mappings();
  init_highlight(1);
  }
  if ((unsigned long )use_vimrc != (unsigned long )((void *)0)) {
    {
    tmp___15 = strcmp((char const   *)((char *)use_vimrc), (char const   *)((char *)"NONE"));
    }
    if (! (tmp___15 == 0)) {
      {
      tmp___14 = do_source(use_vimrc, 0, 0);
      }
      if (tmp___14 != 1) {
        {
        emsg2((char_u *)"Cannot read from \"%s\"", use_vimrc);
        }
      }
    }
  } else { //Added block










































































  }
  if (recoverymode) {






  }
  {
  set_init_3();
  }
  if (no_swap_file) {

  }
  if (bin_mode) {
    {


    }
  }
  if ((int )*p_viminfo != 0) {
    {

    }
  }
  if (edit_type == 4) {





    {

    }






  }
  if ((unsigned long )curbuf->b_ffname == (unsigned long )((void *)0)) {
    {
    setfname(fname, (char_u *)((void *)0), 1);
    arg_idx ++;
    }
  }
  starting = 1;
  no_wait_return = 0;
  if (! exmode_active) {
    msg_scroll = 0;
  }
  if (edit_type == 2) {














  }
  {
  settmode(2);
  }
  if (need_wait_return) {
    {

    }
  } else { //Added block
  if (msg_didany) {
    {

    }
  }
  }
  {
  starttermcap();
  setmouse();
  }
  if (scroll_region) {
    {
    scroll_region_reset();
    }
  }
  {
  scroll_start();
  }
  if (exmode_active) {

  } else {
    {
    screenclear();
    }
  }
  if (ask_for_key) {
    {

    }
  }
  no_wait_return = 1;
  if (window_count == 0) {

  }
  if (window_count > 1) {









  } else {
    window_count = 1;
  }
  if (recoverymode) {
    {



    }





    {

    }
  } else {
    swap_exists_action = 1;
    autocmd_no_enter ++;
    autocmd_no_leave ++;
    curwin = firstwin;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! ((unsigned long )curwin != (unsigned long )((void *)0))) {
        goto while_break___1;
      }
      curbuf = curwin->w_buffer;
      if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
        {
        open_buffer(0);
        check_swap_exists_action();
        curwin = firstwin;
        }
      }
      {
      ui_breakcheck();
      }
      if (got_int) {
        {

        }

      }
      curwin = curwin->w_next;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    autocmd_no_enter --;
    autocmd_no_leave --;
    swap_exists_action = 0;
    curwin = firstwin;
    curbuf = curwin->w_buffer;
  }
  if (exmode_active) {

  }
  {
  apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  setpcmark();
  }
  if (edit_type == 4) {
    {

    }
  }
  autocmd_no_enter ++;
  autocmd_no_leave ++;
  i___0 = 1;
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (! (i___0 < window_count)) {
      goto while_break___2;
    }



    {

    }





















    {

    }







  }
  while_break___2: ;/* CIL Label */ ;
  }
  {
  autocmd_no_enter --;
  win_enter(firstwin, 0);
  autocmd_no_leave --;
  }
  if (window_count > 1) {
    {

    }
  }
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! (arg_idx < arg_file_count)) {
      goto while_break___3;
    }
    {
    tmp___28 = arg_idx;
    arg_idx ++;
    buflist_add(*(arg_files + tmp___28));
    }
  }
  while_break___3: ;/* CIL Label */ ;
  }
  {
  shorten_fnames(0);
  }
  if (tagname) {
    {




    }
  }
  if (n_commands > 0) {



    {











    while_break___4: ;/* CIL Label */ ;
    }









  }
  {
  RedrawingDisabled = 0;
  redraw_later(40);
  no_wait_return = 0;
  starting = 0;
  }
  if (p_im) {

  }
  {
  apply_autocmds((EVENT_T )33, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (restart_edit) {
    {

    }
  }
  {
  clear_oparg(& oa);
  }
  {
  while (1) {
    while_continue___5: ;/* CIL Label */ ;
    {
    tmp___30 = stuff_empty();
    }
    if (tmp___30) {
      if (need_check_timestamps) {
        {
        check_timestamps(0);
        }
      }
      if (need_wait_return) {
        {

        }
      }
      if (need_start_insertmode) {
        {

        }







      }
    }
    if (got_int) {








    }
    if (! exmode_active) {
      msg_scroll = 0;
    }
    quit_more = 0;
    if (skip_redraw) {
      skip_redraw = 0;
    } else { //Added block
    if (exmode_active) {

    } else { //Added block
    if (do_redraw) {
      goto _L___3;
    } else {
      {
      tmp___31 = stuff_empty();
      }
      if (tmp___31) {
        _L___3: ;
        {
        update_topline();
        validate_cursor();
        }
        if (VIsual_active) {
          {
          update_curbuf(20);
          }
        } else { //Added block
        if (must_redraw) {
          {
          update_screen(must_redraw);
          }
        } else { //Added block
        if (redraw_cmdline) {
          {
          showmode();
          }
        } else { //Added block
        if (clear_cmdline) {
          {
          showmode();
          }
        }
        }
        }
        }
        {
        redraw_statuslines();
        }
        if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
          {
          msg_attr(keep_msg, keep_msg_attr);
          }
        }
        if (need_fileinfo) {
          {


          }
        }
        {
        emsg_on_display = 0;
        msg_didany = 0;
        do_redraw = 0;
        showruler(0);
        setcursor();
        cursor_on();
        }
      }
    }
    }
    }
    {
    update_curswant();
    }
    if (exmode_active) {
      {

      }
    } else {
      {
      normal_cmd(& oa, 1);
      }
    }
  }
  while_break___5: ;/* CIL Label */ ;
  }

}
}
static int get_number_arg(char_u *p___0 , int *idx , int def ) 
{



























}
int process_env(char_u *env , int is_viminit ) 
{
































}
void getout(int r ) 
{ 


  {
  {
  exiting = 1;
  windgoto((int )Rows - 1, 0);
  apply_autocmds((EVENT_T )35, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if ((int )*p_viminfo != 0) {
    {


    }






  }
  {
  apply_autocmds((EVENT_T )34, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  windgoto((int )Rows - 1, 0);
  mch_windexit(r);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-XFp4uAh1.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
FPOS *movemark(int count___2 ) ;
char_u *fm_getname(struct filemark *fmark , int lead_len ) ;
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
static struct filemark namedfm[36]  ;
static char_u *namedfm_names[36]  ;
static char_u *mark_line(FPOS *mp , int lead_len ) ;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) ;
static void cleanup_jumplist(void) ;
int setmark(int c ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  if (c == 39) {
    {


    }

  } else { //Added block
  if (c == 96) {
    {


    }

  }
  }
  if (c > 122) {

  }
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + c) & 512) {
    i___0 = c - 97;
    curbuf->b_namedm[i___0] = curwin->w_cursor;
    return (1);
  }
  {

  }







}
}
void setpcmark(void) 
{ 
  int i___0 ;

  {
  if (global_busy) {

  }
  curwin->w_prev_pcmark = curwin->w_pcmark;
  curwin->w_pcmark = curwin->w_cursor;
  (curwin->w_jumplistlen) ++;
  if (curwin->w_jumplistlen > 50) {


    {








    while_break: ;/* CIL Label */ ;
    }
  }
  curwin->w_jumplistidx = curwin->w_jumplistlen - 1;
  curwin->w_jumplist[curwin->w_jumplistidx].mark = curwin->w_pcmark;
  curwin->w_jumplist[curwin->w_jumplistidx].fnum = curbuf->b_fnum;
  (curwin->w_jumplistidx) ++;
  return;
}
}
void checkpcmark(void) 
{ 


  {
  if (curwin->w_prev_pcmark.lnum != 0L) {
    if (curwin->w_pcmark.lnum == curwin->w_cursor.lnum) {
      if (curwin->w_pcmark.col == curwin->w_cursor.col) {
        curwin->w_pcmark = curwin->w_prev_pcmark;
        curwin->w_prev_pcmark.lnum = (linenr_t )0;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: ;
    if (curwin->w_pcmark.lnum == 0L) {


    }
    }
  }
  return;
}
}
FPOS *movemark(int count___2 ) 
{ 
  FPOS *pos___0 ;
  struct filemark *jmp ;
  int tmp ;
  BUF *tmp___0 ;
  int tmp___1 ;

  {
  {
  cleanup_jumplist();
  }
  if (curwin->w_jumplistlen == 0) {

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (curwin->w_jumplistidx + count___2 < 0) {
      return ((FPOS *)((void *)0));
    } else { //Added block
    if (curwin->w_jumplistidx + count___2 >= curwin->w_jumplistlen) {
      return ((FPOS *)((void *)0));
    }
    }
    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
      {
      setpcmark();
      (curwin->w_jumplistidx) --;
      }
      if (curwin->w_jumplistidx + count___2 < 0) {

      }
    }
    curwin->w_jumplistidx += count___2;
    jmp = curwin->w_jumplist + curwin->w_jumplistidx;
    if (jmp->fnum != curbuf->b_fnum) {
      {

      }









      {

      }






    } else {
      pos___0 = & jmp->mark;
    }
    return (pos___0);
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
}
}
static FPOS pos_copy  ;
FPOS *getmark(int c , int changefile ) 
{ 
  FPOS *posp ;
  FPOS *startp ;
  FPOS *endp ;
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  posp = (FPOS *)((void *)0);
  if (! (c > 126)) {
    if (c == 39) {


    } else { //Added block
    if (c == 96) {


    } else { //Added block
    if (c == 34) {

    } else { //Added block
    if (c == 91) {
      posp = & curbuf->b_op_start;
    } else { //Added block
    if (c == 93) {
      posp = & curbuf->b_op_end;
    } else { //Added block
    if (c == 60) {
      goto _L___0;
    } else { //Added block
    if (c == 62) {
      _L___0: ;
      startp = & curbuf->b_visual_start;
      endp = & curbuf->b_visual_end;
      if (startp->lnum != endp->lnum) {

      } else {
        tmp = startp->col < endp->col;
      }
      if ((c == 60) == tmp) {
        posp = startp;
      } else {
        posp = endp;
      }
      if (curbuf->b_visual_mode == 86) {







      }
    } else {
      {
      tmp___4 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___4 + c) & 512) {
        posp = & curbuf->b_namedm[c - 97];
      } else {
        {
        tmp___2 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___2 + c) & 256) {

        } else {
          {
          tmp___3 = vim_isdigit(c);
          }
          if (tmp___3) {
            _L: ;
            {
            tmp___0 = vim_isdigit(c);
            }
            if (tmp___0) {
              c = (c - 48) + 26;
            } else {

            }
            posp = & namedfm[c].mark;
            if (namedfm[c].fnum == 0) {
              if ((unsigned long )namedfm_names[c] != (unsigned long )((void *)0)) {
                {




                }
              }
            }
            if (namedfm[c].fnum != curbuf->b_fnum) {
              if (namedfm[c].mark.lnum != 0L) {
                if (changefile) {
                  if (namedfm[c].fnum) {
                    {


                    }





                  }
                }
              }
              posp = & pos_copy;
              pos_copy.lnum = (linenr_t )0;
            }
          }
        }
      }
    }
    }
    }
    }
    }
    }
    }
  }
  return (posp);
}
}
void fmarks_check_names(BUF *buf___3 ) 
{ 
  char_u *name___1 ;
  int i___0 ;
  int tmp ;

  {
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {
    return;
  }
  {
  name___1 = home_replace_save(buf___3, buf___3->b_ffname);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break;
    }
    if (namedfm[i___0].fnum == 0) {
      if ((unsigned long )namedfm_names[i___0] != (unsigned long )((void *)0)) {
        {

        }







      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)name___1);
  }
  return;
}
}
int check_mark(FPOS *pos___0 ) 
{ 


  {
  if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
    {

    }

  }
  if (pos___0->lnum == 0L) {
    {
    emsg(e_marknotset);
    }
    return (0);
  }
  if (pos___0->lnum > curbuf->b_ml.ml_line_count) {
    {

    }

  }
  return (1);
}
}
static int i  =    -1;
void clrallmarks(BUF *buf___3 ) 
{ 


  {
  if (i == -1) {
    i = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (i < 27)) {
        goto while_break;
      }
      namedfm[i].mark.lnum = (linenr_t )0;
      namedfm_names[i] = (char_u *)((void *)0);
      i ++;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i < 26)) {
      goto while_break___0;
    }
    buf___3->b_namedm[i].lnum = (linenr_t )0;
    i ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  buf___3->b_op_start.lnum = (linenr_t )0;
  buf___3->b_op_end.lnum = (linenr_t )0;
  buf___3->b_last_cursor.lnum = (linenr_t )1;
  buf___3->b_last_cursor.col = (colnr_t )0;
  return;
}
}
char_u *fm_getname(struct filemark *fmark , int lead_len ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if (fmark->fnum == curbuf->b_fnum) {
    {
    tmp = mark_line(& fmark->mark, lead_len);
    }
    return (tmp);
  }
  {

  }

}
}
static char_u *mark_line(FPOS *mp , int lead_len ) 
{ 
  char_u *s ;
  char_u *p___0 ;
  int len___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  if (mp->lnum == 0L) {
    {

    }

  } else { //Added block
  if (mp->lnum > curbuf->b_ml.ml_line_count) {
    {

    }

  }
  }
  {
  tmp___0 = ml_get(mp->lnum);
  tmp___1 = skipwhite(tmp___0);
  s = vim_strnsave(tmp___1, (int )Columns);
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {

  }
  len___0 = 0;
  p___0 = s;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*p___0 != 0)) {
      goto while_break;
    }
    {
    tmp___2 = charsize((int )*p___0);
    len___0 += tmp___2;
    }
    if ((long )len___0 >= Columns - (long )lead_len) {

    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  *p___0 = (char_u )'\000';
  return (s);
}
}
void do_marks(char_u *arg ) 
{ 
  int i___0 ;
  char_u *name___1 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    if ((int )*arg == 0) {
      arg = (char_u *)((void *)0);
    }
  }
  {
  show_one_mark('\'', arg, & curwin->w_pcmark, (char_u *)((void *)0), 1);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 26)) {
      goto while_break;
    }
    {
    show_one_mark(i___0 + 97, arg, & curbuf->b_namedm[i___0], (char_u *)((void *)0),
                  1);
    i___0 ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___0;
    }
    if (namedfm[i___0].fnum) {
      {


      }
    } else {
      name___1 = namedfm_names[i___0];
    }
    if ((unsigned long )name___1 != (unsigned long )((void *)0)) {





      {

      }





    }
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  show_one_mark('\"', arg, & curbuf->b_last_cursor, (char_u *)((void *)0), 1);
  show_one_mark('[', arg, & curbuf->b_op_start, (char_u *)((void *)0), 1);
  show_one_mark(']', arg, & curbuf->b_op_end, (char_u *)((void *)0), 1);
  show_one_mark('<', arg, & curbuf->b_visual_start, (char_u *)((void *)0), 1);
  show_one_mark('>', arg, & curbuf->b_visual_end, (char_u *)((void *)0), 1);
  show_one_mark(-1, arg, (FPOS *)((void *)0), (char_u *)((void *)0), 0);
  }
  return;
}
}
static int did_title  =    0;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) 
{ 
  int mustfree ;
  int tmp ;
  char_u *tmp___0 ;

  {
  mustfree = 0;
  if (c == -1) {
    if (did_title) {
      did_title = 0;
    } else { //Added block
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {

      }
    } else {
      {
      emsg2((char_u *)"No marks matching \"%s\"", arg);
      }
    }
    }
  } else { //Added block
  if (! got_int) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      goto _L;
    } else {
      {
      tmp___0 = vim_strchr(arg, c);
      }
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        _L: ;
        if (p___0->lnum != 0L) {
          if (! did_title) {
            {
            msg_puts_title((char_u *)"\nmark line  col file/text");
            did_title = 1;
            }
          }
          {
          msg_putchar('\n');
          }
          if (! got_int) {
            {
            sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )" %c %6ld %4d ",
                    c, p___0->lnum, p___0->col);
            msg_outtrans(IObuff);
            }
            if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
              if (current) {
                {
                name___1 = mark_line(p___0, 15);
                mustfree = 1;
                }
              }
            }
            if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
              if (current) {
                tmp = highlight_attr[2];
              } else {

              }
              {
              msg_outtrans_attr(name___1, tmp);
              }
              if (mustfree) {
                {
                vim_free((void *)name___1);
                }
              }
            }
          }
          {
          out_flush();
          }
        }
      }
    }
  }
  }
  return;
}
}
void do_jumps(void) 
{ 
  int i___0 ;
  char_u *name___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  cleanup_jumplist();
  msg_puts_title((char_u *)"\n jump line  col file/text");
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < curwin->w_jumplistlen)) {
      goto while_break;
    }
    if (curwin->w_jumplist[i___0].mark.lnum != 0L) {
      {
      name___1 = fm_getname(& curwin->w_jumplist[i___0], 16);
      }
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

      }
      {
      msg_putchar('\n');
      }
      if (i___0 > curwin->w_jumplistidx) {

      } else {
        tmp = curwin->w_jumplistidx - i___0;
      }
      if (i___0 == curwin->w_jumplistidx) {

      } else {
        tmp___0 = ' ';
      }
      {
      sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )"%c %2d %5ld %4d ",
              tmp___0, tmp, curwin->w_jumplist[i___0].mark.lnum, curwin->w_jumplist[i___0].mark.col);
      msg_outtrans(IObuff);
      }
      if (curwin->w_jumplist[i___0].fnum == curbuf->b_fnum) {
        tmp___1 = highlight_attr[2];
      } else {

      }
      {
      msg_outtrans_attr(name___1, tmp___1);
      vim_free((void *)name___1);
      }
    }
    {
    out_flush();
    }
    __Cont: ;
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
    {
    msg_puts((char_u *)"\n>");
    }
  }
  return;
}
}
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{ 
  int i___0 ;
  int fnum ;
  linenr_t *lp ;
  WIN *win ;

  {
  fnum = curbuf->b_fnum;
  if (line2 < line1) {



  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 26)) {
      goto while_break;
    }
    lp = & curbuf->b_namedm[i___0].lnum;
    if (*lp >= line1) {









    } else { //Added block
    _L: ;
    if (amount_after) {



    }
    }
    if (namedfm[i___0].fnum == fnum) {



















    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  i___0 = 26;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___0;
    }
    if (namedfm[i___0].fnum == fnum) {



















    }
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  lp = & curwin->w_pcmark.lnum;
  if (*lp >= line1) {









  } else { //Added block
  _L___2: ;
  if (amount_after) {



  }
  }
  lp = & curwin->w_prev_pcmark.lnum;
  if (*lp >= line1) {









  } else { //Added block
  _L___3: ;
  if (amount_after) {



  }
  }
  lp = & curbuf->b_visual_start.lnum;
  if (*lp >= line1) {









  } else { //Added block
  _L___4: ;
  if (amount_after) {



  }
  }
  lp = & curbuf->b_visual_end.lnum;
  if (*lp >= line1) {









  } else { //Added block
  _L___5: ;
  if (amount_after) {



  }
  }
  win = firstwin;
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___1;
    }
    if ((unsigned long )win->w_buffer == (unsigned long )curbuf) {
      i___0 = 0;
      {
      while (1) {
        while_continue___2: ;/* CIL Label */ ;
        if (! (i___0 < win->w_tagstacklen)) {
          goto while_break___2;
        }






















      }
      while_break___2: ;/* CIL Label */ ;
      }
    }
    win = win->w_next;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  {
  qf_mark_adjust(line1, line2, amount, amount_after);
  win = firstwin;
  }
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break___3;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___4: ;/* CIL Label */ ;
      if (! (i___0 < win->w_jumplistlen)) {
        goto while_break___4;
      }
      if (win->w_jumplist[i___0].fnum == fnum) {
        lp = & win->w_jumplist[i___0].mark.lnum;
        if (*lp >= line1) {









        } else { //Added block
        _L___7: ;
        if (amount_after) {



        }
        }
      }
      i___0 ++;
    }
    while_break___4: ;/* CIL Label */ ;
    }
    if ((unsigned long )win != (unsigned long )curwin) {















































    }
    win = win->w_next;
  }
  while_break___3: ;/* CIL Label */ ;
  }
  return;
}
}
static void cleanup_jumplist(void) 
{ 
  int i___0 ;
  int from ;
  int to ;
  int tmp ;

  {
  to = 0;
  from = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (from < curwin->w_jumplistlen)) {
      goto while_break;
    }
    if (curwin->w_jumplistidx == from) {

    }
    i___0 = from + 1;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (i___0 < curwin->w_jumplistlen)) {
        goto while_break___0;
      }






    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (i___0 >= curwin->w_jumplistlen) {
      tmp = to;
      to ++;
      curwin->w_jumplist[tmp] = curwin->w_jumplist[from];
    }
    from ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (curwin->w_jumplistidx == curwin->w_jumplistlen) {
    curwin->w_jumplistidx = to;
  }
  curwin->w_jumplistlen = to;
  return;
}
}
void set_last_cursor(WIN *win ) 
{ 


  {
  (win->w_buffer)->b_last_cursor = win->w_cursor;
  return;
}
}
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) 
{ 
  int idx ;
  char_u *str___1 ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
  str___1 = line + 1;
  if ((int )*str___1 > 127) {

  } else {
    {
    tmp___2 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___2 + (int )*str___1) & 2048) {
      _L___1: ;
      {
      tmp___0 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___0 + (int )*str___1) & 2048) {
        idx = ((int )*str___1 - 48) + 26;
      } else {

      }
      if (namedfm[idx].mark.lnum == 0L) {
        goto _L;
      } else { //Added block
      if (force) {
        _L: ;
        {
        str___1 = skipwhite(str___1 + 1);
        namedfm[idx].mark.lnum = getdigits(& str___1);
        str___1 = skipwhite(str___1);
        tmp___1 = getdigits(& str___1);
        namedfm[idx].mark.col = (colnr_t )tmp___1;
        str___1 = skipwhite(str___1);
        namedfm_names[idx] = viminfo_readstring(str___1, fp___0);
        }
      }
      }
    } else {
      {

      }
      if ((int const   )*(*tmp___3 + (int )*str___1) & 256) {

      } else {
        _L___0: ;
        {

        }



      }
    }
  }
  {
  tmp___4 = vim_fgets(line, 512, fp___0);
  }
  return (tmp___4);
}
}
void write_viminfo_filemarks(FILE *fp___0 ) 
{ 
  int i___0 ;
  char_u *name___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = get_viminfo_parameter('\'');
  }
  if (tmp == 0) {

  }
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# File marks:\n");
  }
  if ((unsigned long )curbuf->b_ffname != (unsigned long )((void *)0)) {
    {
    tmp___3 = removable(curbuf->b_ffname);
    }
    if (! tmp___3) {
      {
      name___1 = buflist_nr2name(curbuf->b_fnum, 1, 0);
      i___0 = 26;
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! (i___0 < 35)) {
          goto while_break;
        }
        if (namedfm[i___0].mark.lnum == curwin->w_cursor.lnum) {
          if ((unsigned long )namedfm_names[i___0] == (unsigned long )((void *)0)) {

          } else {
            if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
              {
              tmp___0 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)namedfm_names[i___0]));
              }
              if (tmp___0 == 0) {

              } else {
                tmp___1 = 0;
              }
            } else {

            }
            tmp___2 = tmp___1;
          }
          if (tmp___2) {

          }
        }
        i___0 ++;
      }
      while_break: ;/* CIL Label */ ;
      }
      {
      vim_free((void *)name___1);
      vim_free((void *)namedfm_names[i___0]);
      }
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! (i___0 > 26)) {
          goto while_break___0;
        }
        namedfm[i___0] = namedfm[i___0 - 1];
        namedfm_names[i___0] = namedfm_names[i___0 - 1];
        i___0 --;
      }
      while_break___0: ;/* CIL Label */ ;
      }
      namedfm[26].mark = curwin->w_cursor;
      namedfm[26].fnum = curbuf->b_fnum;
      namedfm_names[26] = (char_u *)((void *)0);
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! (i___0 < 36)) {
      goto while_break___1;
    }
    if (namedfm[i___0].mark.lnum == 0L) {
      goto __Cont;
    }
    if (namedfm[i___0].fnum) {
      {
      name___1 = buflist_nr2name(namedfm[i___0].fnum, 1, 0);
      }
    } else {
      name___1 = namedfm_names[i___0];
    }
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

    }
    if (i___0 < 26) {

    } else {
      tmp___4 = (i___0 - 26) + 48;
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\'%c  %ld  %ld  ",
            tmp___4, namedfm[i___0].mark.lnum, (long )namedfm[i___0].mark.col);
    viminfo_writestring(fp___0, name___1);
    }
    if (namedfm[i___0].fnum) {
      {
      vim_free((void *)name___1);
      }
    }
    __Cont: ;
    i___0 ++;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  return;
}
}
int removable(char_u *name___1 ) 
{ 
  char_u *p___0 ;
  char_u part[51] ;
  int retval ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  retval = 0;
  name___1 = home_replace_save((BUF *)((void *)0), name___1);
  }
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {
    p___0 = p_viminfo;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! *p___0) {
        goto while_break;
      }
      {
      copy_option_part(& p___0, part, 51, (char *)", ");
      }
      if ((int )part[0] == 114) {
        {



        }




      }
    }
    while_break: ;/* CIL Label */ ;
    }
    {
    vim_free((void *)name___1);
    }
  }
  return (retval);
}
}
int write_viminfo_marks(FILE *fp_out ) 
{ 
  int count___2 ;
  BUF *buf___3 ;
  WIN *win ;
  int is_mark_set ;
  int i___0 ;
  int tmp ;

  {
  win = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )win != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    set_last_cursor(win);
    win = win->w_next;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  fprintf((FILE * __restrict  )fp_out, (char const   * __restrict  )"\n# History of marks within files (newest to oldest):\n");
  count___2 = 0;
  buf___3 = firstbuf;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if (buf___3->b_marks_read) {




























































    }
    buf___3 = buf___3->b_next;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  return (count___2);
}
}
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) 
{ 
  BUF *buf___3 ;
  int num_marked_files ;
  int load_marks ;
  int copy_marks_out ;
  char_u *str___1 ;
  int i___0 ;
  char_u *p___0 ;
  char_u *name_buf ;
  long lnum ;
  int col ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  name_buf = alloc(512U);
  }
  if ((unsigned long )name_buf == (unsigned long )((void *)0)) {

  }
  {
  num_marked_files = get_viminfo_parameter('\'');
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! eof) {
      if (! (count___2 < num_marked_files)) {



      }
    } else {
      goto while_break;
    }


















    {


    }



    {


    }
    {
















    while_break___0: ;/* CIL Label */ ;
    }























































    {

    }
    {







































    while_break___2: ;/* CIL Label */ ;
    }



  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)name_buf);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-bWye6avC.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
void mch_hide(char_u *name___1 ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) ;
int mf_open_file(MEMFILE *mfp , char_u *fname ) ;
void mf_close(MEMFILE *mfp , int del_file ) ;
void mf_close_file(BUF *buf___3 , int getlines ) ;
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) ;
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) ;
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) ;
void mf_free(MEMFILE *mfp , BHDR *hp ) ;
int mf_sync(MEMFILE *mfp , int flags___0 ) ;
int mf_release_all(void) ;
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) ;
void mf_set_ffname(MEMFILE *mfp ) ;
int mf_need_trans(MEMFILE *mfp ) ;
void ml_open_file(BUF *buf___3 ) ;
int ui_char_avail(void) ;
static long_u total_mem_used  =    (long_u )0;
static int dont_release  =    0;
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) ;
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_release(MEMFILE *mfp , int page_count ) ;
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) ;
static void mf_free_bhdr(BHDR *hp ) ;
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_rem_free(MEMFILE *mfp ) ;
static int mf_read(MEMFILE *mfp , BHDR *hp ) ;
static int mf_write(MEMFILE *mfp , BHDR *hp ) ;
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) ;
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) 
{ 
  MEMFILE *mfp ;
  int i___0 ;
  off_t size ;
  struct stat stf ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = alloc((unsigned int )sizeof(MEMFILE ));
  mfp = (MEMFILE *)tmp;
  }
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  }
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    mfp->mf_fname = (char_u *)((void *)0);
    mfp->mf_ffname = (char_u *)((void *)0);
    mfp->mf_fd = -1;
  } else {
    {

    }






  }
  mfp->mf_free_first = (BHDR *)((void *)0);
  mfp->mf_used_first = (BHDR *)((void *)0);
  mfp->mf_used_last = (BHDR *)((void *)0);
  mfp->mf_dirty = 0;
  mfp->mf_used_count = 0U;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 64)) {
      goto while_break;
    }
    mfp->mf_hash[i___0] = (BHDR *)((void *)0);
    mfp->mf_trans[i___0] = (NR_TRANS *)((void *)0);
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  mfp->mf_page_size = 4096U;
  if (mfp->mf_fd >= 0) {
    {

    }







  }
  if (mfp->mf_fd < 0) {
    mfp->mf_blocknr_max = (blocknr_t )0;
  } else { //Added block












  }
  mfp->mf_blocknr_min = (blocknr_t )-1;
  mfp->mf_neg_count = (blocknr_t )0;
  mfp->mf_infile_count = mfp->mf_blocknr_max;
  mfp->mf_used_count_max = (unsigned int )((p_mm * 1024L) / (long )mfp->mf_page_size);
  return (mfp);
}
}
int mf_open_file(MEMFILE *mfp , char_u *fname ) 
{ 


  {
  {
  mf_do_open(mfp, fname, 1);
  }
  if (mfp->mf_fd < 0) {

  }
  mfp->mf_dirty = 1;
  return (1);
}
}
void mf_close(MEMFILE *mfp , int del_file ) 
{ 
  BHDR *hp ;
  BHDR *nextp ;
  NR_TRANS *tp ;
  NR_TRANS *tpnext ;
  int i___0 ;
  int tmp ;
  BHDR *tmp___0 ;

  {
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  }
  if (mfp->mf_fd >= 0) {
    {
    tmp = close(mfp->mf_fd);
    }
    if (tmp < 0) {
      {

      }
    }
  }
  if (del_file) {
    if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
      {
      unlink((char const   *)((char *)mfp->mf_fname));
      }
    }
  }
  hp = mfp->mf_used_first;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    total_mem_used -= (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
    nextp = hp->bh_next;
    mf_free_bhdr(hp);
    hp = nextp;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )mfp->mf_free_first != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {


    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! (i___0 < 64)) {
      goto while_break___1;
    }
    tp = mfp->mf_trans[i___0];
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
        goto while_break___2;
      }
      {



      }
    }
    while_break___2: ;/* CIL Label */ ;
    }
    i___0 ++;
  }
  while_break___1: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)mfp->mf_fname);
  vim_free((void *)mfp->mf_ffname);
  vim_free((void *)mfp);
  }
  return;
}
}
void mf_close_file(BUF *buf___3 , int getlines ) 
{



















































}
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) 
{ 
  BHDR *hp ;
  BHDR *freep ;
  char_u *p___0 ;
  char_u *tmp ;
  blocknr_t tmp___0 ;

  {
  {
  hp = mf_release(mfp, page_count);
  freep = mfp->mf_free_first;
  }
  if (! negative) {
    if ((unsigned long )freep != (unsigned long )((void *)0)) {





































    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
      hp = mf_alloc_bhdr(mfp, page_count);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {

      }
    }
    if (negative) {




    } else {
      hp->bh_bnum = mfp->mf_blocknr_max;
      mfp->mf_blocknr_max += (blocknr_t )page_count;
    }
  }
  {
  hp->bh_flags = (char)3;
  mfp->mf_dirty = 1;
  hp->bh_page_count = page_count;
  mf_ins_used(mfp, hp);
  mf_ins_hash(mfp, hp);
  memset((void *)((char *)hp->bh_data), 0, (size_t )mfp->mf_page_size);
  }
  return (hp);
}
}
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) 
{ 
  BHDR *hp ;
  int tmp ;

  {
  if (nr >= mfp->mf_blocknr_max) {

  } else { //Added block
  if (nr <= mfp->mf_blocknr_min) {

  }
  }
  {
  hp = mf_find_hash(mfp, nr);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {







    {

    }








    {




    }






  } else {
    {
    mf_rem_used(mfp, hp);
    mf_rem_hash(mfp, hp);
    }
  }
  {
  hp->bh_flags = (char )((int )hp->bh_flags | 2);
  mf_ins_used(mfp, hp);
  mf_ins_hash(mfp, hp);
  }
  return (hp);
}
}
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) 
{ 
  int flags___0 ;

  {
  flags___0 = (int )hp->bh_flags;
  if ((flags___0 & 2) == 0) {
    {

    }
  }
  flags___0 &= -3;
  if (dirty) {
    flags___0 |= 1;
    mfp->mf_dirty = 1;
  }
  hp->bh_flags = (char )flags___0;
  if (infile) {
    {
    mf_trans_add(mfp, hp);
    }
  }
  return;
}
}
void mf_free(MEMFILE *mfp , BHDR *hp ) 
{




















}
int mf_sync(MEMFILE *mfp , int flags___0 ) 
{ 
  int status ;
  BHDR *hp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (mfp->mf_fd < 0) {
    mfp->mf_dirty = 0;
    return (0);
  }
  status = 1;
  hp = mfp->mf_used_last;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (flags___0 & 1) {
      goto _L___0;
    } else { //Added block
    if (hp->bh_bnum >= 0L) {
      _L___0: ;
      if ((int )hp->bh_flags & 1) {
        if (status == 1) {
          goto _L;
        } else { //Added block
        if (hp->bh_bnum >= 0L) {
          if (hp->bh_bnum < mfp->mf_infile_count) {
            _L: ;
            if (flags___0 & 8) {
              if (hp->bh_bnum != 0L) {
                goto __Cont;
              }
            }
            {
            tmp = mf_write(mfp, hp);
            }
            if (tmp == 0) {




            }
            if (flags___0 & 2) {
              {

              }



            }
          }
        }
        }
      }
    }
    }
    __Cont: ;
    hp = hp->bh_prev;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    mfp->mf_dirty = 0;
  } else { //Added block



  }
  if (flags___0 & 4) {
    if ((int )*p_sws != 0) {
      {
      tmp___2 = strcmp((char const   *)((char *)p_sws), (char const   *)((char *)"fsync"));
      }
      if (tmp___2 == 0) {
        {
        tmp___1 = fsync(mfp->mf_fd);
        }
        if (tmp___1) {

        }
      } else {
        {

        }
      }
    }
  }
  return (status);
}
}
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) 
{ 
  BHDR *hhp ;
  int hash ;

  {
  hash = (int )(hp->bh_bnum & 63L);
  hhp = mfp->mf_hash[hash];
  hp->bh_hash_next = hhp;
  hp->bh_hash_prev = (BHDR *)((void *)0);
  if ((unsigned long )hhp != (unsigned long )((void *)0)) {

  }
  mfp->mf_hash[hash] = hp;
  return;
}
}
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  if ((unsigned long )hp->bh_hash_prev == (unsigned long )((void *)0)) {
    mfp->mf_hash[hp->bh_bnum & 63L] = hp->bh_hash_next;
  } else {

  }
  if (hp->bh_hash_next) {

  }
  return;
}
}
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) 
{ 
  BHDR *hp ;

  {
  hp = mfp->mf_hash[nr & 63L];
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {

    }
    if (hp->bh_bnum == nr) {
      goto while_break;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return (hp);
}
}
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  hp->bh_next = mfp->mf_used_first;
  mfp->mf_used_first = hp;
  hp->bh_prev = (BHDR *)((void *)0);
  if ((unsigned long )hp->bh_next == (unsigned long )((void *)0)) {
    mfp->mf_used_last = hp;
  } else {
    (hp->bh_next)->bh_prev = hp;
  }
  mfp->mf_used_count += (unsigned int )hp->bh_page_count;
  total_mem_used += (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
  return;
}
}
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) 
{ 


  {
  if ((unsigned long )hp->bh_next == (unsigned long )((void *)0)) {
    mfp->mf_used_last = hp->bh_prev;
  } else {
    (hp->bh_next)->bh_prev = hp->bh_prev;
  }
  if ((unsigned long )hp->bh_prev == (unsigned long )((void *)0)) {
    mfp->mf_used_first = hp->bh_next;
  } else {
    (hp->bh_prev)->bh_next = hp->bh_next;
  }
  mfp->mf_used_count -= (unsigned int )hp->bh_page_count;
  total_mem_used -= (long_u )((unsigned int )hp->bh_page_count * mfp->mf_page_size);
  return;
}
}
static BHDR *mf_release(MEMFILE *mfp , int page_count ) 
{ 
  BHDR *hp ;
  int need_release ;
  BUF *buf___3 ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  if (dont_release) {

  }
  if (mfp->mf_used_count >= mfp->mf_used_count_max) {

  } else { //Added block
  if (total_mem_used >> 10 >= (long_u )p_mmt) {

  } else {
    tmp = 0;
  }
  }
  need_release = tmp;
  if (mfp->mf_fd < 0) {
    if (need_release) {























    }
  }
  if (mfp->mf_fd < 0) {
    return ((BHDR *)((void *)0));
  } else { //Added block



  }

  {










  while_break___0: ;/* CIL Label */ ;
  }











  {


  }















}
}
int mf_release_all(void) 
{







































































}
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) 
{ 
  BHDR *hp ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  tmp___1 = alloc((unsigned int )sizeof(BHDR ));
  hp = (BHDR *)tmp___1;
  }
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
    {
    tmp___0 = alloc(mfp->mf_page_size * (unsigned int )page_count);
    tmp = tmp___0;
    hp->bh_data = tmp;
    }
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {

      }

    }
    hp->bh_page_count = page_count;
  }
  return (hp);
}
}
static void mf_free_bhdr(BHDR *hp ) 
{ 


  {
  {
  vim_free((void *)hp->bh_data);
  vim_free((void *)hp);
  }
  return;
}
}
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) 
{







}
static BHDR *mf_rem_free(MEMFILE *mfp ) 
{







}
static int mf_read(MEMFILE *mfp , BHDR *hp ) 
{

































}
static int mf_write(MEMFILE *mfp , BHDR *hp ) 
{ 
  off_t offset ;
  blocknr_t nr ;
  BHDR *hp2 ;
  unsigned int page_size ;
  unsigned int page_count ;
  unsigned int size ;
  int tmp ;
  __off_t tmp___0 ;
  BHDR *tmp___1 ;
  ssize_t tmp___2 ;

  {
  if (mfp->mf_fd < 0) {

  }
  if (hp->bh_bnum < 0L) {
    {

    }



  }
  page_size = mfp->mf_page_size;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    nr = hp->bh_bnum;
    if (nr > mfp->mf_infile_count) {
      {
      nr = mfp->mf_infile_count;
      hp2 = mf_find_hash(mfp, nr);
      }
    } else {
      hp2 = hp;
    }
    {
    offset = (off_t )page_size * nr;
    tmp___0 = lseek(mfp->mf_fd, offset, 0);
    }
    if (tmp___0 != offset) {
      {

      }

    }
    if ((unsigned long )hp2 == (unsigned long )((void *)0)) {

    } else {
      page_count = (unsigned int )hp2->bh_page_count;
    }
    size = page_size * page_count;
    if ((unsigned long )hp2 == (unsigned long )((void *)0)) {

    } else {
      tmp___1 = hp2;
    }
    {
    tmp___2 = write(mfp->mf_fd, (void const   *)((char *)tmp___1->bh_data), (size_t )size);
    }
    if ((unsigned int )tmp___2 != size) {







    }
    did_swapwrite_msg = 0;
    if ((unsigned long )hp2 != (unsigned long )((void *)0)) {
      hp2->bh_flags = (char )((int )hp2->bh_flags & -2);
    }
    if (nr + (blocknr_t )page_count > mfp->mf_infile_count) {
      mfp->mf_infile_count = nr + (blocknr_t )page_count;
    }
    if (nr == hp->bh_bnum) {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) 
{ 
  BHDR *freep ;
  blocknr_t new_bnum ;
  int hash ;
  NR_TRANS *np___0 ;
  int page_count ;
  char_u *tmp ;

  {
  if (hp->bh_bnum >= 0L) {
    return (1);
  }
  {


  }

























  {








  }





}
}
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) 
{






































}
void mf_set_ffname(MEMFILE *mfp ) 
{ 


  {
  {
  mfp->mf_ffname = FullName_save(mfp->mf_fname, 0);
  }
  return;
}
}
void mf_fullname(MEMFILE *mfp ) 
{ 


  {
  if ((unsigned long )mfp != (unsigned long )((void *)0)) {
    if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
      if ((unsigned long )mfp->mf_ffname != (unsigned long )((void *)0)) {
        {
        vim_free((void *)mfp->mf_fname);
        mfp->mf_fname = mfp->mf_ffname;
        mfp->mf_ffname = (char_u *)((void *)0);
        }
      }
    }
  }
  return;
}
}
int mf_need_trans(MEMFILE *mfp ) 
{ 
  int tmp ;

  {
  if ((unsigned long )mfp->mf_fname != (unsigned long )((void *)0)) {
    if (mfp->mf_neg_count > 0L) {

    } else {
      tmp = 0;
    }
  } else {

  }
  return (tmp);
}
}
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) 
{ 
  int tmp ;

  {
  {
  mfp->mf_fname = fname;
  mf_set_ffname(mfp);
  }
  if (trunc_file) {
    {
    unlink((char const   *)((char *)mfp->mf_fname));
    }
  }
  if (trunc_file) {
    tmp = 194;
  } else {

  }
  {
  mfp->mf_fd = open((char const   *)((char *)mfp->mf_fname), tmp, (mode_t )384);
  }
  if (mfp->mf_fd < 0) {
    {




    }
  } else {
    {
    mch_hide(mfp->mf_fname);
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-hl89qSPY.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
char *Version ;
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) ;
void ml_open_files(void) ;
void ml_close_all(int del_file ) ;
void ml_close_notmod(void) ;
char_u *ml_get_pos(FPOS *pos___0 ) ;
int ml_line_alloced(void) ;
void ml_setdirty(BUF *buf___3 , int flag ) ;
void msg_outnum(long n ) ;
void msg_home_replace(char_u *fname ) ;
int get_number(int colon ) ;
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) ;
int get_user_name(char_u *buf___3 , int len___0 ) ;
static linenr_t lowest_marked  =    (linenr_t )0;
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) ;
static void swapfile_info(char_u *fname ) ;
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) ;
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) ;
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) ;
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) ;
static void ml_flush_line(BUF *buf___3 ) ;
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) ;
static BHDR *ml_new_ptr(MEMFILE *mfp ) ;
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) ;
static int ml_add_stack(BUF *buf___3 ) ;
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) ;
static void ml_lineadd(BUF *buf___3 , int count___2 ) ;
static int b0_magic_wrong(ZERO_BL *b0p ) ;
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) ;
static void long_to_char(long n , char_u *s ) ;
static long char_to_long(char_u *s ) ;
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) ;
int ml_open(void) 
{ 
  MEMFILE *mfp ;
  BHDR *hp ;
  ZERO_BL *b0p ;
  PTR_BL *pp ;
  DATA_BL *dp ;
  long tmp ;

  {
  hp = (BHDR *)((void *)0);
  curbuf->b_ml.ml_stack_size = 0;
  curbuf->b_ml.ml_stack = (IPTR *)((void *)0);
  curbuf->b_ml.ml_stack_top = 0;
  curbuf->b_ml.ml_locked = (BHDR *)((void *)0);
  curbuf->b_ml.ml_line_lnum = (linenr_t )0;
  curbuf->b_ml.ml_chunksize = (ML_CHUNKSIZE *)((void *)0);
  if (p_uc) {
    if (curbuf->b_p_swf) {
      curbuf->b_may_swap = 1;
    } else {

    }
  } else {

  }
  {
  mfp = mf_open((char_u *)((void *)0), 1);
  }
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  }
  {
  curbuf->b_ml.ml_mfp = mfp;
  curbuf->b_ml.ml_flags = 1;
  curbuf->b_ml.ml_line_count = (linenr_t )1;
  hp = mf_new(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  if (hp->bh_bnum != 0L) {
    {

    }

  }
  b0p = (ZERO_BL *)hp->bh_data;
  b0p->b0_id[0] = (char_u )'b';
  b0p->b0_id[1] = (char_u )'0';
  if (curbuf->b_changed) {

  } else {
    b0p->b0_fname[899] = (char_u )0;
  }
  {
  b0p->b0_magic_long = 808530483L;
  b0p->b0_magic_int = 539042339;
  b0p->b0_magic_short = (short)4627;
  b0p->b0_magic_char = (char_u )85;
  strncpy((char * __restrict  )((char *)(b0p->b0_version)), (char const   * __restrict  )((char *)"VIM "),
          (size_t )4);
  strncpy((char * __restrict  )((char *)(b0p->b0_version + 4)), (char const   * __restrict  )Version,
          (size_t )6);
  set_b0_fname(b0p, curbuf);
  long_to_char((long )mfp->mf_page_size, b0p->b0_page_size);
  get_user_name(b0p->b0_uname, 40);
  b0p->b0_uname[39] = (char_u )'\000';
  mch_get_host_name(b0p->b0_hname, 40);
  b0p->b0_hname[39] = (char_u )'\000';
  tmp = mch_get_pid();
  long_to_char(tmp, b0p->b0_pid);
  mf_put(mfp, hp, 1, 0);
  }
  if (! curbuf->b_help) {
    {
    mf_sync(mfp, 0);
    }
  }
  {
  hp = ml_new_ptr(mfp);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  if (hp->bh_bnum != 1L) {
    {

    }

  }
  {
  pp = (PTR_BL *)hp->bh_data;
  pp->pb_count = (short_u )1;
  pp->pb_pointer[0].pe_bnum = (blocknr_t )2;
  pp->pb_pointer[0].pe_page_count = 1;
  pp->pb_pointer[0].pe_old_lnum = (linenr_t )1;
  pp->pb_pointer[0].pe_line_count = (linenr_t )1;
  mf_put(mfp, hp, 1, 0);
  hp = ml_new_data(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  if (hp->bh_bnum != 2L) {
    {

    }

  }
  dp = (DATA_BL *)hp->bh_data;
  (dp->db_txt_start) --;
  dp->db_index[0] = dp->db_txt_start;
  dp->db_free = (unsigned int )((unsigned long )dp->db_free - (1UL + sizeof(unsigned int )));
  dp->db_line_count = (linenr_t )1;
  *((char_u *)dp + dp->db_txt_start) = (char_u )'\000';
  return (1);
  error: ;












}
}
void ml_setname(void) 
{ 
  int success___0 ;
  MEMFILE *mfp ;
  char_u *fname ;
  char_u *dirp ;
  int tmp ;
  int tmp___0 ;

  {
  success___0 = 0;
  mfp = curbuf->b_ml.ml_mfp;
  if (mfp->mf_fd < 0) {






  }
  dirp = p_dir;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (! ((int )*dirp == 0))) {

    }
    {
    fname = findswapname(curbuf, & dirp, mfp->mf_fname);
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {

    }
    {
    tmp = strcmp((char const   *)((char *)fname), (char const   *)((char *)mfp->mf_fname));
    }
    if (tmp == 0) {
      {


      }

    }
    if (mfp->mf_fd >= 0) {
      {
      close(mfp->mf_fd);
      mfp->mf_fd = -1;
      }
    }
    {
    tmp___0 = vim_rename(mfp->mf_fname, fname);
    }
    if (tmp___0 == 0) {
      {
      success___0 = 1;
      vim_free((void *)mfp->mf_fname);
      mfp->mf_fname = fname;
      vim_free((void *)mfp->mf_ffname);
      mf_set_ffname(mfp);
      }
      goto while_break;
    }
    {

    }
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (mfp->mf_fd == -1) {
    {
    mfp->mf_fd = open((char const   *)((char *)mfp->mf_fname), 2, 0);
    }
    if (mfp->mf_fd < 0) {
      {

      }

    }
  }
  if (! success___0) {
    {

    }
  }
  return;
}
}
void ml_open_files(void) 
{



























}
void ml_open_file(BUF *buf___3 ) 
{ 
  MEMFILE *mfp ;
  char_u *fname ;
  char_u *dirp ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  } else { //Added block
  if (mfp->mf_fd >= 0) {

  } else { //Added block
  if (! buf___3->b_p_swf) {

  }
  }
  }
  dirp = p_dir;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (! ((int )*dirp == 0))) {

    }
    {
    fname = findswapname(buf___3, & dirp, (char_u *)((void *)0));
    }
    if ((unsigned long )fname == (unsigned long )((void *)0)) {

    }
    {
    tmp___0 = mf_open_file(mfp, fname);
    }
    if (tmp___0 == 1) {
      {
      tmp = mf_sync(mfp, 8);
      }
      if (tmp == 1) {
        goto while_break;
      }
      {

      }
    }
    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )mfp->mf_fname == (unsigned long )((void *)0)) {







    {


    }
  }
  buf___3->b_may_swap = 0;
  return;
}
}
void check_need_swap(int newfile ) 
{ 


  {
  if (curbuf->b_may_swap) {
    if (! curbuf->b_p_ro) {
      {
      ml_open_file(curbuf);
      }
    } else { //Added block





    }
  }
  return;
}
}
void ml_close(BUF *buf___3 , int del_file ) 
{ 


  {
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return;
  }
  {
  mf_close(buf___3->b_ml.ml_mfp, del_file);
  }
  if (buf___3->b_ml.ml_line_lnum != 0L) {
    if (buf___3->b_ml.ml_flags & 2) {
      {
      vim_free((void *)buf___3->b_ml.ml_line_ptr);
      }
    }
  }
  {
  vim_free((void *)buf___3->b_ml.ml_stack);
  vim_free((void *)buf___3->b_ml.ml_chunksize);
  buf___3->b_ml.ml_chunksize = (ML_CHUNKSIZE *)((void *)0);
  buf___3->b_ml.ml_mfp = (MEMFILE *)((void *)0);
  }
  return;
}
}
void ml_close_all(int del_file ) 
{ 
  BUF *buf___3 ;

  {
  buf___3 = firstbuf;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    ml_close(buf___3, del_file);
    buf___3 = buf___3->b_next;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_deltempdir();
  }
  return;
}
}
void ml_close_notmod(void) 
{

























}
void ml_timestamp(BUF *buf___3 ) 
{ 
  MEMFILE *mfp ;
  BHDR *hp ;
  ZERO_BL *b0p ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {
    return;
  } else {
    {
    hp = mf_get(mfp, (blocknr_t )0, 1);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {

    }
  }
  b0p = (ZERO_BL *)hp->bh_data;
  if ((int )b0p->b0_id[0] != 98) {
    {

    }
  } else { //Added block
  if ((int )b0p->b0_id[1] != 48) {
    {

    }
  } else {
    {
    set_b0_fname(b0p, buf___3);
    }
  }
  }
  {
  mf_put(mfp, hp, 1, 0);
  }
  return;
}
}
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) 
{ 
  struct stat st ;
  size_t flen ;
  size_t ulen ;
  char_u uname___0[40] ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )buf___3->b_ffname == (unsigned long )((void *)0)) {

  } else {
    {
    home_replace((BUF *)((void *)0), buf___3->b_ffname, b0p->b0_fname, 900, 1);
    }
    if ((int )b0p->b0_fname[0] == 126) {
      {


      }























    }
    {
    tmp___0 = stat((char const   * __restrict  )((char *)buf___3->b_ffname), (struct stat * __restrict  )(& st));
    }
    if (tmp___0 >= 0) {
      {
      long_to_char(st.st_mtim.tv_sec, b0p->b0_mtime);
      long_to_char((long )st.st_ino, b0p->b0_ino);
      buf___3->b_mtime = st.st_mtim.tv_sec;
      buf___3->b_mtime_read = st.st_mtim.tv_sec;
      }
    } else {
      {
      long_to_char(0L, b0p->b0_mtime);
      long_to_char(0L, b0p->b0_ino);
      buf___3->b_mtime = 0L;
      buf___3->b_mtime_read = 0L;
      }
    }
  }
  return;
}
}
void ml_recover(void) 
{































































































































































































































































































































































































































































































































































































}
int recover_names(char_u **fname , int list , int nr ) 
{







































































































































































































































































































































}
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) 
{

























































}
static int process_still_running  ;
static void swapfile_info(char_u *fname ) 
{


















































































































































}
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) 
{



















































































}
void ml_sync_all(int check_file , int check_char ) 
{


























































































}
void ml_preserve(BUF *buf___3 , int message ) 
{ 
  BHDR *hp ;
  linenr_t lnum ;
  MEMFILE *mfp ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )mfp->mf_fname == (unsigned long )((void *)0)) {
    _L: ;






  }
  }
  {
  ml_flush_line(buf___3);
  ml_find_line(buf___3, (linenr_t )0, 2);
  status = mf_sync(mfp, 5);
  buf___3->b_ml.ml_stack_top = 0;
  tmp___1 = mf_need_trans(mfp);
  }
  if (tmp___1) {

    {





















    while_break: ;/* CIL Label */ ;
    }
    {


    }




  }
  theend: ;
  if (message) {









  }
  return;
}
}
char_u *ml_get(linenr_t lnum ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, lnum, 0);
  }
  return (tmp);
}
}
char_u *ml_get_pos(FPOS *pos___0 ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, pos___0->lnum, 0);
  }
  return (tmp + pos___0->col);
}
}
char_u *ml_get_curline(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, curwin->w_cursor.lnum, 0);
  }
  return (tmp);
}
}
char_u *ml_get_cursor(void) 
{ 
  char_u *tmp ;

  {
  {
  tmp = ml_get_buf(curbuf, curwin->w_cursor.lnum, 0);
  }
  return (tmp + curwin->w_cursor.col);
}
}
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  char_u *ptr ;

  {
  if (lnum > buf___3->b_ml.ml_line_count) {
    {

    }
    errorret: ;
    {

    }

  }
  if (lnum <= 0L) {

  }
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    return ((char_u *)"");
  }
  if (buf___3->b_ml.ml_line_lnum != lnum) {
    {
    ml_flush_line(buf___3);
    hp = ml_find_line(buf___3, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {

      }

    }
    dp = (DATA_BL *)hp->bh_data;
    ptr = (char_u *)dp + (dp->db_index[lnum - buf___3->b_ml.ml_locked_low] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
    buf___3->b_ml.ml_line_ptr = ptr;
    buf___3->b_ml.ml_line_lnum = lnum;
    buf___3->b_ml.ml_flags &= -3;
  }
  if (will_change) {
    buf___3->b_ml.ml_flags |= 12;
  }
  return (buf___3->b_ml.ml_line_ptr);
}
}
int ml_line_alloced(void) 
{ 


  {
  return (curbuf->b_ml.ml_flags & 2);
}
}
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (curbuf->b_syn_change_lnum > lnum + 1L) {

  }
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {

    }



  }
  if (curbuf->b_ml.ml_line_lnum != 0L) {
    {
    ml_flush_line(curbuf);
    }
  }
  {
  tmp___0 = ml_append_int(curbuf, lnum, line, len___0, newfile, 0);
  }
  return (tmp___0);
}
}
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) 
{ 
  int i___0 ;
  int line_count ;
  int offset ;
  int from ;
  int to ;
  int space_needed ;
  int page_size ;
  int page_count ;
  int db_idx ;
  BHDR *hp ;
  MEMFILE *mfp ;
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  size_t tmp ;
  linenr_t tmp___0 ;
  long line_count_left ;
  long line_count_right ;
  int page_count_left ;
  int page_count_right ;
  BHDR *hp_left ;
  BHDR *hp_right ;
  BHDR *hp_new ;
  int lines_moved ;
  int data_moved ;
  int total_moved ;
  DATA_BL *dp_right ;
  DATA_BL *dp_left ;
  int stack_idx ;
  int in_left ;
  int lineadd ;
  blocknr_t bnum_left ;
  blocknr_t bnum_right ;
  linenr_t lnum_left ;
  linenr_t lnum_right ;
  int pb_idx ;
  PTR_BL *pp_new ;

  {
  if (lnum > buf___3->b_ml.ml_line_count) {

  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {

  }
  }
  if (lowest_marked) {



  }
  if (len___0 == 0U) {
    {
    tmp = strlen((char const   *)((char *)line));
    len___0 = (colnr_t )(tmp + 1UL);
    }
  }
  space_needed = (int )((unsigned long )len___0 + sizeof(unsigned int ));
  mfp = buf___3->b_ml.ml_mfp;
  page_size = (int )mfp->mf_page_size;
  if (lnum == 0L) {
    tmp___0 = (linenr_t )1;
  } else {
    tmp___0 = lnum;
  }
  {
  hp = ml_find_line(buf___3, tmp___0, 18);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  buf___3->b_ml.ml_flags &= -2;
  if (lnum == 0L) {
    db_idx = -1;
  } else {
    db_idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
  }
  line_count = (int )(buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low);
  dp = (DATA_BL *)hp->bh_data;
  if ((int )dp->db_free < space_needed) {















  }
  (buf___3->b_ml.ml_line_count) ++;
  if ((int )dp->db_free >= space_needed) {
    dp->db_txt_start -= len___0;
    dp->db_free -= (unsigned int )space_needed;
    (dp->db_line_count) ++;
    if (line_count > db_idx + 1) {
      if (db_idx < 0) {
        offset = (int )dp->db_txt_end;
      } else {
        offset = (int )(dp->db_index[db_idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
      }
      {
      memmove((void *)((char *)dp + dp->db_txt_start), (void const   *)(((char *)dp + dp->db_txt_start) + len___0),
              (size_t )((unsigned int )offset - (dp->db_txt_start + len___0)));
      i___0 = line_count - 1;
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! (i___0 > db_idx)) {
          goto while_break;
        }
        dp->db_index[i___0 + 1] = dp->db_index[i___0] - len___0;
        i___0 --;
      }
      while_break: ;/* CIL Label */ ;
      }
      dp->db_index[db_idx + 1] = (colnr_t )offset - len___0;
    } else {

    }
    {
    memmove((void *)((char *)dp + dp->db_index[db_idx + 1]), (void const   *)((char *)line),
            (size_t )len___0);
    }
    if (mark) {

    }
    buf___3->b_ml.ml_flags |= 4;
    if (! newfile) {
      buf___3->b_ml.ml_flags |= 8;
    }
  } else {





















    {


    }






































































































    {





    }
    {






















































































































































    while_break___1: ;/* CIL Label */ ;
    }






  }
  {
  ml_updatechunk(buf___3, lnum + 1L, (int )len___0, 1);
  }
  return (1);
}
}
int ml_replace(linenr_t lnum , char_u *line , int copy ) 
{ 
  int tmp ;

  {
  if ((unsigned long )line == (unsigned long )((void *)0)) {

  }
  if ((unsigned long )curbuf->b_ml.ml_mfp == (unsigned long )((void *)0)) {
    {

    }



  }
  if (curbuf->b_ml.ml_line_lnum != lnum) {
    {

    }
  } else { //Added block
  if (curbuf->b_ml.ml_flags & 2) {
    {
    vim_free((void *)curbuf->b_ml.ml_line_ptr);
    }
  }
  }
  if (copy) {
    {

    }



  }
  curbuf->b_ml.ml_line_ptr = line;
  curbuf->b_ml.ml_line_lnum = lnum;
  curbuf->b_ml.ml_flags = (curbuf->b_ml.ml_flags | 2) & -2;
  return (1);
}
}
int ml_delete(linenr_t lnum , int message ) 
{ 
  int tmp ;

  {
  if (curbuf->b_syn_change_lnum > lnum) {

  }
  {
  ml_flush_line(curbuf);
  tmp = ml_delete_int(curbuf, lnum, message);
  }
  return (tmp);
}
}
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) 
{ 
  BHDR *hp ;
  MEMFILE *mfp ;
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  int count___2 ;
  int idx ;
  int stack_idx ;
  int text_start ;
  int line_start ;
  int line_size ;
  int i___0 ;

  {
  if (lnum < 1L) {

  } else { //Added block
  if (lnum > buf___3->b_ml.ml_line_count) {

  }
  }
  if (lowest_marked) {



  }
  if (buf___3->b_ml.ml_line_count == 1L) {




    {


    }

  }
  mfp = buf___3->b_ml.ml_mfp;
  if ((unsigned long )mfp == (unsigned long )((void *)0)) {

  }
  {
  hp = ml_find_line(buf___3, lnum, 17);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  dp = (DATA_BL *)hp->bh_data;
  count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 2L);
  idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
  (buf___3->b_ml.ml_line_count) --;
  line_start = (int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
  if (idx == 0) {

  } else {
    line_size = (int )((dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - (unsigned int )line_start);
  }
  if (count___2 == 1) {
    {



    }
    {


















































    while_break: ;/* CIL Label */ ;
    }
  } else {
    {
    text_start = (int )dp->db_txt_start;
    memmove((void *)(((char *)dp + text_start) + line_size), (void const   *)((char *)dp + text_start),
            (size_t )(line_start - text_start));
    i___0 = idx;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (i___0 < count___2 - 1)) {
        goto while_break___0;
      }


    }
    while_break___0: ;/* CIL Label */ ;
    }
    dp->db_free = (unsigned int )((unsigned long )dp->db_free + ((unsigned long )line_size + sizeof(unsigned int )));
    dp->db_txt_start += (unsigned int )line_size;
    (dp->db_line_count) --;
    buf___3->b_ml.ml_flags |= 12;
  }
  {
  ml_updatechunk(buf___3, lnum, line_size, 2);
  }
  return (1);
}
}
void ml_setmarked(linenr_t lnum ) 
{

































}
linenr_t ml_firstmarked(void) 
{














































}
void ml_clearmarked(void) 
{













































}
static void ml_flush_line(BUF *buf___3 ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  linenr_t lnum ;
  char_u *new_line ;
  char_u *old_line ;
  colnr_t new_len ;
  int old_len ;
  int extra ;
  int idx ;
  int start___0 ;
  int count___2 ;
  int i___0 ;
  size_t tmp ;

  {
  if (buf___3->b_ml.ml_line_lnum == 0L) {
    return;
  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_mfp == (unsigned long )((void *)0)) {

  }
  }
  if (buf___3->b_ml.ml_flags & 2) {
    {
    lnum = buf___3->b_ml.ml_line_lnum;
    new_line = buf___3->b_ml.ml_line_ptr;
    hp = ml_find_line(buf___3, lnum, 19);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {

      }
    } else {
      dp = (DATA_BL *)hp->bh_data;
      idx = (int )(lnum - buf___3->b_ml.ml_locked_low);
      start___0 = (int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL)));
      old_line = (char_u *)dp + start___0;
      if (idx == 0) {
        old_len = (int )(dp->db_txt_end - (unsigned int )start___0);
      } else {
        old_len = (int )((dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))) - (unsigned int )start___0);
      }
      {
      tmp = strlen((char const   *)((char *)new_line));
      new_len = (colnr_t )(tmp + 1UL);
      extra = (int )(new_len - (colnr_t )old_len);
      }
      if ((int )dp->db_free >= extra) {
        count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 1L);
        if (extra != 0) {
          if (idx < count___2 - 1) {
            {
            memmove((void *)(((char *)dp + dp->db_txt_start) - extra), (void const   *)((char *)dp + dp->db_txt_start),
                    (size_t )((unsigned int )start___0 - dp->db_txt_start));
            i___0 = idx + 1;
            }
            {
            while (1) {
              while_continue: ;/* CIL Label */ ;
              if (! (i___0 < count___2)) {
                goto while_break;
              }
              dp->db_index[i___0] -= (unsigned int )extra;
              i___0 ++;
            }
            while_break: ;/* CIL Label */ ;
            }
          }
        }
        {
        dp->db_index[idx] -= (unsigned int )extra;
        dp->db_free -= (unsigned int )extra;
        dp->db_txt_start -= (unsigned int )extra;
        memmove((void *)((char *)(old_line - extra)), (void const   *)((char *)new_line),
                (size_t )new_len);
        buf___3->b_ml.ml_flags |= 12;
        ml_updatechunk(buf___3, lnum, extra, 3);
        }
      } else {
        {


        }
      }
    }
    {
    vim_free((void *)new_line);
    }
  }
  buf___3->b_ml.ml_line_lnum = (linenr_t )0;
  return;
}
}
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) 
{ 
  BHDR *hp ;
  DATA_BL *dp ;
  unsigned int tmp ;

  {
  {
  hp = mf_new(mfp, negative, page_count);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  dp = (DATA_BL *)hp->bh_data;
  dp->db_id = (short_u )((100 << 8) + 97);
  tmp = (unsigned int )page_count * mfp->mf_page_size;
  dp->db_txt_end = tmp;
  dp->db_txt_start = tmp;
  dp->db_free = (unsigned int )((unsigned long )dp->db_txt_start - (sizeof(DATA_BL ) - sizeof(unsigned int )));
  dp->db_line_count = (linenr_t )0;
  return (hp);
}
}
static BHDR *ml_new_ptr(MEMFILE *mfp ) 
{ 
  BHDR *hp ;
  PTR_BL *pp ;

  {
  {
  hp = mf_new(mfp, 0, 1);
  }
  if ((unsigned long )hp == (unsigned long )((void *)0)) {

  }
  pp = (PTR_BL *)hp->bh_data;
  pp->pb_id = (short_u )((112 << 8) + 116);
  pp->pb_count = (short_u )0;
  pp->pb_count_max = (short_u )(((unsigned long )mfp->mf_page_size - sizeof(PTR_BL )) / sizeof(PTR_EN ) + 1UL);
  return (hp);
}
}
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) 
{ 
  DATA_BL *dp ;
  PTR_BL *pp ;
  IPTR *ip ;
  BHDR *hp ;
  MEMFILE *mfp ;
  linenr_t t ;
  blocknr_t bnum ;
  blocknr_t bnum2 ;
  int dirty ;
  linenr_t low ;
  linenr_t high ;
  int top ;
  int page_count ;
  int idx ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  if (buf___3->b_ml.ml_locked) {
    if (action & 16) {
      if (buf___3->b_ml.ml_locked_low <= lnum) {
        if (buf___3->b_ml.ml_locked_high >= lnum) {
          if (action == 18) {
            (buf___3->b_ml.ml_locked_lineadd) ++;
            (buf___3->b_ml.ml_locked_high) ++;
          } else { //Added block
          if (action == 17) {
            (buf___3->b_ml.ml_locked_lineadd) --;
            (buf___3->b_ml.ml_locked_high) --;
          }
          }
          return (buf___3->b_ml.ml_locked);
        }
      }
    }
    {
    mf_put(mfp, buf___3->b_ml.ml_locked, buf___3->b_ml.ml_flags & 4, buf___3->b_ml.ml_flags & 8);
    buf___3->b_ml.ml_locked = (BHDR *)((void *)0);
    }
    if (buf___3->b_ml.ml_locked_lineadd) {
      {
      ml_lineadd(buf___3, buf___3->b_ml.ml_locked_lineadd);
      }
    }
  }
  if (action == 2) {
    return ((BHDR *)((void *)0));
  }
  bnum = (blocknr_t )1;
  page_count = 1;
  low = (linenr_t )1;
  high = buf___3->b_ml.ml_line_count;
  if (action == 19) {
    top = buf___3->b_ml.ml_stack_top - 1;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (top >= 0)) {
        goto while_break;
      }











    }
    while_break: ;/* CIL Label */ ;
    }
    if (top < 0) {
      buf___3->b_ml.ml_stack_top = 0;
    }
  } else {
    buf___3->b_ml.ml_stack_top = 0;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    {
    hp = mf_get(mfp, bnum, page_count);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {

    }
    if (action == 18) {
      high ++;
    } else { //Added block
    if (action == 17) {

    }
    }
    dp = (DATA_BL *)hp->bh_data;
    if ((int )dp->db_id == (100 << 8) + 97) {
      buf___3->b_ml.ml_locked = hp;
      buf___3->b_ml.ml_locked_low = low;
      buf___3->b_ml.ml_locked_high = high;
      buf___3->b_ml.ml_locked_lineadd = 0;
      buf___3->b_ml.ml_flags &= -13;
      return (hp);
    }
    pp = (PTR_BL *)dp;
    if ((int )pp->pb_id != (112 << 8) + 116) {
      {

      }

    }
    {
    top = ml_add_stack(buf___3);
    }
    if (top < 0) {

    }
    ip = buf___3->b_ml.ml_stack + top;
    ip->ip_bnum = bnum;
    ip->ip_low = low;
    ip->ip_high = high;
    ip->ip_index = -1;
    dirty = 0;
    idx = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! (idx < (int )pp->pb_count)) {

      }
      t = pp->pb_pointer[idx].pe_line_count;
      low += t;
      if (low > lnum) {
        ip->ip_index = idx;
        bnum = pp->pb_pointer[idx].pe_bnum;
        page_count = pp->pb_pointer[idx].pe_page_count;
        high = low - 1L;
        low -= t;
        if (bnum < 0L) {
          {

          }





        }
        goto while_break___1;
      }

    }
    while_break___1: ;/* CIL Label */ ;
    }
    if (idx >= (int )pp->pb_count) {










    }
    if (action == 17) {


    } else { //Added block
    if (action == 18) {
      (pp->pb_pointer[idx].pe_line_count) ++;
      dirty = 1;
    }
    }
    {
    mf_put(mfp, hp, dirty, 0);
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  error_block: ;
  {

  }
  error_noblock: ;













}
}
static int ml_add_stack(BUF *buf___3 ) 
{ 
  int top ;
  IPTR *newstack ;
  char_u *tmp ;

  {
  top = buf___3->b_ml.ml_stack_top;
  if (top == buf___3->b_ml.ml_stack_size) {
    {
    tmp = alloc((unsigned int )sizeof(IPTR ) * (unsigned int )(buf___3->b_ml.ml_stack_size + 5));
    newstack = (IPTR *)tmp;
    }
    if ((unsigned long )newstack == (unsigned long )((void *)0)) {

    }
    {
    memmove((void *)((char *)newstack), (void const   *)((char *)buf___3->b_ml.ml_stack),
            (size_t )top * sizeof(IPTR ));
    vim_free((void *)buf___3->b_ml.ml_stack);
    buf___3->b_ml.ml_stack = newstack;
    buf___3->b_ml.ml_stack_size += 5;
    }
  }
  (buf___3->b_ml.ml_stack_top) ++;
  return (top);
}
}
static void ml_lineadd(BUF *buf___3 , int count___2 ) 
{ 
  int idx ;
  IPTR *ip ;
  PTR_BL *pp ;
  MEMFILE *mfp ;
  BHDR *hp ;

  {
  mfp = buf___3->b_ml.ml_mfp;
  idx = buf___3->b_ml.ml_stack_top - 1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (idx >= 0)) {
      goto while_break;
    }
    {
    ip = buf___3->b_ml.ml_stack + idx;
    hp = mf_get(mfp, ip->ip_bnum, 1);
    }
    if ((unsigned long )hp == (unsigned long )((void *)0)) {

    }
    pp = (PTR_BL *)hp->bh_data;
    if ((int )pp->pb_id != (112 << 8) + 116) {
      {


      }

    }
    {
    pp->pb_pointer[ip->ip_index].pe_line_count += (linenr_t )count___2;
    ip->ip_high += (linenr_t )count___2;
    mf_put(mfp, hp, 1, 0);
    idx --;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) 
{ 
  char_u *r ;
  char_u *s ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = strlen((char const   *)((char *)dir_name));
  s = dir_name + tmp;
  tmp___0 = vim_ispathsep((int )*(s + -1));
  }
  if (tmp___0) {













  }
  if ((int )*(dir_name + 0) == 46) {
    if ((int )*(dir_name + 1) == 0) {
      tmp___1 = 1;
    } else {

    }
  } else {

  }
  if (buf___3->b_p_sn) {

  } else { //Added block
  if (buf___3->b_shortname) {

  } else {
    tmp___2 = 0;
  }
  }
  {
  r = buf_modname(tmp___2, buf___3->b_fname, (char_u *)".swp", tmp___1);
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {

  }
  {
  s = get_file_in_dir(r, dir_name);
  vim_free((void *)r);
  }
  return (s);
}
}
char_u *get_file_in_dir(char_u *fname , char_u *dname ) 
{ 
  char_u *t ;
  char_u *tail ;
  char_u *retval ;
  int save_char ;
  int tmp ;

  {
  {
  tail = gettail(fname);
  }
  if ((int )*(dname + 0) == 46) {
    if ((int )*(dname + 1) == 0) {
      {
      retval = vim_strsave(fname);
      }
    } else {

    }
  } else { //Added block
  _L: ;



































  }
  return (retval);
}
}
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) 
{ 
  char_u *fname ;
  int n ;
  time_t x___0 ;
  char_u *dir_name ;
  int r ;
  FILE *dummyfd ;
  struct stat st ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char_u *tail ;
  char_u *fname2 ;
  struct stat s1 ;
  struct stat s2 ;
  int f1 ;
  int f2 ;
  int created1 ;
  int created2 ;
  int same ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  size_t tmp___8 ;
  char_u *tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int fd ;
  struct block0 b0 ;
  int differ ;
  long tmp___13 ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  struct stat st___0 ;
  char *tmp___16 ;
  int tmp___17 ;
  char_u *name___1 ;
  size_t tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;

  {
  dummyfd = (FILE *)((void *)0);
  if (! buf___3->b_p_sn) {
    if (! buf___3->b_shortname) {
      if (buf___3->b_fname) {
        {
        tmp___0 = mch_getperm(buf___3->b_fname);
        }
        if (tmp___0 < 0L) {
          {
          tmp = lstat((char const   * __restrict  )((char *)buf___3->b_fname), (struct stat * __restrict  )(& st));
          }
          if (tmp == -1) {
            {
            dummyfd = fopen((char const   * __restrict  )((char *)buf___3->b_fname),
                            (char const   * __restrict  )"w");
            }
          } else { //Added block






          }
        }
      }
    }
  }
  {
  tmp___1 = strlen((char const   *)((char *)*dirp));
  dir_name = alloc((unsigned int )tmp___1 + 1U);
  }
  if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
    {
    copy_option_part(dirp, dir_name, 31000, (char *)",");
    }
  }
  if ((unsigned long )dir_name == (unsigned long )((void *)0)) {

  } else {
    {
    fname = makeswapname(buf___3, dir_name);
    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (! ((unsigned long )fname == (unsigned long )((void *)0)))) {

    }
    {
    tmp___2 = strlen((char const   *)((char *)fname));
    n = (int )tmp___2;
    }
    if (n == 0) {
      {


      }

    }
    if ((int )*(fname + (n - 2)) == 119) {
      if ((int )*(fname + (n - 1)) == 112) {
        if (! buf___3->b_p_sn) {
          if (! buf___3->b_shortname) {
            {
            created1 = 0;
            created2 = 0;
            same = 0;
            tail = gettail(buf___3->b_fname);
            tmp___7 = vim_strchr(tail, '.');
            }
            if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
              goto _L;
            } else {
              {
              tmp___8 = strlen((char const   *)((char *)tail));
              }
              if (tmp___8 > 8UL) {
                goto _L;
              } else {
                {
                tmp___9 = gettail(fname);
                }
                if ((int )*tmp___9 == 46) {
                  _L: ;
                  {
                  fname2 = alloc((unsigned int )(n + 2));
                  }
                  if ((unsigned long )fname2 != (unsigned long )((void *)0)) {
                    {
                    strcpy((char * __restrict  )((char *)fname2), (char const   * __restrict  )((char *)fname));
                    tmp___4 = vim_strchr(tail, '.');
                    }
                    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
                      *(fname2 + (n - 1)) = (char_u )'x';
                    } else {
                      {
                      tmp___3 = gettail(fname);
                      }
                      if ((int )*tmp___3 == 46) {
                        *(fname2 + n) = (char_u )'x';
                        *(fname2 + (n + 1)) = (char_u )'\000';
                      } else {

                      }
                    }
                    {
                    f1 = open((char const   *)((char *)fname), 0, 0);
                    }
                    if (f1 < 0) {
                      {
                      f1 = open((char const   *)((char *)fname), 194, (mode_t )384);
                      created1 = 1;
                      }
                    }
                    if (f1 >= 0) {
                      {
                      f2 = open((char const   *)((char *)fname2), 0, 0);
                      }
                      if (f2 < 0) {
                        {
                        f2 = open((char const   *)((char *)fname2), 194, (mode_t )384);
                        created2 = 1;
                        }
                      }
                      if (f2 >= 0) {
                        {
                        tmp___5 = fstat(f1, & s1);
                        }
                        if (tmp___5 != -1) {
                          {
                          tmp___6 = fstat(f2, & s2);
                          }
                          if (tmp___6 != -1) {
                            if (s1.st_dev == s2.st_dev) {
                              if (s1.st_ino == s2.st_ino) {

                              }
                            }
                          }
                        }
                        {
                        close(f2);
                        }
                        if (created2) {
                          {
                          unlink((char const   *)((char *)fname2));
                          }
                        }
                      }
                      {
                      close(f1);
                      }
                      if (created1) {
                        {
                        unlink((char const   *)((char *)fname));
                        }
                      }
                    }
                    {
                    vim_free((void *)fname2);
                    }
                    if (same) {
                      {



                      }

                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
    tmp___10 = mch_getperm(fname);
    }
    if (tmp___10 < 0L) {
      goto while_break;
    }



























































































































































































    __Cont: ;;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)dir_name);
  }
  if (dummyfd) {
    {
    fclose(dummyfd);
    unlink((char const   *)((char *)buf___3->b_fname));
    }
  }
  return (fname);
}
}
static int b0_magic_wrong(ZERO_BL *b0p ) 
{






















}
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) 
{























































}
static void long_to_char(long n , char_u *s ) 
{ 


  {
  *(s + 0) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 1) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 2) = (char_u )(n & 255L);
  n = (long )((unsigned int )n >> 8);
  *(s + 3) = (char_u )(n & 255L);
  return;
}
}
static long char_to_long(char_u *s ) 
{












}
void ml_setdirty(BUF *buf___3 , int flag ) 
{ 
  BHDR *hp ;
  ZERO_BL *b0p ;

  {
  if (! buf___3->b_ml.ml_mfp) {
    return;
  }
  hp = (buf___3->b_ml.ml_mfp)->mf_used_last;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {

    }
    if (hp->bh_bnum == 0L) {
      b0p = (ZERO_BL *)hp->bh_data;
      if (flag) {
        b0p->b0_fname[899] = (char_u )85;
      } else {
        b0p->b0_fname[899] = (char_u )0;
      }
      {
      hp->bh_flags = (char )((int )hp->bh_flags | 1);
      mf_sync(buf___3->b_ml.ml_mfp, 8);
      }
      goto while_break;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static BUF *ml_upd_lastbuf  =    (BUF *)((void *)0);
static linenr_t ml_upd_lastline  ;
static linenr_t ml_upd_lastcurline  ;
static int ml_upd_lastcurix  ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) 
{ 
  linenr_t curline ;
  int curix ;
  long size ;
  ML_CHUNKSIZE *curchnk ;
  int rest ;
  BHDR *hp ;
  DATA_BL *dp ;
  char_u *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int count___2 ;
  int idx ;
  int text_end ;
  int linecnt ;

  {
  curline = ml_upd_lastcurline;
  curix = ml_upd_lastcurix;
  if (buf___3->b_ml.ml_usedchunks == -1) {

  } else { //Added block
  if (! len___0) {

  }
  }
  if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {
    {
    tmp = alloc((unsigned int )sizeof(ML_CHUNKSIZE ) * 100U);
    buf___3->b_ml.ml_chunksize = (ML_CHUNKSIZE *)tmp;
    }
    if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {


    }
    buf___3->b_ml.ml_numchunks = 100;
    buf___3->b_ml.ml_usedchunks = 1;
    (buf___3->b_ml.ml_chunksize + 0)->mlcs_numlines = 1;
    (buf___3->b_ml.ml_chunksize + 0)->mlcs_totalsize = 1;
  }
  if (updtype == 3) {
    if (buf___3->b_ml.ml_line_count == 1L) {
      {




      }

    }
  }
  if ((unsigned long )buf___3 != (unsigned long )ml_upd_lastbuf) {
    goto _L;
  } else { //Added block
  if (line != ml_upd_lastline + 1L) {
    goto _L;
  } else { //Added block
  if (updtype != 1) {
    _L: ;
    curline = (linenr_t )1;
    curix = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (curix < buf___3->b_ml.ml_usedchunks - 1) {



      } else {
        goto while_break;
      }


    }
    while_break: ;/* CIL Label */ ;
    }
  } else { //Added block
  if (line >= curline + (linenr_t )(buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines) {




  }
  }
  }
  }
  curchnk = buf___3->b_ml.ml_chunksize + curix;
  if (updtype == 2) {
    len___0 *= -1;
  }
  curchnk->mlcs_totalsize += len___0;
  if (updtype == 1) {
    (curchnk->mlcs_numlines) ++;
    if (buf___3->b_ml.ml_usedchunks + 1 >= buf___3->b_ml.ml_numchunks) {
      {



      }




    }
    if ((buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines >= 800) {
      {




      }
      {



































      while_break___0: ;/* CIL Label */ ;
      }







    } else { //Added block
    if ((buf___3->b_ml.ml_chunksize + curix)->mlcs_numlines >= 400) {




























    }
    }
  } else { //Added block
  if (updtype == 2) {
    (curchnk->mlcs_numlines) --;
    ml_upd_lastbuf = (BUF *)((void *)0);
    if (curix < buf___3->b_ml.ml_usedchunks - 1) {






    } else { //Added block
    _L___1: ;
    if (curix == 0) {
      if (curchnk->mlcs_numlines <= 0) {
        {



        }

      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if (curix == 0) {
      return;
    } else { //Added block





    }
    }
    }










  }
  }
  ml_upd_lastbuf = buf___3;
  ml_upd_lastline = line;
  ml_upd_lastcurline = curline;
  ml_upd_lastcurix = curix;
  return;
}
}
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) 
{ 
  linenr_t curline ;
  int curix ;
  long size ;
  BHDR *hp ;
  DATA_BL *dp ;
  int count___2 ;
  int idx ;
  int start_idx ;
  int text_end ;
  long offset ;
  int len___0 ;
  int ffdos ;
  int tmp ;

  {
  {
  tmp = get_fileformat(buf___3);
  ffdos = tmp == 1;
  }
  if (buf___3->b_ml.ml_usedchunks == -1) {

  } else { //Added block
  if ((unsigned long )buf___3->b_ml.ml_chunksize == (unsigned long )((void *)0)) {

  } else { //Added block
  if (line < 0L) {

  }
  }
  }
  if ((unsigned long )offp == (unsigned long )((void *)0)) {

  } else {
    offset = *offp;
  }
  if (line == 0L) {
    if (offset <= 0L) {
      return (1L);
    }
  }
  curline = (linenr_t )1;
  size = 0L;
  curix = (int )size;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (curix < buf___3->b_ml.ml_usedchunks - 1) {
      if (line) {



      } else { //Added block
      _L: ;







      }
    } else {
      goto while_break;
    }








  }
  while_break: ;/* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (line) {



    } else { //Added block
    _L___0: ;
    if (offset) {
      if (! (size < offset)) {

      }
    } else {

    }
    }
    if (curline > buf___3->b_ml.ml_line_count) {

    } else {
      {
      hp = ml_find_line(buf___3, curline, 19);
      }
      if ((unsigned long )hp == (unsigned long )((void *)0)) {

      }
    }
    dp = (DATA_BL *)hp->bh_data;
    count___2 = (int )((buf___3->b_ml.ml_locked_high - buf___3->b_ml.ml_locked_low) + 1L);
    idx = (int )(curline - buf___3->b_ml.ml_locked_low);
    start_idx = idx;
    if (idx == 0) {
      text_end = (int )dp->db_txt_end;
    } else {

    }
    if (line) {





    } else {
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (! (offset >= ((size + (long )text_end) - (long )((int )(dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))))) + (long )ffdos)) {
          goto while_break___1;
        }
        if (ffdos) {

        }
        if (idx == count___2 - 1) {

        }
        idx ++;
      }
      while_break___1: ;/* CIL Label */ ;
      }
    }
    len___0 = (int )((unsigned int )text_end - (dp->db_index[idx] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
    size += (long )len___0;
    if ((unsigned long )offp != (unsigned long )((void *)0)) {
      if (size >= offset) {
        if (size + (long )ffdos == offset) {

        } else { //Added block
        if (idx == start_idx) {
          *offp = (offset - size) + (long )len___0;
        } else {
          *offp = ((offset - size) + (long )len___0) - (long )((unsigned int )text_end - (dp->db_index[idx - 1] & ~ (1U << (sizeof(unsigned int ) * 8UL - 1UL))));
        }
        }
        return ((curline + (linenr_t )idx) - (linenr_t )start_idx);
      }
    }

  }
  while_break___0: ;/* CIL Label */ ;
  }




}
}
void goto_byte(long cnt ) 
{ 
  long boff ;
  linenr_t lnum ;

  {
  {
  boff = cnt;
  ml_flush_line(curbuf);
  setpcmark();
  }
  if (boff) {
    boff --;
  }
  {
  lnum = ml_find_line_or_offset(curbuf, (linenr_t )0, & boff);
  }
  if (lnum < 1L) {
    {



    }
  } else {
    curwin->w_cursor.lnum = lnum;
    curwin->w_cursor.col = (colnr_t )boff;
    curwin->w_set_curswant = 1;
  }
  {
  adjust_cursor();
  }
  return;
}
}
#pragma merger("0","/tmp/cil-VelGDUyk.i","-O0")
char_u *menu_name_skip(char_u *name___1 ) ;
int get_menu_index(VimMenu *menu___1 , int state ) ;
int menubar_menu(char_u *name___1 ) ;
int popup_menu(char_u *name___1 ) ;
int toolbar_menu(char_u *name___1 ) ;
int is_menu_separator(char_u *name___1 ) ;
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) ;
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) ;
static void free_menu(VimMenu **menup ) ;
static void free_menu_string(VimMenu *menu___1 , int idx ) ;
static int show_menus(char_u *path_name , int modes ) ;
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) ;
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) ;
static int menu_namecmp(char_u *name___1 , char_u *mname ) ;
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) ;
static char_u *popup_mode_name(char_u *name___1 , int idx ) ;
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) ;
static char_u menu_mode_chars[6]  = {      (char_u )'n',      (char_u )'v',      (char_u )'o',      (char_u )'i', 
        (char_u )'c',      (char_u )'t'};
void do_menu(EXARG *eap ) 
{




































































































































































































































































}
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) 
{



















































































































































































































































}
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) 
{


















































































































}
static void free_menu(VimMenu **menup ) 
{






























}
static void free_menu_string(VimMenu *menu___1 , int idx ) 
{



























}
static int show_menus(char_u *path_name , int modes ) 
{
















































































}
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) 
{






































































































































}
static VimMenu *expand_menu  =    (VimMenu *)((void *)0);
static int expand_modes  =    0;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) 
{





















































































































































}
static VimMenu *menu  =    (VimMenu *)((void *)0);
static int get_dname  =    0;
char_u *get_menu_name(int idx ) 
{























































}
static VimMenu *menu___0  =    (VimMenu *)((void *)0);
static char_u tbuffer[256]  ;
char_u *get_menu_names(int idx ) 
{























































}
char_u *menu_name_skip(char_u *name___1 ) 
{









































}
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) 
{






















}
static int menu_namecmp(char_u *name___1 , char_u *mname ) 
{










































}
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) 
{





































































}
static char_u *popup_mode_name(char_u *name___1 , int idx ) 
{



















}
int get_menu_index(VimMenu *menu___1 , int state ) 
{































}
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) 
{






































}
int menubar_menu(char_u *name___1 ) 
{


























}
int popup_menu(char_u *name___1 ) 
{









}
int toolbar_menu(char_u *name___1 ) 
{









}
void execute_menu(char_u *path_name ) 
{






































































































}
int is_menu_separator(char_u *name___1 ) 
{


















}
#pragma merger("0","/tmp/cil-UVU21_qu.i","-O0")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
char_u *msg_strtrunc(char_u *s ) ;
void msg_home_replace_hl(char_u *fname ) ;
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) ;
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) ;
void msg_moremsg(int full ) ;
void repeat_message(void) ;
void msg_clr_cmdline(void) ;
void give_warning(char_u *message , int hl ) ;
void display_confirm_msg(void) ;
void screen_puts(char_u *text , int row , int col , int attr ) ;
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) ;
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) ;
int screen_valid(int clear ) ;
int jump_to_mouse(int flags___0 , int *inclusive ) ;
void out_str(char_u *s ) ;
static void reset_last_sourcing(void) ;
static void add_msg_hist(char_u *s , int len___0 , int attr ) ;
static void hit_return_msg(void) ;
static void msg_home_replace_attr(char_u *fname , int attr ) ;
static int msg_use_printf(void) ;
static void msg_screen_putchar(int c , int attr ) ;
static int msg_check_screen(void) ;
static void redir_write(char_u *s ) ;
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) ;
static int msg_noquit_more  =    0;
static struct msg_hist *first_msg_hist  =    (struct msg_hist *)((void *)0);
static struct msg_hist *last_msg_hist  =    (struct msg_hist *)((void *)0);
static int msg_hist_len  =    0;
static int msg_hist_off  =    0;
int msg(char_u *s ) 
{ 
  int tmp ;

  {
  {
  set_vim_var_string(4, s);
  tmp = msg_attr(s, 0);
  }
  return (tmp);
}
}
static int entered___0  =    0;
int msg_attr(char_u *s , int attr ) 
{ 
  int retval ;
  char_u *buf___3 ;
  int tmp ;

  {
  buf___3 = (char_u *)((void *)0);
  if (entered___0 >= 3) {

  }
  entered___0 ++;
  if ((unsigned long )s != (unsigned long )keep_msg) {
    {
    add_msg_hist(s, -1, attr);
    }
  } else { //Added block
  if ((int )*s != 60) {
    if ((unsigned long )last_msg_hist != (unsigned long )((void *)0)) {
      if ((unsigned long )last_msg_hist->msg != (unsigned long )((void *)0)) {
        {
        tmp = strcmp((char const   *)((char *)s), (char const   *)((char *)last_msg_hist->msg));
        }
        if (tmp) {
          {
          add_msg_hist(s, -1, attr);
          }
        }
      }
    }
  }
  }
  {
  buf___3 = msg_strtrunc(s);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {

  }
  {
  msg_start();
  msg_outtrans_attr(s, attr);
  msg_clr_eos();
  retval = msg_end();
  vim_free((void *)buf___3);
  entered___0 --;
  }
  return (retval);
}
}
char_u *msg_strtrunc(char_u *s ) 
{ 
  char_u *buf___3 ;
  int len___0 ;
  int room ;
  int half ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  buf___3 = (char_u *)((void *)0);
  if (! msg_scroll) {
    if (! need_wait_return) {
      {
      tmp___3 = shortmess('T');
      }
      if (tmp___3) {




























































      }
    }
  }
  return (buf___3);
}
}
int smsg(char_u *s  , ...) 
{ 
  va_list arglist ;
  int tmp ;

  {
  {
  __builtin_va_start(arglist, s);
  vsprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
           arglist);
  __builtin_va_end(arglist);
  tmp = msg(IObuff);
  }
  return (tmp);
}
}
int smsg_attr(int attr , char_u *s  , ...) 
{













}
static int last_sourcing_lnum  =    0;
static char_u *last_sourcing_name  =    (char_u *)((void *)0);
static void reset_last_sourcing(void) 
{ 


  {
  {
  vim_free((void *)last_sourcing_name);
  last_sourcing_name = (char_u *)((void *)0);
  last_sourcing_lnum = 0;
  }
  return;
}
}
int emsg(char_u *s ) 
{ 
  char_u *Buf ;
  int attr ;
  int other_sourcing_name ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (emsg_off) {

  }
  if (global_busy) {

  }
  if (p_eb) {
    {

    }
  } else {
    {
    flush_buffers(0);
    }
  }
  {
  did_emsg = 1;
  set_vim_var_string(2, s);
  emsg_on_display = 1;
  msg_scroll ++;
  attr = highlight_attr[3];
  }
  if (msg_scrolled) {
    need_wait_return = 1;
  }
  if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {







  } else {
    other_sourcing_name = 0;
  }
  if ((unsigned long )sourcing_name != (unsigned long )((void *)0)) {

































  }
  if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
    goto _L___0;
  } else { //Added block
  if (other_sourcing_name) {
    _L___0: ;
    {
    vim_free((void *)last_sourcing_name);
    }
    if ((unsigned long )sourcing_name == (unsigned long )((void *)0)) {
      last_sourcing_name = (char_u *)((void *)0);
    } else {
      {

      }
    }
  }
  }
  {
  msg_nowait = 0;
  tmp___0 = msg_attr(s, attr);
  }
  return (tmp___0);
}
}
int emsg2(char_u *s , char_u *a1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (emsg_off) {

  }
  if ((unsigned long )a1 == (unsigned long )((void *)0)) {

  }
  {
  tmp = strlen((char const   *)((char *)s));
  tmp___0 = strlen((char const   *)((char *)a1));
  }
  if (tmp + tmp___0 >= 1025UL) {

  }
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
          (char *)a1);
  tmp___1 = emsg(IObuff);
  }
  return (tmp___1);
}
}
int emsgn(char_u *s , long n ) 
{ 
  int tmp ;

  {
  if (emsg_off) {

  }
  {
  sprintf((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)s),
          n);
  tmp = emsg(IObuff);
  }
  return (tmp);
}
}
char_u *msg_trunc_attr(char_u *s , int force , int attr ) 
{ 
  int n ;

  {
  {
  add_msg_hist(s, -1, attr);
  s = msg_may_trunc(force, s);
  msg_hist_off = 1;
  n = msg_attr(s, attr);
  msg_hist_off = 0;
  }
  if (n) {
    return (s);
  }
  return ((char_u *)((void *)0));
}
}
char_u *msg_may_trunc(int force , char_u *s ) 
{ 
  int n ;
  int tmp ;
  size_t tmp___0 ;

  {
  if (force) {

  } else {
    {
    tmp = shortmess('t');
    }
    if (tmp) {











    }
  }
  return (s);
}
}
static void add_msg_hist(char_u *s , int len___0 , int attr ) 
{ 
  struct msg_hist *p___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  if (msg_hist_off) {
    return;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (msg_hist_len > 20)) {
      goto while_break;
    }
    {





    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  tmp = alloc((unsigned int )((int )sizeof(struct msg_hist )));
  p___0 = (struct msg_hist *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if (len___0 < 0) {
      {
      tmp___0 = strlen((char const   *)((char *)s));
      len___0 = (int )tmp___0;
      }
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (len___0 > 0) {
        if (! ((int )*s == 10)) {
          goto while_break___0;
        }
      } else {

      }


    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (len___0 > 0) {
        if (! ((int )*(s + (len___0 - 1)) == 10)) {
          goto while_break___1;
        }
      } else {

      }

    }
    while_break___1: ;/* CIL Label */ ;
    }
    {
    p___0->msg = vim_strnsave(s, len___0);
    p___0->next = (struct msg_hist *)((void *)0);
    p___0->attr = attr;
    }
    if ((unsigned long )last_msg_hist != (unsigned long )((void *)0)) {
      last_msg_hist->next = p___0;
    }
    last_msg_hist = p___0;
    if ((unsigned long )first_msg_hist == (unsigned long )((void *)0)) {
      first_msg_hist = last_msg_hist;
    }
    msg_hist_len ++;
  }
  return;
}
}
void ex_messages(void) 
{























}
static void msg_end_prompt(void) ;
static void msg_end_prompt(void) 
{












}
void wait_return(int redraw ) 
{ 
  int c ;
  int oldState ;
  int tmpState ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (redraw == 1) {
    must_redraw = 50;
  }
  if (vgetc_busy) {

  }
  if (no_wait_return) {
    need_wait_return = 1;
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
    return;
  }
  redir_off = 1;
  oldState = State;
  if (quit_more) {



  } else { //Added block
  if (exmode_active) {
    {



    }
  } else {
    {
    State = 1537;
    setmouse();
    hit_return_msg();
    }
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      {
      c = safe_vgetc();
      }
      if (! global_busy) {
        got_int = 0;
      }
      if (! (c == 3)) {
        if (! (c == 253 + (43 << 8))) {
          if (! (c == 253 + (44 << 8))) {
            if (! (c == 253 + (46 << 8))) {
              if (! (c == 253 + (47 << 8))) {
                if (! (c == 253 + (49 << 8))) {
                  if (! (c == 253 + (50 << 8))) {
                    if (! (c == 253 + (67 << 8))) {
                      if (! (c == 253 + (68 << 8))) {
                        if (! (c == 253 + (51 << 8))) {
                          {
                          tmp = mouse_has('r');
                          }
                          if (tmp) {

                          } else { //Added block
                          if (! (c == 253 + (42 << 8))) {
                            if (! (c == 253 + (45 << 8))) {
                              if (! (c == 253 + (48 << 8))) {
                                goto while_break;
                              }
                            }
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while_break: ;/* CIL Label */ ;
    }
    {
    ui_breakcheck();
    }
    if (c == 253 + (42 << 8)) {
      {

      }
    } else { //Added block
    if (c == 253 + (45 << 8)) {
      {

      }
    } else { //Added block
    if (c == 253 + (48 << 8)) {
      {

      }
    } else {
      {
      tmp___0 = vim_strchr((char_u *)"\r\n ", c);
      }
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
        stuffcharReadbuff(c);
        do_redraw = 1;
        }
      }
    }
    }
    }
  }
  }
  redir_off = 0;
  if (c == 58) {
    goto _L;
  } else { //Added block
  if (c == 63) {

  } else { //Added block
  if (c == 47) {
    _L: ;
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
    skip_redraw = 1;
    do_redraw = 0;
  }
  }
  }
  {
  tmpState = State;
  State = oldState;
  setmouse();
  msg_check();
  tmp___1 = swapping_screen();
  }
  if (tmp___1) {
    if (! termcap_active) {
      newline_on_exit = 1;
    }
  }
  {
  need_wait_return = 0;
  emsg_on_display = 0;
  msg_didany = 0;
  lines_left = -1;
  reset_last_sourcing();
  }
  if ((unsigned long )keep_msg != (unsigned long )((void *)0)) {
    {

    }



  }
  if (tmpState == 2048) {
    {


    }
  } else { //Added block
  if (! skip_redraw) {
    if (redraw == 1) {
      {
      starttermcap();
      update_screen(10);
      }
    } else { //Added block
    if (msg_scrolled) {
      if (redraw != -1) {
        {
        starttermcap();
        update_screen(10);
        }
      }
    }
    }
  }
  }
  return;
}
}
static void hit_return_msg(void) 
{ 
  int tmp ;

  {
  if (msg_didout) {
    {
    msg_putchar('\n');
    }
  }
  if (got_int) {
    {

    }
  }
  {
  msg_puts_attr((char_u *)"Press RETURN or enter command to continue", highlight_attr[10]);
  tmp = msg_use_printf();
  }
  if (! tmp) {
    {
    msg_clr_eos();
    }
  }
  return;
}
}
void msg_start(void) 
{ 
  int did_return ;

  {
  did_return = 0;
  keep_msg = (char_u *)((void *)0);
  if (! msg_scroll) {
    if (full_screen) {
      msg_row = cmdline_row;
      msg_col = 0;
    } else {

    }
  } else { //Added block
  _L: ;
  if (msg_didout) {
    {
    msg_putchar('\n');
    did_return = 1;
    }
    if (! exmode_active) {
      cmdline_row = msg_row;
    }
  }
  }
  if (! msg_didany) {
    {
    msg_starthere();
    }
  }
  {
  msg_didout = 0;
  cursor_off();
  }
  if (! did_return) {
    {
    redir_write((char_u *)"\n");
    }
  }
  return;
}
}
void msg_starthere(void) 
{ 


  {
  lines_left = cmdline_row;
  msg_didany = 0;
  return;
}
}
void msg_putchar(int c ) 
{ 


  {
  {
  msg_putchar_attr(c, 0);
  }
  return;
}
}
void msg_putchar_attr(int c , int attr ) 
{ 
  char_u buf___3[4] ;
  int tmp ;

  {
  if (c >= 512) {





















  } else {
    buf___3[0] = (char_u )c;
    buf___3[1] = (char_u )'\000';
  }
  {
  msg_puts_attr(buf___3, attr);
  }
  return;
}
}
void msg_outnum(long n ) 
{ 
  char_u buf___3[20] ;

  {
  {
  sprintf((char * __restrict  )((char *)(buf___3)), (char const   * __restrict  )"%ld",
          n);
  msg_puts(buf___3);
  }
  return;
}
}
void msg_home_replace(char_u *fname ) 
{








}
void msg_home_replace_hl(char_u *fname ) 
{








}
static void msg_home_replace_attr(char_u *fname , int attr ) 
{
















}
int msg_outtrans(char_u *str___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = msg_outtrans_attr(str___1, 0);
  }
  return (tmp);
}
}
int msg_outtrans_attr(char_u *str___1 , int attr ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)str___1));
  tmp___0 = msg_outtrans_len_attr(str___1, (int )tmp, attr);
  }
  return (tmp___0);
}
}
int msg_outtrans_len(char_u *str___1 , int len___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = msg_outtrans_len_attr(str___1, len___0, 0);
  }
  return (tmp);
}
}
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) 
{ 
  int retval ;
  char_u *tmp ;
  int tmp___0 ;

  {
  retval = 0;
  if (attr & 4096) {
    {


    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    len___0 --;
    if (! (len___0 >= 0)) {
      goto while_break;
    }
    {
    tmp = transchar((int )*str___1);
    msg_puts_attr(tmp, attr);
    tmp___0 = charsize((int )*str___1);
    retval += tmp___0;
    str___1 ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (retval);
}
}
static char_u *str  =    (char_u *)"eeffoc";
static char_u *rs  =    (char_u *)"Plon#dqg#vxjduB";
void msg_make(char_u *arg ) 
{
















































}
int msg_outtrans_special(char_u *str___1 , int from ) 
{ 
  int retval ;
  char_u *string___0 ;
  int attr ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  retval = 0;
  attr = highlight_attr[0];
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*str___1 != 0)) {
      goto while_break;
    }
    {
    string___0 = str2special(& str___1, from);
    tmp = strlen((char const   *)((char *)string___0));
    len___0 = (int )tmp;
    }
    if (len___0 > 1) {
      tmp___0 = attr;
    } else {
      tmp___0 = 0;
    }
    {
    msg_puts_attr(string___0, tmp___0);
    retval += len___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (retval);
}
}
static char_u buf___0[2]  ;
char_u *str2special(char_u **sp , int from ) 
{ 
  int c ;
  char_u *str___1 ;
  int modifiers ;
  int special ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  str___1 = *sp;
  modifiers = 0;
  special = 0;
  c = (int )*str___1;
  if (c == 128) {
    if ((int )*(str___1 + 1) != 0) {
      if ((int )*(str___1 + 2) != 0) {
        if ((int )*(str___1 + 1) == 252) {



        }
        if (c == 128) {
          if ((int )*(str___1 + 1) != 0) {
            if ((int )*(str___1 + 2) != 0) {
              if ((int )*(str___1 + 1) == 254) {

              } else {
                if ((int )*(str___1 + 1) == 255) {

                } else {
                  tmp = (int )*(str___1 + 1) + ((int )*(str___1 + 2) << 8);
                }
                c = tmp;
              }
              str___1 += 2;
              if (c == 255 + (88 << 8)) {

              }
            }
          }
        }
        if (c >= 512) {
          special = 1;
        } else { //Added block



        }
      }
    }
  }
  *sp = str___1 + 1;
  if (special) {
    {
    tmp___0 = get_special_key_name(c, modifiers);
    }
    return (tmp___0);
  } else {
    {
    tmp___1 = charsize(c);
    }
    if (tmp___1 > 1) {
      {

      }

    } else { //Added block
    if (from) {
      if (c == 32) {
        {

        }

      }
    }
    }
  }
  buf___0[0] = (char_u )c;
  buf___0[1] = (char_u )'\000';
  return (buf___0);
}
}
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) 
{ 
  char_u *s ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  *buf___3 = (char_u )'\000';
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *sp) {
      goto while_break;
    }
    {



    }





  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
void msg_prt_line(char_u *s ) 
{ 
  int c ;
  int col ;
  int n_extra ;
  int c_extra ;
  char_u *p_extra ;
  int n ;
  int attr ;
  char_u *trail ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;

  {
  col = 0;
  n_extra = 0;
  c_extra = 0;
  p_extra = (char_u *)((void *)0);
  attr = 0;
  trail = (char_u *)((void *)0);
  if (curwin->w_p_list) {
    if (lcs_trail) {
      {


      }
      {













      while_break: ;/* CIL Label */ ;
      }
    }
  }
  if ((int )*s == 0) {
    if (! curwin->w_p_list) {
      {
      msg_putchar(' ');
      }
    }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (n_extra) {
      n_extra --;
      if (c_extra) {

      } else {
        tmp___0 = p_extra;
        p_extra ++;
        c = (int )*tmp___0;
      }
    } else {
      attr = 0;
      tmp___1 = s;
      s ++;
      c = (int )*tmp___1;
      if (c == 9) {
        if (! curwin->w_p_list) {

        } else { //Added block














        }
      } else { //Added block
      _L___2: ;
      if (c == 0) {
        if (curwin->w_p_list) {
          if (lcs_eol) {
            p_extra = (char_u *)"";
            c_extra = '\000';
            n_extra = 1;
            c = lcs_eol;
            attr = highlight_attr[1];
            s --;
          } else {

          }
        } else {
          goto _L___1;
        }
      } else { //Added block
      _L___1: ;
      if (c != 0) {
        {
        n = charsize(c);
        }
        if (n > 1) {
          {






          }
        } else {
          goto _L;
        }
      } else { //Added block
      _L: ;
      if (c == 32) {
        if ((unsigned long )trail != (unsigned long )((void *)0)) {




        }
      }
      }
      }
      }
    }
    if (c == 0) {
      goto while_break___0;
    }
    {
    msg_putchar_attr(c, attr);
    col ++;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  msg_clr_eos();
  }
  return;
}
}
void msg_puts(char_u *s ) 
{ 


  {
  {
  msg_puts_attr(s, 0);
  }
  return;
}
}
void msg_puts_title(char_u *s ) 
{ 


  {
  {
  msg_puts_attr(s, highlight_attr[13]);
  }
  return;
}
}
void msg_puts_long_attr(char_u *longstr , int attr ) 
{









}
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) 
{




















}
void msg_puts_attr(char_u *s , int attr ) 
{ 
  int oldState ;
  char_u *p___0 ;
  char_u buf___3[4] ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  redir_write(s);
  }
  if (attr & 4096) {
    {


    }
  }
  if (msg_scrolled) {
    need_wait_return = 1;
  }
  {
  tmp___1 = msg_use_printf();
  }
  if (tmp___1) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! *s) {
        goto while_break;
      }
      if (! silent_mode) {
        p___0 = & buf___3[0];
        if ((int )*s == 10) {
          tmp = p___0;
          p___0 ++;
          *tmp = (char_u )'\r';
        }
        {
        tmp___0 = p___0;
        p___0 ++;
        *tmp___0 = *s;
        *p___0 = (char_u )'\000';
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", (char *)(buf___3));
        }
      }
      if ((int )*s == 13) {

      } else { //Added block
      if ((int )*s == 10) {
        msg_col = 0;
      } else {
        msg_col ++;
      }
      }
      s ++;
    }
    while_break: ;/* CIL Label */ ;
    }
    msg_didout = 1;
    return;
  }
  msg_didany = 1;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! *s) {
      goto while_break___0;
    }
    if ((long )msg_row >= Rows - 1L) {
      if ((int )*s == 10) {
        goto _L;
      } else { //Added block
      if ((long )msg_col >= Columns - 1L) {
        goto _L;
      } else { //Added block
      if ((int )*s == 9) {
        if ((long )msg_col >= ((Columns - 1L) & -8L)) {
          _L: ;
          if (msg_no_more) {



          }
          {
          screen_del_lines(0, 0, 1, (int )Rows, 1);
          msg_row = (int )(Rows - 2L);
          }
          if ((long )msg_col >= Columns) {

          }
          {
          msg_scrolled ++;
          need_wait_return = 1;
          redraw_all_later(40);
          redraw_cmdline = 1;
          }
          if (cmdline_row > 0) {
            if (! exmode_active) {
              cmdline_row --;
            }
          }
          if (p_more) {

            if (lines_left == 0) {
              if (State != 1537) {
                if (! msg_no_more) {
                  if (! exmode_active) {
                    {




                    }
                    {































































































































                    while_break___1: ;/* CIL Label */ ;
                    }
                    {




                    }





                  }
                }
              }
            }
          }
        }
      }
      }
      }
    }
    if ((int )*s == 10) {
      msg_didout = 0;
      msg_col = 0;
      msg_row ++;
      if ((long )msg_row >= Rows) {

      }
    } else { //Added block
    if ((int )*s == 13) {
      msg_col = 0;
    } else { //Added block
    if ((int )*s == 8) {



    } else { //Added block
    if ((int )*s == 9) {
      {









      while_break___2: ;/* CIL Label */ ;
      }
    } else {
      {
      msg_screen_putchar((int )*s, attr);
      }
    }
    }
    }
    }
    s ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  msg_check();
  }
  return;
}
}
static int msg_use_printf(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = msg_check_screen();
  }
  if (tmp) {
    {
    tmp___0 = swapping_screen();
    }
    if (tmp___0) {
      if (! termcap_active) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {

    }
  } else {

  }
  return (tmp___1);
}
}
static void msg_screen_putchar(int c , int attr ) 
{ 


  {
  {
  msg_didout = 1;
  screen_putchar(c, msg_row, msg_col, attr);
  msg_col ++;
  }
  if ((long )msg_col >= Columns) {
    msg_col = 0;
    msg_row ++;
  }
  return;
}
}
void msg_moremsg(int full ) 
{




















}
void repeat_message(void) 
{






































}
static int msg_check_screen(void) 
{ 
  int tmp ;

  {
  if (! full_screen) {

  } else {
    {
    tmp = screen_valid(0);
    }
    if (! tmp) {

    }
  }
  if ((long )msg_row >= Rows) {

  }
  if ((long )msg_col >= Columns) {
    msg_col = (int )(Columns - 1L);
  }
  return (1);
}
}
void msg_clr_eos(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = msg_check_screen();
  }
  if (tmp) {
    {
    tmp___0 = swapping_screen();
    }
    if (tmp___0) {
      if (! termcap_active) {
        _L: ;
        if (full_screen) {
          if (*(term_strings[8])) {
            {
            out_str(term_strings[8]);
            }
          } else { //Added block





          }
        }
      } else {
        {
        screen_fill(msg_row, msg_row + 1, msg_col, (int )Columns, ' ', ' ', 0);
        screen_fill(msg_row + 1, (int )Rows, 0, (int )Columns, ' ', ' ', 0);
        }
      }
    } else {
      {


      }
    }
  } else {

  }
  return;
}
}
void msg_clr_cmdline(void) 
{ 


  {
  {
  msg_row = cmdline_row;
  msg_col = 0;
  msg_clr_eos();
  }
  return;
}
}
int msg_end(void) 
{ 


  {
  if (! exiting) {
    if (need_wait_return) {
      if (State != 8) {
        {
        wait_return(0);
        }
        return (0);
      }
    }
  }
  {
  out_flush();
  }
  return (1);
}
}
void msg_check(void) 
{ 


  {
  if ((long )msg_row == Rows - 1L) {
    if (msg_col >= sc_col) {


    }
  }
  return;
}
}
static int cur_col  =    0;
static void redir_write(char_u *s ) 
{ 


  {
  if ((unsigned long )redir_fd != (unsigned long )((void *)0)) {
    goto _L;
  } else { //Added block
  if (redir_reg) {
    _L: ;
    if (! redir_off) {
      if ((int )*s != 10) {
        if ((int )*s != 13) {
          {
          while (1) {
            while_continue: ;/* CIL Label */ ;
            if (! (cur_col < msg_col)) {
              goto while_break;
            }
            if (redir_reg) {
              {

              }
            } else { //Added block
            if (redir_fd) {
              {
              fputs((char const   * __restrict  )" ", (FILE * __restrict  )redir_fd);
              }
            }
            }
            cur_col ++;
          }
          while_break: ;/* CIL Label */ ;
          }
        }
      }
      if (redir_reg) {
        {

        }
      } else { //Added block
      if (redir_fd) {
        {
        fputs((char const   * __restrict  )((char *)s), (FILE * __restrict  )redir_fd);
        }
      }
      }
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! *s) {
          goto while_break___0;
        }
        if ((int )*s == 13) {
          cur_col = 0;
        } else { //Added block
        if ((int )*s == 10) {
          cur_col = 0;
        } else { //Added block
        if ((int )*s == 9) {

        } else {
          cur_col ++;
        }
        }
        }
        s ++;
      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
  }
  }
  return;
}
}
void give_warning(char_u *message , int hl ) 
{ 
  int tmp ;

  {
  {
  set_vim_var_string(3, message);
  keep_msg = (char_u *)((void *)0);
  }
  if (hl) {
    keep_msg_attr = highlight_attr[16];
  } else {

  }
  {
  tmp = msg_attr(message, keep_msg_attr);
  }
  if (tmp) {
    if (! msg_scrolled) {
      keep_msg = message;
    }
  }
  msg_didout = 0;
  msg_nowait = 1;
  msg_col = 0;
  return;
}
}
void msg_advance(int col ) 
{




















}
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) 
{




























































































}
char_u *confirm_msg  =    (char_u *)((void *)0);
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) 
{























































































































































}
void display_confirm_msg(void) 
{












}
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) 
{

















}
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) 
{




























}
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) 
{







































}
#pragma merger("0","/tmp/cil-hgjlur8Q.i","-O0")
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
char_u *default_vim_dir ;
char_u *default_vimruntime_dir ;
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) ;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
int get_indent_lnum(linenr_t lnum ) ;
int plines_check(linenr_t p___0 ) ;
int plines(linenr_t p___0 ) ;
int plines_win(WIN *wp , linenr_t p___0 ) ;
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) ;
int plines_m(linenr_t first___0 , linenr_t last ) ;
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) ;
int del_chars(long count___2 , int fixpos ) ;
int truncate_line(int fixpos ) ;
int gchar_pos(FPOS *pos___0 ) ;
void check_status(BUF *buf___3 ) ;
char_u *getnextcomp(char_u *fname ) ;
FPOS *find_start_comment(int ind_maxcomment ) ;
int get_lisp_indent(void) ;
void preserve_exit(void) ;
void addfile(struct growarray *gap , char_u *f , int flags___0 ) ;
void validate_cline_row(void) ;
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) ;
void showmatch(void) ;
int u_savedel(linenr_t lnum , long nlines ) ;
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) ;
static char_u *vim_version_dir(char_u *vimdir ) ;
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) ;
static int get_indent_str(char_u *ptr ) ;
static int temporary_nolist(void) ;
int get_indent(void) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = get_indent_str(tmp);
  }
  return (tmp___0);
}
}
int get_indent_lnum(linenr_t lnum ) 
{










}
static int get_indent_str(char_u *ptr ) 
{ 
  int count___2 ;

  {
  count___2 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *ptr) {

    }
    if ((int )*ptr == 9) {
      count___2 += (int )curbuf->b_p_ts - count___2 % (int )curbuf->b_p_ts;
    } else { //Added block
    if ((int )*ptr == 32) {

    } else {
      goto while_break;
    }
    }
    ptr ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (count___2);
}
}
void set_indent(int size , int del_first ) 
{ 
  int oldstate ;
  int c ;
  int tmp ;

  {
  oldstate = State;
  State = 16;
  curwin->w_cursor.col = (colnr_t )0;
  if (del_first) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      {
      c = gchar_cursor();
      }
      if (c == 32) {

      } else { //Added block
      if (c == 9) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      }
      if (! tmp) {
        goto while_break;
      }
      {
      del_char(0);
      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  if (! curbuf->b_p_et) {
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (size >= (int )curbuf->b_p_ts)) {
        goto while_break___0;
      }
      {


      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (! size) {
      goto while_break___1;
    }
    {


    }
  }
  while_break___1: ;/* CIL Label */ ;
  }
  State = oldstate;
  return;
}
}
static int cin_is_cinword(char_u *line ) ;
static int cin_is_cinword(char_u *line ) 
{



























































}
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) 
{ 
  char_u *saved_line ;
  char_u *next_line ;
  char_u *p_extra ;
  FPOS old_cursor ;
  int newcol ;
  int newindent ;
  int n ;
  int trunc_line ;
  int retval ;
  int extra_len ;
  int lead_len ;
  char_u *lead_flags ;
  char_u *leader ;
  char_u *allocated ;
  char_u *p___0 ;
  int saved_char ;
  FPOS *pos___0 ;
  int old_plines ;
  int new_plines ;
  int extra_plines ;
  int do_si ;
  int tmp ;
  int no_si ;
  int first_char ;
  int vreplace_mode ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;
  char_u *ptr ;
  char_u last_char ;
  size_t tmp___4 ;
  int tmp___5 ;
  int was_backslashed ;
  size_t tmp___6 ;
  char_u *lead_repl ;
  int lead_repl_len ;
  char_u lead_middle[50] ;
  char_u lead_end[50] ;
  char_u *comment_end ;
  int extra_space ;
  int current_flag ;
  int require_blank ;
  char_u *p2 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int c ;
  int off___0 ;
  long tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char_u *tmp___15 ;
  char_u *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;

  {
  next_line = (char_u *)((void *)0);
  p_extra = (char_u *)((void *)0);
  newcol = 0;
  newindent = 0;
  trunc_line = 0;
  retval = 0;
  extra_len = 0;
  leader = (char_u *)((void *)0);
  allocated = (char_u *)((void *)0);
  saved_char = '\000';
  old_plines = 0;
  new_plines = 0;
  extra_plines = 0;
  if (curbuf->b_p_si) {





  } else {
    tmp = 0;
  }
  {
  do_si = tmp;
  no_si = 0;
  first_char = '\000';
  tmp___0 = ml_get_curline();
  saved_line = vim_strsave(tmp___0);
  }
  if ((unsigned long )saved_line == (unsigned long )((void *)0)) {

  }
  if (State == 784) {













    {



    }
    {











    while_break: ;/* CIL Label */ ;
    }

  }
  if (State == 16) {
    goto _L;
  } else { //Added block
  if (State == 528) {
    _L: ;
    p_extra = saved_line + curwin->w_cursor.col;
    if (do_si) {
      {


      }
    }
    {
    tmp___3 = strlen((char const   *)((char *)p_extra));
    extra_len = (int )tmp___3;
    saved_char = (int )*p_extra;
    *p_extra = (char_u )'\000';
    }
  }
  }
  {
  u_clearline();
  did_si = 0;
  ai_col = (colnr_t )0;
  }
  if (dir == 1) {
    if (did_ai) {

    }
  }
  if (curbuf->b_p_ai) {

  } else { //Added block
  if (do_si) {
    _L___3: ;
    {

    }































































































































































































































  }
  }
  {
  end_comment_pending = '\000';
  lead_len = get_leader_len(saved_line, & lead_flags, dir == -1);
  }
  if (lead_len > 0) {






    {



























































































































































































































    while_break___5: ;/* CIL Label */ ;
    }










































































































































































































































  }
  if ((unsigned long )p_extra != (unsigned long )((void *)0)) {
    *p_extra = (char_u )saved_char;
    if (State == 528) {
      {

      }
    }
    if (curbuf->b_p_ai) {

    } else { //Added block
    if (del_spaces) {
      _L___9: ;
      {














      while_break___19: ;/* CIL Label */ ;
      }
    }
    }
    if ((int )*p_extra != 0) {
      did_ai = 0;
    }
  }
  if ((unsigned long )p_extra == (unsigned long )((void *)0)) {

  }
  if (lead_len) {
    {



    }
  } else {
    end_comment_pending = '\000';
  }
  old_cursor = curwin->w_cursor;
  if (dir == -1) {

  }
  if (State != 784) {
    goto _L___10;
  } else { //Added block
  if (old_cursor.lnum >= (linenr_t )orig_line_count) {
    _L___10: ;
    {
    tmp___12 = ml_append(curwin->w_cursor.lnum, p_extra, (colnr_t )0, 0);
    }
    if (! tmp___12) {

    }
    {
    mark_adjust(curwin->w_cursor.lnum + 1L, (linenr_t )2147483647, 1L, 0L);
    }
  } else {







    {


    }
  }
  }
  {
  changed_line_abv_curs();
  }
  if (newindent) {

  } else { //Added block
  if (did_si) {
    _L___11: ;







    {


    }




















  }
  }
  if (State == 528) {
    {











    while_break___21: ;/* CIL Label */ ;
    }
  }
  curwin->w_cursor = old_cursor;
  if (dir == 1) {
    if (redraw) {
      {
      old_plines = plines(curwin->w_cursor.lnum);
      new_plines = old_plines;
      }
    }
    if (trunc_line) {

    } else { //Added block
    if (State == 16) {
      goto _L___12;
    } else { //Added block
    if (State == 528) {

    } else { //Added block
    if (State == 784) {
      _L___12: ;
      *(saved_line + curwin->w_cursor.col) = (char_u )'\000';
      if (trunc_line) {
        {

        }
      }
      {
      ml_replace(curwin->w_cursor.lnum, saved_line, 0);
      saved_line = (char_u *)((void *)0);
      syn_changed(curwin->w_cursor.lnum);
      }
      if (redraw) {
        {
        new_plines = plines(curwin->w_cursor.lnum);
        }
      }
    }
    }
    }
    }
    curwin->w_cursor.col = (colnr_t )0;
    if (redraw) {
      if (State != 784) {
        {
        extra_plines = plines(curwin->w_cursor.lnum + 1L);
        }
      } else { //Added block





      }
      n = curwin->w_cline_row + new_plines;
      if ((long )((n + extra_plines) - 1) >= (long )curwin->w_height - p_so) {






        {

        }
      } else {
        {
        win_ins_lines(curwin, n, (new_plines - old_plines) + extra_plines, 1, 1);
        }
      }
    }
    curwin->w_cursor.lnum = old_cursor.lnum + 1L;
  } else { //Added block





  }
  curwin->w_cursor.col = (colnr_t )newcol;
  if (State == 784) {


  } else {
    vreplace_mode = 0;
  }
  if ((unsigned long )leader == (unsigned long )((void *)0)) {
    if (curbuf->b_p_lisp) {








    }
  }
  if ((unsigned long )leader == (unsigned long )((void *)0)) {
    goto _L___13;
  } else { //Added block
  if (! curbuf->b_p_ai) {
    _L___13: ;
    if (curbuf->b_p_cin) {
      {

      }





      {

      }








    }
  }
  }
  if (vreplace_mode) {

  }
  if (State == 784) {
    {


    }



    {



    }
    {











    while_break___22: ;/* CIL Label */ ;
    }

  }
  {
  approximate_botline();
  }
  if (redraw > 0) {
    {
    update_topline();
    update_screen(35);
    }
  }
  {
  changed();
  retval = 1;
  }
  theend: ;
  {
  vim_free((void *)saved_line);
  vim_free((void *)next_line);
  vim_free((void *)allocated);
  }
  return (retval);
}
}
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) 
{ 
  int i___0 ;
  int j ;
  int got_com ;
  int found_one ;
  char_u part_buf[50] ;
  char_u *string___0 ;
  char_u *list ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  got_com = 0;
  if (! fo_do_comments) {
    return (0);
  }

  {









  while_break: ;/* CIL Label */ ;
  }
  {




































































































































  while_break___0: ;/* CIL Label */ ;
  }






}
}
int plines_check(linenr_t p___0 ) 
{ 
  int tmp ;

  {
  if (p___0 < 1L) {

  } else { //Added block
  if (p___0 > curbuf->b_ml.ml_line_count) {

  }
  }
  {
  tmp = plines_win(curwin, p___0);
  }
  return (tmp);
}
}
int plines(linenr_t p___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = plines_win(curwin, p___0);
  }
  return (tmp);
}
}
int plines_win(WIN *wp , linenr_t p___0 ) 
{ 
  long col ;
  char_u *s ;
  int lines___0 ;
  int tmp ;

  {
  if (! wp->w_p_wrap) {
    return (1);
  }
  {
  s = ml_get_buf(wp->w_buffer, p___0, 0);
  }
  if ((int )*s == 0) {
    return (1);
  }
  {
  tmp = win_linetabsize(wp, s);
  col = (long )tmp;
  }
  if (wp->w_p_list) {
    if (lcs_eol != 0) {
      col ++;
    }
  }
  if (wp->w_p_nu) {
    col += 8L;
  }
  lines___0 = (int )((col + (Columns - 1L)) / Columns);
  if (lines___0 <= wp->w_height) {
    return (lines___0);
  }

}
}
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) 
{ 
  register long col ;
  register char_u *s ;
  register int lines___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! wp->w_p_wrap) {
    return (1);
  }
  {
  s = ml_get_buf(wp->w_buffer, p___0, 0);
  col = 0L;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((int )*s != 0) {
      column --;
      if (! (column >= 0L)) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {




    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*s == 9) {















  }
  if (wp->w_p_nu) {

  }
  lines___0 = (int )(1L + col / Columns);
  if (lines___0 <= wp->w_height) {
    return (lines___0);
  }

}
}
int plines_m(linenr_t first___0 , linenr_t last ) 
{








}
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) 
{ 
  int count___2 ;
  linenr_t tmp ;
  int tmp___0 ;

  {
  count___2 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (first___0 <= last)) {
      goto while_break;
    }
    {
    tmp = first___0;
    first___0 ++;
    tmp___0 = plines_win(wp, tmp);
    count___2 += tmp___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (count___2);
}
}
static int temporary_nolist(void) 
{















}
void ins_char(int c ) 
{ 
  char_u *p___0 ;
  char_u *newp ;
  char_u *oldp ;
  int oldlen ;
  int extra ;
  colnr_t col ;
  linenr_t lnum ;
  int vcol ;
  int new_vcol ;
  int i___0 ;
  int size ;
  int old_list ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  col = curwin->w_cursor.col;
  lnum = curwin->w_cursor.lnum;
  new_vcol = 0;
  oldp = ml_get(lnum);
  tmp = strlen((char const   *)((char *)oldp));
  oldlen = (int )(tmp + 1UL);
  }
  if (State != 528) {
    extra = 1;
  } else { //Added block





  }
  if (State == 528) {
    {

    }





  }
  if (State == 784) {
    {

    }







    {







    }
    {































    while_break: ;/* CIL Label */ ;
    }

  }
  {
  newp = alloc_check((unsigned int )(oldlen + extra));
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {

  }
  if (col > 0U) {
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  p___0 = newp + col;
  if (State == 784) {












  } else {
    {
    memmove((void *)((char *)(p___0 + extra)), (void const   *)((char *)(oldp + col)),
            (size_t )((colnr_t )oldlen - col));
    }
  }
  {
  *p___0 = (char_u )c;
  ml_replace(lnum, newp, 0);
  }
  if (p_sm) {



















  }
  {
  (curwin->w_cursor.col) ++;
  vr_virtcol = (colnr_t )new_vcol;
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return;
}
}
void ins_str(char_u *s ) 
{ 
  char_u *oldp ;
  char_u *newp ;
  int newlen ;
  size_t tmp ;
  int oldlen ;
  colnr_t col ;
  linenr_t lnum ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)s));
  newlen = (int )tmp;
  col = curwin->w_cursor.col;
  lnum = curwin->w_cursor.lnum;
  oldp = ml_get(lnum);
  tmp___0 = strlen((char const   *)((char *)oldp));
  oldlen = (int )tmp___0;
  newp = alloc_check((unsigned int )((oldlen + newlen) + 1));
  }
  if ((unsigned long )newp == (unsigned long )((void *)0)) {

  }
  if (col > 0U) {
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  {
  memmove((void *)((char *)(newp + col)), (void const   *)((char *)s), (size_t )newlen);
  memmove((void *)((char *)((newp + col) + newlen)), (void const   *)((char *)(oldp + col)),
          (size_t )(((colnr_t )oldlen - col) + 1U));
  ml_replace(lnum, newp, 0);
  curwin->w_cursor.col += (colnr_t )newlen;
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return;
}
}
int del_char(int fixpos ) 
{ 
  int tmp ;

  {
  {
  tmp = del_chars(1L, fixpos);
  }
  return (tmp);
}
}
int del_chars(long count___2 , int fixpos ) 
{ 
  char_u *oldp ;
  char_u *newp ;
  colnr_t oldlen ;
  linenr_t lnum ;
  colnr_t col ;
  int was_alloced ;
  long movelen ;
  size_t tmp ;

  {
  {
  lnum = curwin->w_cursor.lnum;
  col = curwin->w_cursor.col;
  oldp = ml_get(lnum);
  tmp = strlen((char const   *)((char *)oldp));
  oldlen = (colnr_t )tmp;
  }
  if (col >= oldlen) {

  }
  movelen = (((long )oldlen - (long )col) - count___2) + 1L;
  if (movelen <= 1L) {
    if (col > 0U) {
      if (fixpos) {
        (curwin->w_cursor.col) --;
      }
    }
    count___2 = (long )(oldlen - col);
    movelen = 1L;
  }
  {
  was_alloced = ml_line_alloced();
  }
  if (was_alloced) {
    newp = oldp;
  } else {
    {
    newp = alloc((unsigned int )((long )(oldlen + 1U) - count___2));
    }
    if ((unsigned long )newp == (unsigned long )((void *)0)) {

    }
    {
    memmove((void *)((char *)newp), (void const   *)((char *)oldp), (size_t )col);
    }
  }
  {
  memmove((void *)((char *)(newp + col)), (void const   *)((char *)((oldp + col) + count___2)),
          (size_t )movelen);
  }
  if (! was_alloced) {
    {
    ml_replace(lnum, newp, 0);
    }
  }
  {
  changed();
  changed_cline_bef_curs();
  approximate_botline();
  }
  return (1);
}
}
int truncate_line(int fixpos ) 
{




































}
void del_lines(long nlines , int dowindow , int undo ) 
{

































































































}
int gchar_pos(FPOS *pos___0 ) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  tmp = ml_get_pos(pos___0);
  ptr = tmp;
  }
  return ((int )*ptr);
}
}
int gchar_cursor(void) 
{ 
  char_u *ptr ;
  char_u *tmp ;

  {
  {
  tmp = ml_get_cursor();
  ptr = tmp;
  }
  return ((int )*ptr);
}
}
void pchar_cursor(int c ) 
{









}
int inindent(int extra ) 
{ 
  char_u *ptr ;
  colnr_t col ;

  {
  {
  col = (colnr_t )0;
  ptr = ml_get_curline();
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*ptr == 32)) {
      if (! ((int )*ptr == 9)) {
        goto while_break;
      }
    }
    ptr ++;
    col ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (col >= curwin->w_cursor.col + (colnr_t )extra) {
    return (1);
  } else {
    return (0);
  }
}
}
char_u *skip_to_option_part(char_u *p___0 ) 
{ 


  {
  if ((int )*p___0 == 44) {
    p___0 ++;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*p___0 == 32)) {
      goto while_break;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
static char buf___1[2]  = {      (char )'s',      (char )'\000'};
char *plural(long n ) 
{ 


  {
  if (n == 1L) {
    return (& buf___1[1]);
  }
  return (& buf___1[0]);
}
}
void changed(void) 
{ 
  int save_msg_scroll ;

  {
  save_msg_scroll = msg_scroll;
  if (! curbuf->b_changed) {
    {
    change_warning(0);
    }
    if (curbuf->b_may_swap) {
      {

      }








    }
    {
    curbuf->b_changed = 1;
    ml_setdirty(curbuf, 1);
    check_status(curbuf);
    }
  }
  modified = 1;
  tag_modified = 1;
  return;
}
}
void unchanged(BUF *buf___3 , int ff ) 
{ 


  {
  if (buf___3->b_changed) {
    goto _L;
  } else { //Added block
  if (ff) {
    if (buf___3->b_start_ffc != (int )*(buf___3->b_p_ff)) {
      _L: ;
      {
      buf___3->b_changed = 0;
      ml_setdirty(buf___3, 0);
      }
      if (ff) {
        buf___3->b_start_ffc = (int )*(buf___3->b_p_ff);
      }
      {
      check_status(buf___3);
      }
    }
  }
  }
  return;
}
}
void check_status(BUF *buf___3 ) 
{ 
  WIN *wp ;
  int i___0 ;

  {
  i___0 = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((unsigned long )wp->w_buffer == (unsigned long )buf___3) {
      if (wp->w_status_height) {


      }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (i___0) {
    {

    }
  }
  return;
}
}
void change_warning(int col ) 
{ 
  int tmp ;

  {
  if (curbuf->b_did_warn == 0) {
    {
    tmp = curbuf_changed();
    }
    if (tmp == 0) {
      if (! p_im) {
        if (! autocmd_busy) {
          if (curbuf->b_p_ro) {
            {

            }



            {







            }





          }
        }
      }
    }
  }
  return;
}
}
int ask_yesno(char_u *str___1 , int direct ) 
{































































}
int get_keystroke(void) 
{










































































































































}
int get_number(int colon ) 
{






























































































}
void msgmore(long n ) 
{ 
  long pn ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  if (global_busy) {

  } else { //Added block
  if (keep_msg) {

  } else {
    {
    tmp = messaging();
    }
    if (! tmp) {

    }
  }
  }
  if (n > 0L) {

  } else {
    pn = - n;
  }
  if (pn > p_report) {





    {

    }





    {



    }




  }
  return;
}
}
void beep_flush(void) 
{ 


  {
  {
  flush_buffers(0);
  vim_beep();
  }
  return;
}
}
void vim_beep(void) 
{ 


  {
  if (p_vb) {
    {

    }
  } else {
    {
    out_char((unsigned int )'\a');
    }
  }
  return;
}
}
static char_u *homedir  =    (char_u *)((void *)0);
void init_homedir(void) 
{ 
  char_u *var___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = getenv((char const   *)((char *)((char_u *)"HOME")));
  var___0 = (char_u *)tmp;
  }
  if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
    if ((int )*var___0 == 0) {

    }
  }
  if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
    {
    tmp___2 = mch_dirname(NameBuff, 1024);
    }
    if (tmp___2 == 1) {
      {
      tmp___0 = chdir((char const   *)((char *)var___0));
      }
      if (! tmp___0) {
        {
        tmp___1 = mch_dirname(IObuff, 1025);
        }
        if (tmp___1 == 1) {
          var___0 = IObuff;
        }
      }
      {
      chdir((char const   *)((char *)NameBuff));
      }
    }
    {
    homedir = vim_strsave(var___0);
    }
  }
  return;
}
}
void expand_env(char_u *src , char_u *dst , int dstlen ) 
{ 
  char_u *tail ;
  int c ;
  char_u *var___0 ;
  int copy_char ;
  int mustfree ;
  int at_start___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct passwd *pw ;
  int tmp___12 ;
  char_u *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;
  char_u *tmp___23 ;

  {
  {
  at_start___0 = 1;
  src = skipwhite(src);
  dstlen --;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (*src) {
      if (! (dstlen > 0)) {

      }
    } else {
      goto while_break;
    }
    copy_char = 1;
    if ((int )*src == 36) {
      goto _L___0;
    } else { //Added block
    if ((int )*src == 126) {
      if (at_start___0) {
        _L___0: ;
        mustfree = 0;
        if ((int )*src == 36) {
          tail = src + 1;
          var___0 = dst;
          c = dstlen - 1;
          if ((int )*tail == 123) {
            {
            tmp___6 = vim_isIDc('{');
            }
            if (tmp___6) {

            } else {
              tail ++;
              {
              while (1) {
                while_continue___0: ;/* CIL Label */ ;
                tmp___1 = c;
                c --;
                if (tmp___1 > 0) {
                  if (*tail) {
                    if (! ((int )*tail != 125)) {
                      goto while_break___0;
                    }
                  } else {

                  }
                } else {

                }
                tmp = var___0;
                var___0 ++;
                tmp___0 = tail;
                tail ++;
                *tmp = *tmp___0;
              }
              while_break___0: ;/* CIL Label */ ;
              }
              tail ++;
            }
          } else {
            _L: ;
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              tmp___4 = c;
              c --;
              if (tmp___4 > 0) {
                if (*tail) {
                  {
                  tmp___5 = vim_isIDc((int )*tail);
                  }
                  if (! tmp___5) {
                    goto while_break___1;
                  }
                } else {

                }
              } else {

              }
              tmp___2 = var___0;
              var___0 ++;
              tmp___3 = tail;
              tail ++;
              *tmp___2 = *tmp___3;
            }
            while_break___1: ;/* CIL Label */ ;
            }
          }
          {
          *var___0 = (char_u )'\000';
          var___0 = vim_getenv(dst, & mustfree);
          }
        } else { //Added block
        if ((int )*(src + 1) == 0) {


        } else {
          {
          tmp___12 = vim_ispathsep((int )*(src + 1));
          }
          if (tmp___12) {
            var___0 = homedir;
            tail = src + 1;
          } else {
            {

            }


























































          }
        }
        }
        if ((unsigned long )var___0 != (unsigned long )((void *)0)) {
          if ((int )*var___0 != 0) {
            {
            tmp___18 = strlen((char const   *)((char *)var___0));
            tmp___19 = strlen((char const   *)((char *)tail));
            }
            if ((tmp___18 + tmp___19) + 1UL < (size_t )((unsigned int )dstlen)) {
              {
              strcpy((char * __restrict  )((char *)dst), (char const   * __restrict  )((char *)var___0));
              tmp___14 = strlen((char const   *)((char *)var___0));
              dstlen = (int )((size_t )dstlen - tmp___14);
              tmp___15 = strlen((char const   *)((char *)var___0));
              dst += tmp___15;
              }
              if (*var___0) {
                {
                tmp___16 = vim_ispathsep((int )*(dst - 1));
                }
                if (tmp___16) {
                  {

                  }



                }
              }
              src = tail;
              copy_char = 0;
            }
          }
        }
        if (mustfree) {
          {

          }
        }
      }
    }
    }
    if (copy_char) {
      at_start___0 = 0;
      if ((int )*(src + 0) == 92) {






      } else { //Added block
      if ((int )*(src + 0) == 32) {
        at_start___0 = 1;
      } else { //Added block
      if ((int )*(src + 0) == 44) {
        at_start___0 = 1;
      }
      }
      }
      tmp___22 = dst;
      dst ++;
      tmp___23 = src;
      src ++;
      *tmp___22 = *tmp___23;
      dstlen --;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  *dst = (char_u )'\000';
  return;
}
}
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) 
{ 
  char_u *p___0 ;
  char_u *pend ;
  int vimruntime ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
  tmp = getenv((char const   *)((char *)name___1));
  p___0 = (char_u *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {



  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {

  }
  {
  tmp___0 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"VIMRUNTIME"));
  vimruntime = tmp___0 == 0;
  }
  if (! vimruntime) {
    {
    tmp___1 = strcmp((char const   *)((char *)name___1), (char const   *)((char *)"VIM"));
    }
    if (tmp___1 != 0) {
      return ((char_u *)((void *)0));
    }
  }
  if (vimruntime) {
    if ((int )*default_vimruntime_dir == 0) {
      {
      tmp___2 = getenv((char const   *)((char *)((char_u *)"VIM")));
      p___0 = (char_u *)tmp___2;
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {



      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {

        }








      }
    }
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
    tmp___4 = vim_strchr(p_hf, '$');
    }
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {

    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      {

      }



















      {

      }















    }
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    if (vimruntime) {
      if ((int )*default_vimruntime_dir != 0) {


      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if (vimruntime) {
      {
      p___0 = vim_version_dir(default_vim_dir);
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {

      } else {
        goto _L;
      }
    } else { //Added block
    _L: ;
    if ((int )*default_vim_dir != 0) {
      p___0 = default_vim_dir;
      *mustfree = 0;
    }
    }
    }
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    if (vimruntime) {
      {
      vim_setenv((char_u *)"VIMRUNTIME", p___0);
      didset_vimruntime = 1;
      }
    } else {
      {


      }
    }
  }
  return (p___0);
}
}
static char_u *vim_version_dir(char_u *vimdir ) 
{ 
  char_u *p___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )vimdir == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*vimdir == 0) {

  }
  }
  {
  p___0 = concat_fnames(vimdir, (char_u *)"vim58", 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp = mch_isdir(p___0);
    }
    if (tmp) {

    }
  }
  {
  vim_free((void *)p___0);
  p___0 = concat_fnames(vimdir, (char_u *)"runtime", 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___0 = mch_isdir(p___0);
    }
    if (tmp___0) {

    }
  }
  {
  vim_free((void *)p___0);
  }
  return ((char_u *)((void *)0));
}
}
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) 
{
































}
char_u *expand_env_save(char_u *src ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = alloc(1024U);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    expand_env(src, p___0, 1024);
    }
  }
  return (p___0);
}
}
void vim_setenv(char_u *name___1 , char_u *val ) 
{ 


  {
  {
  setenv((char const   *)((char *)name___1), (char const   *)((char *)val), 1);
  }
  return;
}
}
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) 
{ 
  size_t dirlen ;
  size_t envlen ;
  size_t len___0 ;
  char_u *homedir_env ;
  char_u *p___0 ;
  char_u *tmp ;
  char *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;

  {
  dirlen = (size_t )0;
  envlen = (size_t )0;
  if ((unsigned long )src == (unsigned long )((void *)0)) {


  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    if (buf___3->b_help) {
      {


      }

    }
  }
  if ((unsigned long )homedir != (unsigned long )((void *)0)) {
    {
    dirlen = strlen((char const   *)((char *)homedir));
    }
  }
  {
  tmp___0 = getenv((char const   *)((char *)((char_u *)"HOME")));
  homedir_env = (char_u *)tmp___0;
  }
  if ((unsigned long )homedir_env != (unsigned long )((void *)0)) {
    if ((int )*homedir_env == 0) {

    }
  }
  if ((unsigned long )homedir_env != (unsigned long )((void *)0)) {
    {
    envlen = strlen((char const   *)((char *)homedir_env));
    }
  }
  if (! one) {
    {
    src = skipwhite(src);
    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (*src) {
      if (! (dstlen > 0)) {

      }
    } else {
      goto while_break;
    }
    p___0 = homedir;
    len___0 = dirlen;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (len___0) {
        {
        tmp___4 = strncmp((char const   *)((char *)src), (char const   *)((char *)p___0),
                          len___0);
        }
        if (tmp___4 == 0) {
          {
          tmp___5 = vim_ispathsep((int )*(src + len___0));
          }
          if (tmp___5) {
            goto _L;
          } else { //Added block
          if (! one) {









          } else { //Added block
          _L___0: ;
          if ((int )*(src + len___0) == 0) {
            _L: ;
            src += len___0;
            dstlen --;
            if (dstlen > 0) {
              tmp___1 = dst;
              dst ++;
              *tmp___1 = (char_u )'~';
            }
            {
            tmp___3 = vim_ispathsep((int )*(src + 0));
            }
            if (! tmp___3) {






            }
            goto while_break___0;
          }
          }
          }
        }
      }
      if ((unsigned long )p___0 == (unsigned long )homedir_env) {
        goto while_break___0;
      }
      p___0 = homedir_env;
      len___0 = envlen;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (*src) {
        if (one) {
          goto _L___1;
        } else { //Added block
        if ((int )*src != 44) {
          if ((int )*src != 32) {
            _L___1: ;
            dstlen --;
            if (! (dstlen > 0)) {

            }
          } else {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        }
      } else {
        goto while_break___1;
      }
      tmp___6 = dst;
      dst ++;
      tmp___7 = src;
      src ++;
      *tmp___6 = *tmp___7;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      if ((int )*src == 32) {
        goto _L___2;
      } else { //Added block
      if ((int )*src == 44) {
        _L___2: ;
        dstlen --;
        if (! (dstlen > 0)) {

        }
      } else {
        goto while_break___2;
      }
      }
      tmp___8 = dst;
      dst ++;
      tmp___9 = src;
      src ++;
      *tmp___8 = *tmp___9;
    }
    while_break___2: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  *dst = (char_u )'\000';
  return;
}
}
char_u *home_replace_save(BUF *buf___3 , char_u *src ) 
{ 
  char_u *dst ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  len___0 = 3U;
  if ((unsigned long )src != (unsigned long )((void *)0)) {
    {
    tmp = strlen((char const   *)((char *)src));
    len___0 = (unsigned int )((size_t )len___0 + tmp);
    }
  }
  {
  dst = alloc(len___0);
  }
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
    home_replace(buf___3, src, dst, (int )len___0, 1);
    }
  }
  return (dst);
}
}
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) 
{ 
  char_u exp1[1024] ;
  char_u full1[1024] ;
  char_u full2[1024] ;
  struct stat st1 ;
  struct stat st2 ;
  int r1 ;
  int r2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  expand_env(s1, exp1, 1024);
  r1 = stat((char const   * __restrict  )((char *)(exp1)), (struct stat * __restrict  )(& st1));
  r2 = stat((char const   * __restrict  )((char *)s2), (struct stat * __restrict  )(& st2));
  }
  if (r1 != 0) {

























  }
  if (r1 != 0) {

  } else { //Added block
  if (r2 != 0) {

  }
  }
  if (st1.st_dev == st2.st_dev) {
    if (st1.st_ino == st2.st_ino) {
      return (1);
    }
  }

}
}
char_u *gettail(char_u *fname ) 
{ 
  char_u *p1 ;
  char_u *p2 ;
  int tmp ;

  {
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  }
  p2 = fname;
  p1 = p2;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p2) {
      goto while_break;
    }
    {
    tmp = vim_ispathsep((int )*p2);
    }
    if (tmp) {
      p1 = p2 + 1;
    }
    p2 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p1);
}
}
char_u *getnextcomp(char_u *fname ) 
{

























}
char_u *get_past_head(char_u *path ) 
{




















}
int vim_ispathsep(int c ) 
{ 


  {
  return (c == 47);
}
}
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) 
{ 
  char_u *dest ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = strlen((char const   *)((char *)fname1));
  tmp___0 = strlen((char const   *)((char *)fname2));
  dest = alloc((unsigned int )((tmp + tmp___0) + 3UL));
  }
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
    {
    strcpy((char * __restrict  )((char *)dest), (char const   * __restrict  )((char *)fname1));
    }
    if (sep) {
      {
      add_pathsep(dest);
      }
    }
    {
    strcat((char * __restrict  )((char *)dest), (char const   * __restrict  )((char *)fname2));
    }
  }
  return (dest);
}
}
void add_pathsep(char_u *p___0 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if (*p___0) {
    {
    tmp = strlen((char const   *)((char *)p___0));
    tmp___0 = vim_ispathsep((int )*((p___0 + tmp) - 1));
    }
    if (! tmp___0) {
      {
      strcat((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)"/"));
      }
    }
  }
  return;
}
}
char_u *FullName_save(char_u *fname , int force ) 
{ 
  char_u *buf___3 ;
  char_u *new_fname ;
  int tmp ;

  {
  new_fname = (char_u *)((void *)0);
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  }
  {
  buf___3 = alloc(1024U);
  }
  if ((unsigned long )buf___3 != (unsigned long )((void *)0)) {
    {
    tmp = mch_FullName(fname, buf___3, 1024, force);
    }
    if (tmp != 0) {
      {
      new_fname = vim_strsave(buf___3);
      }
    } else {
      {

      }
    }
    {
    vim_free((void *)buf___3);
    }
  }
  return (new_fname);
}
}
static char_u *skip_string(char_u *p___0 ) ;
FPOS *find_start_comment(int ind_maxcomment ) 
{





































}
static char_u *skip_string(char_u *p___0 ) 
{







































































}
static char_u *cin_skipcomment(char_u *s ) ;
static int cin_nocode(char_u *s ) ;
static int cin_islabel_skip(char_u **s ) ;
static int cin_isdefault(char_u *s ) ;
static char_u *after_label(char_u *l ) ;
static int get_indent_nolabel(linenr_t lnum ) ;
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) ;
static int cin_ispreproc(char_u *s ) ;
static int cin_iscomment(char_u *p___0 ) ;
static int cin_isterminated(char_u *s , int incl_open ) ;
static int cin_isfuncdecl(char_u *s ) ;
static int cin_isif(char_u *p___0 ) ;
static int cin_iselse(char_u *p___0 ) ;
static int cin_isdo(char_u *p___0 ) ;
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) ;
static int cin_skip2pos(FPOS *trypos ) ;
static FPOS *find_start_brace(int ind_maxcomment ) ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) ;
static int find_last_paren(char_u *l ) ;
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) ;
static char_u *cin_skipcomment(char_u *s ) 
{
















































}
static int cin_nocode(char_u *s ) 
{








}
static int cin_islabel_skip(char_u **s ) 
{







































}
int cin_islabel(int ind_maxcomment ) 
{








































































































}
int cin_iscase(char_u *s ) 
{











































































}
static int cin_isdefault(char_u *s ) 
{


























}
int cin_isscopedecl(char_u *s ) 
{















































}
static char_u *after_label(char_u *l ) 
{












































}
static int get_indent_nolabel(linenr_t lnum ) 
{




















}
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) 
{



















































}
static int cin_ispreproc(char_u *s ) 
{











}
static int cin_iscomment(char_u *p___0 ) 
{


















}
static int cin_isterminated(char_u *s , int incl_open ) 
{
































































}
static int cin_isfuncdecl(char_u *s ) 
{




















































































}
static int cin_isif(char_u *p___0 ) 
{






















}
static int cin_iselse(char_u *p___0 ) 
{




























}
static int cin_isdo(char_u *p___0 ) 
{






















}
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) 
{

































































}
static int cin_skip2pos(FPOS *trypos ) 
{





































}
static FPOS pos_copy___0  ;
static FPOS *find_start_brace(int ind_maxcomment ) 
{








































}
static FPOS pos_copy___1  ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) 
{































}
static int find_last_paren(char_u *l ) 
{




























}
int get_c_indent(void) 
{














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) 
{































































































































}
int get_lisp_indent(void) 
{





































































































































































































































































































































































































































































}
void preserve_exit(void) 
{










































}
int vim_fexists(char_u *fname ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
  tmp = stat((char const   * __restrict  )((char *)fname), (struct stat * __restrict  )(& st));
  }
  if (tmp) {
    return (0);
  }

}
}
static int count___1  =    0;
void line_breakcheck(void) 
{ 


  {
  count___1 ++;
  if (count___1 == 32) {
    {
    count___1 = 0;
    ui_breakcheck();
    }
  }
  return;
}
}
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) 
{ 
  int retval ;
  int i___0 ;
  int j ;
  char_u *p___0 ;
  int non_suf_match ;
  char_u buf___3[100] ;
  char_u *ffname ;
  char_u *tail ;
  char_u *regpat ;
  char allow_dirs ;
  int match ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = gen_expand_wildcards(num_pat, pat, num_file, file, flags___0);
  }
  if (flags___0 & 16) {

  }
  if (*p_wig) {

    {





























































    while_break: ;/* CIL Label */ ;
    }
  }
  if (*num_file > 1) {


    {




























    while_break___2: ;/* CIL Label */ ;
    }
  }
  return (retval);
}
}
int match_suffix(char_u *fname ) 
{






































}
static int recursive___0  =    0;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{ 
  int i___0 ;
  struct growarray ga ;
  char_u *p___0 ;
  int add_pat ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char_u *t ;
  char_u *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  if (recursive___0) {
    {

    }

  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break;
    }
    {
    tmp___1 = strpbrk((char const   *)((char *)*(pat + i___0)), (char const   *)((char *)((char_u *)"`\'{")));
    }
    if ((unsigned long )((char_u *)tmp___1) != (unsigned long )((void *)0)) {
      {

      }

    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  recursive___0 = 1;
  ga_init2(& ga, (int )sizeof(char_u *), 30);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < num_pat)) {
      goto while_break___0;
    }
    {
    add_pat = -1;
    p___0 = *(pat + i___0);
    tmp___3 = strpbrk((char const   *)((char *)p___0), (char const   *)((char *)((char_u *)"$~")));
    }
    if ((unsigned long )((char_u *)tmp___3) != (unsigned long )((void *)0)) {
      {

      }
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

      } else {
        {

        }









      }
    }
    {
    tmp___4 = mch_has_wildcard(p___0);
    }
    if (tmp___4) {
      {

      }
    }
    if (add_pat <= 0) {
      if (flags___0 & 4) {
        {
        tmp___5 = backslash_halve_save(p___0);
        t = tmp___5;
        addfile(& ga, t, flags___0);
        vim_free((void *)t);
        }
      } else {

      }
    } else { //Added block
    _L: ;













    }
    if ((unsigned long )p___0 != (unsigned long )*(pat + i___0)) {
      {

      }
    }
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  *num_file = ga.ga_len;
  if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
    *file = (char_u **)ga.ga_data;
  } else {

  }
  recursive___0 = 0;
  if ((unsigned long )ga.ga_data != (unsigned long )((void *)0)) {
    tmp___7 = 1;
  } else {

  }
  return (tmp___7);
}
}
void addfile(struct growarray *gap , char_u *f , int flags___0 ) 
{ 
  char_u *p___0 ;
  int isdir ;
  long tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (! (flags___0 & 4)) {
    {

    }



  }
  {
  isdir = mch_isdir(f);
  }
  if (isdir) {





  } else { //Added block
  _L: ;
  if (! isdir) {
    if (! (flags___0 & 2)) {

    }
  }
  }
  {
  tmp___0 = ga_grow(gap, 1);
  }
  if (tmp___0 == 0) {

  }
  {
  tmp___1 = strlen((char const   *)((char *)f));
  p___0 = alloc((unsigned int )((tmp___1 + 1UL) + (size_t )isdir));
  }
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

  }
  {
  strcpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)f));
  }
  if (isdir) {





  }
  tmp___2 = gap->ga_len;
  (gap->ga_len) ++;
  *((char_u **)gap->ga_data + tmp___2) = p___0;
  (gap->ga_room) --;
  return;
}
}
char_u *get_cmd_output(char_u *cmd , int flags___0 ) 
{

























































































}
void FreeWild(int num , char_u **file ) 
{ 
  int tmp ;

  {
  if ((unsigned long )file == (unsigned long )((void *)0)) {

  } else { //Added block
  if (num <= 0) {

  }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp = num;
    num --;
    if (! tmp) {
      goto while_break;
    }
    {
    vim_free((void *)*(file + num));
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)file);
  }
  return;
}
}
int goto_im(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (p_im) {
    {

    }












  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-yqxOv2S_.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
int mch_get_user_name(char_u *s , int len___0 ) ;
int mch_call_shell(char_u *cmd , int options___0 ) ;
int inc(FPOS *lp ) ;
int incl(FPOS *lp ) ;
int decl(FPOS *lp ) ;
void adjust_cursor_col(void) ;
int leftcol_changed(void) ;
char_u *lalloc_clear(long_u size , int message ) ;
char_u *vim_strsave_up(char_u *string___0 ) ;
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) ;
void copy_spaces(char_u *ptr , size_t count___2 ) ;
void copy_chars(char_u *ptr , size_t count___2 , int c ) ;
int name_to_mod_mask(int c ) ;
int simplify_key(int key , int *modifiers ) ;
int find_special_key(char_u **srcp , int *modp , int keycode ) ;
int find_special_key_in_table(int c ) ;
char_u *get_key_name(int i___0 ) ;
int get_mouse_button(int code , int *is_click , int *is_drag ) ;
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) ;
void tag_freematch(void) ;
int coladvance(colnr_t wcol ) 
{ 
  int idx ;
  char_u *ptr ;
  colnr_t col ;
  int tmp ;

  {
  {
  ptr = ml_get_curline();
  idx = -1;
  col = (colnr_t )0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (col <= wcol) {
      if (! *ptr) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    {
    idx ++;
    tmp = lbr_chartabsize(ptr, col);
    col += (colnr_t )tmp;
    ptr ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (State & 16) {

  } else { //Added block
  if (VIsual_active) {






  }
  }
  if (idx < 0) {
    curwin->w_cursor.col = (colnr_t )0;
  } else {
    curwin->w_cursor.col = (colnr_t )idx;
  }
  if (col <= wcol) {
    return (0);
  } else {
    return (1);
  }
}
}
int inc_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = inc(& curwin->w_cursor);
  }
  return (tmp);
}
}
int inc(FPOS *lp ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = ml_get_pos(lp);
  p___0 = tmp;
  }
  if ((int )*p___0 != 0) {
    (lp->col) ++;
    if ((int )*(p___0 + 1) != 0) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
  }
  if (lp->lnum != curbuf->b_ml.ml_line_count) {
    lp->col = (colnr_t )0;
    (lp->lnum) ++;
    return (1);
  }
  return (-1);
}
}
int incl(FPOS *lp ) 
{ 
  int r ;

  {
  {
  r = inc(lp);
  }
  if (r == 1) {
    if (lp->col) {
      {
      r = inc(lp);
      }
    }
  }
  return (r);
}
}
int dec_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = dec(& curwin->w_cursor);
  }
  return (tmp);
}
}
int dec(FPOS *lp ) 
{ 
  char_u *tmp ;
  size_t tmp___0 ;

  {
  if (lp->col > 0U) {
    (lp->col) --;
    return (0);
  }
  if (lp->lnum > 1L) {
    {
    (lp->lnum) --;
    tmp = ml_get(lp->lnum);
    tmp___0 = strlen((char const   *)((char *)tmp));
    lp->col = (colnr_t )tmp___0;
    }
    return (1);
  }
  return (-1);
}
}
int decl(FPOS *lp ) 
{ 
  int r ;

  {
  {
  r = dec(lp);
  }
  if (r == 1) {
    if (lp->col) {
      {
      r = dec(lp);
      }
    }
  }
  return (r);
}
}
void check_cursor_lnum(void) 
{ 


  {
  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {

  }
  if (curwin->w_cursor.lnum <= 0L) {

  }
  return;
}
}
void check_cursor_col(void) 
{ 
  colnr_t len___0 ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = strlen((char const   *)((char *)tmp));
  len___0 = (colnr_t )tmp___0;
  }
  if (len___0 == 0U) {
    curwin->w_cursor.col = (colnr_t )0;
  } else { //Added block
  if (curwin->w_cursor.col >= len___0) {

















  }
  }
  return;
}
}
void adjust_cursor(void) 
{ 


  {
  {
  check_cursor_lnum();
  check_cursor_col();
  }
  return;
}
}
void adjust_cursor_col(void) 
{ 
  int tmp ;

  {
  if (! VIsual_active) {
    goto _L;
  } else { //Added block
  if ((int )*p_sel == 111) {
    _L: ;
    if (curwin->w_cursor.col) {
      {

      }



    }
  }
  }
  return;
}
}
int leftcol_changed(void) 
{
































































}
static void vim_strup(char_u *p___0 ) ;
char_u *alloc(unsigned int size ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = lalloc((long_u )size, 1);
  }
  return (tmp);
}
}
char_u *alloc_clear(unsigned int size ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = lalloc((long_u )size, 1);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memset((void *)p___0, 0, (size_t )size);
    }
  }
  return (p___0);
}
}
char_u *alloc_check(unsigned int size ) 
{ 
  char_u *tmp ;

  {
  {
  tmp = lalloc((long_u )size, 1);
  }
  return (tmp);
}
}
char_u *lalloc_clear(long_u size , int message ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = lalloc(size, message);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memset((void *)p___0, 0, size);
    }
  }
  return (p___0);
}
}
static int releasing  =    0;
char_u *lalloc(long_u size , int message ) 
{ 
  char_u *p___0 ;
  int try_again ;
  void *tmp ;

  {
  if (size <= 0UL) {
    {

    }

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = malloc(size);
    p___0 = (char_u *)tmp;
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      goto theend;
    }



    {



    }



  }
  while_break: ;/* CIL Label */ ;
  }







  theend: ;
  return (p___0);
}
}
void do_outofmem_msg(void) 
{











}
char_u *vim_strsave(char_u *string___0 ) 
{ 
  char_u *p___0 ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)string___0));
  len___0 = (unsigned int )(tmp + 1UL);
  p___0 = alloc(len___0);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)p___0), (void const   *)((char *)string___0), (size_t )len___0);
    }
  }
  return (p___0);
}
}
char_u *vim_strnsave(char_u *string___0 , int len___0 ) 
{ 
  char_u *p___0 ;

  {
  {
  p___0 = alloc((unsigned int )(len___0 + 1));
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    strncpy((char * __restrict  )((char *)p___0), (char const   * __restrict  )((char *)string___0),
            (size_t )len___0);
    *(p___0 + len___0) = (char_u )'\000';
    }
  }
  return (p___0);
}
}
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) 
{




























































}
char_u *vim_strsave_up(char_u *string___0 ) 
{ 
  char_u *p1 ;

  {
  {
  p1 = vim_strsave(string___0);
  vim_strup(p1);
  }
  return (p1);
}
}
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) 
{ 
  char_u *p1 ;

  {
  {
  p1 = vim_strnsave(string___0, len___0);
  vim_strup(p1);
  }
  return (p1);
}
}
static void vim_strup(char_u *p___0 ) 
{ 
  char_u *p2 ;
  int c ;
  char_u *tmp ;

  {
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    p2 = p___0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      c = (int )*p2;
      if (! (c != 0)) {
        goto while_break;
      }
      tmp = p2;
      p2 ++;
      if (c < 97) {
        *tmp = (char_u )c;
      } else { //Added block
      if (c > 122) {

      } else {
        *tmp = (char_u )(c - 32);
      }
      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  return;
}
}
void copy_spaces(char_u *ptr , size_t count___2 ) 
{
























}
void copy_chars(char_u *ptr , size_t count___2 , int c ) 
{
























}
void del_trailing_spaces(char_u *ptr ) 
{ 
  char_u *q ;
  size_t tmp ;

  {
  {
  tmp = strlen((char const   *)((char *)ptr));
  q = ptr + tmp;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    q --;
    if ((unsigned long )q > (unsigned long )ptr) {
      if ((int )*(q + 0) == 32) {
        goto _L;
      } else { //Added block
      if ((int )*(q + 0) == 9) {
        _L: ;
        if ((int )*(q + -1) != 92) {
          if (! ((int )*(q + -1) != 22)) {

          }
        } else {

        }
      } else {
        goto while_break;
      }
      }
    } else {
      goto while_break;
    }
    *q = (char_u )'\000';
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
void vim_strncpy(char_u *to , char_u *from , int len___0 ) 
{


































































}
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) 
{ 
  int len___0 ;
  char_u *p___0 ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;

  {
  len___0 = 0;
  p___0 = *option;
  if ((int )*p___0 == 46) {
    tmp = len___0;
    len___0 ++;
    tmp___0 = p___0;
    p___0 ++;
    *(buf___3 + tmp) = *tmp___0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (*p___0) {
      {
      tmp___3 = vim_strchr((char_u *)sep_chars, (int )*p___0);
      }
      if (! ((unsigned long )tmp___3 == (unsigned long )((void *)0))) {
        goto while_break;
      }
    } else {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == 92) {
      {

      }



    }
    if (len___0 < maxlen - 1) {
      tmp___2 = len___0;
      len___0 ++;
      *(buf___3 + tmp___2) = *p___0;
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  *(buf___3 + len___0) = (char_u )'\000';
  p___0 = skip_to_option_part(p___0);
  *option = p___0;
  }
  return (len___0);
}
}
void vim_free(void *x___0 ) 
{ 


  {
  if ((unsigned long )x___0 != (unsigned long )((void *)0)) {
    {
    free(x___0);
    }
  }
  return;
}
}
char_u *vim_strchr(char_u *string___0 , int n ) 
{ 
  char_u *p___0 ;
  int c ;

  {
  p___0 = string___0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    c = (int )*p___0;
    if (! (c != 0)) {
      goto while_break;
    }
    if (c == n) {
      return (p___0);
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
char_u *vim_strrchr(char_u *string___0 , int n ) 
{ 
  char_u *retval ;

  {
  retval = (char_u *)((void *)0);
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *string___0) {
      goto while_break;
    }
    if ((int )*string___0 == n) {
      retval = string___0;
    }
    string___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (retval);
}
}
int vim_isspace(int x___0 ) 
{ 
  int tmp ;

  {
  if (x___0 >= 9) {
    if (x___0 <= 13) {

    } else {
      goto _L;
    }
  } else { //Added block
  _L: ;
  if (x___0 == 32) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
void ga_clear(struct growarray *gap ) 
{ 


  {
  {
  vim_free(gap->ga_data);
  ga_init(gap);
  }
  return;
}
}
void ga_clear_strings(struct growarray *gap ) 
{






















}
void ga_init(struct growarray *gap ) 
{ 


  {
  gap->ga_data = (void *)0;
  gap->ga_room = 0;
  gap->ga_len = 0;
  return;
}
}
void ga_init2(struct growarray *gap , int itemsize , int growsize ) 
{ 


  {
  {
  ga_init(gap);
  gap->ga_itemsize = itemsize;
  gap->ga_growsize = growsize;
  }
  return;
}
}
int ga_grow(struct growarray *gap , int n ) 
{ 
  size_t len___0 ;
  char_u *pp ;

  {
  if (gap->ga_room < n) {
    if (n < gap->ga_growsize) {
      n = gap->ga_growsize;
    }
    {
    len___0 = (size_t )(gap->ga_itemsize * (gap->ga_len + n));
    pp = alloc_clear((unsigned int )len___0);
    }
    if ((unsigned long )pp == (unsigned long )((void *)0)) {

    }
    gap->ga_room = n;
    if ((unsigned long )gap->ga_data != (unsigned long )((void *)0)) {
      {
      memmove((void *)((char *)pp), (void const   *)((char *)gap->ga_data), (size_t )(gap->ga_itemsize * gap->ga_len));
      vim_free(gap->ga_data);
      }
    }
    gap->ga_data = (void *)pp;
  }
  return (1);
}
}
void ga_concat(struct growarray *gap , char_u *s ) 
{




















}
void ga_append(struct growarray *gap , int c ) 
{













}
static struct modmasktable mod_mask_table[7]  = {      {8, (char_u )'M'}, 
        {4, (char_u )'C'}, 
        {2, (char_u )'S'}, 
        {16, (char_u )'2'}, 
        {32, (char_u )'3'}, 
        {64, (char_u )'4'}, 
        {0, (char_u )'\000'}};
static char_u shifted_keys_table[277]  = 
  {      (char_u )'&',      (char_u )'9',      (char_u )'@',      (char_u )'1', 
        (char_u )'&',      (char_u )'0',      (char_u )'@',      (char_u )'2', 
        (char_u )'*',      (char_u )'1',      (char_u )'@',      (char_u )'4', 
        (char_u )'*',      (char_u )'2',      (char_u )'@',      (char_u )'5', 
        (char_u )'*',      (char_u )'3',      (char_u )'@',      (char_u )'6', 
        (char_u )'*',      (char_u )'4',      (char_u )'k',      (char_u )'D', 
        (char_u )'*',      (char_u )'5',      (char_u )'k',      (char_u )'L', 
        (char_u )'*',      (char_u )'7',      (char_u )'@',      (char_u )'7', 
        (char_u )'*',      (char_u )'9',      (char_u )'@',      (char_u )'9', 
        (char_u )'*',      (char_u )'0',      (char_u )'@',      (char_u )'0', 
        (char_u )'#',      (char_u )'1',      (char_u )'%',      (char_u )'1', 
        (char_u )'#',      (char_u )'2',      (char_u )'k',      (char_u )'h', 
        (char_u )'#',      (char_u )'3',      (char_u )'k',      (char_u )'I', 
        (char_u )'#',      (char_u )'4',      (char_u )'k',      (char_u )'l', 
        (char_u )'%',      (char_u )'a',      (char_u )'%',      (char_u )'3', 
        (char_u )'%',      (char_u )'b',      (char_u )'%',      (char_u )'4', 
        (char_u )'%',      (char_u )'c',      (char_u )'%',      (char_u )'5', 
        (char_u )'%',      (char_u )'d',      (char_u )'%',      (char_u )'7', 
        (char_u )'%',      (char_u )'e',      (char_u )'%',      (char_u )'8', 
        (char_u )'%',      (char_u )'f',      (char_u )'%',      (char_u )'9', 
        (char_u )'%',      (char_u )'g',      (char_u )'%',      (char_u )'0', 
        (char_u )'%',      (char_u )'h',      (char_u )'&',      (char_u )'3', 
        (char_u )'%',      (char_u )'i',      (char_u )'k',      (char_u )'r', 
        (char_u )'%',      (char_u )'j',      (char_u )'&',      (char_u )'5', 
        (char_u )'!',      (char_u )'1',      (char_u )'&',      (char_u )'6', 
        (char_u )'!',      (char_u )'2',      (char_u )'&',      (char_u )'7', 
        (char_u )'!',      (char_u )'3',      (char_u )'&',      (char_u )'8', 
        (char_u )253,      (char_u )4,      (char_u )'k',      (char_u )'u', 
        (char_u )253,      (char_u )5,      (char_u )'k',      (char_u )'d', 
        (char_u )253,      (char_u )63,      (char_u )253,      (char_u )55, 
        (char_u )253,      (char_u )64,      (char_u )253,      (char_u )56, 
        (char_u )253,      (char_u )65,      (char_u )253,      (char_u )57, 
        (char_u )253,      (char_u )66,      (char_u )253,      (char_u )58, 
        (char_u )253,      (char_u )6,      (char_u )'k',      (char_u )'1', 
        (char_u )253,      (char_u )7,      (char_u )'k',      (char_u )'2', 
        (char_u )253,      (char_u )8,      (char_u )'k',      (char_u )'3', 
        (char_u )253,      (char_u )9,      (char_u )'k',      (char_u )'4', 
        (char_u )253,      (char_u )10,      (char_u )'k',      (char_u )'5', 
        (char_u )253,      (char_u )11,      (char_u )'k',      (char_u )'6', 
        (char_u )253,      (char_u )12,      (char_u )'k',      (char_u )'7', 
        (char_u )253,      (char_u )13,      (char_u )'k',      (char_u )'8', 
        (char_u )253,      (char_u )14,      (char_u )'k',      (char_u )'9', 
        (char_u )253,      (char_u )15,      (char_u )'k',      (char_u )';', 
        (char_u )253,      (char_u )16,      (char_u )'F',      (char_u )'1', 
        (char_u )253,      (char_u )17,      (char_u )'F',      (char_u )'2', 
        (char_u )253,      (char_u )18,      (char_u )'F',      (char_u )'3', 
        (char_u )253,      (char_u )19,      (char_u )'F',      (char_u )'4', 
        (char_u )253,      (char_u )20,      (char_u )'F',      (char_u )'5', 
        (char_u )253,      (char_u )21,      (char_u )'F',      (char_u )'6', 
        (char_u )253,      (char_u )22,      (char_u )'F',      (char_u )'7', 
        (char_u )253,      (char_u )23,      (char_u )'F',      (char_u )'8', 
        (char_u )253,      (char_u )24,      (char_u )'F',      (char_u )'9', 
        (char_u )253,      (char_u )25,      (char_u )'F',      (char_u )'A', 
        (char_u )253,      (char_u )26,      (char_u )'F',      (char_u )'B', 
        (char_u )253,      (char_u )27,      (char_u )'F',      (char_u )'C', 
        (char_u )253,      (char_u )28,      (char_u )'F',      (char_u )'D', 
        (char_u )253,      (char_u )29,      (char_u )'F',      (char_u )'E', 
        (char_u )253,      (char_u )30,      (char_u )'F',      (char_u )'F', 
        (char_u )253,      (char_u )31,      (char_u )'F',      (char_u )'G', 
        (char_u )253,      (char_u )32,      (char_u )'F',      (char_u )'H', 
        (char_u )253,      (char_u )33,      (char_u )'F',      (char_u )'I', 
        (char_u )253,      (char_u )34,      (char_u )'F',      (char_u )'J', 
        (char_u )253,      (char_u )35,      (char_u )'F',      (char_u )'K', 
        (char_u )253,      (char_u )36,      (char_u )'F',      (char_u )'L', 
        (char_u )253,      (char_u )37,      (char_u )'F',      (char_u )'M', 
        (char_u )253,      (char_u )38,      (char_u )'F',      (char_u )'N', 
        (char_u )253,      (char_u )39,      (char_u )'F',      (char_u )'O', 
        (char_u )253,      (char_u )40,      (char_u )'F',      (char_u )'P', 
        (char_u )253,      (char_u )53,      (char_u )253,      (char_u )52, 
        (char_u )'\000'};
static struct key_name_entry key_names_table[99]  = 
  {      {' ', (char_u *)"Space"}, 
        {'\t', (char_u *)"Tab"}, 
        {253 + (52 << 8), (char_u *)"Tab"}, 
        {'\n', (char_u *)"NL"}, 
        {'\n', (char_u *)"NewLine"}, 
        {'\n', (char_u *)"LineFeed"}, 
        {'\n', (char_u *)"LF"}, 
        {'\r', (char_u *)"CR"}, 
        {'\r', (char_u *)"Return"}, 
        {107 + (98 << 8), (char_u *)"BS"}, 
        {107 + (98 << 8), (char_u *)"BackSpace"}, 
        {'\033', (char_u *)"Esc"}, 
        {155, (char_u *)"CSI"}, 
        {253 + (71 << 8), (char_u *)"xCSI"}, 
        {'|', (char_u *)"Bar"}, 
        {'\\', (char_u *)"Bslash"}, 
        {107 + (68 << 8), (char_u *)"Del"}, 
        {107 + (68 << 8), (char_u *)"Delete"}, 
        {253 + (70 << 8), (char_u *)"kDel"}, 
        {107 + (117 << 8), (char_u *)"Up"}, 
        {107 + (100 << 8), (char_u *)"Down"}, 
        {107 + (108 << 8), (char_u *)"Left"}, 
        {107 + (114 << 8), (char_u *)"Right"}, 
        {107 + (49 << 8), (char_u *)"F1"}, 
        {107 + (50 << 8), (char_u *)"F2"}, 
        {107 + (51 << 8), (char_u *)"F3"}, 
        {107 + (52 << 8), (char_u *)"F4"}, 
        {107 + (53 << 8), (char_u *)"F5"}, 
        {107 + (54 << 8), (char_u *)"F6"}, 
        {107 + (55 << 8), (char_u *)"F7"}, 
        {107 + (56 << 8), (char_u *)"F8"}, 
        {107 + (57 << 8), (char_u *)"F9"}, 
        {107 + (59 << 8), (char_u *)"F10"}, 
        {70 + (49 << 8), (char_u *)"F11"}, 
        {70 + (50 << 8), (char_u *)"F12"}, 
        {70 + (51 << 8), (char_u *)"F13"}, 
        {70 + (52 << 8), (char_u *)"F14"}, 
        {70 + (53 << 8), (char_u *)"F15"}, 
        {70 + (54 << 8), (char_u *)"F16"}, 
        {70 + (55 << 8), (char_u *)"F17"}, 
        {70 + (56 << 8), (char_u *)"F18"}, 
        {70 + (57 << 8), (char_u *)"F19"}, 
        {70 + (65 << 8), (char_u *)"F20"}, 
        {70 + (66 << 8), (char_u *)"F21"}, 
        {70 + (67 << 8), (char_u *)"F22"}, 
        {70 + (68 << 8), (char_u *)"F23"}, 
        {70 + (69 << 8), (char_u *)"F24"}, 
        {70 + (70 << 8), (char_u *)"F25"}, 
        {70 + (71 << 8), (char_u *)"F26"}, 
        {70 + (72 << 8), (char_u *)"F27"}, 
        {70 + (73 << 8), (char_u *)"F28"}, 
        {70 + (74 << 8), (char_u *)"F29"}, 
        {70 + (75 << 8), (char_u *)"F30"}, 
        {70 + (76 << 8), (char_u *)"F31"}, 
        {70 + (77 << 8), (char_u *)"F32"}, 
        {70 + (78 << 8), (char_u *)"F33"}, 
        {70 + (79 << 8), (char_u *)"F34"}, 
        {70 + (80 << 8), (char_u *)"F35"}, 
        {253 + (55 << 8), (char_u *)"xF1"}, 
        {253 + (56 << 8), (char_u *)"xF2"}, 
        {253 + (57 << 8), (char_u *)"xF3"}, 
        {253 + (58 << 8), (char_u *)"xF4"}, 
        {37 + (49 << 8), (char_u *)"Help"}, 
        {38 + (56 << 8), (char_u *)"Undo"}, 
        {107 + (73 << 8), (char_u *)"Insert"}, 
        {107 + (73 << 8), (char_u *)"Ins"}, 
        {253 + (69 << 8), (char_u *)"kInsert"}, 
        {107 + (104 << 8), (char_u *)"Home"}, 
        {75 + (49 << 8), (char_u *)"kHome"}, 
        {253 + (60 << 8), (char_u *)"xHome"}, 
        {64 + (55 << 8), (char_u *)"End"}, 
        {75 + (52 << 8), (char_u *)"kEnd"}, 
        {253 + (59 << 8), (char_u *)"xEnd"}, 
        {107 + (80 << 8), (char_u *)"PageUp"}, 
        {107 + (78 << 8), (char_u *)"PageDown"}, 
        {75 + (51 << 8), (char_u *)"kPageUp"}, 
        {75 + (53 << 8), (char_u *)"kPageDown"}, 
        {75 + (54 << 8), (char_u *)"kPlus"}, 
        {75 + (55 << 8), (char_u *)"kMinus"}, 
        {75 + (56 << 8), (char_u *)"kDivide"}, 
        {75 + (57 << 8), (char_u *)"kMultiply"}, 
        {75 + (65 << 8), (char_u *)"kEnter"}, 
        {'<', (char_u *)"lt"}, 
        {251 + (88 << 8), (char_u *)"Mouse"}, 
        {253 + (42 << 8), (char_u *)"LeftMouse"}, 
        {253 + (61 << 8), (char_u *)"LeftMouseNM"}, 
        {253 + (43 << 8), (char_u *)"LeftDrag"}, 
        {253 + (44 << 8), (char_u *)"LeftRelease"}, 
        {253 + (62 << 8), (char_u *)"LeftReleaseNM"}, 
        {253 + (45 << 8), (char_u *)"MiddleMouse"}, 
        {253 + (46 << 8), (char_u *)"MiddleDrag"}, 
        {253 + (47 << 8), (char_u *)"MiddleRelease"}, 
        {253 + (48 << 8), (char_u *)"RightMouse"}, 
        {253 + (49 << 8), (char_u *)"RightDrag"}, 
        {253 + (50 << 8), (char_u *)"RightRelease"}, 
        {253 + (67 << 8), (char_u *)"MouseDown"}, 
        {253 + (68 << 8), (char_u *)"MouseUp"}, 
        {255 + (88 << 8), (char_u *)"Nul"}, 
        {0, (char_u *)((void *)0)}};
static struct mousetable mouse_table[12]  = 
  {      {42, 0, 1, 0}, 
        {43, 0, 0, 1}, 
        {44, 0, 0, 0}, 
        {45, 1, 1, 0}, 
        {46, 1, 0, 1}, 
        {47, 1, 0, 0}, 
        {48, 2, 1, 0}, 
        {49, 2, 0, 1}, 
        {50, 2, 0, 0}, 
        {51, 3, 0, 1}, 
        {51, 3, 0, 0}, 
        {0, 0, 0, 0}};
int name_to_mod_mask(int c ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (c <= 255) {
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! mod_mask_table[i___0].mod_mask) {

      }
      {
      tmp = tolower(c);
      tmp___0 = tolower((int )mod_mask_table[i___0].name);
      }
      if (tmp == tmp___0) {
        return (mod_mask_table[i___0].mod_mask);
      }
      i___0 ++;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  return (0);
}
}
int simplify_key(int key , int *modifiers ) 
{ 
  int i___0 ;
  int key0 ;
  int key1 ;

  {
  if (*modifiers & 2) {
    if (key == 9) {


    }
    key0 = key & 255;
    key1 = (int )(((unsigned int )key >> 8) & 255U);
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((int )shifted_keys_table[i___0] != 0)) {

      }
      if (key0 == (int )shifted_keys_table[i___0 + 2]) {
        if (key1 == (int )shifted_keys_table[i___0 + 3]) {
          *modifiers &= -3;
          return ((int )shifted_keys_table[i___0] + ((int )shifted_keys_table[i___0 + 1] << 8));
        }
      }
      i___0 += 4;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  return (key);
}
}
static char_u string[24]  ;
char_u *get_special_key_name(int c , int modifiers ) 
{ 
  int i___0 ;
  int idx ;
  int table_idx ;
  char_u *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  string[0] = (char_u )'<';
  idx = 1;
  if (c >= 512) {
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! shifted_keys_table[i___0]) {
        goto while_break;
      }
      if ((c & 255) == (int )shifted_keys_table[i___0]) {
        if ((((unsigned int )c >> 8) & 255U) == (unsigned int )shifted_keys_table[i___0 + 1]) {
          modifiers |= 2;
          c = (int )shifted_keys_table[i___0 + 2] + ((int )shifted_keys_table[i___0 + 3] << 8);
          goto while_break;
        }
      }
      i___0 += 4;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  {
  table_idx = find_special_key_in_table(c);
  }
  if (table_idx < 0) {
    {

    }














  }
  if (table_idx < 0) {
    {

    }






  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! mod_mask_table[i___0].mod_mask) {
      goto while_break___0;
    }
    if (modifiers & mod_mask_table[i___0].mod_mask) {
      tmp___1 = idx;
      idx ++;
      string[tmp___1] = mod_mask_table[i___0].name;
      tmp___2 = idx;
      idx ++;
      string[tmp___2] = (char_u )'-';
    }
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (table_idx < 0) {









































  } else {
    {
    strcpy((char * __restrict  )((char *)(string + idx)), (char const   * __restrict  )((char *)key_names_table[table_idx].name));
    tmp___11 = strlen((char const   *)((char *)(string)));
    idx = (int )tmp___11;
    }
  }
  tmp___12 = idx;
  idx ++;
  string[tmp___12] = (char_u )'>';
  string[idx] = (char_u )'\000';
  return (string);
}
}
int trans_special(char_u **srcp , char_u *dst , int keycode ) 
{ 
  int modifiers ;
  int key ;
  int dlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  dlen = 0;
  key = find_special_key(srcp, & modifiers, keycode);
  }
  if (key == 0) {

  }
  if (modifiers != 0) {









  }
  if (key >= 512) {
    tmp___2 = dlen;
    dlen ++;
    *(dst + tmp___2) = (char_u )128;
    tmp___3 = dlen;
    dlen ++;
    *(dst + tmp___3) = (char_u )(key & 255);
    tmp___4 = dlen;
    dlen ++;
    *(dst + tmp___4) = (char_u )(((unsigned int )key >> 8) & 255U);
  } else {



  }
  return (dlen);
}
}
int find_special_key(char_u **srcp , int *modp , int keycode ) 
{ 
  char_u *last_dash ;
  char_u *end_of_name ;
  char_u *src ;
  char_u *bp___0 ;
  int modifiers ;
  int bit ;
  int key ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  src = *srcp;
  if ((int )*(src + 0) != 60) {

  }
  last_dash = src;
  bp___0 = src + 1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*bp___0 == 45)) {
      {
      tmp = vim_isIDc((int )*bp___0);
      }
      if (! tmp) {
        goto while_break;
      }
    }
    if ((int )*bp___0 == 45) {
      last_dash = bp___0;
      if ((int )*(bp___0 + 1) != 0) {
        if ((int )*(bp___0 + 2) == 62) {

        }
      }
    }
    if ((int )*(bp___0 + 0) == 116) {







    }
    bp___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*bp___0 == 62) {
    end_of_name = bp___0 + 1;
    modifiers = 0;
    bp___0 = src + 1;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! ((unsigned long )bp___0 < (unsigned long )last_dash)) {
        goto while_break___0;
      }
      if ((int )*bp___0 != 45) {
        {
        bit = name_to_mod_mask((int )*bp___0);
        }
        if (bit == 0) {

        }
        modifiers |= bit;
      }
      bp___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((unsigned long )bp___0 >= (unsigned long )last_dash) {
      if (modifiers != 0) {
        if ((int )*(last_dash + 2) == 62) {

        } else {
          {
          key = get_special_key_code(last_dash + 1);
          }
        }
      } else {
        {
        key = get_special_key_code(last_dash + 1);
        }
      }
      if (key != 0) {
        {
        key = simplify_key(key, & modifiers);
        }
        if (! keycode) {











        }
        if (! (key >= 512)) {








































        }
        *modp = modifiers;
        *srcp = end_of_name;
        return (key);
      }
    }
  }

}
}
int find_special_key_in_table(int c ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )key_names_table[i___0].name != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (c == key_names_table[i___0].key) {
      goto while_break;
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )key_names_table[i___0].name == (unsigned long )((void *)0)) {
    i___0 = -1;
  }
  return (i___0);
}
}
int get_special_key_code(char_u *name___1 ) 
{ 
  char_u *table_name ;
  char_u string___0[3] ;
  int i___0 ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )*(name___1 + 0) == 116) {





















  } else {
    _L___1: ;
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((unsigned long )key_names_table[i___0].name != (unsigned long )((void *)0))) {

      }
      table_name = key_names_table[i___0].name;
      j = 0;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        tmp___2 = vim_isIDc((int )*(name___1 + j));
        }
        if (tmp___2) {
          if (! ((int )*(table_name + j) != 0)) {

          }
        } else {
          goto while_break___0;
        }
        {
        tmp___0 = tolower((int )*(table_name + j));
        tmp___1 = tolower((int )*(name___1 + j));
        }
        if (tmp___0 != tmp___1) {
          goto while_break___0;
        }
        j ++;
      }
      while_break___0: ;/* CIL Label */ ;
      }
      {
      tmp___3 = vim_isIDc((int )*(name___1 + j));
      }
      if (! tmp___3) {
        if ((int )*(table_name + j) == 0) {
          return (key_names_table[i___0].key);
        }
      }
      i___0 ++;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  return (0);
}
}
char_u *get_key_name(int i___0 ) 
{








}
int get_mouse_button(int code , int *is_click , int *is_drag ) 
{





















}
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) 
{























}
int get_fileformat(BUF *buf___3 ) 
{ 
  int c ;

  {
  c = (int )*(buf___3->b_p_ff);
  if (buf___3->b_p_bin) {
    return (0);
  } else { //Added block
  if (c == 117) {
    return (0);
  }
  }
  if (c == 109) {

  }
  return (1);
}
}
void set_fileformat(int t ) 
{ 


  {
  {
  if (t == 1) {
    goto case_1;
  }
  if (t == 0) {
    goto case_0;
  }




  case_1: ;/* CIL Label */ 
  {
  set_string_option_direct((char_u *)"ff", -1, (char_u *)"dos", 1);
  curbuf->b_p_tx = 1;
  }
  goto switch_break;
  case_0: ;/* CIL Label */ 
  {
  set_string_option_direct((char_u *)"ff", -1, (char_u *)"unix", 1);
  curbuf->b_p_tx = 0;
  }
  goto switch_break;
  case_2: ;/* CIL Label */ 
  {


  }

  switch_break: ;/* CIL Label */ ;
  }
  {
  check_status(curbuf);
  }
  return;
}
}
int default_fileformat(void) 
{



















}
int call_shell(char_u *cmd , int opt ) 
{ 
  char_u *ncmd ;
  int retval ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  tag_freematch();
  }
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {

    }
  } else { //Added block
  if ((int )*p_sxq == 0) {
    {
    retval = mch_call_shell(cmd, opt);
    }
  } else {
    {



    }











  }
  }
  {
  set_vim_var_nr(5, (long )retval);
  }
  return (retval);
}
}
int get_real_state(void) 
{ 


  {
  if (State & 1) {
    if (VIsual_active) {
      return (2);
    } else { //Added block
    if (finish_op) {
      return (4);
    }
    }
  }
  return (State);
}
}
int vim_chdirfile(char_u *fname ) 
{



































}
ulg crc_32_tab[256]  = 
  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
static ulg keys[3]  ;
int decrypt_byte(void) 
{






}
int update_keys(int c ) 
{









}
void crypt_init_keys(char_u *passwd ) 
{


























}
char_u *get_crypt_key(int store ) 
{





















}
static char_u *name  =    (char_u *)((void *)0);
int get_user_name(char_u *buf___3 , int len___0 ) 
{ 
  int tmp ;

  {
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
    tmp = mch_get_user_name(buf___3, len___0);
    }
    if (tmp == 0) {

    }
    {
    name = vim_strsave(buf___3);
    }
  } else {
    {
    strncpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)name),
            (size_t )len___0);
    }
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-kll2qSdF.i","-O0")
#pragma merger("0","/tmp/cil-NdJb9vp2.i","-O0")
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) ;
void check_visual_highlight(void) ;
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) ;
void may_start_select(int c ) ;
int get_op_type(int char1 , int char2 ) ;
int op_on_lines(int op ) ;
int get_op_char(int optype ) ;
int get_extra_op_char(int optype ) ;
void op_reindent(OPARG *oap , int (*how)(void) ) ;
int yank_register_mline(int regname___0 ) ;
int do_record(int c ) ;
int op_replace(OPARG *oap , int c ) ;
void op_tilde(OPARG *oap ) ;
void swapchar(int op_type , FPOS *pos___0 ) ;
void op_insert(OPARG *oap , long count1 ) ;
int op_change(OPARG *oap ) ;
void op_format(OPARG *oap ) ;
int do_addsub(int command , linenr_t Prenum1 ) ;
void update_other_win(void) ;
void scroll_cursor_top(int min_scroll , int always ) ;
void scroll_cursor_bot(int min_scroll , int set_topbot ) ;
void validate_botline(void) ;
void halfpage(int flag , linenr_t Prenum ) ;
int searchc(int c , int dir , int type , long count___2 ) ;
int findsent(int dir , long count___2 ) ;
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) ;
int end_word(long count___2 , int type , int stop , int empty ) ;
int bckend_word(long count___2 , int type , int eol ) ;
int current_word(OPARG *oap , long count___2 , int include , int type ) ;
int current_sent(OPARG *oap , long count___2 , int include ) ;
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) ;
int current_par(OPARG *oap , long count___2 , int include , int type ) ;
int mouse_model_popup(void) ;
void clip_auto_select(void) ;
void u_undoline(void) ;
void do_window(int nchar , long Prenum ) ;
static int resel_VIsual_mode  =    '\000';
static linenr_t resel_VIsual_line_count  ;
static colnr_t resel_VIsual_col  ;
static void op_colon(OPARG *oap ) ;
static void find_start_of_word(FPOS *pos___0 ) ;
static void find_end_of_word(FPOS *pos___0 ) ;
static int get_mouse_class(int c ) ;
static void prep_redo_cmd(CMDARG *cap ) ;
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) ;
static int checkclearop(OPARG *oap ) ;
static int checkclearopq(OPARG *oap ) ;
static void clearop(OPARG *oap ) ;
static void clearopbeep(OPARG *oap ) ;
static void del_from_showcmd(int len___0 ) ;
static void nv_gd(OPARG *oap , int nchar ) ;
static int nv_screengo(OPARG *oap , int dir , long dist ) ;
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) ;
static void nv_zet(CMDARG *cap ) ;
static void nv_colon(CMDARG *cap ) ;
static void nv_ctrlg(CMDARG *cap ) ;
static void nv_zzet(CMDARG *cap ) ;
static void nv_ident(CMDARG *cap , char_u **searchp ) ;
static void nv_scroll(CMDARG *cap ) ;
static void nv_right(CMDARG *cap ) ;
static int nv_left(CMDARG *cap ) ;
static void nv_gotofile(CMDARG *cap ) ;
static void nv_dollar(CMDARG *cap ) ;
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) ;
static void nv_next(CMDARG *cap , int flag ) ;
static void nv_csearch(CMDARG *cap , int dir , int type ) ;
static void nv_brackets(CMDARG *cap , int dir ) ;
static void nv_percent(CMDARG *cap ) ;
static void nv_brace(CMDARG *cap , int dir ) ;
static void nv_findpar(CMDARG *cap , int dir ) ;
static int nv_Replace(CMDARG *cap ) ;
static int nv_VReplace(CMDARG *cap ) ;
static int nv_vreplace(CMDARG *cap ) ;
static void v_swap_corners(CMDARG *cap ) ;
static int nv_replace(CMDARG *cap ) ;
static void n_swapchar(CMDARG *cap ) ;
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) ;
static void v_visop(CMDARG *cap ) ;
static void nv_optrans(CMDARG *cap ) ;
static void nv_gomark(CMDARG *cap , int flag ) ;
static void nv_pcmark(CMDARG *cap ) ;
static void nv_regname(CMDARG *cap , linenr_t *opnump ) ;
static void nv_visual(CMDARG *cap , int selectmode ) ;
static void n_start_visual_mode(int c ) ;
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) ;
static int n_opencmd(CMDARG *cap ) ;
static void nv_Undo(CMDARG *cap ) ;
static void nv_operator(CMDARG *cap ) ;
static void nv_lineop(CMDARG *cap ) ;
static void nv_pipe(CMDARG *cap ) ;
static void nv_bck_word(CMDARG *cap , int type ) ;
static void nv_wordcmd(CMDARG *cap , int type ) ;
static void adjust_for_sel(CMDARG *cap ) ;
static void unadjust_for_sel(void) ;
static void nv_goto(CMDARG *cap , linenr_t lnum ) ;
static void nv_select(CMDARG *cap ) ;
static void nv_normal(CMDARG *cap ) ;
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) ;
static int nv_edit(CMDARG *cap ) ;
static void nv_object(CMDARG *cap ) ;
static void nv_q(CMDARG *cap ) ;
static void nv_at(CMDARG *cap ) ;
static void nv_halfpage(CMDARG *cap ) ;
static void nv_join(CMDARG *cap ) ;
static void nv_put(CMDARG *cap ) ;
static linenr_t opnum  =    (linenr_t )0;
static int restart_VIsual_select  =    0;
static int old_mapped_len  =    0;
static int seltab[42]  = 
  {      37 + (105 << 8),      107 + (114 << 8),      1,      35 + (52 << 8), 
        107 + (108 << 8),      1,      253 + (4 << 8),      107 + (117 << 8), 
        1,      253 + (5 << 8),      107 + (100 << 8),      1, 
        35 + (50 << 8),      107 + (104 << 8),      1,      42 + (55 << 8), 
        64 + (55 << 8),      1,      75 + (49 << 8),      75 + (49 << 8), 
        0,      253 + (60 << 8),      253 + (60 << 8),      0, 
        75 + (52 << 8),      75 + (52 << 8),      0,      253 + (59 << 8), 
        75 + (52 << 8),      0,      107 + (80 << 8),      107 + (80 << 8), 
        0,      75 + (51 << 8),      75 + (51 << 8),      0, 
        107 + (78 << 8),      107 + (78 << 8),      0,      75 + (53 << 8), 
        75 + (53 << 8),      0};
void normal_cmd(OPARG *oap , int toplevel ) 
{ 
  CMDARG ca ;
  int c ;
  int flag ;
  int type ;
  int dir ;
  char_u *searchbuff ;
  int command_busy ;
  int ctrl_w ;
  int old_col ;
  int dont_adjust_op_end ;
  FPOS old_pos ;
  int need_flushbuf ;
  int mapped_len ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int i___0 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char_u *tmp___31 ;
  int save_State ;
  char_u *kmsg ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  {
  flag = 0;
  type = 0;
  dir = 1;
  searchbuff = (char_u *)((void *)0);
  command_busy = 0;
  ctrl_w = 0;
  old_col = (int )curwin->w_curswant;
  dont_adjust_op_end = 0;
  do_check_scrollbind(0);
  memset((void *)(& ca), 0, sizeof(ca));
  ca.oap = oap;
  finish_op = oap->op_type != 0;
  }
  if (! finish_op) {
    if (! oap->regname) {
      opnum = (linenr_t )0;
    }
  }
  {
  mapped_len = typebuf_maplen();
  State = 257;
  c = safe_vgetc();
  }
  if (! restart_edit) {
    old_mapped_len = 0;
  } else { //Added block


















  }
  if (c == 0) {

  } else { //Added block
  if (c == 75 + (57 << 8)) {

  } else { //Added block
  if (c == 75 + (55 << 8)) {

  } else { //Added block
  if (c == 75 + (54 << 8)) {

  } else { //Added block
  if (c == 75 + (56 << 8)) {

  }
  }
  }
  }
  }
  if (VIsual_active) {
    if (VIsual_select) {
      {

      }



























    }
    {
    tmp___1 = vim_strchr(p_km, 'o');
    }
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {























































      case_exp: ;/* CIL Label */ 
      case_16: ;/* CIL Label */ 
      case_exp___0: ;/* CIL Label */ 
      case_14: ;/* CIL Label */ 
      case_exp___1: ;/* CIL Label */ 
      case_exp___2: ;/* CIL Label */ 
      case_2: ;/* CIL Label */ 
      case_exp___3: ;/* CIL Label */ 
      case_exp___4: ;/* CIL Label */ 
      case_6: ;/* CIL Label */ 
      case_exp___5: ;/* CIL Label */ 
      case_exp___6: ;/* CIL Label */ 
      case_exp___7: ;/* CIL Label */ 
      case_exp___8: ;/* CIL Label */ 
      case_exp___9: ;/* CIL Label */ 
      case_exp___10: ;/* CIL Label */ 
      case_exp___11: ;/* CIL Label */ 
      case_exp___12: ;/* CIL Label */ 







      switch_break: ;/* CIL Label */ ;
      }
    }
    {
    tmp___2 = vim_strchr(p_km, 'a');
    }
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {











































      case_exp___13: ;/* CIL Label */ 


      case_exp___14: ;/* CIL Label */ 


      case_exp___15: ;/* CIL Label */ 


      case_exp___16: ;/* CIL Label */ 


      case_exp___17: ;/* CIL Label */ 


      case_exp___18: ;/* CIL Label */ 


      case_exp___19: ;/* CIL Label */ 
      case_exp___20: ;/* CIL Label */ 
      case_exp___21: ;/* CIL Label */ 
      case_exp___22: ;/* CIL Label */ 
      case_exp___23: ;/* CIL Label */ 
      case_exp___24: ;/* CIL Label */ 
      case_exp___25: ;/* CIL Label */ 
      case_exp___26: ;/* CIL Label */ 


      switch_break___0: ;/* CIL Label */ ;
      }
    }
  }
  {
  need_flushbuf = add_to_showcmd(c);
  }
  getcount: ;
  if (VIsual_active) {
    if (! VIsual_select) {
      goto _L___0;
    }
  } else {
    _L___0: ;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (c >= 49) {
        if (! (c <= 57)) {
          goto _L;
        }
      } else { //Added block
      _L: ;
      if (ca.count0 != 0L) {
        if (! (c == 107 + (68 << 8))) {
          if (! (c == 253 + (70 << 8))) {
            if (! (c == 48)) {
              goto while_break;
            }
          }
        }
      } else {
        goto while_break;
      }
      }
      if (c == 107 + (68 << 8)) {
        {


        }
      } else { //Added block
      if (c == 253 + (70 << 8)) {
        {


        }
      } else {
        ca.count0 = ca.count0 * 10L + (long )(c - 48);
      }
      }
      if (ca.count0 < 0L) {

      }
      if (ctrl_w) {


      }
      {
      c = safe_vgetc();
      }
      if (ctrl_w) {


      }
      {
      tmp___3 = add_to_showcmd(c);
      need_flushbuf |= tmp___3;
      }
    }
    while_break: ;/* CIL Label */ ;
    }
    if (c == 23) {
      if (! ctrl_w) {















      }
    }
  }
  ca.cmdchar = c;
  if (opnum != 0L) {





  }
  opnum = ca.count0;
  if (ca.count0 == 0L) {
    ca.count1 = 1L;
  } else {
    ca.count1 = ca.count0;
  }
  if (toplevel) {
    {
    set_vim_var_nr(0, ca.count0);
    set_vim_var_nr(1, ca.count1);
    }
  }
  if (ctrl_w) {


  } else { //Added block
  if (oap->op_type == 0) {
    {
    tmp___7 = vim_strchr((char_u *)"@zm\"", ca.cmdchar);
    }
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      goto _L___2;
    } else {
      goto _L___8;
    }
  } else { //Added block
  _L___8: ;
  if (oap->op_type == 0) {
    if (ca.cmdchar == 114) {
      goto _L___2;
    } else { //Added block
    if (! VIsual_active) {
      if (ca.cmdchar == 90) {
        goto _L___2;
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
    }
  } else {
    _L___7: ;
    {
    tmp___8 = vim_strchr((char_u *)"tTfF[]g\'`", ca.cmdchar);
    }
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
      goto _L___2;
    } else { //Added block
    if (ca.cmdchar == 113) {













    } else { //Added block
    _L___6: ;
    if (ca.cmdchar == 97) {
      goto _L___3;
    } else { //Added block
    if (ca.cmdchar == 105) {
      _L___3: ;
      if (oap->op_type != 0) {
        goto _L___2;
      } else { //Added block
      if (VIsual_active) {
        _L___2: ;
        no_mapping ++;
        allow_keys ++;
        if (ca.cmdchar == 103) {
          {
          ca.nchar = safe_vgetc();
          }
        }
        if (ca.cmdchar != 103) {
          {
          ca.nchar = safe_vgetc();
          }
        } else { //Added block
        if (ca.nchar == 114) {
          {

          }
        }
        }
        {
        no_mapping --;
        allow_keys --;
        tmp___5 = add_to_showcmd(ca.nchar);
        need_flushbuf |= tmp___5;
        }
        if (ca.cmdchar == 103) {
          if (ca.nchar == 114) {
            {


            }
          }
        }
      }
      }
    }
    }
    }
    }
  }
  }
  }
  if (need_flushbuf) {
    {

    }
  }
  State = 1;
  if (ca.nchar == 27) {
    {

    }






  }
  if (! VIsual_active) {
    {
    tmp___9 = vim_strchr(p_km, 'a');
    }
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {

      {
























      while_break___0: ;/* CIL Label */ ;
      }
    }
  }
  msg_didout = 0;
  msg_col = 0;
  old_pos = curwin->w_cursor;
  {
  if (ca.cmdchar == 113) {

  }
  if (ca.cmdchar == 64) {

  }
  if (ca.cmdchar == 4) {
    goto case_4;
  }
  if (ca.cmdchar == 21) {
    goto case_4;
  }
  if (ca.cmdchar == 2) {
    goto case_2___0;
  }
  if (ca.cmdchar == 253 + (4 << 8)) {

  }
  if (ca.cmdchar == 107 + (80 << 8)) {

  }
  if (ca.cmdchar == 75 + (51 << 8)) {

  }
  if (ca.cmdchar == 6) {
    goto case_6___0;
  }
  if (ca.cmdchar == 253 + (5 << 8)) {

  }
  if (ca.cmdchar == 107 + (78 << 8)) {

  }
  if (ca.cmdchar == 75 + (53 << 8)) {

  }
  if (ca.cmdchar == 5) {
    goto case_5;
  }
  if (ca.cmdchar == 25) {
    goto case_25;
  }
  if (ca.cmdchar == 253 + (68 << 8)) {

  }
  if (ca.cmdchar == 253 + (67 << 8)) {

  }
  if (ca.cmdchar == 122) {
    goto case_122;
  }
  if (ca.cmdchar == 58) {
    goto case_58;
  }
  if (ca.cmdchar == 81) {
    goto case_81;
  }
  if (ca.cmdchar == 37 + (49 << 8)) {

  }
  if (ca.cmdchar == 107 + (49 << 8)) {

  }
  if (ca.cmdchar == 253 + (55 << 8)) {

  }
  if (ca.cmdchar == 12) {

  }
  if (ca.cmdchar == 7) {
    goto case_7;
  }
  if (ca.cmdchar == 30) {

  }
  if (ca.cmdchar == 90) {
    goto case_90;
  }
  if (ca.cmdchar == 163) {

  }
  if (ca.cmdchar == 29) {

  }
  if (ca.cmdchar == 75) {
    goto case_29;
  }
  if (ca.cmdchar == 42) {
    goto case_29;
  }
  if (ca.cmdchar == 75 + (57 << 8)) {

  }
  if (ca.cmdchar == 35) {
    goto case_29;
  }
  if (ca.cmdchar == 20) {

  }
  if (ca.cmdchar == 71) {
    goto case_71;
  }
  if (ca.cmdchar == 72) {
    goto case_72;
  }
  if (ca.cmdchar == 77) {
    goto case_72;
  }
  if (ca.cmdchar == 76) {
    goto case_72;
  }
  if (ca.cmdchar == 107 + (114 << 8)) {

  }
  if (ca.cmdchar == 108) {
    goto case_108;
  }
  if (ca.cmdchar == 32) {
    goto case_108;
  }
  if (ca.cmdchar == 107 + (108 << 8)) {

  }
  if (ca.cmdchar == 104) {
    goto case_104;
  }
  if (ca.cmdchar == 107 + (98 << 8)) {

  }
  if (ca.cmdchar == 8) {

  }
  if (ca.cmdchar == 45) {

  }
  if (ca.cmdchar == 75 + (55 << 8)) {

  }
  if (ca.cmdchar == 107) {
    goto case_107;
  }
  if (ca.cmdchar == 107 + (117 << 8)) {

  }
  if (ca.cmdchar == 16) {

  }
  if (ca.cmdchar == 43) {
    goto case_43;
  }
  if (ca.cmdchar == 75 + (54 << 8)) {

  }
  if (ca.cmdchar == 13) {
    goto case_43;
  }
  if (ca.cmdchar == 75 + (65 << 8)) {

  }
  if (ca.cmdchar == 106) {
    goto case_106;
  }
  if (ca.cmdchar == 107 + (100 << 8)) {

  }
  if (ca.cmdchar == 14) {

  }
  if (ca.cmdchar == 10) {

  }
  if (ca.cmdchar == 95) {
    goto case_95;
  }
  if (ca.cmdchar == 107 + (104 << 8)) {

  }
  if (ca.cmdchar == 75 + (49 << 8)) {

  }
  if (ca.cmdchar == 253 + (60 << 8)) {

  }
  if (ca.cmdchar == 35 + (50 << 8)) {

  }
  if (ca.cmdchar == 124) {
    goto case_124;
  }
  if (ca.cmdchar == 66) {
    goto case_66;
  }
  if (ca.cmdchar == 98) {
    goto case_98;
  }
  if (ca.cmdchar == 35 + (52 << 8)) {

  }
  if (ca.cmdchar == 69) {
    goto case_69;
  }
  if (ca.cmdchar == 101) {
    goto case_101;
  }
  if (ca.cmdchar == 87) {
    goto case_87;
  }
  if (ca.cmdchar == 119) {
    goto case_119;
  }
  if (ca.cmdchar == 37 + (105 << 8)) {

  }
  if (ca.cmdchar == 64 + (55 << 8)) {

  }
  if (ca.cmdchar == 75 + (52 << 8)) {

  }
  if (ca.cmdchar == 253 + (59 << 8)) {

  }
  if (ca.cmdchar == 42 + (55 << 8)) {

  }
  if (ca.cmdchar == 36) {
    goto case_36;
  }
  if (ca.cmdchar == 94) {
    goto case_94;
  }
  if (ca.cmdchar == 48) {
    goto case_48;
  }
  if (ca.cmdchar == 75 + (56 << 8)) {

  }
  if (ca.cmdchar == 63) {
    goto case_63;
  }
  if (ca.cmdchar == 47) {
    goto case_63;
  }
  if (ca.cmdchar == 78) {
    goto case_78;
  }
  if (ca.cmdchar == 110) {
    goto case_110;
  }
  if (ca.cmdchar == 84) {
    goto case_84;
  }
  if (ca.cmdchar == 116) {
    goto case_116;
  }
  if (ca.cmdchar == 70) {
    goto case_70;
  }
  if (ca.cmdchar == 102) {
    goto case_102;
  }
  if (ca.cmdchar == 44) {
    goto case_44;
  }
  if (ca.cmdchar == 59) {
    goto case_59;
  }
  if (ca.cmdchar == 91) {

  }
  if (ca.cmdchar == 93) {
    goto case_93;
  }
  if (ca.cmdchar == 37) {
    goto case_37;
  }
  if (ca.cmdchar == 40) {
    goto case_40;
  }
  if (ca.cmdchar == 41) {
    goto case_41;
  }
  if (ca.cmdchar == 123) {
    goto case_123;
  }
  if (ca.cmdchar == 125) {
    goto case_125;
  }
  if (ca.cmdchar == 46) {

  }
  if (ca.cmdchar == 117) {

  }
  if (ca.cmdchar == 38 + (56 << 8)) {

  }
  if (ca.cmdchar == 18) {

  }
  if (ca.cmdchar == 85) {

  }
  if (ca.cmdchar == 114) {
    goto case_114;
  }
  if (ca.cmdchar == 74) {

  }
  if (ca.cmdchar == 80) {

  }
  if (ca.cmdchar == 112) {

  }
  if (ca.cmdchar == 1) {

  }
  if (ca.cmdchar == 24) {

  }
  if (ca.cmdchar == 65) {

  }
  if (ca.cmdchar == 97) {
    goto case_65;
  }
  if (ca.cmdchar == 73) {

  }
  if (ca.cmdchar == 105) {
    goto case_65;
  }
  if (ca.cmdchar == 107 + (73 << 8)) {

  }
  if (ca.cmdchar == 253 + (69 << 8)) {

  }
  if (ca.cmdchar == 111) {

  }
  if (ca.cmdchar == 79) {

  }
  if (ca.cmdchar == 82) {

  }
  if (ca.cmdchar == 126) {

  }
  if (ca.cmdchar == 100) {
    goto case_100;
  }
  if (ca.cmdchar == 99) {

  }
  if (ca.cmdchar == 121) {
    goto case_100;
  }
  if (ca.cmdchar == 62) {

  }
  if (ca.cmdchar == 60) {
    goto case_100;
  }
  if (ca.cmdchar == 33) {

  }
  if (ca.cmdchar == 61) {

  }
  if (ca.cmdchar == 83) {

  }
  if (ca.cmdchar == 115) {

  }
  if (ca.cmdchar == 107 + (68 << 8)) {

  }
  if (ca.cmdchar == 253 + (70 << 8)) {

  }
  if (ca.cmdchar == 89) {

  }
  if (ca.cmdchar == 68) {
    goto case_exp___61;
  }
  if (ca.cmdchar == 67) {

  }
  if (ca.cmdchar == 120) {

  }
  if (ca.cmdchar == 88) {

  }
  if (ca.cmdchar == 38) {

  }
  if (ca.cmdchar == 109) {
    goto case_109;
  }
  if (ca.cmdchar == 39) {
    goto case_39;
  }
  if (ca.cmdchar == 96) {

  }
  if (ca.cmdchar == 15) {
    goto case_15;
  }
  if (ca.cmdchar == 9) {
    goto case_9;
  }
  if (ca.cmdchar == 34) {
    goto case_34;
  }
  if (ca.cmdchar == 118) {
    goto case_118;
  }
  if (ca.cmdchar == 86) {

  }
  if (ca.cmdchar == 22) {

  }
  if (ca.cmdchar == 26) {

  }
  if (ca.cmdchar == 23) {

  }
  if (ca.cmdchar == 103) {
    goto case_103;
  }
  if (ca.cmdchar == 253 + (42 << 8)) {

  }
  if (ca.cmdchar == 253 + (61 << 8)) {

  }
  if (ca.cmdchar == 253 + (43 << 8)) {

  }
  if (ca.cmdchar == 253 + (44 << 8)) {

  }
  if (ca.cmdchar == 253 + (62 << 8)) {

  }
  if (ca.cmdchar == 253 + (45 << 8)) {

  }
  if (ca.cmdchar == 253 + (46 << 8)) {

  }
  if (ca.cmdchar == 253 + (47 << 8)) {

  }
  if (ca.cmdchar == 253 + (48 << 8)) {

  }
  if (ca.cmdchar == 253 + (49 << 8)) {

  }
  if (ca.cmdchar == 253 + (50 << 8)) {

  }
  if (ca.cmdchar == 253 + (51 << 8)) {

  }
  if (ca.cmdchar == 245 + (88 << 8)) {

  }
  if (ca.cmdchar == 28) {

  }
  if (ca.cmdchar == 3) {

  }
  if (ca.cmdchar == 27) {
    goto case_27;
  }

  case_113: ;/* CIL Label */ 
  {

  }

  case_64: ;/* CIL Label */ 
  {

  }

  case_4: ;/* CIL Label */ 
  case_21: ;/* CIL Label */ 
  {
  nv_halfpage(& ca);
  }
  goto switch_break___1;
  case_2___0: ;/* CIL Label */ 
  case_exp___27: ;/* CIL Label */ 
  case_exp___28: ;/* CIL Label */ 
  case_exp___29: ;/* CIL Label */ 
  dir = -1;
  case_6___0: ;/* CIL Label */ 
  case_exp___30: ;/* CIL Label */ 
  case_exp___31: ;/* CIL Label */ 
  case_exp___32: ;/* CIL Label */ 
  {
  tmp___10 = checkclearop(oap);
  }
  if (tmp___10) {

  }
  {
  onepage(dir, ca.count1);
  }
  goto switch_break___1;
  case_5: ;/* CIL Label */ 
  flag = 1;
  case_25: ;/* CIL Label */ 
  {
  nv_scroll_line(& ca, flag);
  }
  goto switch_break___1;
  case_exp___33: ;/* CIL Label */ 

  case_exp___34: ;/* CIL Label */ 

















  case_122: ;/* CIL Label */ 
  {
  tmp___12 = checkclearop(oap);
  }
  if (! tmp___12) {
    {
    nv_zet(& ca);
    }
  }
  goto switch_break___1;
  case_58: ;/* CIL Label */ 
  {
  nv_colon(& ca);
  }
  goto switch_break___1;
  case_81: ;/* CIL Label */ 
  if (VIsual_active) {
    {

    }
  } else {
    {
    tmp___13 = checkclearop(oap);
    }
    if (! tmp___13) {
      {
      do_exmode();
      }
    }
  }
  goto switch_break___1;
  case_exp___35: ;/* CIL Label */ 
  case_exp___36: ;/* CIL Label */ 
  case_exp___37: ;/* CIL Label */ 
  {

  }






  case_12: ;/* CIL Label */ 
  {

  }






  case_7: ;/* CIL Label */ 
  {
  nv_ctrlg(& ca);
  }
  goto switch_break___1;
  case_30: ;/* CIL Label */ 
  {

  }






  case_90: ;/* CIL Label */ 
  {
  nv_zzet(& ca);
  }
  goto switch_break___1;
  case_163: ;/* CIL Label */ 

  case_29: ;/* CIL Label */ 
  case_75: ;/* CIL Label */ 
  case_42: ;/* CIL Label */ 
  case_exp___38: ;/* CIL Label */ 
  case_35: ;/* CIL Label */ 
  if (ca.cmdchar == 75 + (57 << 8)) {

  }
  {
  nv_ident(& ca, & searchbuff);
  }
  goto switch_break___1;
  case_20: ;/* CIL Label */ 
  {

  }






  case_71: ;/* CIL Label */ 
  {
  nv_goto(& ca, curbuf->b_ml.ml_line_count);
  }
  goto switch_break___1;
  case_72: ;/* CIL Label */ 
  case_77: ;/* CIL Label */ 
  case_76: ;/* CIL Label */ 
  {
  nv_scroll(& ca);
  }
  goto switch_break___1;
  case_exp___39: ;/* CIL Label */ 







  case_108: ;/* CIL Label */ 
  case_32: ;/* CIL Label */ 
  {
  nv_right(& ca);
  }
  goto switch_break___1;
  case_exp___40: ;/* CIL Label */ 






  case_104: ;/* CIL Label */ 
  {
  dont_adjust_op_end = nv_left(& ca);
  }
  goto switch_break___1;
  case_exp___41: ;/* CIL Label */ 
  case_8: ;/* CIL Label */ 

















  case_45: ;/* CIL Label */ 
  case_exp___42: ;/* CIL Label */ 

  case_107: ;/* CIL Label */ 
  case_exp___43: ;/* CIL Label */ 
  case_16___0: ;/* CIL Label */ 
  {
  oap->motion_type = 1;
  tmp___18 = cursor_up(ca.count1, oap->op_type == 0);
  }
  if (tmp___18 == 0) {
    {
    clearopbeep(oap);
    }
  } else { //Added block
  if (flag) {
    {

    }
  }
  }
  goto switch_break___1;
  case_43: ;/* CIL Label */ 
  case_exp___44: ;/* CIL Label */ 
  case_13: ;/* CIL Label */ 
  case_exp___45: ;/* CIL Label */ 
  flag = 1;
  case_106: ;/* CIL Label */ 
  case_exp___46: ;/* CIL Label */ 
  case_14___0: ;/* CIL Label */ 
  case_10: ;/* CIL Label */ 
  {
  oap->motion_type = 1;
  tmp___19 = cursor_down(ca.count1, oap->op_type == 0);
  }
  if (tmp___19 == 0) {
    {
    clearopbeep(oap);
    }
  } else { //Added block
  if (flag) {
    {
    beginline(5);
    }
  }
  }
  goto switch_break___1;
  case_95: ;/* CIL Label */ 
  {
  nv_lineop(& ca);
  }
  goto switch_break___1;
  case_exp___47: ;/* CIL Label */ 
  case_exp___48: ;/* CIL Label */ 
  case_exp___49: ;/* CIL Label */ 
  case_exp___50: ;/* CIL Label */ 







  case_124: ;/* CIL Label */ 
  {
  nv_pipe(& ca);
  }
  goto switch_break___1;
  case_66: ;/* CIL Label */ 
  type = 1;
  case_98: ;/* CIL Label */ 
  case_exp___51: ;/* CIL Label */ 
  {
  nv_bck_word(& ca, type);
  }
  goto switch_break___1;
  case_69: ;/* CIL Label */ 
  type = 1;
  case_101: ;/* CIL Label */ 
  {
  oap->inclusive = 1;
  nv_wordcmd(& ca, type);
  }
  goto switch_break___1;
  case_87: ;/* CIL Label */ 
  type = 1;
  case_119: ;/* CIL Label */ 
  case_exp___52: ;/* CIL Label */ 
  {
  oap->inclusive = 0;
  nv_wordcmd(& ca, type);
  }
  goto switch_break___1;
  case_exp___53: ;/* CIL Label */ 
  case_exp___54: ;/* CIL Label */ 
  case_exp___55: ;/* CIL Label */ 
  case_exp___56: ;/* CIL Label */ 






  case_36: ;/* CIL Label */ 
  {
  nv_dollar(& ca);
  }
  goto switch_break___1;
  case_94: ;/* CIL Label */ 
  flag = 5;
  case_48: ;/* CIL Label */ 
  {
  oap->motion_type = 0;
  oap->inclusive = 0;
  beginline(flag);
  }
  goto switch_break___1;
  case_exp___57: ;/* CIL Label */ 

  case_63: ;/* CIL Label */ 
  case_47: ;/* CIL Label */ 
  {
  nv_search(& ca, & searchbuff, 0);
  }
  goto switch_break___1;
  case_78: ;/* CIL Label */ 
  flag = 1;
  case_110: ;/* CIL Label */ 
  {
  nv_next(& ca, flag);
  }
  goto switch_break___1;
  case_84: ;/* CIL Label */ 
  dir = -1;
  case_116: ;/* CIL Label */ 
  {
  nv_csearch(& ca, dir, 1);
  }
  goto switch_break___1;
  case_70: ;/* CIL Label */ 
  dir = -1;
  case_102: ;/* CIL Label */ 
  {
  nv_csearch(& ca, dir, 0);
  }
  goto switch_break___1;
  case_44: ;/* CIL Label */ 
  flag = 1;
  case_59: ;/* CIL Label */ 
  {
  nv_csearch(& ca, flag, 0);
  }
  goto switch_break___1;
  case_91: ;/* CIL Label */ 

  case_93: ;/* CIL Label */ 
  {
  nv_brackets(& ca, dir);
  }
  goto switch_break___1;
  case_37: ;/* CIL Label */ 
  {
  nv_percent(& ca);
  }
  goto switch_break___1;
  case_40: ;/* CIL Label */ 
  dir = -1;
  case_41: ;/* CIL Label */ 
  {
  nv_brace(& ca, dir);
  }
  goto switch_break___1;
  case_123: ;/* CIL Label */ 
  dir = -1;
  case_125: ;/* CIL Label */ 
  {
  nv_findpar(& ca, dir);
  }
  goto switch_break___1;
  case_46: ;/* CIL Label */ 
  {

  }




















  case_117: ;/* CIL Label */ 

















  case_exp___58: ;/* CIL Label */ 
  {

  }







  case_18: ;/* CIL Label */ 
  {

  }







  case_85: ;/* CIL Label */ 
  {

  }

  case_114: ;/* CIL Label */ 
  {
  command_busy = nv_replace(& ca);
  }
  goto switch_break___1;
  case_74: ;/* CIL Label */ 
  {

  }

  case_80: ;/* CIL Label */ 
  case_112: ;/* CIL Label */ 
  {

  }

  case_1: ;/* CIL Label */ 
  case_24: ;/* CIL Label */ 
  {

  }











  case_65: ;/* CIL Label */ 
  case_97: ;/* CIL Label */ 
  case_73: ;/* CIL Label */ 
  case_105: ;/* CIL Label */ 
  case_exp___59: ;/* CIL Label */ 
  case_exp___60: ;/* CIL Label */ 
  {
  command_busy = nv_edit(& ca);
  }
  goto switch_break___1;
  case_111: ;/* CIL Label */ 
  case_79: ;/* CIL Label */ 










  case_82: ;/* CIL Label */ 
  {

  }

  case_126: ;/* CIL Label */ 
  if (! p_to) {
    if (! VIsual_active) {






    }
  }
  case_100: ;/* CIL Label */ 
  case_99: ;/* CIL Label */ 
  case_121: ;/* CIL Label */ 
  case_62: ;/* CIL Label */ 
  case_60: ;/* CIL Label */ 
  case_33: ;/* CIL Label */ 
  case_61: ;/* CIL Label */ 
  {
  nv_operator(& ca);
  }
  goto switch_break___1;
  case_83: ;/* CIL Label */ 
  case_115: ;/* CIL Label */ 










  case_exp___61: ;/* CIL Label */ 
  case_exp___62: ;/* CIL Label */ 
  case_89: ;/* CIL Label */ 
  case_68: ;/* CIL Label */ 
  case_67: ;/* CIL Label */ 
  case_120: ;/* CIL Label */ 
  case_88: ;/* CIL Label */ 
  if (ca.cmdchar == 107 + (68 << 8)) {

  } else { //Added block
  if (ca.cmdchar == 253 + (70 << 8)) {

  }
  }
  if (VIsual_active) {
    {

    }

  }
  case_38: ;/* CIL Label */ 
  {
  nv_optrans(& ca);
  opnum = (linenr_t )0;
  }
  goto switch_break___1;
  case_109: ;/* CIL Label */ 
  {
  tmp___28 = checkclearop(oap);
  }
  if (! tmp___28) {
    {
    tmp___27 = setmark(ca.nchar);
    }
    if (tmp___27 == 0) {
      {

      }
    }
  }
  goto switch_break___1;
  case_39: ;/* CIL Label */ 
  flag = 1;
  case_96: ;/* CIL Label */ 
  {
  nv_gomark(& ca, flag);
  }
  goto switch_break___1;
  case_15: ;/* CIL Label */ 
  if (VIsual_active) {








  }
  ca.count1 = - ca.count1;
  case_9: ;/* CIL Label */ 
  {
  nv_pcmark(& ca);
  }
  goto switch_break___1;
  case_34: ;/* CIL Label */ 
  {
  nv_regname(& ca, & opnum);
  }
  goto switch_break___1;
  case_118: ;/* CIL Label */ 
  case_86: ;/* CIL Label */ 
  case_22: ;/* CIL Label */ 
  {
  tmp___29 = checkclearop(oap);
  }
  if (! tmp___29) {
    {
    nv_visual(& ca, 0);
    }
  }
  goto switch_break___1;
  case_26: ;/* CIL Label */ 
  {

  }





  {

  }

  case_23: ;/* CIL Label */ 
  {

  }






  case_103: ;/* CIL Label */ 
  {
  command_busy = nv_g_cmd(& ca, & searchbuff);
  }
  goto switch_break___1;
  case_exp___63: ;/* CIL Label */ 
  case_exp___64: ;/* CIL Label */ 
  case_exp___65: ;/* CIL Label */ 
  case_exp___66: ;/* CIL Label */ 
  case_exp___67: ;/* CIL Label */ 
  case_exp___68: ;/* CIL Label */ 
  case_exp___69: ;/* CIL Label */ 
  case_exp___70: ;/* CIL Label */ 
  case_exp___71: ;/* CIL Label */ 
  case_exp___72: ;/* CIL Label */ 
  case_exp___73: ;/* CIL Label */ 
  {

  }

  case_exp___74: ;/* CIL Label */ 

  case_exp___75: ;/* CIL Label */ 
  {

  }

  case_28: ;/* CIL Label */ 
  {

  }

  case_3: ;/* CIL Label */ 

  case_27: ;/* CIL Label */ 
  {
  nv_esc(& ca, opnum);
  }
  goto switch_break___1;
  switch_default: ;/* CIL Label */ 
  {

  }

  switch_break___1: ;/* CIL Label */ ;
  }
  if (! finish_op) {
    if (! oap->op_type) {
      {
      tmp___31 = vim_strchr((char_u *)"\"DCYSsXx.", ca.cmdchar);
      }
      if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
        oap->regname = 0;
      }
    }
  }
  {
  do_pending_operator(& ca, searchbuff, & command_busy, old_col, 0, dont_adjust_op_end);
  }
  if (p_smd) {
    if (VIsual_active) {









    } else { //Added block
    _L___19: ;
    if (restart_edit) {
      _L___17: ;
      if (clear_cmdline) {

      } else { //Added block


















      }
    } else {
      goto _L___16;
    }
    }
  } else { //Added block
  _L___16: ;
  if (restart_edit) {






























































  }
  }
  normal_end: ;
  msg_nowait = 0;
  finish_op = 0;
  if (oap->op_type == 0) {
    if (oap->regname == 0) {
      {
      clear_showcmd();
      }
    }
  }
  if (modified) {
    {
    update_other_win();
    modified = 0;
    }
  }
  {
  checkpcmark();
  vim_free((void *)searchbuff);
  }
  if (curwin->w_p_scb) {
    {


    }
  }
  if (restart_edit) {









  } else { //Added block
  _L___22: ;
  if (restart_VIsual_select == 1) {
    _L___20: ;
































  }
  }
  if (restart_VIsual_select == 2) {

  }
  return;
}
}
static int redo_VIsual_mode  =    '\000';
static linenr_t redo_VIsual_line_count  ;
static colnr_t redo_VIsual_col  ;
static long redo_VIsual_count  ;
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) 
{ 
  OPARG *oap ;
  FPOS old_cursor ;
  int empty_region_error ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  char_u *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  colnr_t start___0 ;
  colnr_t end ;
  int tmp___9 ;
  int tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char_u *tmp___16 ;
  int tmp___17 ;
  char_u *tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char_u *tmp___22 ;
  colnr_t tmp___23 ;

  {
  oap = cap->oap;
  if (clipboard.available) {













  }
  old_cursor = curwin->w_cursor;
  if (VIsual_active) {
    goto _L___6;
  } else { //Added block
  if (finish_op) {
    _L___6: ;
    if (oap->op_type != 0) {
      {
      oap->is_VIsual = VIsual_active;
      tmp___2 = vim_strchr(p_cpo, 'y');
      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        goto _L___0;
      } else { //Added block
      if (oap->op_type != 2) {
        _L___0: ;
        if (! VIsual_active) {
          {
          tmp = get_extra_op_char(oap->op_type);
          tmp___0 = get_op_char(oap->op_type);
          prep_redo(oap->regname, cap->count0, tmp___0, tmp, cap->cmdchar, cap->nchar);
          }
          if (cap->cmdchar == 47) {

          } else { //Added block
          if (cap->cmdchar == 63) {
            _L: ;
            {

            }





            {

            }
          }
          }
        }
      }
      }
      if (redo_VIsual_busy) {

























      } else { //Added block
      if (VIsual_active) {
        if (VIsual_select) {

























        } else { //Added block
        _L___1: ;
        if (VIsual_mode == 118) {
          {
          unadjust_for_sel();
          }
        }
        }
        curbuf->b_visual_start = VIsual;
        curbuf->b_visual_end = curwin->w_cursor;
        curbuf->b_visual_mode = VIsual_mode;
        oap->start = VIsual;
        if (VIsual_mode == 86) {

        }
      }
      }
      if (oap->start.lnum != curwin->w_cursor.lnum) {
        tmp___8 = oap->start.lnum < curwin->w_cursor.lnum;
      } else {
        tmp___8 = oap->start.col < curwin->w_cursor.col;
      }
      if (tmp___8) {
        oap->end = curwin->w_cursor;
        curwin->w_cursor = oap->start;
      } else {


      }
      oap->line_count = (oap->end.lnum - oap->start.lnum) + 1L;
      if (VIsual_active) {
        goto _L___3;
      } else { //Added block
      if (redo_VIsual_busy) {
        _L___3: ;
        if (VIsual_mode == 22) {
          {



          }













































          {






          }
        }
        if (! redo_VIsual_busy) {
          if (! gui_yank) {
            resel_VIsual_mode = VIsual_mode;
            if (curwin->w_curswant == 2147483647U) {

            } else { //Added block
            if (VIsual_mode == 22) {

            } else { //Added block
            if (oap->line_count > 1L) {

            } else {
              resel_VIsual_col = (oap->end.col - oap->start.col) + 1U;
            }
            }
            }
            resel_VIsual_line_count = oap->line_count;
          }
        }
        {
        tmp___11 = vim_strchr(p_cpo, 'y');
        }
        if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
          goto _L___2;
        } else { //Added block
        if (oap->op_type != 2) {
          _L___2: ;
          if (oap->op_type != 10) {
            {
            tmp___9 = get_extra_op_char(oap->op_type);
            tmp___10 = get_op_char(oap->op_type);
            prep_redo(oap->regname, 0L, '\000', 'v', tmp___10, tmp___9);
            redo_VIsual_mode = resel_VIsual_mode;
            redo_VIsual_col = resel_VIsual_col;
            redo_VIsual_line_count = resel_VIsual_line_count;
            redo_VIsual_count = cap->count0;
            }
          }
        }
        }
        oap->inclusive = 1;
        if (VIsual_mode == 86) {

        } else {
          oap->motion_type = 0;
          if (VIsual_mode != 22) {
            {
            tmp___13 = ml_get_pos(& oap->end);
            }
            if ((int )*tmp___13 == 0) {













            }
          }
        }
        redo_VIsual_busy = 0;
        if (! gui_yank) {
          {
          VIsual_active = 0;
          setmouse();
          mouse_dragging = 0;
          }
          if (p_smd) {

          }
          if (oap->op_type == 2) {
            {
            update_curbuf(40);
            }
          } else { //Added block
          if (oap->op_type == 10) {
            {

            }
          } else { //Added block
          if (oap->op_type == 6) {
            {

            }
          }
          }
          }
        }
      }
      }
      curwin->w_set_curswant = 1;
      if (oap->motion_type == 0) {
        if (! oap->inclusive) {
          goto _L___4;
        } else { //Added block
        if (oap->op_type == 2) {
          {
          tmp___14 = gchar_pos(& oap->end);
          }
          if (tmp___14 == 0) {
            _L___4: ;
            if (oap->start.lnum == oap->end.lnum) {
              if (oap->start.col == oap->end.col) {

              } else {
                tmp___15 = 0;
              }
            } else {

            }
          } else {
            tmp___15 = 0;
          }
        } else {
          tmp___15 = 0;
        }
        }
      } else {
        tmp___15 = 0;
      }
      oap->empty = tmp___15;
      if (oap->empty) {
        {

        }





      } else {
        tmp___17 = 0;
      }
      empty_region_error = tmp___17;
      if (oap->is_VIsual) {
        if (oap->empty) {
          {

          }
        }
      }
      if (oap->motion_type == 0) {
        if (oap->inclusive == 0) {
          if (! dont_adjust_op_end) {
            if (oap->end.col == 0U) {
































            } else {
              oap->end_adjusted = 0;
            }
          } else {

          }
        } else {
          oap->end_adjusted = 0;
        }
      } else {
        oap->end_adjusted = 0;
      }
      {
      if (oap->op_type == 4) {
        goto case_4;
      }
      if (oap->op_type == 5) {

      }
      if (oap->op_type == 14) {

      }
      if (oap->op_type == 13) {

      }
      if (oap->op_type == 1) {
        goto case_1;
      }
      if (oap->op_type == 2) {
        goto case_2;
      }





































      case_4: ;/* CIL Label */ 
      case_5: ;/* CIL Label */ 
      if (oap->is_VIsual) {
        tmp___21 = (int )cap->count1;
      } else {
        tmp___21 = 1;
      }
      {
      op_shift(oap, 1, tmp___21);
      }
      goto switch_break;
      case_14: ;/* CIL Label */ 
      case_13: ;/* CIL Label */ 













      case_1: ;/* CIL Label */ 
      VIsual_reselect = 0;
      if (empty_region_error) {
        {

        }
      } else {
        {
        op_delete(oap);
        }
      }
      goto switch_break;
      case_2: ;/* CIL Label */ 
      if (empty_region_error) {





      } else {
        {
        op_yank(oap, 0, ! gui_yank);
        }
      }
      {
      check_cursor_col();
      }
      goto switch_break;
      case_3: ;/* CIL Label */ 












      case_6: ;/* CIL Label */ 
      {

      }







      case_8: ;/* CIL Label */ 
      case_10: ;/* CIL Label */ 














      {

      }

      case_7: ;/* CIL Label */ 
      case_11: ;/* CIL Label */ 
      case_12: ;/* CIL Label */ 
      case_15: ;/* CIL Label */ 









      {

      }

      case_9: ;/* CIL Label */ 










      case_17: ;/* CIL Label */ 
      case_18: ;/* CIL Label */ 












      case_16: ;/* CIL Label */ 











      switch_default: ;/* CIL Label */ 
      {

      }
      switch_break: ;/* CIL Label */ ;
      }
      if (! gui_yank) {
        if (! p_sol) {



























        }
        oap->op_type = 0;
      } else {

      }
      oap->block_mode = 0;
      oap->regname = 0;
    }
  }
  }
  return;
}
}
static void op_colon(OPARG *oap ) 
{












































































}
static FPOS orig_cursor  ;
static int do_always  =    0;
static int got_click  =    0;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) 
{




























































































































































































































































































































































































































































































































































}
static void find_start_of_word(FPOS *pos___0 ) 
{







































}
static void find_end_of_word(FPOS *pos___0 ) 
{








































}
static int get_mouse_class(int c ) 
{



























}
static int did_check  =    0;
void check_visual_highlight(void) 
{ 


  {
  if (! did_check) {
    if (highlight_attr[14] == 0) {
      {

      }
    }
  }
  did_check = 1;
  return;
}
}
void end_visual_mode(void) 
{































}
int find_ident_under_cursor(char_u **string___0 , int find_type ) 
{ 
  char_u *ptr ;
  int col ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  col = 0;
  ptr = ml_get_curline();
  }
  if (find_type & 1) {
    i___0 = 0;
  } else {

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break;
    }
    col = (int )curwin->w_cursor.col;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if ((int )*(ptr + col) != 0) {
        if (i___0 == 0) {
          {
          tmp = vim_iswordc((int )*(ptr + col));
          }
          if (tmp) {
            tmp___0 = 0;
          } else {

          }
          tmp___2 = tmp___0;
        } else {










        }
        if (! tmp___2) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }

    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (col > 0) {































      } else {
        goto while_break___1;
      }

    }
    while_break___1: ;/* CIL Label */ ;
    }
    if (! (find_type & 2)) {
      goto while_break;
    } else {
      {
      tmp___7 = vim_iswordc((int )*(ptr + col));
      }
      if (tmp___7) {
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*(ptr + col) == 0) {
    goto _L;
  } else {
    {
    tmp___8 = vim_iswordc((int )*(ptr + col));
    }
    if (! tmp___8) {
      if (i___0 == 0) {
        _L: ;
        if (find_type & 2) {
          {
          emsg((char_u *)"No string under cursor");
          }
        } else {
          {

          }
        }
        return (0);
      }
    }
  }
  ptr += col;
  *string___0 = ptr;
  col = 0;
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (i___0 == 0) {
      {
      tmp___9 = vim_iswordc((int )*ptr);
      tmp___11 = tmp___9;
      }
    } else {














    }
    if (! tmp___11) {
      goto while_break___2;
    }
    ptr ++;
    col ++;
  }
  while_break___2: ;/* CIL Label */ ;
  }
  return (col);
}
}
static void prep_redo_cmd(CMDARG *cap ) 
{








}
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) 
{ 


  {
  {
  ResetRedobuff();
  }
  if (regname___0 != 0) {
    {
    AppendCharToRedobuff('\"');
    AppendCharToRedobuff(regname___0);
    }
  }
  if (num) {
    {
    AppendNumberToRedobuff(num);
    }
  }
  if (cmd1 != 0) {
    {
    AppendCharToRedobuff(cmd1);
    }
  }
  if (cmd2 != 0) {
    {
    AppendCharToRedobuff(cmd2);
    }
  }
  if (cmd3 != 0) {
    {
    AppendCharToRedobuff(cmd3);
    }
  }
  if (cmd4 != 0) {
    {
    AppendCharToRedobuff(cmd4);
    }
  }
  return;
}
}
static int checkclearop(OPARG *oap ) 
{ 


  {
  if (oap->op_type == 0) {
    return (0);
  }
  {

  }

}
}
static int checkclearopq(OPARG *oap ) 
{ 


  {
  if (oap->op_type == 0) {
    if (! VIsual_active) {
      return (0);
    }
  }
  {

  }

}
}
static void clearop(OPARG *oap ) 
{ 


  {
  oap->op_type = 0;
  oap->regname = 0;
  return;
}
}
static void clearopbeep(OPARG *oap ) 
{ 


  {
  {
  clearop(oap);
  beep_flush();
  }
  return;
}
}
static char_u showcmd_buf[11]  ;
static char_u old_showcmd_buf[11]  ;
static int showcmd_is_clear  =    1;
static void display_showcmd(void) ;
void clear_showcmd(void) 
{ 


  {
  if (! p_sc) {
    return;
  }
  showcmd_buf[0] = (char_u )'\000';
  if (showcmd_is_clear) {
    return;
  }
  {

  }

}
}
static int ignore[13]  = 
  {      253 + (51 << 8),      253 + (42 << 8),      253 + (43 << 8),      253 + (44 << 8), 
        253 + (45 << 8),      253 + (46 << 8),      253 + (47 << 8),      253 + (48 << 8), 
        253 + (49 << 8),      253 + (50 << 8),      253 + (67 << 8),      253 + (68 << 8), 
        0};
int add_to_showcmd(int c ) 
{ 
  char_u *p___0 ;
  int old_len ;
  int extra_len ;
  int overflow ;
  int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (! p_sc) {
    return (0);
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ignore[i___0]) {
      goto while_break;
    }
    if (ignore[i___0] == c) {

    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  p___0 = transchar(c);
  tmp = strlen((char const   *)((char *)(showcmd_buf)));
  old_len = (int )tmp;
  tmp___0 = strlen((char const   *)((char *)p___0));
  extra_len = (int )tmp___0;
  overflow = (old_len + extra_len) - 10;
  }
  if (overflow > 0) {
    {

    }
  }
  {
  strcat((char * __restrict  )((char *)(showcmd_buf)), (char const   * __restrict  )((char *)p___0));
  tmp___1 = char_avail();
  }
  if (tmp___1) {
    return (0);
  }
  {

  }

}
}
void add_to_showcmd_c(int c ) 
{













}
static void del_from_showcmd(int len___0 ) 
{


























}
void push_showcmd(void) 
{










}
void pop_showcmd(void) 
{












}
static void display_showcmd(void) 
{
























}
static WIN *old_curwin  =    (WIN *)((void *)0);
static linenr_t old_topline  =    (linenr_t )0;
static BUF *old_buf  =    (BUF *)((void *)0);
static colnr_t old_leftcol  =    (colnr_t )0;
void do_check_scrollbind(int check ) 
{ 
  char_u *tmp ;

  {
  if (check) {































  }
  old_curwin = curwin;
  old_topline = curwin->w_topline;
  old_buf = curwin->w_buffer;
  old_leftcol = curwin->w_leftcol;
  return;
}
}
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) 
{






















































































































}
static void nv_gd(OPARG *oap , int nchar ) 
{









































































































































}
static int nv_screengo(OPARG *oap , int dir , long dist ) 
{ 
  int linelen___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int retval ;
  int atend ;
  int n ;
  int tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;
  long tmp___6 ;

  {
  {
  tmp = ml_get_curline();
  tmp___0 = linetabsize(tmp);
  linelen___0 = tmp___0;
  retval = 1;
  atend = 0;
  oap->motion_type = 0;
  oap->inclusive = 0;
  }
  if (curwin->w_curswant == 2147483647U) {
    {


    }











  } else {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (curwin->w_curswant >= (colnr_t )((long )linelen___0 + Columns))) {
        goto while_break;
      }

    }
    while_break: ;/* CIL Label */ ;
    }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    tmp___6 = dist;
    dist --;
    if (! tmp___6) {
      goto while_break___0;
    }
    if (dir == -1) {
      if ((long )curwin->w_curswant >= Columns) {

      } else {
        if (curwin->w_cursor.lnum == 1L) {
          retval = 0;
          goto while_break___0;
        }
        {
        (curwin->w_cursor.lnum) --;
        tmp___2 = ml_get_curline();
        linelen___0 = linetabsize(tmp___2);
        }
        if (curwin->w_p_nu) {

        } else {
          tmp___3 = 0;
        }
        n = (int )(((long )((linelen___0 + tmp___3) - 1) / Columns) * Columns);
        if (curwin->w_p_nu) {





        }
        curwin->w_curswant += (colnr_t )n;
      }
    } else {
      if (curwin->w_p_nu) {

      } else {
        tmp___4 = 0;
      }
      n = (int )(((long )((linelen___0 + tmp___4) - 1) / Columns) * Columns);
      if (curwin->w_p_nu) {



      }
      if (curwin->w_curswant < (colnr_t )n) {
        curwin->w_curswant = (colnr_t )((long )curwin->w_curswant + Columns);
      } else {
        if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {


        }
        {
        (curwin->w_cursor.lnum) ++;
        tmp___5 = ml_get_curline();
        linelen___0 = linetabsize(tmp___5);
        curwin->w_curswant = (colnr_t )((long )curwin->w_curswant % Columns);
        }
      }
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  coladvance(curwin->w_curswant);
  }
  if (atend) {

  }
  return (retval);
}
}
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) 
{ 
  int tmp ;

  {
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {

  }
  {
  scroll_redraw(is_ctrl_e, cap->count1);
  }
  return;
}
}
void scroll_redraw(int up , long count___2 ) 
{ 
  linenr_t prev_topline ;
  linenr_t prev_lnum ;

  {
  prev_topline = curwin->w_topline;
  prev_lnum = curwin->w_cursor.lnum;
  if (up) {
    {
    scrollup(count___2);
    }
  } else {
    {
    scrolldown(count___2);
    }
  }
  if (p_so) {
    {


    }













  }
  if (curwin->w_cursor.lnum != prev_lnum) {
    {
    coladvance(curwin->w_curswant);
    }
  }
  {
  update_screen(10);
  }
  return;
}
}
static void nv_zet(CMDARG *cap ) 
{ 
  long n ;
  colnr_t col ;
  int nchar ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  {
  nchar = cap->nchar;
  tmp___0 = vim_isdigit(nchar);
  }
  if (tmp___0) {

    {



























































    while_break: ;/* CIL Label */ ;
    }


  }
  dozet: ;
  {
  tmp___1 = vim_strchr((char_u *)"hles", nchar);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
















  }
  {
  if (nchar == 43) {

  }
  if (nchar == 75 + (54 << 8)) {

  }
  if (nchar == 10) {

  }
  if (nchar == 13) {

  }
  if (nchar == 75 + (65 << 8)) {

  }
  if (nchar == 116) {

  }
  if (nchar == 46) {

  }
  if (nchar == 122) {

  }
  if (nchar == 94) {

  }
  if (nchar == 45) {

  }
  if (nchar == 75 + (55 << 8)) {

  }
  if (nchar == 98) {

  }
  if (nchar == 72) {

  }
  if (nchar == 104) {
    goto case_104;
  }

























  case_43: ;/* CIL Label */ 
  case_exp: ;/* CIL Label */ 










  case_10: ;/* CIL Label */ 
  case_13: ;/* CIL Label */ 
  case_exp___0: ;/* CIL Label */ 
  {

  }
  case_116: ;/* CIL Label */ 
  {

  }

  case_46: ;/* CIL Label */ 
  {

  }
  case_122: ;/* CIL Label */ 
  {

  }

  case_94: ;/* CIL Label */ 












  case_45: ;/* CIL Label */ 
  case_exp___1: ;/* CIL Label */ 
  {

  }
  case_98: ;/* CIL Label */ 
  {

  }

  case_72: ;/* CIL Label */ 

  case_104: ;/* CIL Label */ 
  case_exp___2: ;/* CIL Label */ 
  if (! curwin->w_p_wrap) {





    {

    }
  }
  goto switch_break;
  case_76: ;/* CIL Label */ 

  case_108: ;/* CIL Label */ 
  case_exp___3: ;/* CIL Label */ 







  case_115: ;/* CIL Label */ 








  case_101: ;/* CIL Label */ 



















  case_19: ;/* CIL Label */ 
  case_17: ;/* CIL Label */ 

  switch_default: ;/* CIL Label */ 
  {

  }
  switch_break: ;/* CIL Label */ ;
  }
  {
  update_screen(10);
  }
  return;
}
}
static void nv_colon(CMDARG *cap ) 
{ 
  int old_p_im ;
  int tmp ;

  {
  if (VIsual_active) {
    {

    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      if (cap->count0) {
        {

        }






      }
      if (KeyTyped) {
        {
        compute_cmdrow();
        }
      }
      {
      old_p_im = p_im;
      do_cmdline((char_u *)((void *)0), & getexline, (void *)0, 0);
      }
      if (p_im != old_p_im) {





      }
    }
  }
  return;
}
}
static void nv_ctrlg(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {
    {


    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      {
      fileinfo((int )cap->count0, 0, 1);
      }
    }
  }
  return;
}
}
static void nv_zzet(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  tmp = checkclearopq(cap->oap);
  }
  if (! tmp) {
    if (cap->nchar == 90) {
      {
      do_cmdline((char_u *)"x", (char_u *(*)(int  , void * , int  ))((void *)0), (void *)0,
                 3);
      }
    } else { //Added block
    if (cap->nchar == 81) {
      {
      do_cmdline((char_u *)"q!", (char_u *(*)(int  , void * , int  ))((void *)0),
                 (void *)0, 3);
      }
    } else {
      {

      }
    }
    }
  }
  return;
}
}
static void nv_ident(CMDARG *cap , char_u **searchp ) 
{ 
  char_u *ptr ;
  int n ;
  int cmdchar ;
  int g_cmd ;
  char_u *aux_ptr ;
  int isman ;
  int isman_s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  ptr = (char_u *)((void *)0);
  n = 0;
  if (cap->cmdchar == 103) {
    cmdchar = cap->nchar;
    g_cmd = 1;
  } else {
    cmdchar = cap->cmdchar;
    g_cmd = 0;
  }
  if (cmdchar == 93) {

  } else { //Added block
  if (cmdchar == 29) {

  } else { //Added block
  if (cmdchar == 75) {
    _L: ;
    if (VIsual_active) {



























      {



      }
    }
    {
    tmp___0 = checkclearopq(cap->oap);
    }
    if (tmp___0) {

    }
  }
  }
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    if (cmdchar == 42) {
      tmp___1 = 3;
    } else { //Added block
    if (cmdchar == 35) {
      tmp___1 = 3;
    } else {
      tmp___1 = 1;
    }
    }
    {
    n = find_ident_under_cursor(& ptr, tmp___1);
    }
    if (n == 0) {
      {
      clearop(cap->oap);
      }
      return;
    }
  }
  {
  tmp___2 = strcmp((char const   *)((char *)p_kp), (char const   *)((char *)"man"));
  isman = tmp___2 == 0;
  tmp___3 = strcmp((char const   *)((char *)p_kp), (char const   *)((char *)"man -s"));
  isman_s = tmp___3 == 0;
  }
  if (cap->count0) {
    if (cmdchar == 75) {
      if (! isman) {



      }
    } else { //Added block
    _L___0: ;
    if (! (cmdchar == 42)) {





    }
    }
  }
  {
  if (cmdchar == 42) {
    goto case_42;
  }
  if (cmdchar == 35) {

  }
  if (cmdchar == 75) {
    goto case_75;
  }




  case_42: ;/* CIL Label */ 
  case_35: ;/* CIL Label */ 
  {
  setpcmark();
  tmp___4 = ml_get_curline();
  curwin->w_cursor.col = (colnr_t )(ptr - tmp___4);
  }
  if (! g_cmd) {
    {
    tmp___5 = vim_iswordc((int )*ptr);
    }
    if (tmp___5) {
      {
      stuffReadbuff((char_u *)"\\<");
      }
    }
  }
  no_smartcase = 1;
  goto switch_break;
  case_75: ;/* CIL Label */ 
  if ((int )*p_kp == 0) {
    {

    }
  } else {
    {
    stuffReadbuff((char_u *)":! ");
    }
    if (! cap->count0) {
      if (isman_s) {
        {
        stuffReadbuff((char_u *)"man");
        }
      } else {
        {

        }
      }
    } else {
      {

      }
    }
    {
    stuffReadbuff((char_u *)" ");
    }
    if (cap->count0) {













    }
  }
  goto switch_break;
  case_93: ;/* CIL Label */ 
  {

  }

  switch_default: ;/* CIL Label */ 















  switch_break: ;/* CIL Label */ ;
  }
  if (cmdchar == 42) {
    goto _L___1;
  } else { //Added block
  if (cmdchar == 35) {
    _L___1: ;
    if (p_magic) {
      tmp___6 = "/?.*~[^$\\";
    } else {

    }
    aux_ptr = (char_u *)tmp___6;
  } else { //Added block
  if (cmdchar == 75) {
    if ((int )*p_kp != 0) {
      aux_ptr = escape_chars;
    } else {

    }
  } else {

  }
  }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___9 = n;
    n --;
    if (! tmp___9) {
      goto while_break;
    }
    {
    tmp___7 = vim_strchr(aux_ptr, (int )*ptr);
    }
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {

      }
    } else { //Added block
    if ((int )*ptr < 32) {
      {

      }
    } else { //Added block
    if ((int )*ptr > 126) {
      {

      }
    }
    }
    }
    {
    tmp___8 = ptr;
    ptr ++;
    stuffcharReadbuff((int )*tmp___8);
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (! g_cmd) {
    if (cmdchar == 42) {
      goto _L___2;
    } else { //Added block
    if (cmdchar == 35) {
      _L___2: ;
      {
      tmp___10 = vim_iswordc((int )*(ptr + -1));
      }
      if (tmp___10) {
        {
        stuffReadbuff((char_u *)"\\>");
        }
      }
    }
    }
  }
  {
  stuffReadbuff((char_u *)"\n");
  }
  if (cmdchar == 42) {
    goto _L___3;
  } else { //Added block
  if (cmdchar == 35) {
    _L___3: ;
    if (cmdchar == 42) {
      cap->cmdchar = '/';
    } else {

    }
    {
    nv_search(cap, searchp, 1);
    }
  }
  }
  return;
}
}
static void nv_scroll(CMDARG *cap ) 
{ 
  int used ;
  long n ;
  int tmp ;

  {
  {
  used = 0;
  (cap->oap)->motion_type = 1;
  setpcmark();
  }
  if (cap->cmdchar == 76) {
    {
    validate_botline();
    curwin->w_cursor.lnum = curwin->w_botline - 1L;
    }
    if (cap->count1 - 1L >= curwin->w_cursor.lnum) {

    } else {
      curwin->w_cursor.lnum -= cap->count1 - 1L;
    }
  } else {
    if (cap->cmdchar == 77) {
      {
      validate_botline();
      n = 0L;
      }
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! (curwin->w_topline + n < curbuf->b_ml.ml_line_count)) {

        }
        {
        tmp = plines(curwin->w_topline + n);
        used += tmp;
        }
        if (used >= ((curwin->w_height - curwin->w_empty_rows) + 1) / 2) {
          goto while_break;
        }
        n ++;
      }
      while_break: ;/* CIL Label */ ;
      }
      if (n) {
        if (used > curwin->w_height) {

        }
      }
    } else {
      n = cap->count1 - 1L;
    }
    curwin->w_cursor.lnum = curwin->w_topline + n;
    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {
      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
    }
  }
  {
  cursor_correct();
  beginline(6);
  }
  return;
}
}
static void nv_right(CMDARG *cap ) 
{ 
  long n ;
  int past_line ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;

  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  if (VIsual_active) {





  } else {
    tmp = 0;
  }
  past_line = tmp;
  n = cap->count1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (n > 0L)) {
      goto while_break;
    }
    if (! past_line) {
      {
      tmp___5 = oneright();
      }
      if (tmp___5 == 0) {
        goto _L___3;
      } else {
        goto _L___5;
      }
    } else { //Added block
    _L___5: ;
    if (past_line) {
      {

      }
      if ((int )*tmp___6 == 0) {
        _L___3: ;
        if (cap->cmdchar == 32) {
          {
          tmp___1 = vim_strchr(p_ww, 's');
          }
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {

          } else {
            goto _L___2;
          }
        } else { //Added block
        _L___2: ;
        if (cap->cmdchar == 108) {
          {
          tmp___2 = vim_strchr(p_ww, 'l');
          }
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {

          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: ;
        if (cap->cmdchar == 107 + (114 << 8)) {
          {

          }
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            _L___0: ;
            if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {































            }
          }
        }
        }
        }
        if ((cap->oap)->op_type == 0) {
          if (n == cap->count1) {
            {
            beep_flush();
            }
          }
        } else {
          {

          }



        }
        goto while_break;
      } else {

      }
    } else { //Added block
    _L___4: ;
    if (past_line) {


    }
    }
    }
    __Cont: ;
    n --;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static int nv_left(CMDARG *cap ) 
{ 
  long n ;
  int retval ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;

  {
  retval = 0;
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  n = cap->count1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (n > 0L)) {
      goto while_break;
    }
    {
    tmp___3 = oneleft();
    }
    if (tmp___3 == 0) {
      if (cap->cmdchar == 107 + (98 << 8)) {

      } else { //Added block
      if (cap->cmdchar == 8) {
        _L___5: ;
        {

        }





      } else { //Added block
      _L___4: ;
      if (cap->cmdchar == 104) {
        {
        tmp___1 = vim_strchr(p_ww, 'h');
        }
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {

        } else {
          goto _L___3;
        }
      } else { //Added block
      _L___3: ;
      if (cap->cmdchar == 107 + (108 << 8)) {
        {

        }





























      } else { //Added block
      _L___2: ;
      if ((cap->oap)->op_type == 0) {
        if (n == cap->count1) {
          {
          beep_flush();
          }
        }
      }
      }
      }
      }
      }
      goto while_break;
    }
    __Cont: ;
    n --;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (retval);
}
}
static void nv_gotofile(CMDARG *cap ) 
{








































}
static void nv_dollar(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 1;
  curwin->w_curswant = (colnr_t )2147483647;
  tmp = cursor_down(cap->count1 - 1L, (cap->oap)->op_type == 0);
  }
  if (tmp == 0) {
    {

    }
  }
  return;
}
}
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) 
{ 
  OPARG *oap ;
  int i___0 ;
  char_u *tmp ;
  int tmp___0 ;

  {
  oap = cap->oap;
  if (cap->cmdchar == 63) {
    if ((cap->oap)->op_type == 15) {
      {



      }

    }
  }
  {
  tmp = getcmdline(cap->cmdchar, cap->count1, 0);
  *searchp = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {

    }

  }
  oap->motion_type = 0;
  oap->inclusive = 0;
  curwin->w_set_curswant = 1;
  if (dont_set_mark) {
    tmp___0 = 0;
  } else {
    tmp___0 = 512;
  }
  {
  i___0 = do_search(oap, cap->cmdchar, *searchp, cap->count1, ((tmp___0 | 16) | 2) | 12);
  }
  if (i___0 == 0) {
    {
    clearop(oap);
    }
  } else { //Added block
  if (i___0 == 2) {

  }
  }
  {
  adjust_cursor();
  }
  return;
}
}
static void nv_next(CMDARG *cap , int flag ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = do_search(cap->oap, 0, (char_u *)((void *)0), cap->count1, 542 | flag);
  }
  if (! tmp) {
    {
    clearop(cap->oap);
    }
  }
  {
  adjust_cursor();
  }
  return;
}
}
static void nv_csearch(CMDARG *cap , int dir , int type ) 
{ 
  int tmp ;

  {
  (cap->oap)->motion_type = 0;
  if (dir == -1) {
    (cap->oap)->inclusive = 0;
  } else {
    (cap->oap)->inclusive = 1;
  }
  if (cap->nchar >= 256) {
    {

    }
  } else {
    {
    tmp = searchc(cap->nchar, dir, type, cap->count1);
    }
    if (tmp) {
      {
      curwin->w_set_curswant = 1;
      adjust_for_sel(cap);
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
  }
  return;
}
}
static void nv_brackets(CMDARG *cap , int dir ) 
{ 
  FPOS new_pos ;
  FPOS prev_pos ;
  FPOS *pos___0 ;
  FPOS old_pos ;
  int flag ;
  long n ;
  int findc ;
  int c ;
  char_u *ptr ;
  int len___0 ;
  linenr_t tmp ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int norm ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char_u *tmp___20 ;
  char_u *tmp___21 ;
  char_u *tmp___22 ;

  {
  pos___0 = (FPOS *)((void *)0);
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  old_pos = curwin->w_cursor;
  if (cap->nchar == 102) {
    {

    }
  } else {
    {
    tmp___22 = vim_strchr((char_u *)"iI\tdD\004", cap->nchar);
    }
    if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
      {

      }


















































    } else { //Added block
    if (cap->cmdchar == 91) {
      {

      }





    } else { //Added block
    _L___8: ;
    if (cap->cmdchar == 93) {
      {
      tmp___21 = vim_strchr((char_u *)"})*/#mM", cap->nchar);
      }
      if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
        _L___6: ;
        if (cap->nchar == 42) {
          cap->nchar = '/';
        }
        new_pos.lnum = (linenr_t )0;
        prev_pos.lnum = (linenr_t )0;
        if (cap->nchar == 109) {

        } else { //Added block
        if (cap->nchar == 77) {
          _L: ;






        } else {
          findc = cap->nchar;
          n = cap->count1;
        }
        }
        {
        while (1) {
          while_continue: ;/* CIL Label */ ;
          if (! (n > 0L)) {
            goto while_break;
          }
          if (cap->cmdchar == 91) {

          } else {
            tmp___10 = 2;
          }
          {
          pos___0 = findmatchlimit(cap->oap, findc, tmp___10, 0);
          }
          if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
            if (new_pos.lnum == 0L) {
              if (cap->nchar != 109) {
                if (cap->nchar != 77) {
                  {
                  clearopbeep(cap->oap);
                  }
                }
              }
            } else {
              pos___0 = & new_pos;
            }
            goto while_break;
          }
          prev_pos = new_pos;
          curwin->w_cursor = *pos___0;
          new_pos = *pos___0;
          n --;
        }
        while_break: ;/* CIL Label */ ;
        }
        curwin->w_cursor = old_pos;
        if (cap->nchar == 109) {

        } else { //Added block
        if (cap->nchar == 77) {
          _L___3: ;











          {




















































































          while_break___0: ;/* CIL Label */ ;
          }








        }
        }
        if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
          {
          setpcmark();
          curwin->w_cursor = *pos___0;
          curwin->w_set_curswant = 1;
          }
        }
      } else {

      }
    } else { //Added block
    _L___7: ;

























































































    }
    }
    }
  }
  return;
}
}
static void nv_percent(CMDARG *cap ) 
{ 
  FPOS *pos___0 ;

  {
  (cap->oap)->inclusive = 1;
  if (cap->count0) {
    if (cap->count0 > 100L) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {
      (cap->oap)->motion_type = 1;
      setpcmark();
      curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count * cap->count0 + 99L) / 100L;
      beginline(6);
      }
    }
  } else {
    {
    (cap->oap)->motion_type = 0;
    pos___0 = findmatch(cap->oap, '\000');
    }
    if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {




      }
    }
  }
  return;
}
}
static void nv_brace(CMDARG *cap , int dir ) 
{ 
  int tmp ;

  {
  (cap->oap)->motion_type = 0;
  if (cap->cmdchar == 41) {
    (cap->oap)->inclusive = 0;
  } else {
    (cap->oap)->inclusive = 1;
  }
  {
  curwin->w_set_curswant = 1;
  tmp = findsent(dir, cap->count1);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_findpar(CMDARG *cap , int dir ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = findpar(cap->oap, dir, cap->count1, '\000', 0);
  }
  if (! tmp) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static int nv_replace(CMDARG *cap ) 
{ 
  char_u *ptr ;
  int had_ctrl_v ;
  int command_busy ;
  long n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  command_busy = 0;
  if (VIsual_active) {
    {

    }

  }
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {

  }
  {
  ptr = ml_get_cursor();
  }
  if (cap->nchar >= 256) {
    {

    }

  } else {
    {
    tmp___0 = strlen((char const   *)((char *)ptr));
    }
    if (tmp___0 < (size_t )((unsigned int )cap->count1)) {
      {

      }

    }
  }
  if (cap->nchar == 9) {
    if (curbuf->b_p_et) {
      {




      }

    } else { //Added block









    }
  }
  if (cap->nchar == 22) {
    {


    }
  } else {
    had_ctrl_v = '\000';
  }
  {
  tmp___1 = u_save_cursor();
  }
  if (tmp___1 == 0) {

  }
  if (had_ctrl_v != 22) {
    if (cap->nchar == 13) {
      {




      }
    } else { //Added block
    if (cap->nchar == 10) {
      {




      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: ;
    {
    prep_redo((cap->oap)->regname, cap->count1, '\000', 'r', had_ctrl_v, cap->nchar);
    n = cap->count1;
    }
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (n > 0L)) {
        goto while_break;
      }
      {
      ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, 1);
      *(ptr + curwin->w_cursor.col) = (char_u )cap->nchar;
      }
      if (p_sm) {

















      }
      (curwin->w_cursor.col) ++;
      n --;
    }
    while_break: ;/* CIL Label */ ;
    }
    {
    (curwin->w_cursor.col) --;
    curwin->w_set_curswant = 1;
    set_last_insert(cap->nchar);
    changed_cline_bef_curs();
    approximate_botline();
    update_screenline();
    }
  }
  {
  changed();
  }
  return (command_busy);
}
}
static void v_swap_corners(CMDARG *cap ) 
{












































}
static int nv_Replace(CMDARG *cap ) 
{






























}
static int nv_VReplace(CMDARG *cap ) 
{
































}
static int nv_vreplace(CMDARG *cap ) 
{







































}
static void n_swapchar(CMDARG *cap ) 
{


























































































}
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) 
{ 
  int tmp ;

  {
  {
  tmp = check_mark(pos___0);
  }
  if (tmp == 0) {
    {
    clearop(cap->oap);
    }
  } else {
    if (cap->cmdchar == 39) {
      {
      setpcmark();
      }
    } else { //Added block
    if (cap->cmdchar == 96) {
      {

      }
    }
    }
    curwin->w_cursor = *pos___0;
    if (flag) {
      {
      beginline(5);
      }
    } else {
      {
      adjust_cursor();
      }
    }
  }
  if (flag) {
    (cap->oap)->motion_type = 1;
  } else {
    (cap->oap)->motion_type = 0;
  }
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  return;
}
}
static char_u trans[17]  = 
  {      (char_u )'Y',      (char_u )'y',      (char_u )'D',      (char_u )'d', 
        (char_u )'C',      (char_u )'c',      (char_u )'x',      (char_u )'d', 
        (char_u )'X',      (char_u )'d',      (char_u )'A',      (char_u )'A', 
        (char_u )'I',      (char_u )'I',      (char_u )'r',      (char_u )'r', 
        (char_u )'\000'};
static void v_visop(CMDARG *cap ) 
{



























}
static char_u *ar[8]  = 
  {      (char_u *)"dl",      (char_u *)"dh",      (char_u *)"d$",      (char_u *)"c$", 
        (char_u *)"cl",      (char_u *)"cc",      (char_u *)"yy",      (char_u *)":s\r"};
static char_u *str___0  =    (char_u *)"xXDCsSY&";
static void nv_optrans(CMDARG *cap ) 
{ 
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = checkclearopq(cap->oap);
  }
  if (! tmp___0) {
    if (cap->count0) {
      {

      }
    }
    {
    tmp = vim_strchr(str___0, cap->cmdchar);
    stuffReadbuff(ar[(int )(tmp - str___0)]);
    }
  }
  return;
}
}
static void nv_gomark(CMDARG *cap , int flag ) 
{ 
  FPOS *pos___0 ;

  {
  {
  pos___0 = getmark(cap->nchar, (cap->oap)->op_type == 0);
  }
  if ((unsigned long )pos___0 == (unsigned long )((FPOS *)-1)) {










  } else {
    {
    nv_cursormark(cap, flag, pos___0);
    }
  }
  return;
}
}
static void nv_pcmark(CMDARG *cap ) 
{ 
  FPOS *pos___0 ;
  int tmp ;

  {
  {
  tmp = checkclearopq(cap->oap);
  }
  if (! tmp) {
    {
    pos___0 = movemark((int )cap->count1);
    }
    if ((unsigned long )pos___0 == (unsigned long )((FPOS *)-1)) {
      {


      }
    } else { //Added block
    if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
      {
      nv_cursormark(cap, 0, pos___0);
      }
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
    }
  }
  return;
}
}
static void nv_regname(CMDARG *cap , linenr_t *opnump ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = checkclearop(cap->oap);
  }
  if (tmp) {

  }
  if (cap->nchar == 61) {
    {

    }
  }
  if (cap->nchar != 0) {
    {
    tmp___0 = valid_yank_reg(cap->nchar, 0);
    }
    if (tmp___0) {
      (cap->oap)->regname = cap->nchar;
      *opnump = cap->count0;
    } else {
      {
      clearopbeep(cap->oap);
      }
    }
  } else {
    {

    }
  }
  return;
}
}
static void nv_visual(CMDARG *cap , int selectmode ) 
{ 


  {
  VIsual_select = selectmode;
  if (VIsual_active) {










    {

    }
  } else {
    {
    check_visual_highlight();
    }
    if (cap->count0) {














      {

      }






































      {

      }
    } else {
      if (! selectmode) {
        {
        may_start_select('c');
        }
      }
      {
      n_start_visual_mode(cap->cmdchar);
      }
    }
  }
  return;
}
}
void start_selection(void) 
{









}
void may_start_select(int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = stuff_empty();
  }
  if (tmp) {
    {
    tmp___0 = typebuf_typed();
    }
    if (tmp___0) {
      {
      tmp___1 = vim_strchr(p_slm, c);
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {

      } else {
        tmp___2 = 0;
      }
    } else {

    }
  } else {

  }
  VIsual_select = tmp___2;
  return;
}
}
static void n_start_visual_mode(int c ) 
{ 


  {
  {
  VIsual = curwin->w_cursor;
  VIsual_mode = c;
  VIsual_active = 1;
  VIsual_reselect = 1;
  setmouse();
  }
  if (p_smd) {

  }
  {
  clipboard.vmode = '\000';
  update_screenline();
  }
  return;
}
}
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) 
{ 
  OPARG *oap ;
  FPOS tpos ;
  int i___0 ;
  int flag ;
  int command_busy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
  oap = cap->oap;
  flag = 0;
  command_busy = 0;
  {
  if (cap->nchar == 82) {

  }
  if (cap->nchar == 114) {

  }
  if (cap->nchar == 118) {

  }
  if (cap->nchar == 86) {

  }
  if (cap->nchar == 107 + (98 << 8)) {

  }
  if (cap->nchar == 104) {

  }
  if (cap->nchar == 72) {

  }
  if (cap->nchar == 8) {

  }
  if (cap->nchar == 106) {
    goto case_106;
  }
  if (cap->nchar == 107 + (100 << 8)) {

  }
  if (cap->nchar == 107) {
    goto case_107;
  }
  if (cap->nchar == 107 + (117 << 8)) {

  }
  if (cap->nchar == 74) {

  }
  if (cap->nchar == 94) {
    goto case_94;
  }
  if (cap->nchar == 48) {
    goto case_48;
  }
  if (cap->nchar == 109) {

  }
  if (cap->nchar == 107 + (104 << 8)) {

  }
  if (cap->nchar == 75 + (49 << 8)) {

  }
  if (cap->nchar == 253 + (60 << 8)) {

  }
  if (cap->nchar == 36) {
    goto case_36;
  }
  if (cap->nchar == 64 + (55 << 8)) {

  }
  if (cap->nchar == 75 + (52 << 8)) {

  }
  if (cap->nchar == 253 + (59 << 8)) {

  }
  if (cap->nchar == 42) {
    goto case_42;
  }
  if (cap->nchar == 35) {
    goto case_42;
  }
  if (cap->nchar == 101) {
    goto case_101;
  }
  if (cap->nchar == 69) {
    goto case_101;
  }
  if (cap->nchar == 7) {
    goto case_7;
  }
  if (cap->nchar == 73) {

  }
  if (cap->nchar == 102) {

  }
  if (cap->nchar == 115) {

  }
  if (cap->nchar == 97) {
    goto case_97;
  }
  if (cap->nchar == 103) {
    goto case_103;
  }
  if (cap->nchar == 113) {

  }
  if (cap->nchar == 126) {

  }
  if (cap->nchar == 117) {

  }
  if (cap->nchar == 85) {

  }
  if (cap->nchar == 63) {

  }
  if (cap->nchar == 100) {

  }
  if (cap->nchar == 68) {

  }
  if (cap->nchar == 253 + (45 << 8)) {

  }
  if (cap->nchar == 253 + (46 << 8)) {

  }
  if (cap->nchar == 253 + (47 << 8)) {

  }
  if (cap->nchar == 253 + (42 << 8)) {

  }
  if (cap->nchar == 253 + (43 << 8)) {

  }
  if (cap->nchar == 253 + (44 << 8)) {

  }
  if (cap->nchar == 253 + (48 << 8)) {

  }
  if (cap->nchar == 253 + (49 << 8)) {

  }
  if (cap->nchar == 253 + (50 << 8)) {

  }
  if (cap->nchar == 253 + (51 << 8)) {

  }
  if (cap->nchar == 29) {

  }
  if (cap->nchar == 93) {

  }
  if (cap->nchar == 112) {

  }
  if (cap->nchar == 80) {

  }
  if (cap->nchar == 111) {
    goto case_111;
  }

  case_82: ;/* CIL Label */ 
  {

  }

  case_114: ;/* CIL Label */ 
  {

  }

  case_118: ;/* CIL Label */ 
  {

  }

























































  case_86: ;/* CIL Label */ 


  case_exp: ;/* CIL Label */ 

  case_104: ;/* CIL Label */ 
  case_72: ;/* CIL Label */ 
  case_8: ;/* CIL Label */ 
  {

  }







  case_106: ;/* CIL Label */ 
  case_exp___0: ;/* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {


    }
  } else {
    {
    i___0 = nv_screengo(oap, 1, cap->count1);
    }
  }
  if (i___0 == 0) {
    {

    }
  }
  goto switch_break;
  case_107: ;/* CIL Label */ 
  case_exp___1: ;/* CIL Label */ 
  if (! curwin->w_p_wrap) {
    {


    }
  } else {
    {
    i___0 = nv_screengo(oap, -1, cap->count1);
    }
  }
  if (i___0 == 0) {
    {
    clearopbeep(oap);
    }
  }
  goto switch_break;
  case_74: ;/* CIL Label */ 
  {

  }

  case_94: ;/* CIL Label */ 
  flag = 1;
  case_48: ;/* CIL Label */ 
  case_109: ;/* CIL Label */ 
  case_exp___2: ;/* CIL Label */ 
  case_exp___3: ;/* CIL Label */ 
  case_exp___4: ;/* CIL Label */ 
  oap->motion_type = 0;
  oap->inclusive = 0;
  if (curwin->w_p_wrap) {
    {
    validate_virtcol();
    }
    if (curwin->w_p_nu) {

    } else {
      tmp___1 = 0;
    }
    i___0 = (int )(((long )(curwin->w_virtcol + (colnr_t )tmp___1) / Columns) * Columns);
    if (curwin->w_p_nu) {



    }
  } else {

  }
  if (cap->nchar == 109) {

  }
  {
  coladvance((colnr_t )i___0);
  }
  if (flag) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      {
      i___0 = gchar_cursor();
      }
      if (i___0 == 32) {
        goto _L;
      } else { //Added block
      if (i___0 == 9) {
        _L: ;
        {
        tmp___2 = oneright();
        }
        if (! (tmp___2 == 1)) {

        }
      } else {
        goto while_break;
      }
      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  curwin->w_set_curswant = 1;
  goto switch_break;
  case_36: ;/* CIL Label */ 
  case_exp___5: ;/* CIL Label */ 
  case_exp___6: ;/* CIL Label */ 
  case_exp___7: ;/* CIL Label */ 
  oap->motion_type = 0;
  oap->inclusive = 1;
  if (curwin->w_p_wrap) {
    curwin->w_curswant = (colnr_t )2147483647;
    if (cap->count1 == 1L) {
      {
      validate_virtcol();
      }
      if (curwin->w_p_nu) {

      } else {
        tmp___3 = 0;
      }
      i___0 = (int )(((long )(curwin->w_virtcol + (colnr_t )tmp___3) / Columns + 1L) * Columns - 1L);
      if (curwin->w_p_nu) {



      }
      {
      coladvance((colnr_t )i___0);
      }
    } else {
      {

      }





    }
  } else {




    {


    }
  }
  goto switch_break;
  case_42: ;/* CIL Label */ 
  case_35: ;/* CIL Label */ 
  {
  nv_ident(cap, searchp);
  }
  goto switch_break;
  case_101: ;/* CIL Label */ 
  case_69: ;/* CIL Label */ 
  {
  oap->motion_type = 0;
  curwin->w_set_curswant = 1;
  oap->inclusive = 1;
  tmp___5 = bckend_word(cap->count1, cap->nchar == 69, 0);
  }
  if (tmp___5 == 0) {
    {
    clearopbeep(oap);
    }
  }
  goto switch_break;
  case_7: ;/* CIL Label */ 
  {
  cursor_pos_info();
  }
  goto switch_break;
  case_73: ;/* CIL Label */ 
  {


  }












  case_102: ;/* CIL Label */ 
  {

  }

  case_115: ;/* CIL Label */ 
  {

  }
  {
















  while_break___0: ;/* CIL Label */ ;
  }

  case_97: ;/* CIL Label */ 
  {
  do_ascii();
  }
  goto switch_break;
  case_103: ;/* CIL Label */ 
  {
  nv_goto(cap, (linenr_t )1);
  }
  goto switch_break;
  case_113: ;/* CIL Label */ 
  case_126: ;/* CIL Label */ 
  case_117: ;/* CIL Label */ 
  case_85: ;/* CIL Label */ 
  case_63: ;/* CIL Label */ 
  {

  }

  case_100: ;/* CIL Label */ 
  case_68: ;/* CIL Label */ 
  {

  }

  case_exp___8: ;/* CIL Label */ 
  case_exp___9: ;/* CIL Label */ 
  case_exp___10: ;/* CIL Label */ 
  case_exp___11: ;/* CIL Label */ 
  case_exp___12: ;/* CIL Label */ 
  case_exp___13: ;/* CIL Label */ 
  case_exp___14: ;/* CIL Label */ 
  case_exp___15: ;/* CIL Label */ 
  case_exp___16: ;/* CIL Label */ 
  {


  }

  case_exp___17: ;/* CIL Label */ 

  case_29: ;/* CIL Label */ 
  case_93: ;/* CIL Label */ 
  {

  }

  case_112: ;/* CIL Label */ 
  case_80: ;/* CIL Label */ 
  {

  }

  case_111: ;/* CIL Label */ 
  {
  goto_byte(cap->count0);
  }
  goto switch_break;
  switch_default: ;/* CIL Label */ 
  {

  }

  switch_break: ;/* CIL Label */ ;
  }
  return (command_busy);
}
}
static int n_opencmd(CMDARG *cap ) 
{






















































}
static void nv_Undo(CMDARG *cap ) 
{






























}
static void nv_operator(CMDARG *cap ) 
{ 
  int op_type ;
  int tmp ;

  {
  {
  op_type = get_op_type(cap->cmdchar, cap->nchar);
  }
  if (op_type == (cap->oap)->op_type) {
    {

    }
  } else {
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      (cap->oap)->start = curwin->w_cursor;
      (cap->oap)->op_type = op_type;
    }
  }
  return;
}
}
static void nv_lineop(CMDARG *cap ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 1;
  tmp = cursor_down(cap->count1 - 1L, (cap->oap)->op_type == 0);
  }
  if (tmp == 0) {
    {

    }
  } else { //Added block
  if ((cap->oap)->op_type == 1) {
    {

    }
  } else { //Added block
  if ((cap->oap)->op_type == 4) {
    {

    }
  } else { //Added block
  if ((cap->oap)->op_type == 5) {
    {

    }
  } else { //Added block
  if ((cap->oap)->op_type != 2) {
    {
    beginline(5);
    }
  }
  }
  }
  }
  }
  return;
}
}
static void nv_pipe(CMDARG *cap ) 
{ 


  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  beginline(0);
  }
  if (cap->count0 > 0L) {
    {
    coladvance((colnr_t )(cap->count0 - 1L));
    curwin->w_curswant = (colnr_t )(cap->count0 - 1L);
    }
  } else {
    curwin->w_curswant = (colnr_t )0;
  }
  curwin->w_set_curswant = 0;
  return;
}
}
static void nv_bck_word(CMDARG *cap , int type ) 
{ 
  int tmp ;

  {
  {
  (cap->oap)->motion_type = 0;
  (cap->oap)->inclusive = 0;
  curwin->w_set_curswant = 1;
  tmp = bck_word(cap->count1, type, 0);
  }
  if (tmp == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  return;
}
}
static void nv_wordcmd(CMDARG *cap , int type ) 
{ 
  int n ;
  int word_end ;
  int flag ;
  char_u *tmp ;
  int tmp___0 ;

  {
  flag = 0;
  word_end = (cap->oap)->inclusive;
  if (! word_end) {
    if ((cap->oap)->op_type == 3) {
      {

      }























    }
  }
  (cap->oap)->motion_type = 0;
  curwin->w_set_curswant = 1;
  if (word_end) {
    {
    n = end_word(cap->count1, type, flag, 0);
    }
  } else {
    {
    n = fwd_word(cap->count1, type, (cap->oap)->op_type != 0);
    }
  }
  if (curwin->w_cursor.col) {
    {
    tmp___0 = gchar_cursor();
    }
    if (tmp___0 == 0) {
      (curwin->w_cursor.col) --;
      (cap->oap)->inclusive = 1;
    }
  }
  if (n == 0) {
    if ((cap->oap)->op_type == 0) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      {

      }
    }
  } else {
    {
    adjust_for_sel(cap);
    }
  }
  return;
}
}
static void adjust_for_sel(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (VIsual_active) {











  }
  return;
}
}
static void unadjust_for_sel(void) 
{ 
  FPOS *pp ;
  int tmp ;
  char_u *tmp___0 ;
  size_t tmp___1 ;

  {
  if ((int )*p_sel == 101) {





























  }
  return;
}
}
static void nv_goto(CMDARG *cap , linenr_t lnum ) 
{ 


  {
  {
  (cap->oap)->motion_type = 1;
  setpcmark();
  }
  if (cap->count0 != 0L) {
    lnum = cap->count0;
  }
  if (lnum < 1L) {

  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {
    lnum = curbuf->b_ml.ml_line_count;
  }
  }
  {
  curwin->w_cursor.lnum = lnum;
  beginline(6);
  }
  return;
}
}
static void nv_select(CMDARG *cap ) 
{














































}
static void nv_normal(CMDARG *cap ) 
{























}
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) 
{ 


  {
  if (VIsual_active) {
    {




    }
  } else { //Added block
  if ((cap->oap)->op_type == 0) {
    if (opnum___0 == 0L) {
      if (cap->count0 == 0L) {
        if ((cap->oap)->regname == 0) {
          if (! p_im) {
            {
            vim_beep();
            }
          }
        }
      }
    }
  }
  }
  {
  clearop(cap->oap);
  }
  if (p_im) {



  }
  return;
}
}
static int nv_edit(CMDARG *cap ) 
{ 
  char_u *tmp ;
  size_t tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (cap->cmdchar == 107 + (73 << 8)) {

  } else { //Added block
  if (cap->cmdchar == 253 + (69 << 8)) {

  }
  }
  if (cap->cmdchar == 65) {

  } else { //Added block
  if (cap->cmdchar == 73) {
    _L___2: ;







  } else { //Added block
  _L___1: ;
  if (cap->cmdchar == 97) {
    goto _L___0;
  } else { //Added block
  if (cap->cmdchar == 105) {
    _L___0: ;
    if ((cap->oap)->op_type != 0) {
      {
      nv_object(cap);
      }
    } else { //Added block
    if (VIsual_active) {
      {
      nv_object(cap);
      }
    } else {
      goto _L;
    }
    }
  } else {
    _L: ;
    {
    tmp___3 = checkclearopq(cap->oap);
    }
    if (! tmp___3) {
      {
      tmp___4 = u_save_cursor();
      }
      if (tmp___4 == 1) {
        {
        if (cap->cmdchar == 65) {

        }
        if (cap->cmdchar == 73) {

        }
        if (cap->cmdchar == 97) {

        }
        goto switch_break;
        case_65: ;/* CIL Label */ 
        {




        }

        case_73: ;/* CIL Label */ 
        {

        }

        case_97: ;/* CIL Label */ 
        {

        }






        switch_break: ;/* CIL Label */ ;
        }
        {
        restart_edit = 0;
        tmp___2 = edit(cap->cmdchar, 0, cap->count1);
        }
        return (tmp___2);
      }
    }
  }
  }
  }
  }
  return (0);
}
}
static void nv_object(CMDARG *cap ) 
{ 
  int flag ;
  int include ;
  char_u *mps_save ;

  {
  if (cap->cmdchar == 105) {
    include = 0;
  } else {
    include = 1;
  }
  mps_save = curbuf->b_p_mps;
  curbuf->b_p_mps = (char_u *)"(:),{:},[:],<:>";
  {
  if (cap->nchar == 119) {
    goto case_119;
  }
  if (cap->nchar == 87) {

  }
  if (cap->nchar == 98) {

  }
  if (cap->nchar == 40) {

  }
  if (cap->nchar == 41) {

  }
  if (cap->nchar == 66) {

  }
  if (cap->nchar == 123) {

  }
  if (cap->nchar == 125) {

  }
  if (cap->nchar == 91) {

  }
  if (cap->nchar == 93) {

  }
  if (cap->nchar == 60) {

  }
  if (cap->nchar == 62) {

  }
  if (cap->nchar == 112) {

  }
  if (cap->nchar == 115) {

  }
  goto switch_default;
  case_119: ;/* CIL Label */ 
  {
  flag = current_word(cap->oap, cap->count1, include, 0);
  }
  goto switch_break;
  case_87: ;/* CIL Label */ 
  {

  }

  case_98: ;/* CIL Label */ 
  case_40: ;/* CIL Label */ 
  case_41: ;/* CIL Label */ 
  {

  }

  case_66: ;/* CIL Label */ 
  case_123: ;/* CIL Label */ 
  case_125: ;/* CIL Label */ 
  {

  }

  case_91: ;/* CIL Label */ 
  case_93: ;/* CIL Label */ 
  {

  }

  case_60: ;/* CIL Label */ 
  case_62: ;/* CIL Label */ 
  {

  }

  case_112: ;/* CIL Label */ 
  {

  }

  case_115: ;/* CIL Label */ 
  {

  }

  switch_default: ;/* CIL Label */ 
  flag = 0;
  goto switch_break;
  switch_break: ;/* CIL Label */ ;
  }
  curbuf->b_p_mps = mps_save;
  if (flag == 0) {
    {
    clearopbeep(cap->oap);
    }
  }
  {
  adjust_cursor_col();
  curwin->w_set_curswant = 1;
  }
  return;
}
}
static void nv_q(CMDARG *cap ) 
{





























}
static void nv_at(CMDARG *cap ) 
{

















































}
static void nv_halfpage(CMDARG *cap ) 
{ 
  int tmp ;

  {
  if (cap->cmdchar == 21) {
    if (curwin->w_cursor.lnum == 1L) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: ;
  if (cap->cmdchar == 4) {
    if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {
      {
      clearopbeep(cap->oap);
      }
    } else {
      goto _L;
    }
  } else {
    _L: ;
    {
    tmp = checkclearop(cap->oap);
    }
    if (! tmp) {
      {
      halfpage(cap->cmdchar == 4, cap->count0);
      }
    }
  }
  }
  return;
}
}
static void nv_join(CMDARG *cap ) 
{






























}
static void nv_put(CMDARG *cap ) 
{










































}
#pragma merger("0","/tmp/cil-PCiYej8m.i","-O0")
int get_register_name(int num ) ;
void dis_msg(char_u *p___0 , int skip_esc ) ;
void clip_free_selection(void) ;
void clip_get_selection(void) ;
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) ;
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) ;
void update_topline_redraw(void) ;
int may_validate_crow(void) ;
char_u *last_search_pat(void) ;
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) ;
int startPS(linenr_t lnum , int para , int both ) ;
void clip_own_selection(void) ;
void clip_gen_set_selection(void) ;
void clip_gen_request_selection(void) ;
static struct yankreg y_regs[38]  ;
static struct yankreg *y_current  ;
static int y_append  ;
static struct yankreg *y_previous  =    (struct yankreg *)((void *)0);
static void shift_block(OPARG *oap , int amount ) ;
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) ;
static char_u *get_expr_line(void) ;
static void get_yank_register(int regname___0 , int writing ) ;
static int stuff_yank(int regname___0 , char_u *p___0 ) ;
static int put_in_typebuf(char_u *s , int colon ) ;
static void stuffescaped(char_u *arg ) ;
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) ;
static void cmdline_paste_str(char_u *s , int literally ) ;
static void free_yank(long n ) ;
static void free_yank_all(void) ;
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) ;
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) ;
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) ;
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) ;
static char opchars[19][3]  = 
  { {        (char )'\000',        (char )'\000',        (char)0}, 
   {        (char )'d',        (char )'\000',        (char)0}, 
   {        (char )'y',        (char )'\000',        (char)0}, 
   {        (char )'c',        (char )'\000',        (char)0}, 
   {        (char )'<',        (char )'\000',        (char)1}, 
   {        (char )'>',        (char )'\000',        (char)1}, 
   {        (char )'!',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'~',        (char)0}, 
   {        (char )'=',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'q',        (char)1}, 
   {        (char )':',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'U',        (char)0}, 
   {        (char )'g',        (char )'u',        (char)0}, 
   {        (char )'J',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'J',        (char)1}, 
   {        (char )'g',        (char )'?',        (char)0}, 
   {        (char )'r',        (char )'\000',        (char)0}, 
   {        (char )'I',        (char )'\000',        (char)0}, 
   {        (char )'A',        (char )'\000',        (char)0}};
int get_op_type(int char1 , int char2 ) 
{ 
  int i___0 ;

  {
  if (char1 == 114) {

  }
  if (char1 == 126) {

  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((int )opchars[i___0][0] == char1) {
      if ((int )opchars[i___0][1] == char2) {
        goto while_break;
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (i___0);
}
}
int op_on_lines(int op ) 
{





}
int get_op_char(int optype ) 
{ 


  {
  return ((int )opchars[optype][0]);
}
}
int get_extra_op_char(int optype ) 
{ 


  {
  return ((int )opchars[optype][1]);
}
}
void op_shift(OPARG *oap , int curs_top , int amount ) 
{ 
  long i___0 ;
  int first_char ;
  int block_col ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
  block_col = 0;
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + oap->line_count);
  }
  if (tmp == 0) {

  }
  {
  syn_changed(curwin->w_cursor.lnum);
  }
  if (oap->block_mode) {

  }
  i___0 = oap->line_count;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0L)) {
      goto while_break;
    }
    {
    tmp___0 = ml_get_curline();
    first_char = (int )*tmp___0;
    }
    if (first_char == 0) {
      curwin->w_cursor.col = (colnr_t )0;
    } else { //Added block
    if (oap->block_mode) {
      {

      }
    } else { //Added block
    if (first_char != 35) {
      {
      shift_line(oap->op_type == 4, p_sr, amount);
      }
    } else { //Added block





















    }
    }
    }
    (curwin->w_cursor.lnum) ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (oap->block_mode) {


  } else { //Added block
  if (curs_top) {
    {
    curwin->w_cursor.lnum -= oap->line_count;
    beginline(6);
    }
  } else {

  }
  }
  {
  update_topline();
  update_screen(40);
  }
  if (oap->line_count > p_report) {
    {
    tmp___2 = plural((long )amount);
    }
    if (oap->op_type == 5) {

    } else {
      tmp___3 = '<';
    }
    {
    tmp___4 = plural(oap->line_count);
    smsg((char_u *)"%ld line%s %ced %d time%s", oap->line_count, tmp___4, tmp___3,
         amount, tmp___2);
    }
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  return;
}
}
void shift_line(int left , int round , int amount ) 
{ 
  int count___2 ;
  int i___0 ;
  int j ;
  int p_sw ;

  {
  {
  p_sw = (int )curbuf->b_p_sw;
  count___2 = get_indent();
  }
  if (round) {
















  } else { //Added block
  if (left) {
    count___2 -= p_sw * amount;
    if (count___2 < 0) {
      count___2 = 0;
    }
  } else {

  }
  }
  if (State == 784) {
    {

    }
  } else {
    {
    set_indent(count___2, 1);
    }
  }
  return;
}
}
static void shift_block(OPARG *oap , int amount ) 
{










































































































































































































}
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) 
{
















































































































}
void op_reindent(OPARG *oap , int (*how)(void) ) 
{

























































































}
static char_u *expr_line  =    (char_u *)((void *)0);
int get_expr_register(void) 
{




















}
void set_expr_line(char_u *new_line ) 
{









}
static char_u *get_expr_line(void) 
{











}
int valid_yank_reg(int regname___0 , int writing ) 
{ 
  unsigned short const   **tmp ;
  char_u *tmp___0 ;

  {
  if (regname___0 > 126) {

  }
  {
  tmp = __ctype_b_loc();
  }
  if ((int const   )*(*tmp + regname___0) & 8) {
    return (1);
  } else { //Added block
  if (! writing) {
    {
    tmp___0 = vim_strchr((char_u *)"/.%#:=", regname___0);
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {

    } else {
      goto _L;
    }
  } else { //Added block
  _L: ;
  if (regname___0 == 34) {

  } else { //Added block
  if (regname___0 == 45) {

  } else { //Added block
  if (regname___0 == 95) {

  } else { //Added block
  if (regname___0 == 42) {

  }
  }
  }
  }
  }
  }
  return (0);
}
}
static void get_yank_register(int regname___0 , int writing ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  y_append = 0;
  if (regname___0 == 0) {





  } else { //Added block
  _L___0: ;
  if (regname___0 == 34) {
    _L: ;




  }
  }
  {
  i___0 = regname___0;
  tmp___1 = __ctype_b_loc();
  }
  if ((int const   )*(*tmp___1 + i___0) & 2048) {

  } else {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + i___0) & 512) {
      i___0 -= 87;
    } else {
      {
      tmp = __ctype_b_loc();
      }
      if ((int const   )*(*tmp + i___0) & 256) {


      } else { //Added block
      if (regname___0 == 45) {
        i___0 = 36;
      } else { //Added block









      }
      }
    }
  }
  y_current = & y_regs[i___0];
  if (writing) {
    y_previous = y_current;
  }
  return;
}
}
int yank_register_mline(int regname___0 ) 
{



















}
static int regname  ;
int do_record(int c ) 
{






















































}
static int stuff_yank(int regname___0 , char_u *p___0 ) 
{









































































}
static int lastc  =    '\000';
int do_execreg(int regname___0 , int colon , int addcr ) 
{



































































































































}
static int put_in_typebuf(char_u *s , int colon ) 
{























}
int insert_reg(int regname___0 , int literally ) 
{





































































































}
static void stuffescaped(char_u *arg ) 
{



































}
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) 
{


















































































































































}
int cmdline_paste(int regname___0 , int literally ) 
{
















































































}
static void cmdline_paste_str(char_u *s , int literally ) 
{












































































}
int op_delete(OPARG *oap ) 
{ 
  int n ;
  linenr_t lnum ;
  char_u *ptr ;
  char_u *newp ;
  char_u *oldp ;
  linenr_t old_lcount ;
  int did_yank ;
  struct block_def bd ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  old_lcount = curbuf->b_ml.ml_line_count;
  did_yank = 0;
  if (curbuf->b_ml.ml_flags & 1) {

  }
  if (oap->empty) {
    {

    }

  }
  if (oap->regname == 0) {
    {
    tmp___0 = vim_strchr(p_cb, 'd');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {

    }
  }
  if (! clipboard.available) {
    if (oap->regname == 42) {

    }
  }
  if (oap->motion_type == 0) {
    if (! oap->is_VIsual) {
      if (oap->line_count > 1L) {















      }
    }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (oap->op_type == 1) {
        {
        tmp___4 = ml_get(oap->start.lnum);
        }
        if ((int )*tmp___4 == 0) {
          {

          }






        }
      }
    }
  }
  if (oap->regname != 95) {
    if (oap->regname != 0) {
      {

      }






      {


      }



    }
    if (oap->regname != 0) {

    } else { //Added block
    if (oap->motion_type == 1) {

    } else { //Added block
    if (oap->line_count > 1L) {
      _L: ;
      {



      }
      {








      while_break: ;/* CIL Label */ ;
      }




    } else { //Added block
    if (oap->regname == 0) {
      {
      oap->regname = '-';
      get_yank_register(oap->regname, 1);
      oap->regname = 0;
      }
    }
    }
    }
    }
    if (oap->regname == 0) {
      {
      tmp___7 = op_yank(oap, 1, 0);
      }
      if (tmp___7 == 1) {
        did_yank = 1;
      }
    }
    if (! did_yank) {
      {

      }






    }
  }
  if (oap->block_mode) {
    {

    }



    {


    }
    {
































    while_break___0: ;/* CIL Label */ ;
    }
    {







    }
  } else { //Added block
  if (oap->motion_type == 1) {










































  } else { //Added block
  if (oap->line_count == 1L) {
    {
    tmp___13 = u_save_cursor();
    }
    if (tmp___13 == 0) {

    }
    {
    tmp___14 = vim_strchr(p_cpo, '$');
    }
    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
      if (oap->op_type == 3) {







      }
    }
    {
    n = (int )(((oap->end.col - oap->start.col) + 1U) - (colnr_t )(! oap->inclusive));
    del_chars((long )n, restart_edit == 0);
    }
  } else {
    {

    }



    {






    }



    {





    }
  }
  }
  }
  if (oap->motion_type == 0) {
    if (oap->line_count == 1L) {
      if (dollar_vcol) {

      } else {
        {
        update_screenline();
        }
      }
    } else {

    }
  } else { //Added block
  _L___0: ;






  }
  {
  msgmore(curbuf->b_ml.ml_line_count - old_lcount);
  curbuf->b_op_start = oap->start;
  }
  if (oap->block_mode) {


  } else {
    curbuf->b_op_end = oap->start;
  }
  return (1);
}
}
int op_replace(OPARG *oap , int c ) 
{













































































































































}
void op_tilde(OPARG *oap ) 
{































































































































}
void swapchar(int op_type , FPOS *pos___0 ) 
{






















































}
void op_insert(OPARG *oap , long count1 ) 
{





















































































































































































}
int op_change(OPARG *oap ) 
{











































































































































































}
void init_yank(void) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    y_regs[i___0].y_array = (char_u **)((void *)0);
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static void free_yank(long n ) 
{ 
  long i___0 ;

  {
  if ((unsigned long )y_current->y_array != (unsigned long )((void *)0)) {

    {










    while_break: ;/* CIL Label */ ;
    }
    {


    }
  }
  return;
}
}
static void free_yank_all(void) 
{ 


  {
  {
  free_yank(y_current->y_size);
  }
  return;
}
}
int op_yank(OPARG *oap , int deleting , int mess ) 
{ 
  long y_idx ;
  struct yankreg *curr ;
  struct yankreg newreg ;
  char_u **new_ptr ;
  linenr_t lnum ;
  long j ;
  long len___0 ;
  int yanktype ;
  long yanklines ;
  linenr_t yankendlnum ;
  char_u *p___0 ;
  char_u *pnew ;
  struct block_def bd ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  long tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  linenr_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  linenr_t tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  char_u *tmp___13 ;
  char_u *tmp___14 ;
  char_u *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  char *tmp___21 ;

  {
  yanktype = oap->motion_type;
  yanklines = oap->line_count;
  yankendlnum = oap->end.lnum;
  if (oap->regname != 0) {
    {
    tmp = valid_yank_reg(oap->regname, 1);
    }
    if (! tmp) {
      {

      }

    }
  }
  if (oap->regname == 95) {

  }
  if (! deleting) {
    if (oap->regname == 0) {
      {

      }



    }
  }
  if (! clipboard.available) {
    if (oap->regname == 42) {

    }
  }
  if (! deleting) {
    {
    get_yank_register(oap->regname, 1);
    }
  }
  curr = y_current;
  if (y_append) {







  } else {
    {
    free_yank_all();
    }
  }
  if (oap->motion_type == 0) {
    if (oap->start.col == 0U) {
      if (! oap->inclusive) {














      }
    }
  }
  {
  y_current->y_size = yanklines;
  y_current->y_type = (char_u )yanktype;
  tmp___1 = lalloc_clear(sizeof(char_u *) * (unsigned long )yanklines, 1);
  y_current->y_array = (char_u **)tmp___1;
  }
  if ((unsigned long )y_current->y_array == (unsigned long )((void *)0)) {


  }
  y_idx = 0L;
  lnum = oap->start.lnum;
  if (oap->block_mode) {

    {


























    while_break: ;/* CIL Label */ ;
    }
  } else {
    if (yanktype != 1) {
      if (yanklines == 1L) {
        {
        j = (long )(((oap->end.col - oap->start.col) + 1U) - (colnr_t )(! oap->inclusive));
        tmp___3 = ml_get(lnum);
        p___0 = tmp___3 + oap->start.col;
        tmp___4 = strlen((char const   *)((char *)p___0));
        len___0 = (long )tmp___4;
        }
        if (j > len___0) {

        } else { //Added block
        if (j < 0L) {

        }
        }
        {
        tmp___5 = vim_strnsave(p___0, (int )j);
        *(y_current->y_array + 0) = tmp___5;
        }
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          fail: ;
          {


          }

        }
        goto success;
      }
      {





      }




    }
    {






















    while_break___0: ;/* CIL Label */ ;
    }
    if (yanktype != 1) {
      {



      }



    }
  }
  success: ;
  if ((unsigned long )curr != (unsigned long )y_current) {
    {



    }




    {








    while_break___1: ;/* CIL Label */ ;
    }
    {


    }



























    {











    while_break___2: ;/* CIL Label */ ;
    }
    {



    }
  }
  if (mess) {
    if (yanktype == 0) {
      if (! oap->block_mode) {
        if (yanklines == 1L) {
          yanklines = 0L;
        }
      }
    }
    if (yanklines > p_report) {
      {



      }
    }
  }
  curbuf->b_op_start = oap->start;
  curbuf->b_op_end = oap->end;
  if ((unsigned long )curr == (unsigned long )(& y_regs[37])) {






  }
  return (1);
}
}
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) 
{























































































































































































































































































































































































































































































































































































































































































































}
int get_register_name(int num ) 
{ 


  {
  if (num == -1) {
    return ('\"');
  } else { //Added block
  if (num < 10) {
    return (num + 48);
  } else { //Added block
  if (num == 36) {
    return ('-');
  } else { //Added block
  if (num == 37) {
    return ('*');
  } else {
    return ((num + 97) - 10);
  }
  }
  }
  }
}
}
void do_dis(char_u *arg ) 
{ 
  int i___0 ;
  int n ;
  long j ;
  char_u *p___0 ;
  struct yankreg *yb ;
  char_u name___1 ;
  int attr ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *fname ;
  linenr_t dummy ;
  int tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;

  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    if ((int )*arg == 0) {

    }
  }
  {
  attr = highlight_attr[0];
  msg_puts_title((char_u *)"\n--- Registers ---");
  i___0 = -1;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    if (i___0 == -1) {
      if ((unsigned long )y_previous != (unsigned long )((void *)0)) {
        yb = y_previous;
      } else {

      }
    } else {
      yb = & y_regs[i___0];
    }
    {
    tmp = get_register_name(i___0);
    name___1 = (char_u )tmp;
    }
    if ((unsigned long )yb->y_array != (unsigned long )((void *)0)) {
      if ((unsigned long )arg == (unsigned long )((void *)0)) {

      } else {
        {
        tmp___1 = vim_strchr(arg, (int )name___1);
        }
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
          _L: ;
          {
          msg_putchar('\n');
          msg_putchar('\"');
          msg_putchar((int )name___1);
          msg_puts((char_u *)"   ");
          n = (int )Columns - 6;
          j = 0L;
          }
          {
          while (1) {
            while_continue___0: ;/* CIL Label */ ;
            if (j < yb->y_size) {
              if (! (n > 1)) {

              }
            } else {
              goto while_break___0;
            }
            if (j) {
              {


              }
            }
            p___0 = *(yb->y_array + j);
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              if (*p___0) {
                {
                tmp___0 = charsize((int )*p___0);
                n -= tmp___0;
                }
                if (! (n >= 0)) {

                }
              } else {
                goto while_break___1;
              }
              {
              msg_outtrans_len(p___0, 1);
              p___0 ++;
              }
            }
            while_break___1: ;/* CIL Label */ ;
            }
            j ++;
          }
          while_break___0: ;/* CIL Label */ ;
          }
          if (n > 1) {
            if ((int )yb->y_type == 1) {
              {

              }
            }
          }
          {
          out_flush();
          }
        }
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  p___0 = get_last_insert();
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
















  }
  if ((unsigned long )last_cmdline != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {


      }
    } else {
      {
      tmp___3 = vim_strchr(arg, ':');
      }
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {


        }
      }
    }
  }
  if ((unsigned long )curbuf->b_fname != (unsigned long )((void *)0)) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {


      }
    } else {
      {
      tmp___4 = vim_strchr(arg, '%');
      }
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        {


        }
      }
    }
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {

  } else {
    {
    tmp___6 = vim_strchr(arg, '%');
    }
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      _L___0: ;
      {

      }






    }
  }
  {
  tmp___8 = last_search_pat();
  }
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {


















  }
  if ((unsigned long )expr_line != (unsigned long )((void *)0)) {
















  }
  return;
}
}
void dis_msg(char_u *p___0 , int skip_esc ) 
{











































}
void do_do_join(long count___2 , int insert_space , int redraw ) 
{
















































}
int do_join(int insert_space , int redraw ) 
{


































































































































}
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) 
{

















































































































































}
void op_format(OPARG *oap ) 
{













































































































































































































































































}
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) 
{























































}
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) 
{























































































































































}
static int hexupper  =    0;
int do_addsub(int command , linenr_t Prenum1 ) 
{

































































































































































































































































































































}
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) 
{








































































































































































}
void write_viminfo_registers(FILE *fp___0 ) 
{ 
  int i___0 ;
  int j ;
  char_u *type ;
  char_u c ;
  int num_lines ;
  int max_num_lines ;

  {
  {
  fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# Registers:\n");
  max_num_lines = get_viminfo_parameter('\"');
  }
  if (max_num_lines == 0) {

  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 38)) {
      goto while_break;
    }
    if ((unsigned long )y_regs[i___0].y_array == (unsigned long )((void *)0)) {
      goto __Cont;
    }



    {










    case_1: ;/* CIL Label */ 


    case_0: ;/* CIL Label */ 


    case_2: ;/* CIL Label */ 


    switch_default: ;/* CIL Label */ 
    {




    }

    switch_break: ;/* CIL Label */ ;
    }














    {



    }






    {











    while_break___0: ;/* CIL Label */ ;
    }
    __Cont: ;
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
void clip_free_selection(void) 
{












}
void clip_get_selection(void) 
{















































}
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) 
{










}
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) 
{








































































}
char_u *get_reg_contents(int regname___0 ) 
{

















































































































}
void write_reg_contents(int name___1 , char_u *str___1 ) 
{






































































}
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) 
{




























































































































































}
void clear_oparg(OPARG *oap ) 
{ 


  {
  {
  memset((void *)oap, 0, sizeof(OPARG ));
  }
  return;
}
}
#pragma merger("0","/tmp/cil-57zfFRmO.i","-O0")
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
int mch_can_restore_title(void) ;
int mch_can_restore_icon(void) ;
void mch_setmouse(int on ) ;
void check_mouse_termcode(void) ;
void clear_xterm_clip(void) ;
void set_string_default(char *name___1 , char_u *val ) ;
void set_number_default(char *name___1 , long val ) ;
void set_title_defaults(void) ;
void check_options(void) ;
void set_term_option_alloced(char_u **p___0 ) ;
char_u *check_stl_option(char_u *s ) ;
char_u *get_term_code(char_u *tname ) ;
char_u *get_highlight_default(void) ;
void clear_termoptions(void) ;
void set_term_defaults(void) ;
void comp_col(void) ;
void win_copy_options(WIN *wp_from , WIN *wp_to ) ;
int option_was_set(char_u *name___1 ) ;
int highlight_changed(void) ;
int set_termname(char_u *term ) ;
void ttest(int pairs ) ;
void check_winsize(void) ;
void clear_termcodes(void) ;
char_u *get_termcode(int i___0 ) ;
void show_termcodes(void) ;
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) ;
void ui_set_winsize(void) ;
void win_setminheight(void) ;
void win_comp_scroll(WIN *wp ) ;
void command_height(long old_p_ch ) ;
int min_rows(void) ;
static struct vimoption options[286]  = 
  {      {(char *)"aleph", (char *)"al", (short_u )1026, (char_u *)((void *)0), {(char_u *)224L,
                                                                             (char_u *)0L}}, 
        {(char *)"allowrevins",
      (char *)"ari", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"altkeymap",
      (char *)"akm", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoindent",
      (char *)"ai", (short_u )1057, (char_u *)1, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoprint", (char *)"ap", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"autowrite",
      (char *)"aw", (short_u )1025, (char_u *)(& p_aw), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"background",
      (char *)"bg", (short_u )29700, (char_u *)(& p_bg), {(char_u *)"light", (char_u *)0L}}, 
        {(char *)"backspace",
      (char *)"bs", (short_u )35844, (char_u *)(& p_bs), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"backup",
      (char *)"bk", (short_u )3073, (char_u *)(& p_bk), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"backupdir",
      (char *)"bdir", (short_u )33812, (char_u *)(& p_bdir), {(char_u *)".,~/tmp,~/",
                                                              (char_u *)0L}}, 
        {(char *)"backupext", (char *)"bex", (short_u )1028, (char_u *)(& p_bex), {(char_u *)"~",
                                                                                (char_u *)0L}}, 
        {(char *)"beautify",
      (char *)"bf", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"binary",
      (char *)"bin", (short_u )5153, (char_u *)2, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"bioskey", (char *)"biosk", (short_u )1025, (char_u *)((void *)0), {(char_u *)1,
                                                                                  (char_u *)0L}}, 
        {(char *)"breakat",
      (char *)"brk", (short_u )17412, (char_u *)(& p_breakat), {(char_u *)" \t!@*-+_;:,./?",
                                                                (char_u *)0L}}, 
        {(char *)"browsedir", (char *)"bsdir", (short_u )1028, (char_u *)((void *)0),
      {(char_u *)"last", (char_u *)0L}}, 
        {(char *)"cindent", (char *)"cin", (short_u )3105, (char_u *)3, {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"cinkeys",
      (char *)"cink", (short_u )33836, (char_u *)4, {(char_u *)"0{,0},:,0#,!^F,o,O,e",
                                                     (char_u *)0L}}, 
        {(char *)"cinoptions", (char *)"cino", (short_u )33836, (char_u *)5, {(char_u *)"",
                                                                           (char_u *)0L}}, 
        {(char *)"cinwords",
      (char *)"cinw", (short_u )33836, (char_u *)6, {(char_u *)"if,else,while,do,for,switch",
                                                     (char_u *)0L}}, 
        {(char *)"clipboard", (char *)"cb", (short_u )33796, (char_u *)(& p_cb), {(char_u *)"",
                                                                               (char_u *)0L}}, 
        {(char *)"cmdheight",
      (char *)"ch", (short_u )17410, (char_u *)(& p_ch), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"columns",
      (char *)"co", (short_u )30274, (char_u *)(& Columns), {(char_u *)80L, (char_u *)0L}}, 
        {(char *)"comments",
      (char *)"com", (short_u )33836, (char_u *)7, {(char_u *)"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-",
                                                    (char_u *)0L}}, 
        {(char *)"compatible", (char *)"cp", (short_u )16385, (char_u *)(& p_cp), {(char_u *)1,
                                                                                (char_u *)0}}, 
        {(char *)"complete",
      (char *)"cpt", (short_u )33836, (char_u *)8, {(char_u *)".,w,b,u,t,i", (char_u *)0L}}, 
        {(char *)"confirm",
      (char *)"cf", (short_u )1025, (char_u *)(& p_confirm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"conskey",
      (char *)"consk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"cpoptions",
      (char *)"cpo", (short_u )18436, (char_u *)(& p_cpo), {(char_u *)"aAbBcCdeEfFjJkKlLmoOprsStuwWxy$!%*<",
                                                            (char_u *)"aABceFs"}}, 
        {(char *)"cscopeprg",
      (char *)"csprg", (short_u )1044, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetag",
      (char *)"cst", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetagorder",
      (char *)"csto", (short_u )3074, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopeverbose",
      (char *)"csverb", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"define",
      (char *)"def", (short_u )1028, (char_u *)(& p_def), {(char_u *)"^#\\s*define",
                                                           (char_u *)0L}}, 
        {(char *)"dictionary", (char *)"dict", (short_u )33812, (char_u *)(& p_dict),
      {(char_u *)"", (char_u *)0L}}, 
        {(char *)"digraph", (char *)"dg", (short_u )3073, (char_u *)(& p_dg), {(char_u *)0,
                                                                            (char_u *)0L}}, 
        {(char *)"directory",
      (char *)"dir", (short_u )33812, (char_u *)(& p_dir), {(char_u *)".,~/tmp,/var/tmp,/tmp",
                                                            (char_u *)0L}}, 
        {(char *)"display", (char *)"dy", (short_u )50180, (char_u *)(& p_dy), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"edcompatible",
      (char *)"ed", (short_u )1025, (char_u *)(& p_ed), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"endofline",
      (char *)"eol", (short_u )5665, (char_u *)9, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"equalalways", (char *)"ea", (short_u )17409, (char_u *)(& p_ea), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"equalprg",
      (char *)"ep", (short_u )1044, (char_u *)(& p_ep), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"errorbells",
      (char *)"eb", (short_u )1025, (char_u *)(& p_eb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"errorfile",
      (char *)"ef", (short_u )1044, (char_u *)(& p_ef), {(char_u *)"errors.err", (char_u *)0L}}, 
        {(char *)"errorformat",
      (char *)"efm", (short_u )33796, (char_u *)(& p_efm), {(char_u *)"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f\',%X%*\\a[%*\\d]: Leaving directory `%f\',%DMaking %*\\a in %f",
                                                            (char_u *)0L}}, 
        {(char *)"esckeys", (char *)"ek", (short_u )2049, (char_u *)(& p_ek), {(char_u *)0,
                                                                            (char_u *)1}}, 
        {(char *)"eventignore",
      (char *)"ei", (short_u )33796, (char_u *)(& p_ei), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"expandtab",
      (char *)"et", (short_u )3105, (char_u *)10, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"exrc", (char *)"ex", (short_u )1025, (char_u *)(& p_exrc), {(char_u *)0,
                                                                           (char_u *)0L}}, 
        {(char *)"fileencoding",
      (char *)"fe", (short_u )5164, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"fileformat",
      (char *)"ff", (short_u )5676, (char_u *)12, {(char_u *)"unix", (char_u *)0L}}, 
        {(char *)"fileformats",
      (char *)"ffs", (short_u )34820, (char_u *)(& p_ffs), {(char_u *)"", (char_u *)"unix,dos"}}, 
        {(char *)"filetype",
      (char *)"ft", (short_u )1068, (char_u *)14, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"fkmap", (char *)"fk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                             (char_u *)0L}}, 
        {(char *)"flash",
      (char *)"fl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"formatoptions",
      (char *)"fo", (short_u )2092, (char_u *)13, {(char_u *)"vt", (char_u *)"tcq"}}, 
        {(char *)"formatprg",
      (char *)"fp", (short_u )1044, (char_u *)(& p_fp), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"gdefault",
      (char *)"gd", (short_u )3073, (char_u *)(& p_gd), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"graphic",
      (char *)"gr", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"grepformat",
      (char *)"gfm", (short_u )33796, (char_u *)(& p_gefm), {(char_u *)"%f:%l%m,%f  %l%m",
                                                             (char_u *)0L}}, 
        {(char *)"grepprg", (char *)"gp", (short_u )1044, (char_u *)(& p_gp), {(char_u *)"grep -n",
                                                                            (char_u *)0L}}, 
        {(char *)"guicursor",
      (char *)"gcr", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guifont", (char *)"gfn", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                                 (char_u *)0L}}, 
        {(char *)"guifontset",
      (char *)"gfs", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guiheadroom", (char *)"ghr", (short_u )1026, (char_u *)((void *)0),
      {(char_u *)50L, (char_u *)0L}}, 
        {(char *)"guioptions", (char *)"go", (short_u )17412, (char_u *)((void *)0),
      {(char_u *)((void *)0), (char_u *)0L}}, 
        {(char *)"guipty", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)1, (char_u *)0L}}, 
        {(char *)"hardtabs", (char *)"ht", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                                (char_u *)0L}}, 
        {(char *)"helpfile",
      (char *)"hf", (short_u )1044, (char_u *)(& p_hf), {(char_u *)"$VIMRUNTIME/doc/help.txt",
                                                         (char_u *)0L}}, 
        {(char *)"helpheight", (char *)"hh", (short_u )1026, (char_u *)(& p_hh), {(char_u *)20L,
                                                                               (char_u *)0L}}, 
        {(char *)"hidden",
      (char *)"hid", (short_u )1025, (char_u *)(& p_hid), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"highlight",
      (char *)"hl", (short_u )62468, (char_u *)(& p_hl), {(char_u *)"8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu",
                                                          (char_u *)0L}}, 
        {(char *)"history", (char *)"hi", (short_u )2050, (char_u *)(& p_hi), {(char_u *)0L,
                                                                            (char_u *)20L}}, 
        {(char *)"hkmap",
      (char *)"hk", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hkmapp",
      (char *)"hkp", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hlsearch",
      (char *)"hls", (short_u )19457, (char_u *)(& p_hls), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"icon",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_icon), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"iconstring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_iconstring), {(char_u *)"",
                                                                        (char_u *)0L}}, 
        {(char *)"ignorecase",
      (char *)"ic", (short_u )1025, (char_u *)(& p_ic), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"include",
      (char *)"inc", (short_u )1028, (char_u *)(& p_inc), {(char_u *)"^#\\s*include",
                                                           (char_u *)0L}}, 
        {(char *)"incsearch", (char *)"is", (short_u )3073, (char_u *)(& p_is), {(char_u *)0,
                                                                              (char_u *)0L}}, 
        {(char *)"infercase",
      (char *)"inf", (short_u )1057, (char_u *)15, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"insertmode", (char *)"im", (short_u )3073, (char_u *)(& p_im), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"isfname",
      (char *)"isf", (short_u )33796, (char_u *)(& p_isf), {(char_u *)"@,48-57,/,.,-,_,+,,,$,~",
                                                            (char_u *)0L}}, 
        {(char *)"isident", (char *)"isi", (short_u )33796, (char_u *)(& p_isi), {(char_u *)"@,48-57,_,192-255",
                                                                               (char_u *)0L}}, 
        {(char *)"iskeyword",
      (char *)"isk", (short_u )34860, (char_u *)16, {(char_u *)"@,48-57,_", (char_u *)"@,48-57,_,192-255"}}, 
        {(char *)"isprint",
      (char *)"isp", (short_u )50180, (char_u *)(& p_isp), {(char_u *)"@,161-255",
                                                            (char_u *)0L}}, 
        {(char *)"joinspaces", (char *)"js", (short_u )3073, (char_u *)(& p_js), {(char_u *)1,
                                                                               (char_u *)0L}}, 
        {(char *)"key",
      (char *)((void *)0), (short_u )1580, (char_u *)17, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keymodel",
      (char *)"km", (short_u )33796, (char_u *)(& p_km), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keywordprg",
      (char *)"kp", (short_u )1044, (char_u *)(& p_kp), {(char_u *)"man -s", (char_u *)0L}}, 
        {(char *)"langmap",
      (char *)"lmap", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                               (char_u *)0L}}, 
        {(char *)"laststatus", (char *)"ls", (short_u )17410, (char_u *)(& p_ls), {(char_u *)1L,
                                                                                (char_u *)0L}}, 
        {(char *)"lazyredraw",
      (char *)"lz", (short_u )1025, (char_u *)(& p_lz), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"linebreak",
      (char *)"lbr", (short_u )9249, (char_u *)18, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"lines", (char *)((void *)0), (short_u )30274, (char_u *)(& Rows), {(char_u *)24L,
                                                                                  (char_u *)0L}}, 
        {(char *)"lisp",
      (char *)((void *)0), (short_u )1057, (char_u *)19, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"list",
      (char *)((void *)0), (short_u )9249, (char_u *)20, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"listchars",
      (char *)"lcs", (short_u )50180, (char_u *)(& p_lcs), {(char_u *)"eol:$", (char_u *)0L}}, 
        {(char *)"magic",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_magic), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"makeef",
      (char *)"mef", (short_u )1044, (char_u *)(& p_mef), {(char_u *)"/tmp/vim##.err",
                                                           (char_u *)0L}}, 
        {(char *)"makeprg", (char *)"mp", (short_u )1044, (char_u *)(& p_mp), {(char_u *)"make",
                                                                            (char_u *)0L}}, 
        {(char *)"matchpairs",
      (char *)"mps", (short_u )33836, (char_u *)22, {(char_u *)"(:),{:},[:]", (char_u *)0L}}, 
        {(char *)"matchtime",
      (char *)"mat", (short_u )1026, (char_u *)(& p_mat), {(char_u *)5L, (char_u *)0L}}, 
        {(char *)"maxfuncdepth",
      (char *)"mfd", (short_u )1026, (char_u *)(& p_mfd), {(char_u *)100L, (char_u *)0L}}, 
        {(char *)"maxmapdepth",
      (char *)"mmd", (short_u )1026, (char_u *)(& p_mmd), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"maxmem",
      (char *)"mm", (short_u )1026, (char_u *)(& p_mm), {(char_u *)5120, (char_u *)0L}}, 
        {(char *)"maxmemtot",
      (char *)"mmt", (short_u )1026, (char_u *)(& p_mmt), {(char_u *)10240, (char_u *)0L}}, 
        {(char *)"mesg",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"modeline",
      (char *)"ml", (short_u )2081, (char_u *)21, {(char_u *)0, (char_u *)1}}, 
        {(char *)"modelines", (char *)"mls", (short_u )1026, (char_u *)(& p_mls), {(char_u *)5L,
                                                                                (char_u *)0L}}, 
        {(char *)"modified",
      (char *)"mod", (short_u )5665, (char_u *)23, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"more", (char *)((void *)0), (short_u )2049, (char_u *)(& p_more), {(char_u *)0,
                                                                                  (char_u *)1}}, 
        {(char *)"mouse",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_mouse), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"mousefocus",
      (char *)"mousef", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousehide",
      (char *)"mh", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousemodel",
      (char *)"mousem", (short_u )1028, (char_u *)(& p_mousem), {(char_u *)"extend",
                                                                 (char_u *)0L}}, 
        {(char *)"mousetime", (char *)"mouset", (short_u )1026, (char_u *)(& p_mouset),
      {(char_u *)500L, (char_u *)0L}}, 
        {(char *)"novice", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"nrformats", (char *)"nf", (short_u )33836, (char_u *)24, {(char_u *)"octal,hex",
                                                                         (char_u *)0L}}, 
        {(char *)"number",
      (char *)"nu", (short_u )9249, (char_u *)25, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"open", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"optimize", (char *)"opt", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"osfiletype",
      (char *)"oft", (short_u )1068, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"paragraphs",
      (char *)"para", (short_u )1028, (char_u *)(& p_para), {(char_u *)"IPLPPPQPP LIpplpipbp",
                                                             (char_u *)0L}}, 
        {(char *)"paste", (char *)((void *)0), (short_u )1025, (char_u *)(& p_paste),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"pastetoggle", (char *)"pt", (short_u )1028, (char_u *)(& p_pt), {(char_u *)"",
                                                                                (char_u *)0L}}, 
        {(char *)"patchmode",
      (char *)"pm", (short_u )1028, (char_u *)(& p_pm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"path",
      (char *)"pa", (short_u )33812, (char_u *)(& p_path), {(char_u *)".,/usr/include,,",
                                                            (char_u *)0L}}, 
        {(char *)"previewheight", (char *)"pvh", (short_u )1026, (char_u *)(& p_pvh),
      {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"prompt", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"readonly", (char *)"ro", (short_u )5153, (char_u *)28, {(char_u *)0,
                                                                       (char_u *)0L}}, 
        {(char *)"redraw",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"remap",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_remap), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"report",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_report), {(char_u *)2L,
                                                                    (char_u *)0L}}, 
        {(char *)"restorescreen",
      (char *)"rs", (short_u )1025, (char_u *)((void *)0), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"revins",
      (char *)"ri", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rightleft",
      (char *)"rl", (short_u )9249, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ruler",
      (char *)"ru", (short_u )7169, (char_u *)(& p_ru), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rulerformat",
      (char *)"ruf", (short_u )5132, (char_u *)(& p_ruf), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"scroll",
      (char *)"scr", (short_u )1570, (char_u *)29, {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"scrollbind",
      (char *)"scb", (short_u )1057, (char_u *)35, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"scrolljump", (char *)"sj", (short_u )3074, (char_u *)(& p_sj), {(char_u *)1L,
                                                                               (char_u *)0L}}, 
        {(char *)"scrolloff",
      (char *)"so", (short_u )19458, (char_u *)(& p_so), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"scrollopt",
      (char *)"sbo", (short_u )33796, (char_u *)(& p_sbo), {(char_u *)"ver,jump",
                                                            (char_u *)0L}}, 
        {(char *)"sections", (char *)"sect", (short_u )1028, (char_u *)(& p_sections),
      {(char_u *)"SHNHH HUnhsh", (char_u *)0L}}, 
        {(char *)"secure", (char *)((void *)0), (short_u )1025, (char_u *)(& p_secure),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"selection", (char *)"sel", (short_u )1028, (char_u *)(& p_sel), {(char_u *)"inclusive",
                                                                                (char_u *)0L}}, 
        {(char *)"selectmode",
      (char *)"slm", (short_u )33796, (char_u *)(& p_slm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"sessionoptions",
      (char *)"ssop", (short_u )33796, (char_u *)(& p_sessopt), {(char_u *)"buffers,winsize,options,help,blank",
                                                                 (char_u *)0L}}, 
        {(char *)"shell", (char *)"sh", (short_u )1044, (char_u *)(& p_sh), {(char_u *)"sh",
                                                                          (char_u *)0L}}, 
        {(char *)"shellcmdflag",
      (char *)"shcf", (short_u )1028, (char_u *)(& p_shcf), {(char_u *)"-c", (char_u *)0L}}, 
        {(char *)"shellpipe",
      (char *)"sp", (short_u )1028, (char_u *)(& p_sp), {(char_u *)"| tee", (char_u *)0L}}, 
        {(char *)"shellquote",
      (char *)"shq", (short_u )1028, (char_u *)(& p_shq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shellredir",
      (char *)"srr", (short_u )1028, (char_u *)(& p_srr), {(char_u *)">", (char_u *)0L}}, 
        {(char *)"shellslash",
      (char *)"ssl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shelltype",
      (char *)"st", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"shellxquote",
      (char *)"sxq", (short_u )1028, (char_u *)(& p_sxq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shiftround",
      (char *)"sr", (short_u )3073, (char_u *)(& p_sr), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shiftwidth",
      (char *)"sw", (short_u )1058, (char_u *)36, {(char_u *)8L, (char_u *)0L}}, 
        {(char *)"shortmess", (char *)"shm", (short_u )2052, (char_u *)(& p_shm), {(char_u *)"",
                                                                                (char_u *)"filnxtToO"}}, 
        {(char *)"shortname",
      (char *)"sn", (short_u )1057, (char_u *)31, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showbreak", (char *)"sbr", (short_u )17412, (char_u *)(& p_sbr), {(char_u *)"",
                                                                                 (char_u *)0L}}, 
        {(char *)"showcmd",
      (char *)"sc", (short_u )2049, (char_u *)(& p_sc), {(char_u *)0, (char_u *)0}}, 
        {(char *)"showfulltag",
      (char *)"sft", (short_u )1025, (char_u *)(& p_sft), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmatch",
      (char *)"sm", (short_u )1025, (char_u *)(& p_sm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmode",
      (char *)"smd", (short_u )2049, (char_u *)(& p_smd), {(char_u *)0, (char_u *)1}}, 
        {(char *)"sidescroll",
      (char *)"ss", (short_u )1026, (char_u *)(& p_ss), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"slowopen",
      (char *)"slow", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartcase",
      (char *)"scs", (short_u )3073, (char_u *)(& p_scs), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartindent",
      (char *)"si", (short_u )3105, (char_u *)30, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smarttab", (char *)"sta", (short_u )3073, (char_u *)(& p_sta), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"softtabstop",
      (char *)"sts", (short_u )3106, (char_u *)32, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"sourceany", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"splitbelow", (char *)"sb", (short_u )1025, (char_u *)(& p_sb), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"startofline",
      (char *)"sol", (short_u )3073, (char_u *)(& p_sol), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"statusline",
      (char *)"stl", (short_u )5132, (char_u *)(& p_stl), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"suffixes",
      (char *)"su", (short_u )33796, (char_u *)(& p_su), {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
                                                          (char_u *)0L}}, 
        {(char *)"swapfile", (char *)"swf", (short_u )5153, (char_u *)33, {(char_u *)1,
                                                                        (char_u *)0L}}, 
        {(char *)"swapsync",
      (char *)"sws", (short_u )1028, (char_u *)(& p_sws), {(char_u *)"fsync", (char_u *)0L}}, 
        {(char *)"switchbuf",
      (char *)"swb", (short_u )33796, (char_u *)(& p_swb), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"syntax",
      (char *)"syn", (short_u )1068, (char_u *)34, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"tabstop", (char *)"ts", (short_u )9250, (char_u *)37, {(char_u *)8L,
                                                                      (char_u *)0L}}, 
        {(char *)"tagbsearch",
      (char *)"tbs", (short_u )1025, (char_u *)(& p_tbs), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"taglength",
      (char *)"tl", (short_u )1026, (char_u *)(& p_tl), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"tagrelative",
      (char *)"tr", (short_u )2049, (char_u *)(& p_tr), {(char_u *)0, (char_u *)1}}, 
        {(char *)"tags",
      (char *)"tag", (short_u )33812, (char_u *)(& p_tags), {(char_u *)"./tags,tags",
                                                             (char_u *)0L}}, 
        {(char *)"tagstack", (char *)"tgst", (short_u )1025, (char_u *)(& p_tgst), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"term",
      (char *)((void *)0), (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"terse",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_terse), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textauto",
      (char *)"ta", (short_u )2049, (char_u *)(& p_ta), {(char_u *)0, (char_u *)1}}, 
        {(char *)"textmode",
      (char *)"tx", (short_u )1569, (char_u *)39, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textwidth", (char *)"tw", (short_u )3106, (char_u *)38, {(char_u *)0L,
                                                                        (char_u *)0L}}, 
        {(char *)"tildeop",
      (char *)"top", (short_u )3073, (char_u *)(& p_to), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"timeout",
      (char *)"to", (short_u )1025, (char_u *)(& p_timeout), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"timeoutlen",
      (char *)"tm", (short_u )1026, (char_u *)(& p_tm), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"title",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_title), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"titlelen",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_titlelen), {(char_u *)85L,
                                                                      (char_u *)0L}}, 
        {(char *)"titleold",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titleold), {(char_u *)"Thanks for flying Vim",
                                                                      (char_u *)0L}}, 
        {(char *)"titlestring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titlestring), {(char_u *)"",
                                                                         (char_u *)0L}}, 
        {(char *)"ttimeout",
      (char *)((void *)0), (short_u )3073, (char_u *)(& p_ttimeout), {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"ttimeoutlen",
      (char *)"ttm", (short_u )1026, (char_u *)(& p_ttm), {(char_u *)-1L, (char_u *)0L}}, 
        {(char *)"ttybuiltin",
      (char *)"tbi", (short_u )1025, (char_u *)(& p_tbi), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"ttyfast",
      (char *)"tf", (short_u )1537, (char_u *)(& p_tf), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ttymouse",
      (char *)"ttym", (short_u )1604, (char_u *)(& p_ttym), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"ttyscroll",
      (char *)"tsl", (short_u )1026, (char_u *)(& p_ttyscroll), {(char_u *)999L, (char_u *)0L}}, 
        {(char *)"ttytype",
      (char *)"tty", (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                      (char_u *)0L}}, 
        {(char *)"undolevels",
      (char *)"ul", (short_u )1026, (char_u *)(& p_ul), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"updatecount",
      (char *)"uc", (short_u )1026, (char_u *)(& p_uc), {(char_u *)200L, (char_u *)0L}}, 
        {(char *)"updatetime",
      (char *)"ut", (short_u )1026, (char_u *)(& p_ut), {(char_u *)4000L, (char_u *)0L}}, 
        {(char *)"verbose",
      (char *)"vbs", (short_u )1026, (char_u *)(& p_verbose), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"viminfo",
      (char *)"vi", (short_u )33796, (char_u *)(& p_viminfo), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"visualbell",
      (char *)"vb", (short_u )1025, (char_u *)(& p_vb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"w300",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w1200",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w9600",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"warn",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_warn), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"weirdinvert",
      (char *)"wiv", (short_u )29697, (char_u *)(& p_wiv), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"whichwrap",
      (char *)"ww", (short_u )34820, (char_u *)(& p_ww), {(char_u *)"", (char_u *)"b,s"}}, 
        {(char *)"wildchar",
      (char *)"wc", (short_u )2050, (char_u *)(& p_wc), {(char_u *)5L, (char_u *)((long )'\t')}}, 
        {(char *)"wildcharm",
      (char *)"wcm", (short_u )1026, (char_u *)(& p_wcm), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wildignore",
      (char *)"wig", (short_u )33796, (char_u *)(& p_wig), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"wildmenu",
      (char *)"wmnu", (short_u )1025, (char_u *)(& p_wmnu), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"wildmode",
      (char *)"wim", (short_u )33796, (char_u *)(& p_wim), {(char_u *)"full", (char_u *)0L}}, 
        {(char *)"winaltkeys",
      (char *)"wak", (short_u )1028, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                             (char_u *)0L}}, 
        {(char *)"window", (char *)"wi", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                              (char_u *)0L}}, 
        {(char *)"winheight",
      (char *)"wh", (short_u )1026, (char_u *)(& p_wh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"winminheight",
      (char *)"wmh", (short_u )1026, (char_u *)(& p_wmh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"wrap",
      (char *)((void *)0), (short_u )9249, (char_u *)41, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"wrapmargin",
      (char *)"wm", (short_u )1058, (char_u *)40, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wrapscan", (char *)"ws", (short_u )1025, (char_u *)(& p_ws), {(char_u *)1,
                                                                             (char_u *)0L}}, 
        {(char *)"write",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_write), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writeany",
      (char *)"wa", (short_u )1025, (char_u *)(& p_wa), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"writebackup",
      (char *)"wb", (short_u )3073, (char_u *)(& p_wb), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writedelay",
      (char *)"wd", (short_u )1026, (char_u *)(& p_wd), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"t_AB",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[40]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AF",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[39]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[3]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_al",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[2]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_bc",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[32]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[8]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_ce",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[1]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[7]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cm",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[24]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Co",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[34]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_CS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[33]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[6]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_da",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[9]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_db",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[10]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_DL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[5]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_dl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[4]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_fs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[46]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IE",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[44]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[43]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ke",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[29]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ks",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[28]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_le",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[41]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[38]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_md",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[16]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_me",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[14]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[15]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ms",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[23]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_nd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[42]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_op",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[50]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RI",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[26]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RV",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[49]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[36]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sf",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[35]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_se",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[17]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_so",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[18]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_sr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[25]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ts",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[45]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_te",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[31]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ti",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[30]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ue",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[21]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_us",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[22]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[27]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ve",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[12]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vi",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[11]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[13]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WP",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[47]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[48]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_xs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[37]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZH",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[19]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZR",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[20]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)((void *)0),
      (char *)((void *)0), (short_u )0, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                (char_u *)((void *)0)}}};
static char *p_bg_values[3]  = {      (char *)"light",      (char *)"dark",      (char *)((void *)0)};
static char *p_nf_values[3]  = {      (char *)"octal",      (char *)"hex",      (char *)((void *)0)};
static char *p_ff_values[4]  = {      (char *)"unix",      (char *)"dos",      (char *)"mac",      (char *)((void *)0)};
static char *p_sessopt_values[11]  = 
  {      (char *)"buffers",      (char *)"winpos",      (char *)"resize",      (char *)"winsize", 
        (char *)"options",      (char *)"help",      (char *)"blank",      (char *)"globals", 
        (char *)"slash",      (char *)"unix",      (char *)((void *)0)};
static char *p_mousem_values[5]  = {      (char *)"extend",      (char *)"popup",      (char *)"popup_setpos",      (char *)"mac", 
        (char *)((void *)0)};
static char *p_slm_values[4]  = {      (char *)"mouse",      (char *)"key",      (char *)"cmd",      (char *)((void *)0)};
static char *p_sel_values[4]  = {      (char *)"inclusive",      (char *)"exclusive",      (char *)"old",      (char *)((void *)0)};
static char *p_ttym_values[5]  = {      (char *)"xterm",      (char *)"xterm2",      (char *)"dec",      (char *)"netterm", 
        (char *)((void *)0)};
static char *p_km_values[3]  = {      (char *)"startsel",      (char *)"stopsel",      (char *)((void *)0)};
static char *p_bsdir_values[4]  = {      (char *)"current",      (char *)"last",      (char *)"buffer",      (char *)((void *)0)};
static char *p_scbopt_values[4]  = {      (char *)"ver",      (char *)"hor",      (char *)"jump",      (char *)((void *)0)};
static char *p_swb_values[3]  = {      (char *)"useopen",      (char *)"split",      (char *)((void *)0)};
static char *p_dy_values[2]  = {      (char *)"lastline",      (char *)((void *)0)};
static char *p_cb_values[3]  = {      (char *)"unnamed",      (char *)"autoselect",      (char *)((void *)0)};
static char *p_bs_values[4]  = {      (char *)"indent",      (char *)"eol",      (char *)"start",      (char *)((void *)0)};
static void set_option_default(int opt_idx , int dofree ) ;
static void set_options_default(int dofree ) ;
static char_u *illegal_char(char_u *errbuf___0 , int c ) ;
static void did_set_title(int icon ) ;
static char_u *option_expand(int opt_idx ) ;
static void set_string_option(int opt_idx , char_u *value ) ;
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) ;
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) ;
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) ;
static void check_redraw(int flags___0 ) ;
static int findoption(char_u *arg ) ;
static int find_key_option(char_u *arg ) ;
static void showoptions(int all ) ;
static int option_not_default(struct vimoption *p___0 ) ;
static void showoneopt(struct vimoption *p___0 ) ;
static int istermoption(struct vimoption *p___0 ) ;
static char_u *get_varp(struct vimoption *p___0 ) ;
static void option_value2string(struct vimoption *opp ) ;
static void paste_option_changed(void) ;
static void compatible_set(void) ;
static void fill_breakat_flags(void) ;
static int check_opt_strings(char_u *val , char **values , int list ) ;
static int check_opt_wim(void) ;
void set_init_1(void) 
{ 
  char_u *p___0 ;
  int opt_idx ;
  long n ;
  char *tmp ;
  int tmp___0 ;

  {
  {
  p_cp = 1;
  tmp = getenv((char const   *)((char *)((char_u *)"SHELL")));
  p___0 = (char_u *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {

    }
  }
  {
  opt_idx = findoption((char_u *)"maxmemtot");
  }
  if ((unsigned long )options[opt_idx].def_val[0] == (unsigned long )((char_u *)0L)) {
    {



    }







  }
  {
  set_options_default(0);
  curbuf->b_p_initialized = 1;
  check_buf_options(curbuf);
  check_options();
  init_chartab();
  fill_breakat_flags();
  opt_idx = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp___0 = istermoption(& options[opt_idx]);
    }
    if (tmp___0) {
      goto while_break;
    }
    {
    p___0 = option_expand(opt_idx);
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      *((char_u **)options[opt_idx].var) = p___0;
      options[opt_idx].def_val[0] = p___0;
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 128);
    }
    opt_idx ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  highlight_changed();
  curbuf->b_start_ffc = (int )*(curbuf->b_p_ff);
  check_opt_wim();
  }
  return;
}
}
static void set_option_default(int opt_idx , int dofree ) 
{ 
  char_u *varp ;
  int dvi ;
  int flags___0 ;

  {
  {
  varp = get_varp(& options[opt_idx]);
  flags___0 = (int )options[opt_idx].flags;
  }
  if ((unsigned long )varp != (unsigned long )((void *)0)) {
    if (flags___0 & 1024) {
      dvi = 0;
    } else { //Added block
    if (p_cp) {
      dvi = 0;
    } else {

    }
    }
    if (flags___0 & 4) {
      if (flags___0 & 32) {
        {
        set_string_option_direct((char_u *)((void *)0), opt_idx, options[opt_idx].def_val[dvi],
                                 dofree);
        }
      } else {
        if (dofree) {
          if (flags___0 & 8) {
            {

            }
          }
        }
        *((char_u **)varp) = options[opt_idx].def_val[dvi];
        options[opt_idx].flags = (short_u )((int )options[opt_idx].flags & -9);
      }
    } else { //Added block
    if (flags___0 & 2) {
      if ((unsigned long )varp == (unsigned long )((char_u *)29)) {
        {

        }
      } else {
        *((long *)varp) = (long )options[opt_idx].def_val[dvi];
      }
    } else {
      *((int *)varp) = (int )((long )options[opt_idx].def_val[dvi]);
    }
    }
  }
  return;
}
}
static void set_options_default(int dofree ) 
{ 
  int i___0 ;
  WIN *wp ;
  int tmp ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = istermoption(& options[i___0]);
    }
    if (tmp) {
      goto while_break;
    }
    if (! ((int )options[i___0].flags & 64)) {
      {
      set_option_default(i___0, dofree);
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  wp = firstwin;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    win_comp_scroll(wp);
    wp = wp->w_next;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  return;
}
}
void set_string_default(char *name___1 , char_u *val ) 
{ 
  char_u *p___0 ;
  int opt_idx ;

  {
  {
  p___0 = vim_strsave(val);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    opt_idx = findoption((char_u *)name___1);
    }
    if ((int )options[opt_idx].flags & 128) {
      {

      }
    }
    options[opt_idx].def_val[0] = p___0;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 128);
  }
  return;
}
}
void set_number_default(char *name___1 , long val ) 
{ 
  int tmp ;

  {
  {
  tmp = findoption((char_u *)name___1);
  options[tmp].def_val[0] = (char_u *)val;
  }
  return;
}
}
void set_init_2(void) 
{ 
  int tmp ;
  int idx4 ;
  int tmp___0 ;

  {
  {
  tmp = findoption((char_u *)"scroll");
  options[tmp].def_val[0] = (char_u *)((long_u )Rows >> 1);
  comp_col();
  idx4 = findoption((char_u *)"bg");
  }
  if (! ((int )options[idx4].flags & 256)) {
    {
    tmp___0 = strcmp((char const   *)((char *)term_strings[0]), (char const   *)((char *)"linux"));
    }
    if (tmp___0 == 0) {
      {

      }
    }
  }
  return;
}
}
void set_init_3(void) 
{ 
  char_u *p___0 ;
  int idx_srr ;
  int do_srr ;
  int idx_sp ;
  int do_sp ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  idx_srr = findoption((char_u *)"srr");
  do_srr = ! ((int )options[idx_srr].flags & 256);
  idx_sp = findoption((char_u *)"sp");
  do_sp = ! ((int )options[idx_sp].flags & 256);
  p___0 = gettail(p_sh);
  tmp = skiptowhite(p___0);
  p___0 = vim_strnsave(p___0, (int )(tmp - p___0));
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___4 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"csh"));
    }
    if (tmp___4 == 0) {

    } else {
      {
      tmp___5 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"tcsh"));
      }
      if (tmp___5 == 0) {
        _L___0: ;








      } else {
        {
        tmp___0 = strcmp((char const   *)((char *)p___0), (char const   *)((char *)"sh"));
        }
        if (tmp___0 == 0) {
          goto _L;
        } else {
          {

          }
          if (tmp___1 == 0) {

          } else {
            {

            }
            if (tmp___2 == 0) {

            } else {
              {

              }
              if (tmp___3 == 0) {
                _L: ;
                if (do_sp) {
                  p_sp = (char_u *)"2>&1| tee";
                  options[idx_sp].def_val[0] = p_sp;
                }
                if (do_srr) {
                  p_srr = (char_u *)">%s 2>&1";
                  options[idx_srr].def_val[0] = p_srr;
                }
              }
            }
          }
        }
      }
    }
    {
    vim_free((void *)p___0);
    }
  }
  {
  set_title_defaults();
  }
  return;
}
}
void set_title_defaults(void) 
{ 
  int idx1 ;
  long val ;
  int tmp ;
  int tmp___0 ;

  {
  {
  idx1 = findoption((char_u *)"title");
  }
  if (! ((int )options[idx1].flags & 256)) {
    {
    tmp = mch_can_restore_title();
    val = (long )tmp;
    options[idx1].def_val[0] = (char_u *)val;
    p_title = (int )val;
    }
  }
  {
  idx1 = findoption((char_u *)"icon");
  }
  if (! ((int )options[idx1].flags & 256)) {
    {
    tmp___0 = mch_can_restore_icon();
    val = (long )tmp___0;
    options[idx1].def_val[0] = (char_u *)val;
    p_icon = (int )val;
    }
  }
  return;
}
}
int do_set(char_u *arg , int modeline ) 
{ 
  int opt_idx ;
  char_u *errmsg ;
  char_u errbuf___0[80] ;
  char_u *startarg ;
  int prefix ;
  int nextchar ;
  int afterchar ;
  int len___0 ;
  int i___0 ;
  long value ;
  int key ;
  int flags___0 ;
  char_u *varp ;
  int did_show ;
  int adding ;
  int prepending ;
  int removing ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u name___1[2] ;
  char_u *p___0 ;
  char_u *tmp___5 ;
  long temp ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char_u *save_arg ;
  char_u *s ;
  char_u *oldval ;
  char_u *newval ;
  unsigned int newlen ;
  int comma ;
  int bs ;
  int new_value_alloced ;
  long tmp___11 ;
  size_t tmp___12 ;
  unsigned short const   **tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char_u *tmp___16 ;
  char_u *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  char_u name___2[2] ;
  char_u *p___1 ;
  int tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned short const   **tmp___31 ;
  char_u *tmp___32 ;
  char_u *tmp___33 ;

  {
  varp = (char_u *)((void *)0);
  did_show = 0;
  if ((int )*arg == 0) {
    {
    showoptions(0);
    }
    return (1);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *arg) {
      goto while_break;
    }
    {
    errmsg = (char_u *)((void *)0);
    startarg = arg;
    tmp___30 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"all"),
                       (size_t )3);
    }
    if (tmp___30 == 0) {
      {
      tmp___31 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___31 + (int )*(arg + 3)) & 1024) {
        goto _L___19;
      } else {
        arg += 3;
        if ((int )*arg == 38) {
          {


          }
        } else {
          {
          showoptions(1);
          }
        }
      }
    } else {
      _L___19: ;
      {
      tmp___29 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"termcap"),
                         (size_t )7);
      }
      if (tmp___29 == 0) {
        {



        }
      } else {
        {
        prefix = 1;
        tmp___0 = strncmp((char const   *)((char *)arg), (char const   *)((char *)"no"),
                          (size_t )2);
        }
        if (tmp___0 == 0) {
          prefix = 0;
          arg += 2;
        } else {
          {
          tmp = strncmp((char const   *)((char *)arg), (char const   *)((char *)"inv"),
                        (size_t )3);
          }
          if (tmp == 0) {
            prefix = 2;
            arg += 3;
          }
        }
        key = 0;
        if ((int )*arg == 60) {





















































        } else {
          len___0 = 0;
          if ((int )*(arg + 0) == 116) {
            if ((int )*(arg + 1) == 95) {









            } else {
              goto _L___4;
            }
          } else {
            _L___4: ;
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              {
              tmp___2 = __ctype_b_loc();
              }
              if (! ((int const   )*(*tmp___2 + (int )*(arg + len___0)) & 8)) {
                if (! ((int )*(arg + len___0) == 95)) {
                  goto while_break___1;
                }
              }
              len___0 ++;
            }
            while_break___1: ;/* CIL Label */ ;
            }
          }
          {
          nextchar = (int )*(arg + len___0);
          *(arg + len___0) = (char_u )'\000';
          opt_idx = findoption(arg);
          *(arg + len___0) = (char_u )nextchar;
          }
          if (opt_idx == -1) {
            {

            }
          }
        }
        if (opt_idx == -1) {




        }
        if (opt_idx >= 0) {
          if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
            goto skip;
          }
          {
          flags___0 = (int )options[opt_idx].flags;
          varp = get_varp(& options[opt_idx]);
          }
        } else {

        }
        if (modeline) {






































































        }
        afterchar = (int )*(arg + len___0);
        {
        while (1) {
          while_continue___2: ;/* CIL Label */ ;
          if (! ((int )*(arg + len___0) == 32)) {
            if (! ((int )*(arg + len___0) == 9)) {
              goto while_break___2;
            }
          }

        }
        while_break___2: ;/* CIL Label */ ;
        }
        adding = 0;
        prepending = 0;
        removing = 0;
        if ((int )*(arg + len___0) == 43) {






        } else { //Added block
        _L___6: ;
        if ((int )*(arg + len___0) == 94) {






        } else { //Added block
        _L___5: ;
        if ((int )*(arg + len___0) == 45) {




        }
        }
        }
        {
        nextchar = (int )*(arg + len___0);
        tmp___4 = vim_strchr((char_u *)"?=:!&", nextchar);
        }
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
          {
          arg += len___0;
          len___0 = 0;
          tmp___3 = vim_strchr((char_u *)"?!&", nextchar);
          }
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            if ((int )*(arg + 1) != 0) {
              if (! ((int )*(arg + 1) == 32)) {




              }
            }
          }
        }
        if (nextchar == 63) {
          goto _L___16;
        } else { //Added block
        if (prefix == 1) {
          {
          tmp___27 = vim_strchr((char_u *)"=:&", nextchar);
          }
          if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
            if (! (flags___0 & 1)) {
              _L___16: ;
              if (did_show) {
                {

                }
              } else {
                {
                gotocmdline(1);
                did_show = 1;
                }
              }
              if (opt_idx >= 0) {
                {
                showoneopt(& options[opt_idx]);
                }
              } else {
                {



                }








              }
              if (nextchar != 63) {
                if (nextchar != 0) {





                }
              }
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: ;
          if (flags___0 & 1) {
            if (nextchar == 61) {


            } else { //Added block
            if (nextchar == 58) {


            }
            }
            if (nextchar == 33) {

            } else { //Added block
            if (nextchar == 38) {
              {




              }
            } else {
              if (nextchar != 0) {
                if (! (afterchar == 32)) {




                }
              }
              if (prefix == 2) {
                value = (long )(*((int *)varp) ^ 1);
              } else {
                value = (long )prefix;
              }
            }
            }
            {
            errmsg = set_bool_option(opt_idx, varp, (int )value);
            }
          } else {
            {
            tmp___5 = vim_strchr((char_u *)"=:&", nextchar);
            }
            if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {


            } else { //Added block
            if (prefix != 1) {


            }
            }
            if (flags___0 & 2) {
              arg += len___0 + 1;
              if (nextchar == 38) {
                {




                }
              } else { //Added block
              if ((unsigned long )((long *)varp) == (unsigned long )(& p_wc)) {

              } else { //Added block
              if ((unsigned long )((long *)varp) == (unsigned long )(& p_wcm)) {
                _L___12: ;
                if ((int )*arg == 60) {

                } else { //Added block
                if ((int )*arg == 94) {

                } else { //Added block
                if (! *(arg + 1)) {

                } else { //Added block
                if ((int )*(arg + 1) == 32) {

                } else { //Added block































                }
                }
                }
                }
              } else { //Added block
              _L___8: ;
              if ((int )*arg == 45) {

              } else {
                {
                tmp___9 = __ctype_b_loc();
                }
                if ((int const   )*(*tmp___9 + (int )*arg) & 2048) {
                  _L___7: ;
                  i___0 = 0;
                  if ((int )*arg == 45) {

                  }
                  {
                  value = strtol((char const   * __restrict  )((char *)arg), (char ** __restrict  )((void *)0),
                                 0);
                  }
                  if ((int )*(arg + i___0) == 48) {
                    {

                    }



                  }
                  {
                  while (1) {
                    while_continue___3: ;/* CIL Label */ ;
                    {
                    tmp___8 = __ctype_b_loc();
                    }
                    if (! ((int const   )*(*tmp___8 + (int )*(arg + i___0)) & 2048)) {
                      goto while_break___3;
                    }
                    i___0 ++;
                  }
                  while_break___3: ;/* CIL Label */ ;
                  }
                  if ((int )*(arg + i___0) != 0) {






                  }
                } else {


                }
              }
              }
              }
              }
              if (adding) {

              }
              if (prepending) {

              }
              if (removing) {

              }
              {
              errmsg = set_num_option(opt_idx, varp, value, errbuf___0);
              }
            } else { //Added block
            if (opt_idx >= 0) {
              save_arg = (char_u *)((void *)0);
              oldval = *((char_u **)varp);
              if (nextchar == 38) {
                {
                set_option_default(opt_idx, 0);
                new_value_alloced = (int )options[opt_idx].flags & 8;
                options[opt_idx].flags = (short_u )flags___0;
                }
              } else {
                arg += len___0 + 1;
                if ((unsigned long )varp == (unsigned long )((char_u *)(& p_ww))) {
                  {

                  }










































                } else { //Added block
                _L___13: ;
                if ((int )*arg == 62) {
                  if ((unsigned long )varp == (unsigned long )((char_u *)(& p_dir))) {

                  } else { //Added block
                  if ((unsigned long )varp == (unsigned long )((char_u *)(& p_bdir))) {

                  }
                  }
                }
                }
                {
                tmp___14 = strlen((char const   *)((char *)arg));
                newlen = (unsigned int )(tmp___14 + 1UL);
                }
                if (adding) {
                  {


                  }
                } else { //Added block
                if (prepending) {
                  {


                  }
                } else { //Added block
                if (removing) {
                  {


                  }
                }
                }
                }
                {
                newval = alloc(newlen);
                }
                if ((unsigned long )newval == (unsigned long )((void *)0)) {

                }
                s = newval;
                {
                while (1) {
                  while_continue___4: ;/* CIL Label */ ;
                  if (*arg) {
                    if ((int )*arg == 32) {

                    } else { //Added block
                    if ((int )*arg == 9) {

                    }
                    }
                  } else {
                    goto while_break___4;
                  }
                  if ((int )*arg == 92) {
                    if ((int )*(arg + 1) != 0) {
                      arg ++;
                    }
                  }
                  tmp___16 = s;
                  s ++;
                  tmp___17 = arg;
                  arg ++;
                  *tmp___16 = *tmp___17;
                }
                while_break___4: ;/* CIL Label */ ;
                }
                *s = (char_u )'\000';
                if (adding) {

                } else { //Added block
                if (prepending) {
                  _L___14: ;
































                }
                }
                if (removing) {
                  {




                  }
                  {














































                  while_break___5: ;/* CIL Label */ ;
                  }
                  {

                  }

















                }
                *((char_u **)varp) = newval;
                if ((unsigned long )save_arg != (unsigned long )((void *)0)) {

                }
                new_value_alloced = 1;
              }
              {
              s = option_expand(opt_idx);
              }
              if ((unsigned long )s != (unsigned long )((void *)0)) {







              }
              {
              errmsg = did_set_string_option(opt_idx, (char_u **)varp, new_value_alloced,
                                             oldval, errbuf___0);
              }
              if ((unsigned long )errmsg != (unsigned long )((void *)0)) {

              }
            } else {















































              {

              }
            }
            }
          }
          if (opt_idx >= 0) {
            options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
          }
        }
        }
        skip: ;
        i___0 = 0;
        {
        while (1) {
          while_continue___7: ;/* CIL Label */ ;
          if (! (i___0 < 2)) {

          }
          {
          while (1) {
            while_continue___8: ;/* CIL Label */ ;
            if ((int )*arg != 0) {
              if ((int )*arg == 32) {

              } else { //Added block
              if ((int )*arg == 9) {

              }
              }
            } else {
              goto while_break___8;
            }
            tmp___28 = arg;
            arg ++;
            if ((int )*tmp___28 == 92) {



            }
          }
          while_break___8: ;/* CIL Label */ ;
          }
          {
          arg = skipwhite(arg);
          }
          if ((int )*arg != 61) {
            goto while_break___7;
          }

        }
        while_break___7: ;/* CIL Label */ ;
        }
      }
    }
    {
    arg = skipwhite(arg);
    }
    if (errmsg) {
      {



      }
      {












      while_break___9: ;/* CIL Label */ ;
      }
      {


      }

    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
static char_u *illegal_char(char_u *errbuf___0 , int c ) 
{













}
static void did_set_title(int icon ) 
{ 


  {
  if (starting != 2) {
    {
    maketitle();
    }
    if (icon) {
      if (! p_icon) {
        {
        mch_restore_title(2);
        }
      }
    } else { //Added block
    if (! p_title) {
      {
      mch_restore_title(1);
      }
    }
    }
  }
  return;
}
}
void set_options_bin(int oldval , int newval ) 
{ 


  {
  if (newval) {
    if (! oldval) {
      curbuf->b_p_tw_nobin = curbuf->b_p_tw;
      curbuf->b_p_wm_nobin = curbuf->b_p_wm;
      curbuf->b_p_ml_nobin = curbuf->b_p_ml;
      curbuf->b_p_et_nobin = curbuf->b_p_et;
    }
    curbuf->b_p_tw = 0L;
    curbuf->b_p_wm = 0L;
    curbuf->b_p_ml = 0;
    curbuf->b_p_et = 0;
  } else { //Added block
  if (oldval) {




  }
  }
  return;
}
}
int get_viminfo_parameter(int type ) 
{ 
  char_u *p___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  p___0 = find_viminfo_parameter(type);
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )*p___0) & 2048) {
      {
      tmp = atoi((char const   *)((char *)p___0));
      }
      return (tmp);
    }
  }
  return (-1);
}
}
char_u *find_viminfo_parameter(int type ) 
{ 
  char_u *p___0 ;

  {
  p___0 = p_viminfo;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == type) {
      return (p___0 + 1);
    }
    if ((int )*p___0 == 110) {

    }
    {
    p___0 = vim_strchr(p___0, ',');
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      goto while_break;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
static char_u *option_expand(int opt_idx ) 
{ 
  char_u *p___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  if (! ((int )options[opt_idx].flags & 16)) {
    return ((char_u *)((void *)0));
  } else { //Added block
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {
    return ((char_u *)((void *)0));
  }
  }
  {
  p___0 = *((char_u **)options[opt_idx].var);
  expand_env(p___0, NameBuff, 1024);
  tmp = strcmp((char const   *)((char *)NameBuff), (char const   *)((char *)p___0));
  }
  if (tmp == 0) {
    return ((char_u *)((void *)0));
  }
  {
  tmp___0 = vim_strsave(NameBuff);
  }
  return (tmp___0);
}
}
void check_options(void) 
{ 
  int opt_idx ;
  char_u **p___0 ;
  char_u *tmp ;

  {
  opt_idx = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )options[opt_idx].fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if ((int )options[opt_idx].flags & 4) {
      if ((unsigned long )options[opt_idx].var != (unsigned long )((void *)0)) {
        {
        tmp = get_varp(& options[opt_idx]);
        p___0 = (char_u **)tmp;
        }
        if ((unsigned long )*p___0 == (unsigned long )((void *)0)) {
          *p___0 = empty_option;
        }
      }
    }
    opt_idx ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
void check_buf_options(BUF *buf___3 ) 
{ 


  {
  if ((unsigned long )buf___3->b_p_ff == (unsigned long )((void *)0)) {
    buf___3->b_p_ff = empty_option;
  }
  if ((unsigned long )buf___3->b_p_key == (unsigned long )((void *)0)) {
    buf___3->b_p_key = empty_option;
  }
  if ((unsigned long )buf___3->b_p_mps == (unsigned long )((void *)0)) {
    buf___3->b_p_mps = empty_option;
  }
  if ((unsigned long )buf___3->b_p_fo == (unsigned long )((void *)0)) {
    buf___3->b_p_fo = empty_option;
  }
  if ((unsigned long )buf___3->b_p_isk == (unsigned long )((void *)0)) {
    buf___3->b_p_isk = empty_option;
  }
  if ((unsigned long )buf___3->b_p_com == (unsigned long )((void *)0)) {
    buf___3->b_p_com = empty_option;
  }
  if ((unsigned long )buf___3->b_p_nf == (unsigned long )((void *)0)) {
    buf___3->b_p_nf = empty_option;
  }
  if ((unsigned long )buf___3->b_p_syn == (unsigned long )((void *)0)) {
    buf___3->b_p_syn = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cink == (unsigned long )((void *)0)) {
    buf___3->b_p_cink = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cino == (unsigned long )((void *)0)) {
    buf___3->b_p_cino = empty_option;
  }
  if ((unsigned long )buf___3->b_p_ft == (unsigned long )((void *)0)) {
    buf___3->b_p_ft = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cinw == (unsigned long )((void *)0)) {
    buf___3->b_p_cinw = empty_option;
  }
  if ((unsigned long )buf___3->b_p_cpt == (unsigned long )((void *)0)) {
    buf___3->b_p_cpt = empty_option;
  }
  return;
}
}
void free_string_option(char_u *p___0 ) 
{ 


  {
  if ((unsigned long )p___0 != (unsigned long )empty_option) {
    {
    vim_free((void *)p___0);
    }
  }
  return;
}
}
void set_term_option_alloced(char_u **p___0 ) 
{




















}
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) 
{ 
  char_u *s ;
  char_u **varp ;
  char_u *tmp ;

  {
  if (opt_idx == -1) {
    {
    opt_idx = findoption(name___1);
    }
    if (opt_idx == -1) {

    }
  }
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {

  }
  {
  s = vim_strsave(val);
  }
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    tmp = get_varp(& options[opt_idx]);
    varp = (char_u **)tmp;
    }
    if (dofree) {
      if ((int )options[opt_idx].flags & 8) {
        {
        free_string_option(*varp);
        }
      }
    }
    *varp = s;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 8);
  }
  return;
}
}
static void set_string_option(int opt_idx , char_u *value ) 
{ 
  char_u *s ;
  char_u **varp ;
  char_u *oldval ;
  char_u *tmp ;

  {
  if ((unsigned long )options[opt_idx].var == (unsigned long )((void *)0)) {

  }
  {
  s = vim_strsave(value);
  }
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    tmp = get_varp(& options[opt_idx]);
    varp = (char_u **)tmp;
    oldval = *varp;
    *varp = s;
    options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
    did_set_string_option(opt_idx, varp, 1, oldval, (char_u *)((void *)0));
    }
  }
  return;
}
}
static struct lcstab lcstab[4]  = {      {& lcs_eol, (char *)"eol"}, 
        {& lcs_ext, (char *)"extends"}, 
        {& lcs_tab2, (char *)"tab"}, 
        {& lcs_trail, (char *)"trail"}};
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) 
{ 
  char_u *errmsg ;
  char_u *s ;
  char_u *p___0 ;
  int did_chartab ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char_u *tmp___14 ;
  unsigned short const   **tmp___15 ;
  char_u *tmp___16 ;
  int round ;
  int i___0 ;
  int len___0 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;
  unsigned short const   **tmp___20 ;
  char_u *tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int flagval ;
  int tmp___26 ;
  char_u *tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int wid ;
  long tmp___38 ;
  char_u *tmp___39 ;
  int tmp___40 ;
  unsigned short const   **tmp___41 ;
  char_u *tmp___42 ;
  int tmp___43 ;

  {
  errmsg = (char_u *)((void *)0);
  did_chartab = 0;
  if ((unsigned long )varp == (unsigned long )(& term_strings[0])) {















  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_bex)) {
    goto _L___4;
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_pm)) {
    _L___4: ;
    if ((int )*p_pm == 46) {

    } else {
      tmp___0 = p_pm;
    }
    if ((int )*p_bex == 46) {

    } else {
      tmp___1 = p_bex;
    }
    {
    tmp___2 = strcmp((char const   *)((char *)tmp___1), (char const   *)((char *)tmp___0));
    }
    if (tmp___2 == 0) {

    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isi)) {

  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_isk)) {

  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isp)) {

  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_isf)) {
    _L___3: ;
    {

    }




  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_hf)) {
    if (didset_vim) {
      {


      }
    }
    if (didset_vimruntime) {
      {
      vim_setenv((char_u *)"VIMRUNTIME", (char_u *)"");
      didset_vimruntime = 0;
      }
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_hl)) {
    {

    }



  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_nf)) {
    {

    }



  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_sessopt)) {
    {

    }



  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_sbo)) {
    {

    }



  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_bg)) {
    {
    tmp___8 = check_opt_strings(p_bg, p_bg_values, 0);
    }
    if (tmp___8 == 1) {
      {
      init_highlight(0);
      }
    } else {

    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_wim)) {
    {

    }



  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_ei)) {
    {
    tmp___10 = check_ei();
    }
    if (tmp___10 == 0) {

    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_ff)) {
    {

    }












  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_ffs)) {
    {

    }









  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_key)) {
    {

    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_mps)) {

    {































    while_break: ;/* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_com)) {

    {










































































    while_break___0: ;/* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_lcs)) {

    {






















































































    while_break___3: ;/* CIL Label */ ;
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )(& p_viminfo)) {

    {

























































































    while_break___7: ;/* CIL Label */ ;
    }










  } else {
    {
    tmp___43 = istermoption(& options[opt_idx]);
    }
    if (tmp___43) {


























    } else { //Added block
    _L___2: ;
    if ((unsigned long )varp == (unsigned long )(& p_sbr)) {

      {













      while_break___10: ;/* CIL Label */ ;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_breakat)) {
      {

      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_titlestring)) {

    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_iconstring)) {
      _L___1: ;





      {


      }












      {

      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_ttym)) {
      {
      tmp___29 = check_opt_strings(p_ttym, p_ttym_values, 0);
      }
      if (tmp___29 != 1) {

      } else {
        {
        check_mouse_termcode();
        }
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_sel)) {










    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_slm)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_bsdir)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_km)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_mousem)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_swb)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_dy)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_cb)) {
      {

      }



    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_syn)) {
      {

      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_ft)) {
      {

      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_stl)) {

    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_ruf)) {
      _L___0: ;





















































    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_cpt)) {

      {








































































      while_break___11: ;/* CIL Label */ ;
      }
    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_pt)) {














    } else { //Added block
    if ((unsigned long )varp == (unsigned long )(& p_bs)) {
      {
      tmp___41 = __ctype_b_loc();
      }
      if ((int const   )*(*tmp___41 + (int )*p_bs) & 2048) {
        if ((int )*p_bs > 50) {

        } else { //Added block
        if ((int )*(p_bs + 1) != 0) {

        }
        }
      } else {
        {

        }



      }
    } else {
      p___0 = (char_u *)((void *)0);
      if ((unsigned long )varp == (unsigned long )(& p_ww)) {

      }
      if ((unsigned long )varp == (unsigned long )(& p_shm)) {

      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& p_cpo)) {

      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& curbuf->b_p_fo)) {
        p___0 = (char_u *)"tcroq2vlb,";
      } else { //Added block
      if ((unsigned long )varp == (unsigned long )(& p_mouse)) {

      }
      }
      }
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        s = *varp;
        {
        while (1) {
          while_continue___14: ;/* CIL Label */ ;
          if (! *s) {
            goto while_break___14;
          }
          {
          tmp___42 = vim_strchr(p___0, (int )*s);
          }
          if ((unsigned long )tmp___42 == (unsigned long )((void *)0)) {
            {

            }

          }
          s ++;
        }
        while_break___14: ;/* CIL Label */ ;
        }
      }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
















  } else {
    if ((int )options[opt_idx].flags & 8) {
      {
      free_string_option(oldval);
      }
    }
    if (new_value_alloced) {
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 8);
    } else {
      options[opt_idx].flags = (short_u )((int )options[opt_idx].flags & -9);
    }
  }
  if ((unsigned long )varp == (unsigned long )(& p_mouse)) {









  }
  {
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return (errmsg);
}
}
static char_u errbuf[80]  ;
char_u *check_stl_option(char_u *s ) 
{












































































































































}
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) 
{ 
  int old_p_bin ;
  int old_p_ea ;
  int old_p_wiv ;
  char_u *p___0 ;
  size_t tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;

  {
  old_p_bin = curbuf->b_p_bin;
  old_p_ea = p_ea;
  old_p_wiv = p_wiv;
  if (secure) {

  } else { //Added block
  if (sandbox != 0) {
    _L: ;



  }
  }
  *((int *)varp) = value;
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_cp)) {
    {
    compatible_set();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_ro)) {





  } else { //Added block
  _L___2: ;
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_bin)) {
    {
    set_options_bin(old_p_bin, curbuf->b_p_bin);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_swf)) {















  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_terse)) {
    {
    p___0 = vim_strchr(p_shm, 's');
    }
    if (p_terse) {
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
        {
        strcpy((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)p_shm));
        strcat((char * __restrict  )((char *)IObuff), (char const   * __restrict  )((char *)"s"));
        set_string_option_direct((char_u *)"shm", -1, IObuff, 1);
        }
      } else {

      }
    } else { //Added block
    _L___0: ;
    if (! p_terse) {
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        {


        }
      }
    }
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_paste)) {
    {
    paste_option_changed();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_ic)) {
    if (p_hls) {
      {

      }
    } else {
      goto _L___1;
    }
  } else { //Added block
  _L___1: ;
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_hls)) {
    no_hlsearch = 0;
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_p_tx)) {
    if (curbuf->b_p_tx) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    {
    set_fileformat(tmp___0);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_ta)) {
    if (p_ta) {
      tmp___1 = (char_u *)"unix,dos";
    } else {
      tmp___1 = (char_u *)"";
    }
    {
    set_string_option_direct((char_u *)"ffs", -1, tmp___1, 1);
    }
  } else { //Added block
  if ((unsigned long )varp == (unsigned long )((char_u *)(& curbuf->b_p_lisp))) {
    {
    init_chartab();
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_title)) {
    {
    did_set_title(0);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& p_icon)) {
    {
    did_set_title(1);
    }
  } else { //Added block
  if ((unsigned long )((int *)varp) == (unsigned long )(& curbuf->b_changed)) {
    if (! value) {

    }
    modified_was_set = value;
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  if (p_ea) {
    if (! old_p_ea) {
      {

      }
    }
  }
  if (p_wiv) {





  } else { //Added block
  _L___3: ;
  if (! p_wiv) {
    if (old_p_wiv) {

    }
  }
  }
  {
  p_wiv = (int )*(term_strings[37]) != 0;
  options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
  comp_col();
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return ((char_u *)((void *)0));
}
}
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) 
{ 
  char_u *errmsg ;
  long old_Rows___0 ;
  long old_Columns ;
  long old_p_ch ;
  long old_p_uc ;
  long old_titlelen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  errmsg = (char_u *)((void *)0);
  old_Rows___0 = Rows;
  old_Columns = Columns;
  old_p_ch = p_ch;
  old_p_uc = p_uc;
  old_titlelen = p_titlelen;
  *((long *)varp) = value;
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_wh)) {

  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_hh)) {
    _L: ;






























  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_wmh)) {








    {

    }
  } else { //Added block
  if ((unsigned long )((long *)varp) == (unsigned long )(& p_ls)) {
    {
    last_status();
    }
  }
  }
  }
  }
  {
  tmp___1 = min_rows();
  }
  if (Rows < (long )tmp___1) {














  }
  if (Columns < 12L) {










  }
  if (old_Rows___0 != Rows) {
    goto _L___0;
  } else { //Added block
  if (old_Columns != Columns) {
    _L___0: ;
    if (full_screen) {
      {
      ui_set_winsize();
      check_winsize();
      }
    }
  }
  }
  if (curbuf->b_p_sts < 0L) {


  }
  if (curbuf->b_p_ts <= 0L) {


  }
  if (curbuf->b_p_sw <= 0L) {


  }
  if (curbuf->b_p_tw < 0L) {


  }
  if (p_tm < 0L) {


  }
  if (p_titlelen < 0L) {


  }
  if (curwin->w_p_scroll <= 0L) {

  } else { //Added block
  if (curwin->w_p_scroll > (long )curwin->w_height) {



















  }
  }
  if (p_report < 0L) {


  }
  if (p_sj < 0L) {

  } else { //Added block
  if (p_sj >= Rows) {
    _L___2: ;








  }
  }
  if (p_so < 0L) {




  }
  if (p_uc < 0L) {


  }
  if (p_ch < 1L) {


  }
  if (p_ut < 0L) {


  }
  if (p_ss < 0L) {


  }
  if (p_uc) {
    if (! old_p_uc) {
      {

      }
    }
  }
  if (p_ch != old_p_ch) {
    {
    command_height(old_p_ch);
    }
  }
  if (old_titlelen != p_titlelen) {





  }
  {
  options[opt_idx].flags = (short_u )((int )options[opt_idx].flags | 256);
  comp_col();
  curwin->w_set_curswant = 1;
  check_redraw((int )options[opt_idx].flags);
  }
  return (errmsg);
}
}
static void check_redraw(int flags___0 ) 
{ 


  {
  if (flags___0 & 20480) {
    {
    status_redraw_all();
    }
  }
  if (flags___0 & 24576) {
    {
    changed_line_abv_curs();
    invalidate_botline();
    update_topline();
    }
  }
  if (flags___0 & 8192) {
    {
    redraw_curbuf_later(40);
    }
  }
  if (flags___0 & 16384) {
    {
    redraw_all_later(40);
    }
  }
  if ((flags___0 & 28672) == 28672) {
    {
    redraw_all_later(50);
    }
  }
  return;
}
}
static short quick_tab[27]  = {      (short)0,      (short)0};
static int findoption(char_u *arg ) 
{ 
  int opt_idx ;
  char *s ;
  char *p___0 ;
  int is_term_opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )quick_tab[1] == 0) {
    p___0 = options[0].fullname;
    opt_idx = 1;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      s = options[opt_idx].fullname;
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((int )*(s + 0) != (int )*(p___0 + 0)) {
        if ((int )*(s + 0) == 116) {
          if ((int )*(s + 1) == 95) {
            quick_tab[26] = (short )opt_idx;
          } else {
            quick_tab[(int )*(s + 0) - 97] = (short )opt_idx;
          }
        } else {
          quick_tab[(int )*(s + 0) - 97] = (short )opt_idx;
        }
      }
      p___0 = s;
      opt_idx ++;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  if ((int )*(arg + 0) < 97) {

  } else { //Added block
  if ((int )*(arg + 0) > 122) {

  }
  }
  if ((int )*(arg + 0) == 116) {
    if ((int )*(arg + 1) == 95) {

    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  is_term_opt = tmp;
  if (is_term_opt) {

  } else {
    opt_idx = (int )quick_tab[(int )*(arg + 0) - 97];
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    s = options[opt_idx].fullname;
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    tmp___0 = strcmp((char const   *)((char *)arg), (char const   *)s);
    }
    if (tmp___0 == 0) {
      goto while_break___0;
    }
    opt_idx ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    if (! is_term_opt) {
      opt_idx = (int )quick_tab[(int )*(arg + 0) - 97];
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (! ((unsigned long )options[opt_idx].fullname != (unsigned long )((void *)0))) {

        }
        s = options[opt_idx].shortname;
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
          tmp___1 = strcmp((char const   *)((char *)arg), (char const   *)s);
          }
          if (tmp___1 == 0) {
            goto while_break___1;
          }
        }
        s = (char *)((void *)0);
        opt_idx ++;
      }
      while_break___1: ;/* CIL Label */ ;
      }
    }
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {

  }
  return (opt_idx);
}
}
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) 
{





































}
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) 
{ 
  int opt_idx ;
  char_u *varp ;

  {
  {
  opt_idx = findoption(name___1);
  }
  if (opt_idx == -1) {
    {

    }
  } else { //Added block
  if ((int )options[opt_idx].flags & 4) {
    {
    set_string_option(opt_idx, string___0);
    }
  } else {
    {

    }











  }
  }
  return;
}
}
char_u *get_term_code(char_u *tname ) 
{





































}
char_u *get_highlight_default(void) 
{ 
  int i___0 ;

  {
  {
  i___0 = findoption((char_u *)"hl");
  }
  if (i___0 >= 0) {
    return (options[i___0].def_val[0]);
  }

}
}
static int find_key_option(char_u *arg ) 
{






























}
static void showoptions(int all ) 
{ 
  struct vimoption *p___0 ;
  int col ;
  int isterm ;
  char_u *varp ;
  struct vimoption **items ;
  int item_count ;
  int run ;
  int row ;
  int rows ;
  int cols ;
  int i___0 ;
  int len___0 ;
  char_u *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = alloc((unsigned int )(sizeof(struct vimoption *) * (sizeof(options) / sizeof(struct vimoption ))));
  items = (struct vimoption **)tmp;
  }
  if ((unsigned long )items == (unsigned long )((void *)0)) {

  }
  if (all == 2) {
    {

    }
  } else {
    {
    msg_puts_title((char_u *)"\n--- Options ---");
    }
  }
  run = 1;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (run <= 2) {
      if (! (! got_int)) {

      }
    } else {
      goto while_break;
    }
    item_count = 0;
    p___0 = & options[0];
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      isterm = istermoption(p___0);
      varp = get_varp(p___0);
      }
      if ((unsigned long )varp != (unsigned long )((void *)0)) {
        if (all == 2) {





        } else { //Added block
        _L___2: ;
        if (all == 1) {
          if (! isterm) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: ;
        if (all == 0) {
          {
          tmp___3 = option_not_default(p___0);
          }
          if (tmp___3) {
            _L___0: ;
            if ((int )p___0->flags & 1) {
              len___0 = 1;
            } else {
              {
              option_value2string(p___0);
              tmp___0 = strlen((char const   *)p___0->fullname);
              tmp___1 = vim_strsize(NameBuff);
              len___0 = (int )((tmp___0 + (size_t )tmp___1) + 1UL);
              }
            }
            if (len___0 <= 17) {
              if (run == 1) {
                tmp___2 = item_count;
                item_count ++;
                *(items + tmp___2) = p___0;
              } else {
                goto _L;
              }
            } else { //Added block
            _L: ;
            if (len___0 > 17) {
              if (run == 2) {
                tmp___2 = item_count;
                item_count ++;
                *(items + tmp___2) = p___0;
              }
            }
            }
          }
        }
        }
        }
      }
      p___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (run == 1) {
      cols = (int )(((Columns + 3L) - 3L) / 20L);
      if (cols == 0) {

      }
      rows = ((item_count + cols) - 1) / cols;
    } else {
      rows = item_count;
    }
    row = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (row < rows) {
        if (! (! got_int)) {

        }
      } else {
        goto while_break___1;
      }
      {
      msg_putchar('\n');
      }
      if (got_int) {

      }
      col = 0;
      i___0 = row;
      {
      while (1) {
        while_continue___2: ;/* CIL Label */ ;
        if (! (i___0 < item_count)) {
          goto while_break___2;
        }
        {
        msg_col = col;
        showoneopt(*(items + i___0));
        col += 20;
        i___0 += rows;
        }
      }
      while_break___2: ;/* CIL Label */ ;
      }
      {
      out_flush();
      ui_breakcheck();
      row ++;
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
    run ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)items);
  }
  return;
}
}
static int option_not_default(struct vimoption *p___0 ) 
{ 
  char_u *varp ;
  int dvi ;
  int tmp ;

  {
  {
  varp = get_varp(p___0);
  }
  if ((unsigned long )varp == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((int )p___0->flags & 1024) {
    dvi = 0;
  } else { //Added block
  if (p_cp) {
    dvi = 0;
  } else {

  }
  }
  if ((int )p___0->flags & 2) {
    return (*((long *)varp) != (long )p___0->def_val[dvi]);
  }
  if ((int )p___0->flags & 1) {
    return (*((int *)varp) != (int )((long )p___0->def_val[dvi]));
  }
  {
  tmp = strcmp((char const   *)((char *)*((char_u **)varp)), (char const   *)((char *)p___0->def_val[dvi]));
  }
  return (tmp);
}
}
static void showoneopt(struct vimoption *p___0 ) 
{ 
  char_u *varp ;

  {
  {
  varp = get_varp(p___0);
  }
  if ((int )p___0->flags & 1) {
    if (! *((int *)varp)) {
      {
      msg_puts((char_u *)"no");
      }
    } else {
      {
      msg_puts((char_u *)"  ");
      }
    }
  } else {
    {
    msg_puts((char_u *)"  ");
    }
  }
  {
  msg_puts((char_u *)p___0->fullname);
  }
  if (! ((int )p___0->flags & 1)) {
    {
    msg_putchar('=');
    option_value2string(p___0);
    msg_outtrans(NameBuff);
    }
  }
  return;
}
}
int makeset(FILE *fd ) 
{ 
  struct vimoption *p___0 ;
  char_u *s ;
  char_u *varp ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  p___0 = & options[0];
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp___7 = istermoption(p___0);
    }
    if (tmp___7) {
      goto while_break;
    }
    if (! ((int )p___0->flags & 512)) {
      {
      tmp___5 = istermoption(p___0);
      }
      if (! tmp___5) {
        {
        tmp___6 = option_not_default(p___0);
        }
        if (tmp___6) {
          {

          }









































          {

          }



        }
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
void clear_termoptions(void) 
{ 
  struct vimoption *p___0 ;
  int tmp ;

  {
  {
  mch_setmouse(0);
  clear_xterm_clip();
  mch_restore_title(3);
  stoptermcap();
  p___0 = & options[0];
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = istermoption(p___0);
    }
    if (tmp) {
      if ((int )p___0->flags & 8) {
        {

        }
      }
      if ((int )p___0->flags & 128) {
        {

        }
      }
      *((char_u **)p___0->var) = empty_option;
      p___0->def_val[0] = empty_option;
      p___0->flags = (short_u )((int )p___0->flags & -137);
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  clear_termcodes();
  }
  return;
}
}
void set_term_defaults(void) 
{ 
  struct vimoption *p___0 ;
  int tmp ;

  {
  p___0 = & options[0];
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )p___0->fullname != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    tmp = istermoption(p___0);
    }
    if (tmp) {
      if ((unsigned long )p___0->def_val[0] != (unsigned long )*((char_u **)p___0->var)) {
        if ((int )p___0->flags & 128) {
          {


          }
        }
        p___0->def_val[0] = *((char_u **)p___0->var);
        if ((int )p___0->flags & 8) {


        }
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static int istermoption(struct vimoption *p___0 ) 
{ 
  int tmp ;

  {
  if ((int )*(p___0->fullname + 0) == 116) {
    if ((int )*(p___0->fullname + 1) == 95) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
void comp_col(void) 
{ 
  int last_has_status ;
  int tmp ;
  int tmp___0 ;

  {
  if (p_ls == 2L) {
    tmp = 1;
  } else { //Added block
  if (p_ls == 1L) {
    if ((unsigned long )firstwin != (unsigned long )lastwin) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {

  }
  }
  last_has_status = tmp;
  sc_col = 0;
  ru_col = 0;
  if (p_ru) {
    if (ru_wid) {

    } else {
      tmp___0 = 17;
    }
    ru_col = tmp___0 + 1;
    if (! last_has_status) {
      sc_col = ru_col;
    }
  }
  if (p_sc) {
    sc_col += 10;
    if (! p_ru) {
      sc_col ++;
    } else { //Added block



    }
  }
  sc_col = (int )(Columns - (long )sc_col);
  ru_col = (int )(Columns - (long )ru_col);
  if (sc_col <= 0) {

  }
  if (ru_col <= 0) {

  }
  return;
}
}
static char_u *get_varp(struct vimoption *p___0 ) 
{ 


  {
  if (! ((int )p___0->flags & 32)) {
    return (p___0->var);
  } else { //Added block
  if ((unsigned long )p___0->var == (unsigned long )((void *)0)) {
    return (p___0->var);
  }
  }
  {
  if ((long )p___0->var == 20L) {
    goto case_20;
  }
  if ((long )p___0->var == 25L) {
    goto case_25;
  }
  if ((long )p___0->var == 29L) {
    goto case_29;
  }
  if ((long )p___0->var == 41L) {
    goto case_41;
  }
  if ((long )p___0->var == 18L) {
    goto case_18;
  }
  if ((long )p___0->var == 35L) {
    goto case_35;
  }
  if ((long )p___0->var == 1L) {
    goto case_1;
  }
  if ((long )p___0->var == 2L) {
    goto case_2;
  }
  if ((long )p___0->var == 3L) {
    goto case_3;
  }
  if ((long )p___0->var == 4L) {
    goto case_4;
  }
  if ((long )p___0->var == 5L) {
    goto case_5;
  }
  if ((long )p___0->var == 6L) {
    goto case_6;
  }
  if ((long )p___0->var == 7L) {
    goto case_7;
  }
  if ((long )p___0->var == 8L) {
    goto case_8;
  }
  if ((long )p___0->var == 9L) {
    goto case_9;
  }
  if ((long )p___0->var == 10L) {
    goto case_10;
  }
  if ((long )p___0->var == 12L) {
    goto case_12;
  }
  if ((long )p___0->var == 14L) {
    goto case_14;
  }
  if ((long )p___0->var == 13L) {
    goto case_13;
  }
  if ((long )p___0->var == 15L) {
    goto case_15;
  }
  if ((long )p___0->var == 16L) {
    goto case_16;
  }
  if ((long )p___0->var == 17L) {
    goto case_17;
  }
  if ((long )p___0->var == 19L) {
    goto case_19;
  }
  if ((long )p___0->var == 21L) {
    goto case_21;
  }
  if ((long )p___0->var == 22L) {
    goto case_22;
  }
  if ((long )p___0->var == 23L) {
    goto case_23;
  }
  if ((long )p___0->var == 24L) {
    goto case_24;
  }
  if ((long )p___0->var == 28L) {
    goto case_28;
  }
  if ((long )p___0->var == 30L) {
    goto case_30;
  }
  if ((long )p___0->var == 31L) {
    goto case_31;
  }
  if ((long )p___0->var == 32L) {
    goto case_32;
  }
  if ((long )p___0->var == 33L) {
    goto case_33;
  }
  if ((long )p___0->var == 34L) {
    goto case_34;
  }
  if ((long )p___0->var == 36L) {
    goto case_36;
  }
  if ((long )p___0->var == 37L) {
    goto case_37;
  }
  if ((long )p___0->var == 38L) {
    goto case_38;
  }
  if ((long )p___0->var == 39L) {
    goto case_39;
  }
  if ((long )p___0->var == 40L) {
    goto case_40;
  }

  case_20: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_list));
  case_25: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_nu));
  case_29: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_scroll));
  case_41: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_wrap));
  case_18: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_lbr));
  case_35: ;/* CIL Label */ 
  return ((char_u *)(& curwin->w_p_scb));
  case_1: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ai));
  case_2: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_bin));
  case_3: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cin));
  case_4: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cink));
  case_5: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cino));
  case_6: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cinw));
  case_7: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_com));
  case_8: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_cpt));
  case_9: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_eol));
  case_10: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_et));
  case_12: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ff));
  case_14: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ft));
  case_13: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_fo));
  case_15: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_inf));
  case_16: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_isk));
  case_17: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_key));
  case_19: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_lisp));
  case_21: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ml));
  case_22: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_mps));
  case_23: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_changed));
  case_24: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_nf));
  case_28: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ro));
  case_30: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_si));
  case_31: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sn));
  case_32: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sts));
  case_33: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_swf));
  case_34: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_syn));
  case_36: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_sw));
  case_37: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_ts));
  case_38: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_tw));
  case_39: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_tx));
  case_40: ;/* CIL Label */ 
  return ((char_u *)(& curbuf->b_p_wm));
  switch_default: ;/* CIL Label */ 
  {

  }
  switch_break: ;/* CIL Label */ ;
  }

}
}
void win_copy_options(WIN *wp_from , WIN *wp_to ) 
{ 


  {
  wp_to->w_p_list = wp_from->w_p_list;
  wp_to->w_p_nu = wp_from->w_p_nu;
  wp_to->w_p_wrap = wp_from->w_p_wrap;
  wp_to->w_p_lbr = wp_from->w_p_lbr;
  wp_to->w_p_scb = wp_from->w_p_scb;
  return;
}
}
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) 
{ 
  int should_copy ;
  char_u *save_p_isk ;
  int dont_do_help ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  should_copy = 1;
  save_p_isk = (char_u *)((void *)0);
  if ((unsigned long )bp_to == (unsigned long )((void *)0)) {

  } else {
    {
    tmp = buf_valid(bp_to);
    }
    if (! tmp) {

    }
  }
  if ((unsigned long )bp_from != (unsigned long )((void *)0)) {
    {
    tmp___3 = buf_valid(bp_from);
    }
    if (tmp___3) {
      if ((unsigned long )bp_from != (unsigned long )bp_to) {
        {
        tmp___0 = vim_strchr(p_cpo, 'S');
        }
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {

        } else { //Added block
        if (! (flags___0 & 1)) {
          _L: ;
          if (bp_to->b_p_initialized) {
            should_copy = 0;
          } else { //Added block
          if (! (flags___0 & 1)) {
            {
            tmp___1 = vim_strchr(p_cpo, 's');
            }
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              should_copy = 0;
            }
          }
          }
        }
        }
        if (should_copy) {
          goto _L___0;
        } else { //Added block
        if (flags___0 & 2) {
          _L___0: ;
          if (flags___0 & 4) {
            if (bp_to->b_help) {

            } else { //Added block
            if (bp_from->b_help) {

            } else {
              tmp___2 = 0;
            }
            }
          } else {
            tmp___2 = 0;
          }
          dont_do_help = tmp___2;
          if (dont_do_help) {


          }
          if (! bp_to->b_p_initialized) {
            {
            free_buf_options(bp_to, 1);
            bp_to->b_p_ro = 0;
            bp_to->b_p_tx = bp_from->b_p_tx;
            bp_to->b_p_ff = vim_strsave(bp_from->b_p_ff);
            }
          } else {
            {
            free_buf_options(bp_to, 0);
            }
          }
          {
          bp_to->b_p_ai = bp_from->b_p_ai;
          bp_to->b_p_ai_save = bp_from->b_p_ai_save;
          bp_to->b_p_sw = bp_from->b_p_sw;
          bp_to->b_p_tw = bp_from->b_p_tw;
          bp_to->b_p_tw_save = bp_from->b_p_tw_save;
          bp_to->b_p_tw_nobin = bp_from->b_p_tw_nobin;
          bp_to->b_p_wm = bp_from->b_p_wm;
          bp_to->b_p_wm_save = bp_from->b_p_wm_save;
          bp_to->b_p_wm_nobin = bp_from->b_p_wm_nobin;
          bp_to->b_p_bin = bp_from->b_p_bin;
          bp_to->b_p_et = bp_from->b_p_et;
          bp_to->b_p_et_nobin = bp_from->b_p_et_nobin;
          bp_to->b_p_ml = bp_from->b_p_ml;
          bp_to->b_p_ml_nobin = bp_from->b_p_ml_nobin;
          bp_to->b_p_inf = bp_from->b_p_inf;
          bp_to->b_p_swf = bp_from->b_p_swf;
          bp_to->b_p_cpt = vim_strsave(bp_from->b_p_cpt);
          bp_to->b_p_sts = bp_from->b_p_sts;
          bp_to->b_p_sn = bp_from->b_p_sn;
          bp_to->b_p_com = vim_strsave(bp_from->b_p_com);
          bp_to->b_p_fo = vim_strsave(bp_from->b_p_fo);
          bp_to->b_p_nf = vim_strsave(bp_from->b_p_nf);
          bp_to->b_p_mps = vim_strsave(bp_from->b_p_mps);
          bp_to->b_p_si = bp_from->b_p_si;
          bp_to->b_p_si_save = bp_from->b_p_si_save;
          bp_to->b_p_cin = bp_from->b_p_cin;
          bp_to->b_p_cin_save = bp_from->b_p_cin_save;
          bp_to->b_p_cink = vim_strsave(bp_from->b_p_cink);
          bp_to->b_p_cino = vim_strsave(bp_from->b_p_cino);
          bp_to->b_p_ft = empty_option;
          bp_to->b_p_cinw = vim_strsave(bp_from->b_p_cinw);
          bp_to->b_p_lisp = bp_from->b_p_lisp;
          bp_to->b_p_lisp_save = bp_from->b_p_lisp_save;
          bp_to->b_p_syn = empty_option;
          bp_to->b_p_key = vim_strsave(bp_from->b_p_key);
          }
          if (dont_do_help) {

          } else { //Added block
          if (! keep_help_flag) {
            if (bp_from->b_help) {






























            } else {
              {
              bp_to->b_p_isk = vim_strsave(bp_from->b_p_isk);
              memmove((void *)(bp_to->b_chartab), (void const   *)(bp_from->b_chartab),
                      (size_t )256);
              bp_to->b_p_ts = bp_from->b_p_ts;
              bp_to->b_help = bp_from->b_help;
              }
            }
          } else {
            {





            }
          }
          }
        }
        }
        if (should_copy) {
          bp_to->b_p_initialized = 1;
        }
      }
    }
  }
  {
  check_buf_options(bp_to);
  }
  return;
}
}
static int expand_option_idx  =    -1;
static char_u expand_option_name[5]  = {      (char_u )'t',      (char_u )'_',      (char_u )'\000',      (char_u )'\000', 
        (char_u )'\000'};
void set_context_in_set_cmd(char_u *arg ) 
{











































































































































































































































































}
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) 
{




















































































































































































































































































}
int ExpandOldSetting(int *num_file , char_u ***file ) 
{
















































}
static void option_value2string(struct vimoption *opp ) 
{ 
  char_u *varp ;
  long wc ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  {
  varp = get_varp(opp);
  }
  if ((int )opp->flags & 2) {
    if ((unsigned long )((long *)varp) == (unsigned long )(& p_wc)) {
      goto _L;
    } else { //Added block
    if ((unsigned long )((long *)varp) == (unsigned long )(& p_wcm)) {
      _L: ;
      wc = *((long *)varp);
      if (wc >= 512L) {
        {


        }
      } else {
        {
        tmp___1 = find_special_key_in_table((int )wc);
        }
        if (tmp___1 >= 0) {
          {


          }
        } else {
          {
          tmp___0 = transchar((int )wc);
          strcpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)tmp___0));
          }
        }
      }
    } else {
      {
      sprintf((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )"%ld",
              *((long *)varp));
      }
    }
    }
  } else {
    varp = *((char_u **)varp);
    if ((unsigned long )varp == (unsigned long )((void *)0)) {

    }
    if ((unsigned long )opp->var == (unsigned long )((char_u *)17)) {
      if (*varp) {
        {

        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if ((int )opp->flags & 16) {
      {
      home_replace((BUF *)((void *)0), varp, NameBuff, 1024, 0);
      }
    } else { //Added block
    if ((unsigned long )((char_u **)opp->var) == (unsigned long )(& p_pt)) {
      {
      str2specialbuf(p_pt, NameBuff, 1024);
      }
    } else {
      {
      strncpy((char * __restrict  )((char *)NameBuff), (char const   * __restrict  )((char *)varp),
              (size_t )1024);
      }
    }
    }
    }
  }
  return;
}
}
int has_format_option(int x___0 ) 
{ 
  char_u *tmp ;

  {
  if (p_paste) {

  }
  {
  tmp = vim_strchr(curbuf->b_p_fo, x___0);
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
int shortmess(int x___0 ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_strchr(p_shm, x___0);
  }
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {

  } else {
    {
    tmp___0 = vim_strchr(p_shm, 'a');
    }
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {

      }





    } else {
      tmp___2 = 0;
    }
  }
  return (tmp___2);
}
}
static int old_p_paste  =    0;
static int save_sm___0  =    0;
static int save_ru  =    0;
static void paste_option_changed(void) 
{ 
  BUF *buf___3 ;

  {
  if (p_paste) {
    if (! old_p_paste) {
      buf___3 = firstbuf;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
          goto while_break;
        }
        buf___3->b_p_tw_save = buf___3->b_p_tw;
        buf___3->b_p_wm_save = buf___3->b_p_wm;
        buf___3->b_p_sts_save = buf___3->b_p_sts;
        buf___3->b_p_ai_save = buf___3->b_p_ai;
        buf___3->b_p_si_save = buf___3->b_p_si;
        buf___3->b_p_cin_save = buf___3->b_p_cin;
        buf___3->b_p_lisp_save = buf___3->b_p_lisp;
        buf___3 = buf___3->b_next;
      }
      while_break: ;/* CIL Label */ ;
      }
      save_sm___0 = p_sm;
      save_ru = p_ru;
    }
    buf___3 = firstbuf;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! ((unsigned long )buf___3 != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      buf___3->b_p_tw = 0L;
      buf___3->b_p_wm = 0L;
      buf___3->b_p_sts = 0L;
      buf___3->b_p_ai = 0;
      buf___3->b_p_si = 0;
      buf___3->b_p_cin = 0;
      buf___3->b_p_lisp = 0;
      buf___3 = buf___3->b_next;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    p_sm = 0;
    if (p_ru) {
      {

      }
    }
    p_ru = 0;
  } else { //Added block
  if (old_p_paste) {

    {














    while_break___1: ;/* CIL Label */ ;
    }







  }
  }
  old_p_paste = p_paste;
  return;
}
}
void vimrc_found(void) 
{



































}
void change_compatible(int on ) 
{















}
int option_was_set(char_u *name___1 ) 
{














}
static void compatible_set(void) 
{ 
  int opt_idx ;
  int tmp ;

  {
  opt_idx = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = istermoption(& options[opt_idx]);
    }
    if (tmp) {
      goto while_break;
    }
    if ((int )options[opt_idx].flags & 2048) {
      if (p_cp) {
        {
        set_option_default(opt_idx, 1);
        }
      } else {

      }
    } else { //Added block
    _L: ;
    if (! ((int )options[opt_idx].flags & 1024)) {
      if (! p_cp) {
        {

        }
      }
    }
    }
    opt_idx ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  init_chartab();
  }
  return;
}
}
static void fill_breakat_flags(void) 
{ 
  char_u *c ;
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 256)) {
      goto while_break;
    }
    breakat_flags[i___0] = (char)0;
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )p_breakat != (unsigned long )((void *)0)) {
    c = p_breakat;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! *c) {
        goto while_break___0;
      }
      breakat_flags[*c] = (char)1;
      c ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  return;
}
}
static int check_opt_strings(char_u *val , char **values , int list ) 
{ 
  int i___0 ;
  int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *val) {

    }
    i___0 = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if ((unsigned long )*(values + i___0) == (unsigned long )((void *)0)) {

      }
      {
      tmp = strlen((char const   *)*(values + i___0));
      len___0 = (int )tmp;
      tmp___0 = strncmp((char const   *)*(values + i___0), (char const   *)((char *)val),
                        (size_t )len___0);
      }
      if (tmp___0 == 0) {
        if (list) {






        } else { //Added block
        _L: ;
        if ((int )*(val + len___0) == 0) {
          return (1);
        }
        }
      }
      i___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }

}
}
static int check_opt_wim(void) 
{ 
  char_u new_wim_flags[4] ;
  char_u *p___0 ;
  int i___0 ;
  int idx ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  idx = 0;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break;
    }
    new_wim_flags[i___0] = (char_u )0;
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  p___0 = p_wim;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! *p___0) {

    }
    i___0 = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      {
      tmp = __ctype_b_loc();
      }
      if (! ((int const   )*(*tmp + (int )*(p___0 + i___0)) & 1024)) {
        goto while_break___1;
      }
      i___0 ++;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    if ((int )*(p___0 + i___0) != 0) {
      if ((int )*(p___0 + i___0) != 44) {



      }
    }
    if (i___0 == 7) {
      {


      }





    } else { //Added block
    _L___0: ;
    if (i___0 == 4) {
      {
      tmp___1 = strncmp((char const   *)((char *)p___0), (char const   *)((char *)"full"),
                        (size_t )4);
      }
      if (tmp___1 == 0) {
        new_wim_flags[idx] = (char_u )((int )new_wim_flags[idx] | 1);
      } else {

      }
    } else { //Added block
    _L: ;













    }
    }
    p___0 += i___0;
    if ((int )*p___0 == 0) {
      goto while_break___0;
    }







  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (! (idx < 3)) {
      goto while_break___2;
    }
    new_wim_flags[idx + 1] = new_wim_flags[idx];
    idx ++;
  }
  while_break___2: ;/* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! (i___0 < 4)) {
      goto while_break___3;
    }
    wim_flags[i___0] = new_wim_flags[i___0];
    i___0 ++;
  }
  while_break___3: ;/* CIL Label */ ;
  }
  return (1);
}
}
int can_bs(int what ) 
{ 
  char_u *tmp ;

  {
  {
  if ((int )*p_bs == 50) {

  }
  if ((int )*p_bs == 49) {

  }
  if ((int )*p_bs == 48) {

  }
  goto switch_break;
  case_50: ;/* CIL Label */ 

  case_49: ;/* CIL Label */ 

  case_48: ;/* CIL Label */ 

  switch_break: ;/* CIL Label */ ;
  }
  {
  tmp = vim_strchr(p_bs, what);
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#pragma merger("0","/tmp/cil-tVUl1r6X.i","-O0")
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern void (*sigset(int  , void (*func)(int  ) ))(int  ) ;
extern Display *XOpenDisplay(char const   * ) ;
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
extern int XCloseDisplay(Display * ) ;
extern int XFlush(Display * ) ;
extern int XFree(void * ) ;
extern int XGetErrorText(Display * , int  , char * , int  ) ;
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
extern int XSync(Display * , int  ) ;
extern int XGetWMIconName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMNormalHints(Display * , Window  , XSizeHints * , long * ) ;
extern void XSetWMIconName(Display * , Window  , XTextProperty * ) ;
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
extern void XtAppProcessEvent(XtAppContext  , XtInputMask  ) ;
extern XtInputMask XtAppPending(XtAppContext  ) ;
extern void XtRealizeWidget(Widget  ) ;
extern void XtDestroyWidget(Widget  ) ;
extern Widget XtVaCreatePopupShell(char const   * , WidgetClass  , Widget   , ...)  __attribute__((__sentinel__(0))) ;
extern Widget XtVaAppCreateShell(char const   * , char const   * , WidgetClass  ,
                                 Display *  , ...)  __attribute__((__sentinel__(0))) ;
extern Display *XtOpenDisplay(XtAppContext  , char const   * , char const   * , char const   * ,
                              XrmOptionDescRec * , Cardinal  , int * , char ** ) ;
void mch_write(char_u *s , int len___0 ) ;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
int mch_char_avail(void) ;
void mch_delay(long msec , int ignoreinput ) ;
void mch_suspend(void) ;
int vim_is_xterm(char_u *name___1 ) ;
int use_xterm_mouse(void) ;
int vim_is_iris(char_u *name___1 ) ;
int vim_is_fastterm(char_u *name___1 ) ;
void mch_settmode(int tmode ) ;
void get_stty(void) ;
int mch_get_winsize(void) ;
void mch_set_winsize(void) ;
void mch_breakcheck(void) ;
void setup_xterm_clip(void) ;
void start_xterm_trace(int button ) ;
void stop_xterm_trace(void) ;
int clip_xterm_own_selection(void) ;
void clip_xterm_lose_selection(void) ;
void clip_xterm_request_selection(void) ;
void clip_xterm_set_selection(void) ;
void set_mouse_termcode(int n , char_u *s ) ;
void del_mouse_termcode(int n ) ;
void getlinecol(void) ;
int term_is_8bit(char_u *name___1 ) ;
void out_str_nf(char_u *s ) ;
void term_set_winsize(int width , int height ) ;
void term_settitle(char_u *title ) ;
int vim_is_input_buf_full(void) ;
int vim_is_input_buf_empty(void) ;
void add_to_input_buf(char_u *s , int len___0 ) ;
int read_from_input_buf(char_u *buf___3 , long maxlen ) ;
void fill_input_buf(int exit_on_error ) ;
int check_col(int col ) ;
int check_row(int row ) ;
void open_app_context(void) ;
void x11_setup_atoms(Display *dpy ) ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) ;
void clip_x11_lose_selection(Widget myShell ) ;
int clip_x11_own_selection(Widget myShell ) ;
void clip_x11_set_selection(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
extern __pid_t wait(int *__stat_loc ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * ) ;
extern WidgetClass topLevelShellWidgetClass ;
extern WidgetClass applicationShellWidgetClass ;
extern char const   XtStrings[] ;
static Widget xterm_Shell  =    (Widget )0;
static void xterm_update(void) ;
Window x11_window  =    (Window )0;
Display *x11_display  =    (Display *)((void *)0);
int got_x_error  =    0;
static int get_x11_windis(void) ;
static void set_x11_title(char_u *title ) ;
static void set_x11_icon(char_u *icon ) ;
static int get_x11_title(int test_only ) ;
static int get_x11_icon(int test_only ) ;
static char_u *oldtitle  =    (char_u *)((void *)0);
static int did_set_title___0  =    0;
static char_u *oldicon  =    (char_u *)((void *)0);
static int did_set_icon  =    0;
static void may_core_dump(void) ;
static int WaitForChar(long msec ) ;
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) ;
static int do_xterm_trace(void) ;
static void handle_resize(void) ;
static void sig_winch(int sigarg ) ;
static void catch_sigint(int sigarg ) ;
static void sig_alarm(int sigarg ) ;
static void deathtrap(int sigarg ) ;
static void set_signals(void) ;
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) ;
static int have_wildcard(int num , char_u **file ) ;
static int have_dollars(int num , char_u **file ) ;
static int pstrcmp(void const   *a , void const   *b ) ;
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) ;
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) ;
static int do_resize___0  =    0;
static char_u *extra_shell_arg  =    (char_u *)((void *)0);
static int show_shell_mess  =    1;
static int deadly_signal  =    0;
static int curr_tmode  =    0;
static struct signalinfo signal_info[22]  = 
  {      {1, (char *)"HUP", (char)1}, 
        {3, (char *)"QUIT", (char)1}, 
        {4, (char *)"ILL", (char)1}, 
        {5, (char *)"TRAP", (char)1}, 
        {6, (char *)"ABRT", (char)1}, 
        {8, (char *)"FPE", (char)1}, 
        {7, (char *)"BUS", (char)1}, 
        {11, (char *)"SEGV", (char)1}, 
        {31, (char *)"SYS", (char)1}, 
        {14, (char *)"ALRM", (char)0}, 
        {15, (char *)"TERM", (char)1}, 
        {26, (char *)"VTALRM", (char)1}, 
        {27, (char *)"PROF", (char)1}, 
        {24, (char *)"XCPU", (char)1}, 
        {25, (char *)"XFSZ", (char)1}, 
        {10, (char *)"USR1", (char)1}, 
        {12, (char *)"USR2", (char)1}, 
        {2, (char *)"INT", (char)0}, 
        {28, (char *)"WINCH", (char)0}, 
        {20, (char *)"TSTP", (char)0}, 
        {13, (char *)"PIPE", (char)0}, 
        {-1, (char *)"Unknown!", (char)0}};
void mch_write(char_u *s , int len___0 ) 
{ 


  {
  {
  write(1, (void const   *)((char *)s), (size_t )len___0);
  }
  if (p_wd) {
    {

    }
  }
  return;
}
}
static int once_already  =    0;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{ 
  int len___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (do_resize___0) {
    {

    }
  }
  if (wtime >= 0L) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      {
      tmp = WaitForChar(wtime);
      }
      if (! (tmp == 0)) {
        goto while_break;
      }
      if (! do_resize___0) {
        once_already = 0;
        return (0);
      }
      {

      }
    }
    while_break: ;/* CIL Label */ ;
    }
  } else { //Added block
  if (once_already == 2) {
    {

    }
  } else { //Added block
  if (once_already == 1) {
    {


    }

  } else {
    {
    tmp___2 = WaitForChar(p_ut);
    }
    if (tmp___2 == 0) {
      {

      }






















    }
  }
  }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (do_resize___0) {
      {

      }
    }
    {
    WaitForChar(-1L);
    }
    if (do_resize___0) {

    }
    {
    len___0 = read_from_input_buf(buf___3, (long )maxlen);
    }
    if (len___0 > 0) {
      once_already = 0;
      return (len___0);
    }
    __Cont: ;;
  }
  while_break___0: ;/* CIL Label */ ;
  }
}
}
static void handle_resize(void) 
{









}
int mch_char_avail(void) 
{








}
void mch_delay(long msec , int ignoreinput ) 
{ 
  int old_tmode ;
  struct timespec ts ;

  {
  if (ignoreinput) {
    {
    old_tmode = curr_tmode;
    settmode(1);
    ts.tv_sec = msec / 1000L;
    ts.tv_nsec = (msec % 1000L) * 1000000L;
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
    settmode(old_tmode);
    }
  } else {
    {

    }
  }
  return;
}
}
static void sig_winch(int sigarg ) 
{









}
static void catch_sigint(int sigarg ) 
{









}
static void sig_alarm(int sigarg ) 
{





}
static int entered___1  =    0;
static void deathtrap(int sigarg ) 
{
















































}
void mch_suspend(void) 
{















}
void mch_windinit(void) 
{ 


  {
  {
  Columns = 80L;
  Rows = 24L;
  out_flush();
  set_signals();
  }
  return;
}
}
static void set_signals(void) 
{ 
  void (*tmp)(int  ) ;

  {
  {
  sigset(28, (void (*)(int  ))((void (*)())(& sig_winch)));
  }
  if (restricted) {

  } else {
    tmp = (void (*)(int  ))0;
  }
  {
  sigset(20, tmp);
  sigset(13, (void (*)(int  ))1);
  sigset(2, (void (*)(int  ))((void (*)())(& catch_sigint)));
  sigset(14, (void (*)(int  ))1);
  catch_signals((void (*)())(& deathtrap), (void (*)())((void (*)(int  ))-1));
  }
  return;
}
}
void reset_signals(void) 
{


  {
  {
  catch_signals((void (*)())((void (*)(int  ))0), (void (*)())((void (*)(int  ))0));
  }
  return;
}
}
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (signal_info[i___0].sig != -1)) {
      goto while_break;
    }
    if (signal_info[i___0].deadly) {
      {
      sigset(signal_info[i___0].sig, (void (*)(int  ))func_deadly);
      }
    } else { //Added block
    if ((unsigned long )func_other != (unsigned long )((void (*)(int  ))-1)) {
      {
      sigset(signal_info[i___0].sig, (void (*)(int  ))func_other);
      }
    }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
int mch_check_win(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
  tmp = isatty(1);
  }
  if (tmp) {
    return (1);
  }

}
}
int mch_input_isatty(void) 
{ 
  int tmp ;

  {
  {
  tmp = isatty(read_cmd_fd);
  }
  if (tmp) {
    return (1);
  }

}
}
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) ;
static int x_error_check(Display *dpy , XErrorEvent *error_event ) ;
static int test_x11_window(Display *dpy ) ;
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) 
{










}
static int x_error_check(Display *dpy , XErrorEvent *error_event ) 
{






}
static int test_x11_window(Display *dpy ) 
{





























}
static int get_x11_thing(int get_title , int test_only ) ;
static int result  =    -1;
static int x11_display_from  =    0;
static int get_x11_windis(void) 
{ 
  char *winid ;
  long tmp ;
  int tmp___0 ;
  void (*sig_save)() ;
  void (*tmp___1)(int  ) ;
  int tmp___2 ;

  {
  {
  XSetErrorHandler(& x_error_handler);
  }
  if (x11_window == 0UL) {
    {
    winid = getenv("WINDOWID");
    }
    if ((unsigned long )winid != (unsigned long )((void *)0)) {
      {


      }
    }
  }
  if ((unsigned long )xterm_dpy != (unsigned long )((void *)0)) {





















  }
  if (x11_window == 0UL) {
    result = -1;
  } else { //Added block



  }
  if (result != -1) {

  }
  if (x11_window != 0UL) {
























  }
  if (x11_window == 0UL) {
    result = 0;
    return (result);
  } else { //Added block




  }


}
}
static int get_x11_title(int test_only ) 
{ 
  int retval ;

  {
  {
  retval = get_x11_thing(1, test_only);
  }
  return (retval);
}
}
static int get_x11_icon(int test_only ) 
{ 
  int retval ;
  int tmp ;

  {
  {
  retval = 0;
  retval = get_x11_thing(0, test_only);
  }
  if ((unsigned long )oldicon == (unsigned long )((void *)0)) {
    if (! test_only) {
      {
      tmp = strncmp((char const   *)((char *)term_strings[0]), (char const   *)((char *)"builtin_"),
                    (size_t )8);
      }
      if (tmp == 0) {

      } else {
        oldicon = term_strings[0];
      }
    }
  }
  return (retval);
}
}
static int get_x11_thing(int get_title , int test_only ) 
{ 
  XTextProperty text_prop ;
  int retval ;
  int status ;
  Window root ;
  Window parent ;
  Window win ;
  Window *children ;
  unsigned int num_children ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  retval = 0;
  tmp___1 = get_x11_windis();
  }
  if (tmp___1 == 1) {









    {

    }





























































  }
  return (retval);
}
}
static void set_x11_title(char_u *title ) 
{













}
static void set_x11_icon(char_u *icon ) 
{













}
int mch_can_restore_title(void) 
{ 
  int tmp ;

  {
  {
  tmp = get_x11_title(1);
  }
  return (tmp);
}
}
int mch_can_restore_icon(void) 
{ 
  int tmp ;

  {
  {
  tmp = get_x11_icon(1);
  }
  return (tmp);
}
}
static int recursive___1  =    0;
void mch_settitle(char_u *title , char_u *icon ) 
{ 
  int type ;
  int tmp ;

  {
  type = 0;
  if ((unsigned long )term_strings[0] == (unsigned long )((void *)0)) {

  }
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    if ((unsigned long )icon == (unsigned long )((void *)0)) {
      return;
    }
  }
  if (recursive___1) {

  }
  {
  recursive___1 ++;
  tmp = get_x11_windis();
  }
  if (tmp == 1) {

  }
  if (type) {

  } else { //Added block
  if ((int )*(term_strings[45]) != 0) {
    _L: ;
    if ((unsigned long )title != (unsigned long )((void *)0)) {
      if ((unsigned long )oldtitle == (unsigned long )((void *)0)) {
        {
        get_x11_title(0);
        }
      }
      if ((int )*(term_strings[45]) != 0) {
        {
        term_settitle(title);
        }
      } else {
        {

        }
      }
      did_set_title___0 = 1;
    }
  }
  }
  if (type) {

  } else { //Added block
  if ((int )*(term_strings[43]) != 0) {
    _L___0: ;
    if ((unsigned long )icon != (unsigned long )((void *)0)) {
      if ((unsigned long )oldicon == (unsigned long )((void *)0)) {
        {
        get_x11_icon(0);
        }
      }
      if ((int )*(term_strings[43]) != 0) {
        {
        out_str(term_strings[43]);
        out_str_nf(icon);
        out_str(term_strings[44]);
        out_flush();
        }
      } else {
        {

        }
      }
      did_set_icon = 1;
    }
  }
  }
  recursive___1 --;
  return;
}
}
void mch_restore_title(int which ) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  if (which & 2) {
    if (did_set_icon) {
      tmp = oldicon;
    } else {
      tmp = (char_u *)((void *)0);
    }
  } else {
    tmp = (char_u *)((void *)0);
  }
  if (which & 1) {
    if (did_set_title___0) {
      if (oldtitle) {

      } else {
        tmp___0 = p_titleold;
      }
      tmp___1 = tmp___0;
    } else {
      tmp___1 = (char_u *)((void *)0);
    }
  } else {
    tmp___1 = (char_u *)((void *)0);
  }
  {
  mch_settitle(tmp___1, tmp);
  }
  return;
}
}
int vim_is_xterm(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

  }
  {
  tmp = strncasecmp((char const   *)((char *)name___1), (char const   *)((char *)"xterm"),
                    (size_t )5);
  }
  if (tmp == 0) {
    tmp___2 = 1;
  } else {
    {


    }












  }
  return (tmp___2);
}
}
int use_xterm_mouse(void) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = strncasecmp((char const   *)((char *)p_ttym), (char const   *)((char *)"xterm"),
                        (size_t )5);
  }
  if (tmp___1 == 0) {
    {
    tmp___0 = __ctype_b_loc();
    }
    if ((int const   )*(*tmp___0 + (int )*(p_ttym + 5)) & 2048) {
      {

      }

    }
    return (1);
  }
  return (0);
}
}
int vim_is_iris(char_u *name___1 ) 
{


























}
int vim_is_fastterm(char_u *name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

  }
  {
  tmp = vim_is_xterm(name___1);
  }
  if (tmp) {
    return (1);
  } else {
    {

    }



  }
  {


  }






































}
}
int mch_get_user_name(char_u *s , int len___0 ) 
{ 
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = getuid();
  tmp___0 = mch_get_uname(tmp, s, len___0);
  }
  return (tmp___0);
}
}
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) 
{ 
  struct passwd *pw ;

  {
  {
  pw = getpwuid(uid);
  }
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
      if ((int )*(pw->pw_name) != 0) {
        {
        strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )pw->pw_name,
                (size_t )len___0);
        }
        return (1);
      }
    }
  }
  {

  }

}
}
void mch_get_host_name(char_u *s , int len___0 ) 
{ 
  struct utsname vutsname ;

  {
  {
  uname(& vutsname);
  strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )(vutsname.nodename),
          (size_t )len___0);
  }
  return;
}
}
long mch_get_pid(void) 
{ 
  __pid_t tmp ;

  {
  {
  tmp = getpid();
  }
  return ((long )tmp);
}
}
int mch_dirname(char_u *buf___3 , int len___0 ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  tmp___1 = getcwd((char *)buf___3, (size_t )len___0);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {



    }

  }
  return (1);
}
}
static int dont_fchdir  =    0;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) 
{ 
  int l ;
  int fd ;
  char_u olddir[1024] ;
  char_u *p___0 ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  fd = -1;
  retval = 1;
  *buf___3 = (char_u )'\000';
  if ((unsigned long )fname == (unsigned long )((void *)0)) {

  }
  if (force) {
    goto _L___0;
  } else {
    {
    tmp___4 = mch_isFullName(fname);
    }
    if (! tmp___4) {
      _L___0: ;
      {
      p___0 = vim_strrchr(fname, '/');
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if (! dont_fchdir) {
          {
          fd = open(".", 0, 0);
          }
          if (fd >= 0) {
            {
            tmp = fchdir(fd);
            }
            if (tmp < 0) {
              {



              }
            }
          }
        }
        if (fd < 0) {
          {

          }






        } else { //Added block
        _L: ;
        if (p___0 - fname >= (long )len___0) {

        } else {
          {
          strncpy((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)fname),
                  (size_t )(p___0 - fname));
          *(buf___3 + (p___0 - fname)) = (char_u )'\000';
          tmp___0 = chdir((char const   *)((char *)buf___3));
          }
          if (tmp___0) {

          } else {
            fname = p___0 + 1;
          }
          *buf___3 = (char_u )'\000';
        }
        }
      }
      {
      tmp___2 = mch_dirname(buf___3, len___0);
      }
      if (tmp___2 == 0) {


      }
      {
      tmp___3 = strlen((char const   *)((char *)buf___3));
      l = (int )tmp___3;
      }
      if (l) {
        if ((int )*(buf___3 + (l - 1)) != 47) {
          {
          strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)"/"));
          }
        }
      }
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        if (fd >= 0) {
          {
          fchdir(fd);
          close(fd);
          }
        } else {
          {

          }
        }
      }
    }
  }
  {
  strcat((char * __restrict  )((char *)buf___3), (char const   * __restrict  )((char *)fname));
  }
  return (retval);
}
}
int mch_isFullName(char_u *fname ) 
{ 
  int tmp ;

  {
  if ((int )*fname == 47) {
    tmp = 1;
  } else { //Added block
  if ((int )*fname == 126) {

  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
long mch_getperm(char_u *name___1 ) 
{ 
  struct stat statb ;
  int tmp ;

  {
  {
  tmp = stat((char const   * __restrict  )((char *)name___1), (struct stat * __restrict  )(& statb));
  }
  if (tmp) {
    return (-1L);
  }
  return ((long )statb.st_mode);
}
}
int mch_setperm(char_u *name___1 , long perm ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = chmod((char const   *)((char *)name___1), (mode_t )perm);
  }
  if (tmp___1 == 0) {
    tmp___0 = 1;
  } else {

  }
  return (tmp___0);
}
}
void mch_hide(char_u *name___1 ) 
{ 


  {
  return;
}
}
int mch_isdir(char_u *name___1 ) 
{ 
  struct stat statb ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*name___1 == 0) {

  }
  {
  tmp = stat((char const   * __restrict  )((char *)name___1), (struct stat * __restrict  )(& statb));
  }
  if (tmp) {
    return (0);
  }
  if ((statb.st_mode & 61440U) == 16384U) {

  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
void mch_windexit(int r ) 
{ 
  int tmp ;

  {
  {
  settmode(0);
  exiting = 1;
  mch_restore_title(3);
  stoptermcap();
  }
  if (newline_on_exit) {
    {
    out_char((unsigned int )'\n');
    }
  } else { //Added block
  if (msg_didout) {
    {
    tmp = swapping_screen();
    }
    if (tmp) {
      {
      msg_clr_eos();
      }
    } else {
      {

      }
    }
  } else {
    {
    msg_clr_eos();
    }
  }
  }
  if (full_screen) {
    {
    cursor_on();
    }
  }
  {
  out_flush();
  ml_close_all(1);
  may_core_dump();
  exit(r);
  }
}
}
static void may_core_dump(void) 
{ 
  __pid_t tmp ;

  {
  if (deadly_signal != 0) {
    {



    }
  }
  return;
}
}
static int first  =    1;
static struct termios told  ;
void mch_settmode(int tmode ) 
{ 
  struct termios tnew ;

  {
  if (first) {
    {
    first = 0;
    tcgetattr(read_cmd_fd, & told);
    }
  }
  tnew = told;
  if (tmode == 2) {
    tnew.c_iflag &= 4294967039U;
    tnew.c_lflag &= 4294934500U;
    tnew.c_oflag &= 4294967291U;
    tnew.c_cc[6] = (cc_t )1;
    tnew.c_cc[5] = (cc_t )0;
  } else { //Added block
  if (tmode == 1) {
    tnew.c_lflag &= 4294967287U;
  }
  }
  {
  tcsetattr(read_cmd_fd, 0, (struct termios  const  *)(& tnew));
  curr_tmode = tmode;
  }
  return;
}
}
void get_stty(void) 
{ 
  char_u buf___3[2] ;
  char_u *p___0 ;
  struct termios keys___0 ;
  int tmp ;

  {
  {
  tmp = tcgetattr(read_cmd_fd, & keys___0);
  }
  if (tmp != -1) {
    {
    buf___3[0] = keys___0.c_cc[2];
    intr_char = (int )keys___0.c_cc[0];
    buf___3[1] = (char_u )'\000';
    add_termcode((char_u *)"kb", buf___3, 0);
    p___0 = find_termcode((char_u *)"kD");
    }
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
      if ((int )*(p___0 + 0) == (int )buf___3[0]) {





      }
    }
  }
  return;
}
}
static int ison  =    0;
void mch_setmouse(int on ) 
{ 
  int xterm_mouse_vers ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (on == ison) {
    return;
  }
  {

  }























}
}
void check_mouse_termcode(void) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___2 = use_xterm_mouse();
  }
  if (tmp___2) {
    {
    tmp___1 = term_is_8bit(term_strings[0]);
    }
    if (tmp___1) {

    } else {
      tmp___0 = "\033[M";
    }
    {
    set_mouse_termcode(251, (char_u *)tmp___0);
    }
    if ((int )*p_mouse != 0) {
      {


      }
    }
  } else {
    {

    }
  }
  return;
}
}
int mch_screenmode(char_u *arg ) 
{ 


  {
  {
  emsg((char_u *)"Screen mode setting not supported");
  }
  return (0);
}
}
int mch_get_winsize(void) 
{ 
  int old_Rows___0 ;
  int old_Columns ;
  char_u *p___0 ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
  old_Rows___0 = (int )Rows;
  old_Columns = (int )Columns;
  Columns = 0L;
  Rows = 0L;
  tmp = ioctl(1, 21523UL, & ws);
  }
  if (tmp == 0) {
    Columns = (long )ws.ws_col;
    Rows = (long )ws.ws_row;
  }
  if (Columns == 0L) {

  } else { //Added block
  if (Rows == 0L) {
    _L: ;
    {


    }






    {


    }






  }
  }
  if (Columns == 0L) {
    {

    }
  } else { //Added block
  if (Rows == 0L) {
    {

    }
  }
  }
  if (Columns <= 0L) {



  } else { //Added block
  if (Rows <= 0L) {



  }
  }
  {
  check_winsize();
  }
  return (1);
}
}
void mch_set_winsize(void) 
{ 


  {
  if (*(term_strings[48])) {
    {
    term_set_winsize((int )Rows, (int )Columns);
    out_flush();
    screen_start();
    }
  }
  return;
}
}
int mch_call_shell(char_u *cmd , int options___0 ) 
{ 
  char_u *newcmd ;
  pid_t pid ;
  pid_t wait_pid ;
  int status ;
  int retval ;
  char **argv ;
  int argc ;
  int i___0 ;
  char_u *p___0 ;
  int inquote ;
  int did_settmode ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int fd ;
  int *tmp___4 ;

  {
  {
  newcmd = (char_u *)((void *)0);
  wait_pid = 0;
  status = -1;
  retval = -1;
  argv = (char **)((void *)0);
  did_settmode = 0;
  out_flush();
  }
  if (options___0 & 4) {
    {
    settmode(0);
    }
  }
  {
  newcmd = vim_strsave(p_sh);
  }
  if ((unsigned long )newcmd == (unsigned long )((void *)0)) {

  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break;
    }
    p___0 = newcmd;
    inquote = 0;
    argc = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (i___0 == 1) {
        *(argv + argc) = (char *)p___0;
      }
      argc ++;
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (*p___0) {
          if (! inquote) {
            if ((int )*p___0 != 32) {
              if (! ((int )*p___0 != 9)) {

              }
            } else {

            }
          }
        } else {
          goto while_break___1;
        }
        if ((int )*p___0 == 34) {

        }
        p___0 ++;
      }
      while_break___1: ;/* CIL Label */ ;
      }
      if ((int )*p___0 == 0) {
        goto while_break___0;
      }





      {

      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (i___0 == 0) {
      {
      tmp___0 = alloc((unsigned int )((unsigned long )(argc + 4) * sizeof(char *)));
      argv = (char **)tmp___0;
      }
      if ((unsigned long )argv == (unsigned long )((void *)0)) {

      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
    if ((unsigned long )extra_shell_arg != (unsigned long )((void *)0)) {



    }
    tmp___2 = argc;
    argc ++;
    *(argv + tmp___2) = (char *)p_shcf;
    tmp___3 = argc;
    argc ++;
    *(argv + tmp___3) = (char *)cmd;
  }
  {
  *(argv + argc) = (char *)((void *)0);
  pid = fork();
  }
  if (pid == -1) {
      {
    msg_puts((char_u *)"\nCannot fork\n");
    }
  } else { //Added block
  if (pid == 0) {
    {
    reset_signals();
    }
    if (! show_shell_mess) {
      goto _L;
    } else { //Added block
    if (options___0 & 2) {
      _L:
      {
      fd = open("/dev/null", 2, 0);
      fclose(stdin);
      fclose(stdout);
      fclose(stderr);
      }
      if (fd >= 0) {
        {
        dup(fd);
        dup(fd);
        dup(fd);
        close(fd);
        }
      }
    }
    }
    {
    execvp((char const   *)*(argv + 0), (char * const  *)argv);
    exit(122);
    }
  } else {
    {
    catch_signals((void (*)())((void (*)(int  ))1), (void (*)())((void (*)(int  ))-1));
    }
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      if (! (wait_pid != pid)) {
        goto while_break___2;
      }
      {
      wait_pid = wait(& status);
      }
      if (wait_pid <= 0) {
        {

        }



      }
    }
    while_break___2: ;/* CIL Label */ ;
    }
    {
    settmode(2);
    did_settmode = 1;
    set_signals();
    ui_get_winsize();
    }
    if ((status & 127) == 0) {
      retval = (status & 65280) >> 8;
      if (retval) {
        if (retval == 122) {
          {



          }
        } else { //Added block
        if (! (options___0 & 16)) {
          {
          msg_putchar('\n');
          msg_outnum((long )retval);
          msg_puts((char_u *)" returned\n");
          }
        }
        }
      }
    } else {
      {

      }
    }
  }
  }
  {
  vim_free((void *)argv);
  }
  error: ;
  if (! did_settmode) {
    {

    }
  }
  {
  resettitle();
  vim_free((void *)newcmd);
  }
  return (retval);
}
}
void mch_breakcheck(void) 
{ 
  int tmp ;

  {
  if (curr_tmode == 2) {
    {
    tmp = RealWaitForChar(read_cmd_fd, 0L, (int *)((void *)0));
    }
    if (tmp) {
      {
      fill_input_buf(0);
      }
    }
  }
  return;
}
}
static int WaitForChar(long msec ) 
{ 
  int rest ;
  int avail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_is_input_buf_empty();
  }
  if (! tmp) {
    return (1);
  }
  {
  rest = 0;
  tmp___0 = do_xterm_trace();
  }
  if (tmp___0) {

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (rest != 0) {









    }
    {
    avail = RealWaitForChar(read_cmd_fd, msec, (int *)((void *)0));
    }
    if (! avail) {
      {
      tmp___1 = vim_is_input_buf_empty();
      }
      if (! tmp___1) {

      }
      if (rest == 0) {
        goto while_break;
      } else {
        {

        }



      }
    }
    if (! avail) {



    } else {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (avail);
}
}
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) 
{ 
  int ret ;
  struct timeval tv ;
  fd_set rfds ;
  fd_set efds ;
  int maxfd ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  struct timeval *tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (msec >= 0L) {
      tv.tv_sec = msec / 1000L;
      tv.tv_usec = (msec % 1000L) * 1000L;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
      goto while_break___0;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& efds.__fds_bits[0]): "memory");
      goto while_break___1;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    rfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    efds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    maxfd = fd;
    if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {




    }
    if (msec >= 0L) {
      tmp = & tv;
    } else {
      tmp = (struct timeval *)((void *)0);
    }
    {
    ret = select(maxfd + 1, & rfds, (fd_set *)((void *)0), & efds, tmp);
    }
    if (ret > 0) {
      if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
        if ((rfds.__fds_bits[((_XPrivDisplay )xterm_dpy)->fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ((_XPrivDisplay )xterm_dpy)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {


          }
          if (ret == 0) {
            {

            }
            if (tmp___0) {



            }
          }
        }
      }
    }
    goto while_break;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (ret > 0);
}
}
static int pstrcmp(void const   *a , void const   *b ) 
{








}
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) 
{








}
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) 
{
















































































































































































































}
static int did_find_nul  =    0;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{





























































































































































































































































































































































































































































































































































































































}
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) 
{




























}
int mch_has_wildcard(char_u *p___0 ) 
{ 
  char_u *tmp ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    if ((int )*p___0 == 92) {





    } else {
      _L: ;
      {
      tmp = vim_strchr((char_u *)"*?[{`\'~$", (int )*p___0);
      }
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        return (1);
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (0);
}
}
static int have_wildcard(int num , char_u **file ) 
{























}
static int have_dollars(int num , char_u **file ) 
{























}
static int xterm_trace  =    -1;
static int xterm_button  ;
void setup_xterm_clip(void) 
{ 
  int z ;
  char *strp ;
  Widget AppShell ;
  int (*oldhandler)() ;
  int (*tmp)(Display * , XErrorEvent * ) ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
  z = 0;
  strp = (char *)"";
  open_app_context();
  }
  if ((unsigned long )app_context != (unsigned long )((void *)0)) {
    if ((unsigned long )xterm_Shell == (unsigned long )((Widget )0)) {
      {
      tmp = XSetErrorHandler(& x_error_check);
      oldhandler = (int (*)())tmp;
      xterm_dpy = XtOpenDisplay(app_context, (char const   *)xterm_display, "vim_xterm",
                                "Vim_xterm", (XrmOptionDescRec *)((void *)0), (Cardinal )0,
                                & z, & strp);
      XSetErrorHandler((int (*)(Display * , XErrorEvent * ))oldhandler);
      }
      if ((unsigned long )xterm_dpy == (unsigned long )((void *)0)) {
        return;
      }
      {


      }



      {




      }






      {



      }
    }
  }
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {

    }











    {

    }






  }

}
}
void start_xterm_trace(int button ) 
{





















}
void stop_xterm_trace(void) 
{









}
static char_u *mouse_code  ;
static char_u mouse_name[2]  = {      (char_u )251,      (char_u )'X'};
static int prev_row  =    0;
static int prev_col  =    0;
static XSizeHints xterm_hints  ;
static int do_xterm_trace(void) 
{ 
  Window root ;
  Window child ;
  int root_x ;
  int root_y ;
  int win_x ;
  int win_y ;
  int row ;
  int col ;
  int_u mask_return ;
  char_u buf___3[50] ;
  char_u *strp ;
  long got_hints ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  if (xterm_trace <= 0) {
    return (0);
  }








































  {




  }





  {

















  }

}
}
void clear_xterm_clip(void) 
{ 


  {
  if ((unsigned long )xterm_Shell != (unsigned long )((Widget )0)) {
    {


    }
  }
  if ((unsigned long )xterm_dpy != (unsigned long )((void *)0)) {




  }
  return;
}
}
static void xterm_update(void) 
{




























}
int clip_xterm_own_selection(void) 
{











}
void clip_xterm_lose_selection(void) 
{










}
void clip_xterm_request_selection(void) 
{










}
void clip_xterm_set_selection(void) 
{








}
#pragma merger("0","/tmp/cil-8goyHUav.i","-O0")
char_u *all_cflags ;
char_u *all_lflags ;
char_u *compiled_user ;
char_u *compiled_sys ;
char_u *default_vim_dir  =    (char_u *)"/vim/source/share/vim";
char_u *default_vimruntime_dir  =    (char_u *)"";
char_u *all_cflags  =    (char_u *)"cilly --merge --keepmerged -c -I. -Iproto -DHAVE_CONFIG_H     -O0     ";
char_u *all_lflags  =    (char_u *)"cilly --merge --keepmerged  -o vim      -lXt -lX11 -lXdmcp -lncurses     ";
char_u *compiled_user  =    (char_u *)"qxin6";
char_u *compiled_sys  =    (char_u *)"qx-debloat";
#pragma merger("0","/tmp/cil-tVOikzOv.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
static void qf_msg(void) ;
static void qf_free(int idx ) ;
static char_u *qf_types(int c , int nr ) ;
static int qf_get_fnum(char_u *directory , char_u *fname ) ;
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) ;
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) ;
static char_u *qf_guess_filepath(char_u *filename ) ;
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) ;
static struct dir_stack_t *dir_stack  =    (struct dir_stack_t *)((void *)0);
struct qf_list qf_lists[10]  ;
static int qf_curlist  =    0;
static int qf_listcount  =    0;
static struct fmtpattern fmt_pat[7]  = {      {(char_u )'f', (char *)"\\f\\+"}, 
        {(char_u )'n', (char *)"\\d\\+"}, 
        {(char_u )'l', (char *)"\\d\\+"}, 
        {(char_u )'c', (char *)"\\d\\+"}, 
        {(char_u )'t', (char *)"."}, 
        {(char_u )'m', (char *)".\\+"}, 
        {(char_u )'r', (char *)".*"}};
int qf_init(char_u *efile , char_u *errorformat ) 
{
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int qf_get_fnum(char_u *directory , char_u *fname ) 
{


































































}
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) 
{






























































































}
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) 
{



















}
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) 
{




















}
static char_u *qf_guess_filepath(char_u *filename ) 
{



























































}
static char_u *e_no_more_items  =    (char_u *)"No more items";
void qf_jump(int dir , int errornr , int forceit ) 
{





















































































































































































































































































































}
void qf_list(char_u *arg , int all ) 
{























































































































































































































































}
void qf_older(int count___2 ) 
{


























}
void qf_newer(int count___2 ) 
{


























}
static void qf_msg(void) 
{








}
static void qf_free(int idx ) 
{





















}
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{ 
  int i___0 ;
  struct qf_line *qfp ;
  int idx ;

  {
  idx = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (idx < qf_listcount)) {
      goto while_break;
    }




































  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static char_u buf___2[20]  ;
static char_u cc[3]  ;
static char_u *qf_types(int c , int nr ) 
{













































}
#pragma merger("0","/tmp/cil-yZLjftJd.i","-O0")
int vim_regcomp_had_eol(void) ;
static int myisalnum(int c ) ;
static int myisalnum(int c ) 
{








}
static int myisalpha(int c ) ;
static int myisalpha(int c ) 
{








}
static int myiscntrl(int c ) ;
static int myiscntrl(int c ) 
{








}
static int myisdigit(int c ) ;
static int myisdigit(int c ) 
{








}
static int myisgraph(int c ) ;
static int myisgraph(int c ) 
{








}
static int myislower(int c ) ;
static int myislower(int c ) 
{








}
static int myispunct(int c ) ;
static int myispunct(int c ) 
{








}
static int myisupper(int c ) ;
static int myisupper(int c ) 
{








}
static int myisxdigit(int c ) ;
static int myisxdigit(int c ) 
{








}
static int re_ismult(int c ) ;
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) ;
static char_u *cstrchr(char_u *s , int c ) ;
static int re_ismult(int c ) 
{ 
  int tmp ;

  {
  if (c == (42 | (92 << 8))) {

  } else { //Added block
  if (c == (43 | (92 << 8))) {

  } else { //Added block
  if (c == (61 | (92 << 8))) {

  } else { //Added block
  if (c == (123 | (92 << 8))) {

  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
static char_u *reg_prev_sub  ;
static char_u REGEXP_INRANGE[5]  = {      (char_u )']',      (char_u )'^',      (char_u )'-',      (char_u )'\\', 
        (char_u )'\000'};
static char_u REGEXP_ABBR[5]  = {      (char_u )'r',      (char_u )'t',      (char_u )'e',      (char_u )'b', 
        (char_u )'\000'};
static int backslash_trans(int c ) ;
static int my_isblank(int c ) ;
static int my_istab(int c ) ;
static int my_isbspace(int c ) ;
static int my_isreturn(int c ) ;
static int my_isesc(int c ) ;
static int (*skip_class_name(char_u **pp ))(int  ) ;
static char_u *skip_range(char_u *p___0 ) ;
static void init_class_tab(void) ;
static int backslash_trans(int c ) 
{ 


  {
  {
  if (c == 114) {
    goto case_114;
  }
  if (c == 116) {
    goto case_116;
  }
  if (c == 101) {
    goto case_101;
  }
  if (c == 98) {
    goto case_98;
  }

  case_114: ;/* CIL Label */ 
  return ('\r');
  case_116: ;/* CIL Label */ 
  return ('\t');
  case_101: ;/* CIL Label */ 
  return ('\033');
  case_98: ;/* CIL Label */ 
  return ('\b');
  switch_break: ;/* CIL Label */ ;
  }

}
}
static int my_isblank(int c ) 
{














}
static int my_istab(int c ) 
{





}
static int my_isbspace(int c ) 
{





}
static int my_isreturn(int c ) 
{





}
static int my_isesc(int c ) 
{





}
static namedata_t const   class_names[16]  = 
  {      {sizeof("alnum:]") - 1UL, & myisalnum, {(char_u )'a', (char_u )'l', (char_u )'n',
                                             (char_u )'u', (char_u )'m', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("alpha:]") - 1UL, & myisalpha, {(char_u )'a', (char_u )'l', (char_u )'p',
                                             (char_u )'h', (char_u )'a', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("blank:]") - 1UL, & my_isblank, {(char_u )'b', (char_u )'l', (char_u )'a',
                                              (char_u )'n', (char_u )'k', (char_u )':',
                                              (char_u )']', (char_u )'\000'}}, 
        {sizeof("cntrl:]") - 1UL, & myiscntrl, {(char_u )'c', (char_u )'n', (char_u )'t',
                                             (char_u )'r', (char_u )'l', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("digit:]") - 1UL, & myisdigit, {(char_u )'d', (char_u )'i', (char_u )'g',
                                             (char_u )'i', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("graph:]") - 1UL, & myisgraph, {(char_u )'g', (char_u )'r', (char_u )'a',
                                             (char_u )'p', (char_u )'h', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("lower:]") - 1UL, & myislower, {(char_u )'l', (char_u )'o', (char_u )'w',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("print:]") - 1UL, & vim_isprintc, {(char_u )'p', (char_u )'r', (char_u )'i',
                                                (char_u )'n', (char_u )'t', (char_u )':',
                                                (char_u )']', (char_u )'\000'}}, 
        {sizeof("punct:]") - 1UL, & myispunct, {(char_u )'p', (char_u )'u', (char_u )'n',
                                             (char_u )'c', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("space:]") - 1UL, & vim_isspace, {(char_u )'s', (char_u )'p', (char_u )'a',
                                               (char_u )'c', (char_u )'e', (char_u )':',
                                               (char_u )']', (char_u )'\000'}}, 
        {sizeof("upper:]") - 1UL, & myisupper, {(char_u )'u', (char_u )'p', (char_u )'p',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("xdigit:]") - 1UL, & myisxdigit, {(char_u )'x', (char_u )'d', (char_u )'i',
                                               (char_u )'g', (char_u )'i', (char_u )'t',
                                               (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("tab:]") - 1UL,
      & my_istab, {(char_u )'t', (char_u )'a', (char_u )'b', (char_u )':', (char_u )']',
                   (char_u )'\000'}}, 
        {sizeof("return:]") - 1UL, & my_isreturn, {(char_u )'r', (char_u )'e', (char_u )'t',
                                                (char_u )'u', (char_u )'r', (char_u )'n',
                                                (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("backspace:]") - 1UL,
      & my_isbspace, {(char_u )'b', (char_u )'a', (char_u )'c', (char_u )'k', (char_u )'s',
                      (char_u )'p', (char_u )'a', (char_u )'c', (char_u )'e', (char_u )':',
                      (char_u )']', (char_u )'\000'}}, 
        {sizeof("escape:]") - 1UL, & my_isesc, {(char_u )'e', (char_u )'s', (char_u )'c',
                                             (char_u )'a', (char_u )'p', (char_u )'e',
                                             (char_u )':', (char_u )']', (char_u )'\000'}}};
static int (*skip_class_name(char_u **pp ))(int  ) 
{




























}
static char_u *skip_range(char_u *p___0 ) 
{ 
  int cpo_lit ;
  char_u *tmp ;
  int tmp___0 ;
  int (*tmp___1)(int  ) ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  if (! reg_syn) {
    {
    tmp = vim_strchr(p_cpo, 'l');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      tmp___0 = 1;
    } else {

    }
  } else {

  }
  cpo_lit = tmp___0;
  if ((int )*p___0 == 94) {

  }
  if ((int )*p___0 == 93) {

  } else { //Added block
  if ((int )*p___0 == 45) {

  }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if ((int )*p___0 != 0) {
      if (! ((int )*p___0 != 93)) {
        goto while_break;
      }
    } else {

    }
    if ((int )*p___0 == 45) {
      p___0 ++;
      if ((int )*p___0 != 93) {
        if ((int )*p___0 != 0) {
          p___0 ++;
        }
      }
    } else { //Added block
    if ((int )*p___0 == 92) {
      {

      }
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {

      } else { //Added block












      }
    } else { //Added block
    _L: ;
    if ((int )*p___0 == 91) {
      {

      }



    } else {
      p___0 ++;
    }
    }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
static char_u class_tab[256]  ;
static int done  =    0;
static void init_class_tab(void) 
{ 
  int i___0 ;

  {
  if (done) {
    return;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < 256)) {
      goto while_break;
    }
    if (i___0 >= 48) {
      if (i___0 <= 55) {
        class_tab[i___0] = (char_u )15;
      } else {
        goto _L___4;
      }
    } else { //Added block
    _L___4: ;
    if (i___0 >= 56) {
      if (i___0 <= 57) {
        class_tab[i___0] = (char_u )11;
      } else {
        goto _L___3;
      }
    } else { //Added block
    _L___3: ;
    if (i___0 >= 97) {
      if (i___0 <= 102) {
        class_tab[i___0] = (char_u )122;
      } else {
        goto _L___2;
      }
    } else { //Added block
    _L___2: ;
    if (i___0 >= 103) {
      if (i___0 <= 122) {
        class_tab[i___0] = (char_u )120;
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: ;
    if (i___0 >= 65) {
      if (i___0 <= 70) {
        class_tab[i___0] = (char_u )186;
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if (i___0 >= 71) {
      if (i___0 <= 90) {
        class_tab[i___0] = (char_u )184;
      } else {
        goto _L;
      }
    } else { //Added block
    _L: ;
    if (i___0 == 95) {
      class_tab[i___0] = (char_u )24;
    }
    }
    }
    }
    }
    }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  done = 1;
  return;
}
}
static char_u *regparse  ;
static int num_complex_braces  ;
static int regnpar  ;
static char_u *regcode  ;
static long regsize  ;
static char_u **regendp  ;
static int brace_min[10]  ;
static int brace_max[10]  ;
static int brace_count[10]  ;
static int had_eol  ;
static int reg_magic  ;
static char_u META[48]  = 
  {      (char_u )'.',      (char_u )'[',      (char_u )'(',      (char_u )')', 
        (char_u )'|',      (char_u )'=',      (char_u )'+',      (char_u )'*', 
        (char_u )'<',      (char_u )'>',      (char_u )'i',      (char_u )'I', 
        (char_u )'k',      (char_u )'K',      (char_u )'f',      (char_u )'F', 
        (char_u )'p',      (char_u )'P',      (char_u )'s',      (char_u )'S', 
        (char_u )'d',      (char_u )'D',      (char_u )'x',      (char_u )'X', 
        (char_u )'o',      (char_u )'O',      (char_u )'w',      (char_u )'W', 
        (char_u )'h',      (char_u )'H',      (char_u )'a',      (char_u )'A', 
        (char_u )'l',      (char_u )'L',      (char_u )'u',      (char_u )'U', 
        (char_u )'~',      (char_u )'1',      (char_u )'2',      (char_u )'3', 
        (char_u )'4',      (char_u )'5',      (char_u )'6',      (char_u )'7', 
        (char_u )'8',      (char_u )'9',      (char_u )'{',      (char_u )'\000'};
static void initchr(char_u *str___1 ) ;
static int getchr(void) ;
static int peekchr(void) ;
static int curchr  ;
static void skipchr(void) ;
static void ungetchr(void) ;
static char_u *reg(int paren , int *flagp ) ;
static char_u *regbranch(int *flagp ) ;
static char_u *regpiece(int *flagp ) ;
static char_u *regatom(int *flagp ) ;
static char_u *regnode(int op ) ;
static char_u *regnext(char_u *p___0 ) ;
static void regc(int b ) ;
static void unregc(void) ;
static void reginsert(int op , char_u *opnd ) ;
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) ;
static int read_limits(int start___0 , int end , int *minval , int *maxval ) ;
static void regtail(char_u *p___0 , char_u *val ) ;
static void regoptail(char_u *p___0 , char_u *val ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*(p___0 + 0) != 0)) {
      goto while_break;
    }
    if ((int )*(p___0 + 0) == dirc) {

    }
    if ((int )*(p___0 + 0) == 91) {





    } else { //Added block
    _L___2: ;
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) == 91) {
        if (! magic) {
          _L: ;
          {

          }



        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else { //Added block
    _L___1: ;
    if ((int )*(p___0 + 0) == 92) {
      if ((int )*(p___0 + 1) != 0) {
        p___0 ++;
      }
    }
    }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (p___0);
}
}
vim_regexp *vim_regcomp(char_u *expr , int magic ) 
{ 
  vim_regexp *r ;
  char_u *scan ;
  char_u *longest ;
  int len___0 ;
  int flags___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char_u *tmp___6 ;

  {
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {


    }

  }
  {
  reg_magic = magic;
  init_class_tab();
  initchr(expr);
  num_complex_braces = 0;
  regnpar = 1;
  regsize = 0L;
  regcode = (char_u *)-1;
  regendp = (char_u **)((void *)0);
  had_eol = 0;
  regc(156);
  tmp = reg(0, & flags___0);
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {

  }
  {
  tmp___0 = lalloc(sizeof(vim_regexp ) + (unsigned long )regsize, 1);
  r = (vim_regexp *)tmp___0;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {

  }
  {
  initchr(expr);
  num_complex_braces = 0;
  regnpar = 1;
  regcode = r->program;
  regendp = r->endp;
  regc(156);
  tmp___1 = reg(0, & flags___0);
  }
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {

    }

  }
  {
  r->regstart = (char_u )'\000';
  r->reganch = (char_u )0;
  r->regmust = (char_u *)((void *)0);
  r->regmlen = 0;
  scan = r->program + 1;
  tmp___6 = regnext(scan);
  }
  if ((int )*tmp___6 == 0) {
    scan += 3;
    if ((int )*scan == 1) {
      {


      }
    }
    if ((int )*scan == 8) {
      r->regstart = *(scan + 3);
    } else { //Added block
    if ((int )*scan == 13) {
      goto _L;
    } else { //Added block
    if ((int )*scan == 14) {
      _L: ;
      {
      tmp___3 = regnext(scan);
      }
      if ((int )*tmp___3 == 8) {
        {
        tmp___2 = regnext(scan);
        r->regstart = *(tmp___2 + 3);
        }
      }
    }
    }
    }
    if (flags___0 & 4) {

    } else { //Added block
    if ((int )*scan == 13) {
      goto _L___0;
    } else { //Added block
    if ((int )*scan == 14) {
      _L___0: ;
      longest = (char_u *)((void *)0);
      len___0 = 0;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
          goto while_break;
        }
        if ((int )*scan == 8) {
          {
          tmp___5 = strlen((char const   *)((char *)(scan + 3)));
          }
          if (tmp___5 >= (size_t )len___0) {
            {
            longest = scan + 3;
            tmp___4 = strlen((char const   *)((char *)(scan + 3)));
            len___0 = (int )tmp___4;
            }
          }
        }
        {
        scan = regnext(scan);
        }
      }
      while_break: ;/* CIL Label */ ;
      }
      r->regmust = longest;
      r->regmlen = len___0;
    }
    }
    }
  }
  return (r);
}
}
int vim_regcomp_had_eol(void) 
{





}
static char_u *reg(int paren , int *flagp ) 
{ 
  char_u *ret ;
  char_u *br ;
  char_u *ender ;
  int parno ;
  int flags___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  parno = 0;
  *flagp = 1;
  if (paren) {







    {



    }



  } else {
    ret = (char_u *)((void *)0);
  }
  {
  br = regbranch(& flags___0);
  }
  if ((unsigned long )br == (unsigned long )((void *)0)) {

  }
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {

    }
  } else {
    ret = br;
  }
  if (! (flags___0 & 1)) {

  }
  *flagp |= flags___0 & 4;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = peekchr();
    }
    if (! (tmp == (124 | (92 << 8)))) {
      goto while_break;
    }
    {


    }



    {

    }




  }
  while_break: ;/* CIL Label */ ;
  }
  if (paren) {

  } else {
    tmp___0 = 0;
  }
  {
  ender = regnode(tmp___0);
  regtail(ret, ender);
  br = ret;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    regoptail(br, ender);
    br = regnext(br);
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (paren) {
    {

    }









  } else { //Added block
  _L: ;
  if (! paren) {
    {
    tmp___1 = peekchr();
    }
    if (tmp___1 != 0) {













    }
  }
  }
  if (paren) {



  }
  return (ret);
}
}
static char_u *regbranch(int *flagp ) 
{ 
  char_u *ret ;
  char_u *chain ;
  char_u *latest ;
  int flags___0 ;
  int tmp ;

  {
  {
  *flagp = 0;
  ret = regnode(6);
  chain = (char_u *)((void *)0);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp = peekchr();
    }
    if (tmp != 0) {
      if (curchr != (124 | (92 << 8))) {
        if (! (curchr != (41 | (92 << 8)))) {

        }
      } else {

      }
    } else {
      goto while_break;
    }
    {
    latest = regpiece(& flags___0);
    }
    if ((unsigned long )latest == (unsigned long )((void *)0)) {

    }
    *flagp |= flags___0 & 1;
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
      *flagp |= flags___0 & 4;
    } else {
      {
      regtail(chain, latest);
      }
    }
    chain = latest;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {

    }
  }
  return (ret);
}
}
static char_u *regpiece(int *flagp ) 
{ 
  char_u *ret ;
  int op ;
  char_u *next ;
  int flags___0 ;
  int minval ;
  int maxval ;
  int tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
  ret = regatom(& flags___0);
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {

  }
  {
  op = peekchr();
  tmp = re_ismult(op);
  }
  if (! tmp) {
    *flagp = flags___0;
    return (ret);
  }









  {


  }












































































































  {


  }








}
}
static char_u *regatom(int *flagp ) 
{ 
  char_u *ret ;
  int flags___0 ;
  int cpo_lit ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *p___0 ;
  char_u *tmp___2 ;
  int refnum ;
  int tmp___3 ;
  char_u *p___1 ;
  char_u *tmp___4 ;
  int cclass ;
  int cclassend ;
  char_u *tmp___5 ;
  int tmp___6 ;
  int (*func)(int  ) ;
  int cu ;
  char_u *tmp___7 ;
  int tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  int len___0 ;
  int chr ;
  int tmp___12 ;

  {
  *flagp = 0;
  if (! reg_syn) {
    {
    tmp = vim_strchr(p_cpo, 'l');
    }
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      tmp___0 = 1;
    } else {

    }
  } else {

  }
  {
  cpo_lit = tmp___0;
  tmp___1 = getchr();
  }
  {
  if (tmp___1 == (94 | (92 << 8))) {

  }
  if (tmp___1 == (36 | (92 << 8))) {

  }
  if (tmp___1 == (60 | (92 << 8))) {
    goto case_exp___1;
  }
  if (tmp___1 == (62 | (92 << 8))) {
    goto case_exp___2;
  }
  if (tmp___1 == (46 | (92 << 8))) {

  }
  if (tmp___1 == (105 | (92 << 8))) {

  }
  if (tmp___1 == (107 | (92 << 8))) {

  }
  if (tmp___1 == (73 | (92 << 8))) {

  }
  if (tmp___1 == (75 | (92 << 8))) {

  }
  if (tmp___1 == (102 | (92 << 8))) {

  }
  if (tmp___1 == (70 | (92 << 8))) {

  }
  if (tmp___1 == (112 | (92 << 8))) {

  }
  if (tmp___1 == (80 | (92 << 8))) {

  }
  if (tmp___1 == (115 | (92 << 8))) {
    goto case_exp___12;
  }
  if (tmp___1 == (83 | (92 << 8))) {
    goto case_exp___13;
  }
  if (tmp___1 == (100 | (92 << 8))) {
    goto case_exp___14;
  }
  if (tmp___1 == (68 | (92 << 8))) {
    goto case_exp___15;
  }
  if (tmp___1 == (120 | (92 << 8))) {

  }
  if (tmp___1 == (88 | (92 << 8))) {

  }
  if (tmp___1 == (111 | (92 << 8))) {
    goto case_exp___18;
  }
  if (tmp___1 == (79 | (92 << 8))) {
    goto case_exp___19;
  }
  if (tmp___1 == (119 | (92 << 8))) {
    goto case_exp___20;
  }
  if (tmp___1 == (87 | (92 << 8))) {
    goto case_exp___21;
  }
  if (tmp___1 == (104 | (92 << 8))) {
    goto case_exp___22;
  }
  if (tmp___1 == (72 | (92 << 8))) {
    goto case_exp___23;
  }
  if (tmp___1 == (97 | (92 << 8))) {
    goto case_exp___24;
  }
  if (tmp___1 == (65 | (92 << 8))) {
    goto case_exp___25;
  }
  if (tmp___1 == (108 | (92 << 8))) {
    goto case_exp___26;
  }
  if (tmp___1 == (76 | (92 << 8))) {
    goto case_exp___27;
  }
  if (tmp___1 == (117 | (92 << 8))) {
    goto case_exp___28;
  }
  if (tmp___1 == (85 | (92 << 8))) {
    goto case_exp___29;
  }
  if (tmp___1 == (40 | (92 << 8))) {

  }
  if (tmp___1 == 0) {

  }
  if (tmp___1 == (124 | (92 << 8))) {

  }
  if (tmp___1 == (41 | (92 << 8))) {

  }
  if (tmp___1 == (61 | (92 << 8))) {

  }
  if (tmp___1 == (43 | (92 << 8))) {

  }
  if (tmp___1 == (123 | (92 << 8))) {

  }
  if (tmp___1 == (42 | (92 << 8))) {

  }
  if (tmp___1 == (126 | (92 << 8))) {

  }
  if (tmp___1 == (49 | (92 << 8))) {

  }
  if (tmp___1 == (50 | (92 << 8))) {

  }
  if (tmp___1 == (51 | (92 << 8))) {

  }
  if (tmp___1 == (52 | (92 << 8))) {

  }
  if (tmp___1 == (53 | (92 << 8))) {

  }
  if (tmp___1 == (54 | (92 << 8))) {

  }
  if (tmp___1 == (55 | (92 << 8))) {

  }
  if (tmp___1 == (56 | (92 << 8))) {

  }
  if (tmp___1 == (57 | (92 << 8))) {

  }
  if (tmp___1 == (91 | (92 << 8))) {
    goto case_exp___47;
  }
  goto switch_default;
  case_exp: ;/* CIL Label */ 
  {

  }

  case_exp___0: ;/* CIL Label */ 
  {


  }

  case_exp___1: ;/* CIL Label */ 
  {
  ret = regnode(13);
  }
  goto switch_break;
  case_exp___2: ;/* CIL Label */ 
  {
  ret = regnode(14);
  }
  goto switch_break;
  case_exp___3: ;/* CIL Label */ 
  {


  }

  case_exp___4: ;/* CIL Label */ 
  {


  }

  case_exp___5: ;/* CIL Label */ 
  {


  }

  case_exp___6: ;/* CIL Label */ 
  {


  }

  case_exp___7: ;/* CIL Label */ 
  {


  }

  case_exp___8: ;/* CIL Label */ 
  {


  }

  case_exp___9: ;/* CIL Label */ 
  {


  }

  case_exp___10: ;/* CIL Label */ 
  {


  }

  case_exp___11: ;/* CIL Label */ 
  {


  }

  case_exp___12: ;/* CIL Label */ 
  {
  ret = regnode(24);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___13: ;/* CIL Label */ 
  {
  ret = regnode(25);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___14: ;/* CIL Label */ 
  {
  ret = regnode(26);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___15: ;/* CIL Label */ 
  {
  ret = regnode(27);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___16: ;/* CIL Label */ 
  {


  }

  case_exp___17: ;/* CIL Label */ 
  {


  }

  case_exp___18: ;/* CIL Label */ 
  {
  ret = regnode(30);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___19: ;/* CIL Label */ 
  {
  ret = regnode(31);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___20: ;/* CIL Label */ 
  {
  ret = regnode(32);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___21: ;/* CIL Label */ 
  {
  ret = regnode(33);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___22: ;/* CIL Label */ 
  {
  ret = regnode(34);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___23: ;/* CIL Label */ 
  {
  ret = regnode(35);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___24: ;/* CIL Label */ 
  {
  ret = regnode(36);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___25: ;/* CIL Label */ 
  {
  ret = regnode(37);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___26: ;/* CIL Label */ 
  {
  ret = regnode(38);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___27: ;/* CIL Label */ 
  {
  ret = regnode(39);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___28: ;/* CIL Label */ 
  {
  ret = regnode(40);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___29: ;/* CIL Label */ 
  {
  ret = regnode(41);
  *flagp |= 3;
  }
  goto switch_break;
  case_exp___30: ;/* CIL Label */ 
  {

  }





  case_0: ;/* CIL Label */ 
  case_exp___31: ;/* CIL Label */ 
  case_exp___32: ;/* CIL Label */ 
  {


  }

  case_exp___33: ;/* CIL Label */ 
  {


  }

  case_exp___34: ;/* CIL Label */ 
  {


  }

  case_exp___35: ;/* CIL Label */ 
  {


  }

  case_exp___36: ;/* CIL Label */ 













  case_exp___37: ;/* CIL Label */ 




































  case_exp___38: ;/* CIL Label */ 
  case_exp___39: ;/* CIL Label */ 
  case_exp___40: ;/* CIL Label */ 
  case_exp___41: ;/* CIL Label */ 
  case_exp___42: ;/* CIL Label */ 
  case_exp___43: ;/* CIL Label */ 
  case_exp___44: ;/* CIL Label */ 
  case_exp___45: ;/* CIL Label */ 
  case_exp___46: ;/* CIL Label */ 
  {



  }


























  case_exp___47: ;/* CIL Label */ 
  {
  p___1 = skip_range(regparse);
  }
  if ((int )*p___1 == 93) {
    if ((int )*regparse == 94) {
      {


      }
    } else {
      {
      ret = regnode(4);
      }
    }
    if ((int )*regparse == 93) {
      {



      }
    } else { //Added block
    if ((int )*regparse == 45) {
      {



      }
    }
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if ((int )*regparse != 0) {
        if (! ((int )*regparse != 93)) {
          goto while_break___0;
        }
      } else {

      }
      if ((int )*regparse == 45) {
        regparse ++;
        if ((int )*regparse == 93) {
          {

          }
        } else { //Added block
        if ((int )*regparse == 0) {
          {

          }
        } else {
          cclass = (int )*(regparse - 2) + 1;
          cclassend = (int )*regparse;
          if (cclass > cclassend + 1) {
            {


            }

          }
          {
          while (1) {
            while_continue___1: ;/* CIL Label */ ;
            if (! (cclass <= cclassend)) {
              goto while_break___1;
            }
            {
            regc(cclass);
            cclass ++;
            }
          }
          while_break___1: ;/* CIL Label */ ;
          }
          regparse ++;
        }
        }
      } else { //Added block
      if ((int )*regparse == 92) {
        {

        }
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {





          }
        } else { //Added block


















        }
      } else { //Added block
      _L: ;
      if ((int )*regparse == 91) {
        {

        }



























      } else {
        {
        tmp___9 = regparse;
        regparse ++;
        regc((int )*tmp___9);
        }
      }
      }
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    regc('\000');
    }
    if ((int )*regparse != 93) {
      {


      }

    }
    {
    skipchr();
    *flagp |= 3;
    }
    goto switch_break;
  }
  switch_default: ;/* CIL Label */ 
  {
  ungetchr();
  len___0 = 0;
  ret = regnode(8);
  }
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    {
    chr = peekchr();
    }
    if (chr != 0) {
      if (! (chr < 92 << 8)) {
        if (! (len___0 == 0)) {
          goto while_break___3;
        }
      }
    } else {
      goto while_break___3;
    }
    {
    regc(chr);
    skipchr();
    len___0 ++;
    }
  }
  while_break___3: ;/* CIL Label */ ;
  }
  if (len___0 > 1) {
    {
    tmp___12 = re_ismult(chr);
    }
    if (tmp___12) {
      {



      }
    }
  }
  {
  regc('\000');
  *flagp |= 1;
  }
  if (len___0 == 1) {
    *flagp |= 2;
  }
  goto switch_break;
  switch_break: ;/* CIL Label */ ;
  }
  return (ret);
}
}
static char_u *regnode(int op ) 
{ 
  char_u *ret ;
  char_u *ptr ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;

  {
  ret = regcode;
  if ((unsigned long )ret == (unsigned long )((char_u *)-1)) {
    regsize += 3L;
    return (ret);
  }
  ptr = ret;
  tmp = ptr;
  ptr ++;
  *tmp = (char_u )op;
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (char_u )'\000';
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (char_u )'\000';
  regcode = ptr;
  return (ret);
}
}
static void regc(int b ) 
{ 
  char_u *tmp ;

  {
  if ((unsigned long )regcode != (unsigned long )((char_u *)-1)) {
    tmp = regcode;
    regcode ++;
    *tmp = (char_u )b;
  } else {
    regsize ++;
  }
  return;
}
}
static void unregc(void) 
{










}
static void reginsert(int op , char_u *opnd ) 
{




































}
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) 
{


























































}
static void regtail(char_u *p___0 , char_u *val ) 
{ 
  char_u *scan ;
  char_u *temp ;
  int offset ;

  {
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return;
  }
  scan = p___0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    temp = regnext(scan);
    }
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
      goto while_break;
    }
    scan = temp;
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((int )*scan == 7) {

  } else {
    offset = (int )(val - scan);
  }
  *(scan + 1) = (char_u )(((unsigned int )offset >> 8) & 255U);
  *(scan + 2) = (char_u )(offset & 255);
  return;
}
}
static void regoptail(char_u *p___0 , char_u *val ) 
{ 


  {
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return;
  } else { //Added block
  if ((int )*p___0 != 6) {
    if ((int )*p___0 < 90) {
      return;
    } else { //Added block



    }
  }
  }
  }
  {
  regtail(p___0 + 3, val);
  }
  return;
}
}
static int prevchr  ;
static int nextchr  ;
static int at_start  ;
static int prev_at_start  ;
static void initchr(char_u *str___1 ) 
{ 


  {
  regparse = str___1;
  nextchr = -1;
  prevchr = nextchr;
  curchr = prevchr;
  at_start = 1;
  prev_at_start = 0;
  return;
}
}
static int peekchr(void) 
{ 
  char_u *tmp ;
  char_u *tmp___0 ;

  {
  if (curchr < 0) {
    curchr = (int )*(regparse + 0);
    {
    if (curchr == 46) {
      goto case_46;
    }
    if (curchr == 91) {
      goto case_46;
    }
    if (curchr == 126) {

    }
    if (curchr == 42) {

    }
    if (curchr == 94) {
      goto case_94;
    }
    if (curchr == 36) {

    }
    if (curchr == 92) {
      goto case_92;
    }
    goto switch_break;
    case_46: ;/* CIL Label */ 
    case_91: ;/* CIL Label */ 
    case_126: ;/* CIL Label */ 
    if (reg_magic) {
      curchr |= 92 << 8;
    }
    goto switch_break;
    case_42: ;/* CIL Label */ 












    case_94: ;/* CIL Label */ 
    if (at_start) {



    } else { //Added block
    if (prevchr == (40 | (92 << 8))) {



    } else { //Added block
    if (prevchr == (124 | (92 << 8))) {



    }
    }
    }
    goto switch_break;
    case_36: ;/* CIL Label */ 














    case_92: ;/* CIL Label */ 
    regparse ++;
    if ((int )*(regparse + 0) == 0) {


    } else {
      {
      tmp___0 = vim_strchr(META, (int )*(regparse + 0));
      }
      if (tmp___0) {
        {
        curchr = -1;
        prev_at_start = at_start;
        at_start = 0;
        peekchr();
        curchr ^= 92 << 8;
        }
      } else {
        {
        tmp = vim_strchr(REGEXP_ABBR, (int )*(regparse + 0));
        }
        if (tmp) {
          {
          curchr = backslash_trans((int )*(regparse + 0));
          }
        } else {
          curchr = (int )*(regparse + 0);
        }
      }
    }
    goto switch_break;
    switch_break: ;/* CIL Label */ ;
    }
  }
  return (curchr);
}
}
static void skipchr(void) 
{ 


  {
  regparse ++;
  prev_at_start = at_start;
  at_start = 0;
  prevchr = curchr;
  curchr = nextchr;
  nextchr = -1;
  return;
}
}
static int getchr(void) 
{ 
  int chr ;

  {
  {
  chr = peekchr();
  skipchr();
  }
  return (chr);
}
}
static void ungetchr(void) 
{ 


  {
  nextchr = curchr;
  curchr = prevchr;
  at_start = prev_at_start;
  prev_at_start = 0;
  regparse --;
  return;
}
}
static int read_limits(int start___0 , int end , int *minval , int *maxval ) 
{






























































































}
static char_u *reginput  ;
static char_u *regbol  ;
static char_u **regstartp  ;
static int need_clear_subexpr  ;
static int regtry(vim_regexp *prog , char_u *string___0 ) ;
static void clear_subexpr(void) ;
static int regmatch(char_u *prog ) ;
static int regrepeat(char_u *p___0 ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{ 
  char_u *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {

    }

  } else { //Added block
  if ((unsigned long )string___0 == (unsigned long )((void *)0)) {
    {

    }

  }
  }
  if ((int )prog->program[0] != 156) {
    {

    }

  }
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
    s = string___0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      {
      s = cstrchr(s, (int )*(prog->regmust + 0));
      }
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      tmp = cstrncmp(s, prog->regmust, prog->regmlen);
      }
      if (tmp == 0) {
        goto while_break;
      }

    }
    while_break: ;/* CIL Label */ ;
    }
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      return (0);
    }
  }
  if (at_bol) {
    regbol = string___0;
  } else {
    regbol = (char_u *)((void *)0);
  }
  if (prog->reganch) {















    {

    }

  }
  s = string___0;
  if ((int )prog->regstart != 0) {
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      s = cstrchr(s, (int )prog->regstart);
      }
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
        goto while_break___0;
      }
      {
      tmp___3 = regtry(prog, s);
      }
      if (tmp___3) {
        return (1);
      }
      s ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  } else {
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      {
      tmp___4 = regtry(prog, s);
      }
      if (tmp___4) {
        return (1);
      }
      tmp___5 = s;
      s ++;
      if (! ((int )*tmp___5 != 0)) {
        goto while_break___1;
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
  }
  return (0);
}
}
static int regtry(vim_regexp *prog , char_u *string___0 ) 
{ 
  int tmp ;

  {
  {
  reginput = string___0;
  regstartp = prog->startp;
  regendp = prog->endp;
  need_clear_subexpr = 1;
  tmp = regmatch(prog->program + 1);
  }
  if (tmp) {
    {
    clear_subexpr();
    prog->startp[0] = string___0;
    prog->endp[0] = reginput;
    }
    return (1);
  } else {
    return (0);
  }
}
}
static void clear_subexpr(void) 
{ 


  {
  if (need_clear_subexpr) {
    {
    memset((void *)regstartp, 0, sizeof(char_u *) * 10UL);
    memset((void *)regendp, 0, sizeof(char_u *) * 10UL);
    need_clear_subexpr = 0;
    }
  }
  return;
}
}
static int break_count  =    0;
static int regmatch(char_u *prog ) 
{ 
  char_u *scan ;
  char_u *next ;
  int minval ;
  int maxval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int len___0 ;
  char_u *opnd ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char_u *tmp___19 ;
  char_u *tmp___20 ;
  int no ;
  char_u *save ;
  int tmp___21 ;
  int no___0 ;
  char_u *save___0 ;
  int tmp___22 ;
  int no___1 ;
  int len___1 ;
  int tmp___23 ;
  char_u *save___1 ;
  int tmp___24 ;
  int no___2 ;
  int no___3 ;
  char_u *save___2 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int nextch ;
  int nextch_ic ;
  int no___4 ;
  char_u *save___3 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
  minval = -1;
  maxval = -1;
  break_count ++;
  if ((break_count & 4095) == 0) {
    {

    }
  }
  scan = prog;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {

    }
    if (got_int) {

    }
    {
    next = regnext(scan);
    }
    {
    if ((int )*scan == 1) {

    }
    if ((int )*scan == 2) {

    }
    if ((int )*scan == 13) {
      goto case_13;
    }
    if ((int )*scan == 14) {
      goto case_14;
    }
    if ((int )*scan == 3) {

    }
    if ((int )*scan == 15) {

    }
    if ((int )*scan == 16) {

    }
    if ((int )*scan == 17) {

    }
    if ((int )*scan == 18) {

    }
    if ((int )*scan == 19) {

    }
    if ((int )*scan == 20) {

    }
    if ((int )*scan == 21) {

    }
    if ((int )*scan == 22) {

    }
    if ((int )*scan == 24) {
      goto case_24;
    }
    if ((int )*scan == 25) {
      goto case_25;
    }
    if ((int )*scan == 26) {
      goto case_26;
    }
    if ((int )*scan == 27) {
      goto case_27;
    }
    if ((int )*scan == 28) {

    }
    if ((int )*scan == 29) {

    }
    if ((int )*scan == 30) {
      goto case_30;
    }
    if ((int )*scan == 31) {
      goto case_31;
    }
    if ((int )*scan == 32) {
      goto case_32;
    }
    if ((int )*scan == 33) {
      goto case_33;
    }
    if ((int )*scan == 34) {
      goto case_34;
    }
    if ((int )*scan == 35) {
      goto case_35;
    }
    if ((int )*scan == 36) {
      goto case_36;
    }
    if ((int )*scan == 37) {
      goto case_37;
    }
    if ((int )*scan == 38) {
      goto case_38;
    }
    if ((int )*scan == 39) {
      goto case_39;
    }
    if ((int )*scan == 40) {
      goto case_40;
    }
    if ((int )*scan == 41) {
      goto case_41;
    }
    if ((int )*scan == 8) {
      goto case_8;
    }
    if ((int )*scan == 4) {

    }
    if ((int )*scan == 5) {

    }
    if ((int )*scan == 9) {

    }
    if ((int )*scan == 7) {

    }
    if ((int )*scan == 61) {

    }
    if ((int )*scan == 62) {

    }
    if ((int )*scan == 63) {

    }
    if ((int )*scan == 64) {

    }
    if ((int )*scan == 65) {

    }
    if ((int )*scan == 66) {

    }
    if ((int )*scan == 67) {

    }
    if ((int )*scan == 68) {

    }
    if ((int )*scan == 69) {

    }
    if ((int )*scan == 71) {

    }
    if ((int )*scan == 72) {

    }
    if ((int )*scan == 73) {

    }
    if ((int )*scan == 74) {

    }
    if ((int )*scan == 75) {

    }
    if ((int )*scan == 76) {

    }
    if ((int )*scan == 77) {

    }
    if ((int )*scan == 78) {

    }
    if ((int )*scan == 79) {

    }
    if ((int )*scan == 81) {

    }
    if ((int )*scan == 82) {

    }
    if ((int )*scan == 83) {

    }
    if ((int )*scan == 84) {

    }
    if ((int )*scan == 85) {

    }
    if ((int )*scan == 86) {

    }
    if ((int )*scan == 87) {

    }
    if ((int )*scan == 88) {

    }
    if ((int )*scan == 89) {

    }
    if ((int )*scan == 6) {
      goto case_6;
    }
    if ((int )*scan == 23) {

    }
    if ((int )*scan == 90) {

    }
    if ((int )*scan == 91) {

    }
    if ((int )*scan == 92) {

    }
    if ((int )*scan == 93) {

    }
    if ((int )*scan == 94) {

    }
    if ((int )*scan == 95) {

    }
    if ((int )*scan == 96) {

    }
    if ((int )*scan == 97) {

    }
    if ((int )*scan == 98) {

    }
    if ((int )*scan == 99) {

    }
    if ((int )*scan == 12) {

    }
    if ((int )*scan == 10) {

    }
    if ((int )*scan == 11) {

    }
    if ((int )*scan == 0) {
      goto case_0;
    }

    case_1: ;/* CIL Label */ 




    case_2: ;/* CIL Label */ 




    case_13: ;/* CIL Label */ 
    if ((unsigned long )reginput != (unsigned long )regbol) {
      {

      }



    }
    if (! *(reginput + 0)) {

    } else {
      {
      tmp___0 = vim_iswordc((int )*(reginput + 0));
      }
      if (! tmp___0) {

      }
    }
    goto switch_break;
    case_14: ;/* CIL Label */ 
    if ((unsigned long )reginput == (unsigned long )regbol) {

    } else {
      {
      tmp___1 = vim_iswordc((int )*(reginput + -1));
      }
      if (! tmp___1) {

      }
    }
    if (*(reginput + 0)) {
      {
      tmp___2 = vim_iswordc((int )*(reginput + 0));
      }
      if (tmp___2) {

      }
    }
    goto switch_break;
    case_3: ;/* CIL Label */ 





    case_15: ;/* CIL Label */ 
    {

    }





    case_16: ;/* CIL Label */ 
    {

    }





    case_17: ;/* CIL Label */ 
    {

    }





    case_18: ;/* CIL Label */ 
    {

    }





    case_19: ;/* CIL Label */ 
    {

    }












    case_20: ;/* CIL Label */ 
    {

    }












    case_21: ;/* CIL Label */ 
    {

    }












    case_22: ;/* CIL Label */ 
    {

    }












    case_24: ;/* CIL Label */ 
    if (! ((int )*reginput == 32)) {
      if (! ((int )*reginput == 9)) {
        return (0);
      }
    }


    case_25: ;/* CIL Label */ 
    if ((int )*reginput == 0) {

    } else { //Added block
    if ((int )*reginput == 32) {

    } else { //Added block
    if ((int )*reginput == 9) {

    }
    }
    }
    reginput ++;
    goto switch_break;
    case_26: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 1)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_27: ;/* CIL Label */ 
    if ((int )*reginput == 0) {

    } else { //Added block
    if ((int )class_tab[*reginput] & 1) {

    }
    }
    reginput ++;
    goto switch_break;
    case_28: ;/* CIL Label */ 





    case_29: ;/* CIL Label */ 









    case_30: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 4)) {
      return (0);
    }
    reginput ++;
    goto switch_break;
    case_31: ;/* CIL Label */ 
    if ((int )*reginput == 0) {

    } else { //Added block
    if ((int )class_tab[*reginput] & 4) {

    }
    }
    reginput ++;
    goto switch_break;
    case_32: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 8)) {

    }
    reginput ++;
    goto switch_break;
    case_33: ;/* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 8) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_34: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 16)) {

    }
    reginput ++;
    goto switch_break;
    case_35: ;/* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 16) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_36: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 32)) {

    }
    reginput ++;
    goto switch_break;
    case_37: ;/* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 32) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_38: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 64)) {

    }
    reginput ++;
    goto switch_break;
    case_39: ;/* CIL Label */ 
    if ((int )*reginput == 0) {
      return (0);
    } else { //Added block
    if ((int )class_tab[*reginput] & 64) {
      return (0);
    }
    }
    reginput ++;
    goto switch_break;
    case_40: ;/* CIL Label */ 
    if (! ((int )class_tab[*reginput] & 128)) {
      return (0);
    }


    case_41: ;/* CIL Label */ 
    if ((int )*reginput == 0) {

    } else { //Added block
    if ((int )class_tab[*reginput] & 128) {

    }
    }
    reginput ++;
    goto switch_break;
    case_8: ;/* CIL Label */ 
    opnd = scan + 3;
    if ((int )*opnd != (int )*reginput) {
      if (! reg_ic) {

      } else {
        {


        }



      }
    }
    {
    tmp___17 = strlen((char const   *)((char *)opnd));
    len___0 = (int )tmp___17;
    }
    if (len___0 > 1) {
      {
      tmp___18 = cstrncmp(opnd, reginput, len___0);
      }
      if (tmp___18 != 0) {
        return (0);
      }
    }
    reginput += len___0;
    goto switch_break;
    case_4: ;/* CIL Label */ 












    case_5: ;/* CIL Label */ 












    case_9: ;/* CIL Label */ 

    case_7: ;/* CIL Label */ 

    case_61: ;/* CIL Label */ 
    case_62: ;/* CIL Label */ 
    case_63: ;/* CIL Label */ 
    case_64: ;/* CIL Label */ 
    case_65: ;/* CIL Label */ 
    case_66: ;/* CIL Label */ 
    case_67: ;/* CIL Label */ 
    case_68: ;/* CIL Label */ 
    case_69: ;/* CIL Label */ 
    {





    }





    case_71: ;/* CIL Label */ 
    case_72: ;/* CIL Label */ 
    case_73: ;/* CIL Label */ 
    case_74: ;/* CIL Label */ 
    case_75: ;/* CIL Label */ 
    case_76: ;/* CIL Label */ 
    case_77: ;/* CIL Label */ 
    case_78: ;/* CIL Label */ 
    case_79: ;/* CIL Label */ 
    {





    }





    case_81: ;/* CIL Label */ 
    case_82: ;/* CIL Label */ 
    case_83: ;/* CIL Label */ 
    case_84: ;/* CIL Label */ 
    case_85: ;/* CIL Label */ 
    case_86: ;/* CIL Label */ 
    case_87: ;/* CIL Label */ 
    case_88: ;/* CIL Label */ 
    case_89: ;/* CIL Label */ 
    {


    }











    case_6: ;/* CIL Label */ 
    if ((int )*next != 6) {
      next = scan + 3;
    } else {
      {





















      while_break___0: ;/* CIL Label */ ;
      }

    }
    goto switch_break;
    case_23: ;/* CIL Label */ 
























    case_90: ;/* CIL Label */ 
    case_91: ;/* CIL Label */ 
    case_92: ;/* CIL Label */ 
    case_93: ;/* CIL Label */ 
    case_94: ;/* CIL Label */ 
    case_95: ;/* CIL Label */ 
    case_96: ;/* CIL Label */ 
    case_97: ;/* CIL Label */ 
    case_98: ;/* CIL Label */ 
    case_99: ;/* CIL Label */ 













































    case_12: ;/* CIL Label */ 
    case_10: ;/* CIL Label */ 
    case_11: ;/* CIL Label */ 






























    {


    }








































































    case_0: ;/* CIL Label */ 
    return (1);
    switch_default: ;/* CIL Label */ 
    {

    }

    switch_break: ;/* CIL Label */ ;
    }
    scan = next;
  }
  while_break: ;/* CIL Label */ ;
  }
  {

  }

}
}
static int regrepeat(char_u *p___0 ) 
{










































































































































































































































































































































































































































































































}
static char_u *regnext(char_u *p___0 ) 
{ 
  int offset ;

  {
  if ((unsigned long )p___0 == (unsigned long )((char_u *)-1)) {
    return ((char_u *)((void *)0));
  }
  offset = (((int )*(p___0 + 1) & 255) << 8) + ((int )*(p___0 + 2) & 255);
  if (offset == 0) {
    return ((char_u *)((void *)0));
  }
  if ((int )*p___0 == 7) {

  } else {
    return (p___0 + offset);
  }
}
}
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! reg_ic) {
    {
    tmp = strncmp((char const   *)((char *)s1), (char const   *)((char *)s2), (size_t )n);
    }
    return (tmp);
  }
  {


  }

}
}
static char_u *cstrchr(char_u *s , int c ) 
{ 
  char_u *p___0 ;
  int cc___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! reg_ic) {
    {
    tmp = vim_strchr(s, c);
    }
    return (tmp);
  }
  {

  }




















  {














  while_break: ;/* CIL Label */ ;
  }

}
}
static fptr do_upper(char_u *d , int c ) ;
static fptr do_Upper(char_u *d , int c ) ;
static fptr do_lower(char_u *d , int c ) ;
static fptr do_Lower(char_u *d , int c ) ;
static fptr do_upper(char_u *d , int c ) 
{









}
static fptr do_Upper(char_u *d , int c ) 
{









}
static fptr do_lower(char_u *d , int c ) 
{









}
static fptr do_Lower(char_u *d , int c ) 
{









}
char_u *regtilde(char_u *source , int magic ) 
{






































































































}
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) 
{






















}
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) 
{










































































































































































































































}
#pragma merger("0","/tmp/cil-BEhIo2Hj.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
char *mediumVersion ;
void screen_stop_highlight(void) ;
void reset_cterm_colors(void) ;
void invalidate_botline_win(WIN *wp ) ;
void validate_cheight(void) ;
void win_rest_invalid(WIN *wp ) ;
vim_regexp *last_pat_prog(void) ;
void syntax_start(WIN *wp , linenr_t lnum ) ;
int syntax_check_changed(linenr_t lnum ) ;
int get_syntax_attr(colnr_t col , char_u *line ) ;
struct attr_entry *syn_term_attr2entry(int attr ) ;
struct attr_entry *syn_cterm_attr2entry(int attr ) ;
void term_windgoto(int row , int col ) ;
void term_cursor_right(int i___0 ) ;
void term_append_lines(int line_count ) ;
void term_delete_lines(int line_count ) ;
void term_fg_color(int n ) ;
void term_bg_color(int n ) ;
void scroll_region_set(WIN *wp , int off___0 ) ;
void clip_update_selection(void) ;
int clip_isautosel(void) ;
int highest_patch(void) ;
int win_alloc_lsize(WIN *wp ) ;
void win_free_lsize(WIN *wp ) ;
void win_drag_status_line(int offset ) ;
static int screen_attr  =    0;
static int screen_cur_row  ;
static int screen_cur_col  ;
vim_regexp *search_hl_prog  =    (vim_regexp *)((void *)0);
int search_hl_attr  ;
int search_hl_ic  ;
static char_u *current_LinePointer  ;
static void win_update(WIN *wp ) ;
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) ;
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) ;
static void screen_line(int row , int endcol , int clear_rest ) ;
static void start_search_hl(void) ;
static void end_search_hl(void) ;
static void screen_start_highlight(int attr ) ;
static void comp_botline(void) ;
static void screen_char(char_u *p___0 , int row , int col ) ;
static void screenclear2(void) ;
static void lineclear(char_u *p___0 ) ;
static void check_cursor_moved(WIN *wp ) ;
static void curs_rows(int do_botline ) ;
static void validate_virtcol_win(WIN *wp ) ;
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) ;
static void msg_pos_mode(void) ;
static int highlight_status(int *attr , int is_curwin ) ;
static void win_redr_custom(WIN *wp , int Ruler ) ;
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) ;
static void win_redr_ruler(WIN *wp , int always ) ;
static void get_rel_pos(WIN *wp , char_u *str___1 ) ;
static int get_scroll_overlap(linenr_t lnum , int dir ) ;
static void intro_message(void) ;
void update_screenline(void) 
{ 
  int row ;
  int old_cline_height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (! tmp) {

  }
  if (must_redraw) {



    {

    }

  }
  {
  tmp___0 = redrawing();
  }
  if (! tmp___0) {
    {

    }

  }
  if ((linenr_t )curwin->w_lsize_valid <= curwin->w_cursor.lnum - curwin->w_topline) {
    {

    }

  } else { //Added block
  if (*(curwin->w_lsize_lnum + 0) != curwin->w_topline) {
    {

    }

  }
  }
  if (clipboard.available) {
    {

    }





  }
  {
  old_cline_height = (int )*(curwin->w_lsize + (curwin->w_cursor.lnum - curwin->w_topline));
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 16)) {
    {

    }
  }
  {
  start_search_hl();
  validate_virtcol();
  cursor_off();
  row = win_line(curwin, curwin->w_cursor.lnum, curwin->w_cline_row, curwin->w_height);
  end_search_hl();
  }
  if (row == curwin->w_height + 1) {




    {


    }
  } else { //Added block
  if (! dollar_vcol) {
    if (old_cline_height != curwin->w_cline_height) {










      {

      }
    } else {
      {
      tmp___2 = syntax_present(curbuf);
      }
      if (tmp___2) {














      } else { //Added block
      _L___0: ;
      if (clear_cmdline) {
        {

        }
      } else { //Added block
      if (redraw_cmdline) {
        {

        }
      }
      }
      }
    }
  }
  }
  return;
}
}
void redraw_later(int type ) 
{ 


  {
  if (curwin->w_redr_type < type) {
    curwin->w_redr_type = type;
  }
  if (must_redraw < type) {
    must_redraw = type;
  }
  return;
}
}
void redraw_all_later(int type ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type < type) {
      wp->w_redr_type = type;
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  redraw_later(type);
  }
  return;
}
}
void redraw_curbuf_later(int type ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type < type) {
      if ((unsigned long )wp->w_buffer == (unsigned long )curbuf) {
        wp->w_redr_type = type;
      }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  redraw_later(type);
  }
  return;
}
}
void update_curbuf(int type ) 
{ 


  {
  {
  redraw_curbuf_later(type);
  update_screen(type);
  }
  return;
}
}
static int did_intro  =    0;
void update_screen(int type ) 
{ 
  WIN *wp ;
  int did_one ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u *tmp___3 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (! tmp) {

  }
  dollar_vcol = (colnr_t )0;
  if (must_redraw) {
    if (type < must_redraw) {
      type = must_redraw;
    }
    must_redraw = 0;
  }
  if (curwin->w_lsize_valid == 0) {
    if (type < 40) {
      type = 40;
    }
  }
  {
  tmp___0 = redrawing();
  }
  if (! tmp___0) {
    {
    redraw_later(type);
    curwin->w_redr_type = type;
    curwin->w_lsize_valid = 0;
    }
    return;
  }
  if (msg_scrolled) {
    clear_cmdline = 1;
    if ((long )msg_scrolled > Rows - 5L) {
      type = 50;
    } else { //Added block
    if (type != 50) {
      {
      check_for_delay(0);
      tmp___1 = screen_ins_lines(0, 0, msg_scrolled, (int )Rows);
      }
      if (tmp___1 == 0) {

      }
      {
      win_rest_invalid(firstwin);
      }
    }
    }
    msg_scrolled = 0;
    need_wait_return = 0;
  }
  {
  compute_cmdrow();
  }
  if (need_highlight_changed) {
    {
    highlight_changed();
    }
  }
  if (type == 50) {
    {
    screenclear();
    type = 40;
    }
  }
  if (clear_cmdline) {
    {
    check_for_delay(0);
    msg_clr_cmdline();
    }
  }
  if (type == 20) {
    {
    update_curswant();
    }
  }
  if (type == 10) {
    if (! (curwin->w_topline == *(curwin->w_lsize_lnum + 0))) {
      goto _L;
    }
  } else { //Added block
  _L: ;
  if (type == 20) {
    if (curwin->w_old_cursor_lnum == curwin->w_cursor.lnum) {
      if (curwin->w_valid & 4) {
        if (! (curwin->w_old_curswant == curwin->w_curswant)) {
          curwin->w_redr_type = type;
        }
      } else {

      }
    } else {
      curwin->w_redr_type = type;
    }
  } else {
    curwin->w_redr_type = type;
  }
  }
  did_one = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_type) {
      {
      cursor_off();
      }
      if (! did_one) {
        {
        start_search_hl();
        did_one = 1;
        }
      }
      {
      win_update(wp);
      }
    }
    if (wp->w_redr_status) {
      {
      cursor_off();
      win_redr_status(wp);
      }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (did_one) {
    {
    end_search_hl();
    }
  }
  if (redraw_cmdline) {
    {
    showmode();
    }
  }
  if (! did_intro) {
    if (curbuf->b_ml.ml_line_count == 1L) {
      {

      }














    }
  }
  did_intro = 1;
  return;
}
}
void update_other_win(void) 
{ 
  WIN *wp ;
  int first___0 ;

  {
  first___0 = 1;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if ((unsigned long )wp != (unsigned long )curwin) {















    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  end_search_hl();
  }
  return;
}
}
static int recursive___2  =    0;
static void win_update(WIN *wp ) 
{ 
  int type ;
  int row ;
  int endrow ;
  linenr_t lnum ;
  linenr_t lastline ;
  int done___0 ;
  int didline ;
  int srow ;
  int idx ;
  int i___0 ;
  long j ;
  int old_botline ;
  int must_start_top ;
  int must_end_bot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  linenr_t from ;
  linenr_t to ;
  colnr_t from1 ;
  colnr_t from2 ;
  colnr_t to1 ;
  colnr_t to2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  srow = 0;
  old_botline = (int )wp->w_botline;
  must_start_top = 0;
  must_end_bot = 0;
  if (clipboard.available) {
    {

    }





  }
  type = wp->w_redr_type;
  if (type == 40) {
    wp->w_redr_status = 1;
    wp->w_lsize_valid = 0;
  }
  {
  wp->w_redr_type = 0;
  idx = 0;
  row = 0;
  lnum = wp->w_topline;
  validate_virtcol_win(wp);
  endrow = wp->w_height;
  }
  if (type == 10) {
    goto _L___5;
  } else { //Added block
  if (type == 30) {

  } else { //Added block
  if (type == 35) {

  } else { //Added block
  if (type == 20) {
    _L___5: ;
    if (wp->w_topline < *(wp->w_lsize_lnum + 0)) {
      j = *(wp->w_lsize_lnum + 0) - wp->w_topline;
      if (j < (long )(wp->w_height - 2)) {
        if (type != 30) {
          goto _L___2;
        } else { //Added block
        if (*(wp->w_lsize_lnum + 0) < curwin->w_cursor.lnum) {
          _L___2: ;
          if (type != 35) {
            goto _L___0;
          } else { //Added block
          if (*(wp->w_lsize_lnum + 0) < curwin->w_cursor.lnum - 1L) {
            _L___0: ;
            {
            lastline = *(wp->w_lsize_lnum + 0) - 1L;
            i___0 = plines_m_win(wp, wp->w_topline, lastline);
            }
            if (i___0 < wp->w_height - 2) {
              if (i___0 > 0) {
                {
                check_for_delay(0);
                }
              }
              {
              tmp___1 = win_ins_lines(wp, 0, i___0, 0, (unsigned long )wp == (unsigned long )firstwin);
              }
              if (tmp___1 == 1) {
                if (wp->w_lsize_valid) {
                  must_start_top = 1;
                  endrow = i___0;
                  if (type == 30) {

                  } else { //Added block
                  if (type == 35) {

                  }
                  }
                  tmp___0 = (int )((long )wp->w_lsize_valid + j);
                  wp->w_lsize_valid = tmp___0;
                  if (tmp___0 > wp->w_height) {
                    wp->w_lsize_valid = wp->w_height;
                  }
                  idx = wp->w_lsize_valid;
                  {
                  while (1) {
                    while_continue: ;/* CIL Label */ ;
                    if (! ((long )idx - j >= 0L)) {
                      goto while_break;
                    }
                    *(wp->w_lsize_lnum + idx) = *(wp->w_lsize_lnum + ((long )idx - j));
                    *(wp->w_lsize + idx) = *(wp->w_lsize + ((long )idx - j));
                    idx --;
                  }
                  while_break: ;/* CIL Label */ ;
                  }
                  idx = 0;
                }
              }
            } else { //Added block







            }
          } else {

          }
          }
        } else {

        }
        }
      } else { //Added block
      _L___1: ;
      if ((unsigned long )lastwin == (unsigned long )firstwin) {
        {
        screenclear();
        must_start_top = 1;
        must_end_bot = 1;
        }
      }
      }
    } else {
      j = -1L;
      i___0 = 0;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (! (i___0 < wp->w_lsize_valid)) {
          goto while_break___0;
        }
        if (*(wp->w_lsize_lnum + i___0) == wp->w_topline) {
          j = (long )i___0;
          goto while_break___0;
        }
        row += (int )*(wp->w_lsize + i___0);
        i___0 ++;
      }
      while_break___0: ;/* CIL Label */ ;
      }
      if (j == -1L) {
        row = 0;
        if ((unsigned long )lastwin == (unsigned long )firstwin) {
          {
          screenclear();
          must_start_top = 1;
          must_end_bot = 1;
          }
        }
      } else {
        if (row) {
          {
          check_for_delay(0);
          tmp___2 = win_del_lines(wp, 0, row, 0, (unsigned long )wp == (unsigned long )firstwin);
          }
          if (tmp___2 == 1) {
            must_end_bot = 1;
          }
        }
        if (row == 0) {
          goto _L___4;
        } else { //Added block
        if (must_end_bot) {
          _L___4: ;
          if (wp->w_lsize_valid) {
            srow = row;
            row = 0;
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              if (type == 30) {






              } else { //Added block
              _L___3: ;
              if (type == 35) {




              }
              }
              *(wp->w_lsize + idx) = *(wp->w_lsize + j);
              *(wp->w_lsize_lnum + idx) = lnum;
              if ((row + srow) + (int )*(wp->w_lsize + j) > wp->w_height) {


              }
              lnum ++;
              tmp___3 = idx;
              idx ++;
              row += (int )*(wp->w_lsize + tmp___3);
              j ++;
              if ((int )j >= wp->w_lsize_valid) {
                wp->w_lsize_valid = idx;
                goto while_break___1;
              }
            }
            while_break___1: ;/* CIL Label */ ;
            }
          } else {

          }
        } else {
          row = 0;
        }
        }
      }
    }
    if (endrow == wp->w_height) {
      if (idx == 0) {
        wp->w_lsize_valid = 0;
      }
    }
  }
  }
  }
  }
  didline = 0;
  done___0 = didline;
  if (VIsual_active) {
    if ((unsigned long )wp->w_buffer == (unsigned long )curwin->w_buffer) {
      if (wp->w_redr_type == 40) {


      }
      if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum) {


      } else {
        from = wp->w_old_cursor_lnum;
        to = curwin->w_cursor.lnum;
        if (from == 0L) {
          from = to;
        }
      }
      if (VIsual.lnum != wp->w_old_visual_lnum) {
        if (wp->w_old_visual_lnum < from) {
          if (wp->w_old_visual_lnum != 0L) {

          }
        }
        if (wp->w_old_visual_lnum > to) {

        }
        if (VIsual.lnum < from) {

        }
        if (VIsual.lnum > to) {

        }
      }
      if (VIsual_mode == 22) {

















































      }
      if (from < wp->w_topline) {

      } else { //Added block
      if (must_start_top) {

      }
      }
      if (wp->w_valid & 32) {
        if (from >= wp->w_botline) {

        }
        if (to >= wp->w_botline) {

        }
      }
      if (lnum > from) {
        lnum = wp->w_topline;
        idx = 0;
        row = 0;
      }
      {
      while (1) {
        while_continue___2: ;/* CIL Label */ ;
        if (lnum < from) {



        } else {
          goto while_break___2;
        }




      }
      while_break___2: ;/* CIL Label */ ;
      }
      if (! must_end_bot) {
        if (! must_start_top) {
          srow = row;
          j = (long )idx;
          {
          while (1) {
            while_continue___3: ;/* CIL Label */ ;
            if (! (j < (long )wp->w_lsize_valid)) {
              goto while_break___3;
            }
            if (*(wp->w_lsize_lnum + j) == to + 1L) {
              endrow = srow;
              goto while_break___3;
            }
            srow += (int )*(wp->w_lsize + j);
            j ++;
          }
          while_break___3: ;/* CIL Label */ ;
          }
        } else {

        }
      } else {

      }
      wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
      wp->w_old_visual_lnum = VIsual.lnum;
      wp->w_old_curswant = curwin->w_curswant;
    } else {


    }
  } else {
    wp->w_old_cursor_lnum = (linenr_t )0;
    wp->w_old_visual_lnum = (linenr_t )0;
  }
  {
  while (1) {
    while_continue___4: ;/* CIL Label */ ;
    if (row == endrow) {
      didline = 1;
      goto while_break___4;
    }
    if (lnum > (wp->w_buffer)->b_ml.ml_line_count) {
      done___0 = 1;
      goto while_break___4;
    }
    {
    srow = row;
    row = win_line(wp, lnum, srow, endrow);
    }
    if (row > endrow) {
      {





      }

    }
    *(wp->w_lsize + idx) = (char_u )(row - srow);
    tmp___8 = idx;
    idx ++;
    *(wp->w_lsize_lnum + tmp___8) = lnum;
    lnum ++;
    if (lnum > (wp->w_buffer)->b_ml.ml_line_count) {
      done___0 = 1;
      goto while_break___4;
    }
  }
  while_break___4: ;/* CIL Label */ ;
  }
  if (idx > wp->w_lsize_valid) {
    wp->w_lsize_valid = idx;
  }
  if (endrow != wp->w_height) {
    row = 0;
    idx = 0;
    {
    while (1) {
      while_continue___5: ;/* CIL Label */ ;
      if (idx < wp->w_lsize_valid) {
        if (! (row < wp->w_height)) {
          goto while_break___5;
        }
      } else {
        goto while_break___5;
      }
      row += (int )*(wp->w_lsize + idx);
      idx ++;
    }
    while_break___5: ;/* CIL Label */ ;
    }
    if (row < wp->w_height) {
      done___0 = 1;
    } else { //Added block
    if (row > wp->w_height) {



    } else {
      lnum = *(wp->w_lsize_lnum + (idx - 1)) + 1L;
      didline = 1;
    }
    }
  }
  wp->w_empty_rows = 0;
  if (! done___0) {
    if (! didline) {


















    } else {
      goto _L___7;
    }
  } else {
    _L___7: ;
    {
    screen_fill(wp->w_winpos + row, wp->w_winpos + wp->w_height, 0, (int )Columns,
                '~', ' ', highlight_attr[1]);
    wp->w_empty_rows = wp->w_height - row;
    }
    if (done___0) {
      wp->w_botline = (wp->w_buffer)->b_ml.ml_line_count + 1L;
    } else {
      wp->w_botline = lnum;
    }
  }
  wp->w_valid |= 32;
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (wp->w_botline != (linenr_t )old_botline) {
      if (! recursive___2) {
        {
        recursive___2 = 1;
        update_topline();
        }
        if (must_redraw) {
          {


          }
        }
        recursive___2 = 0;
      }
    }
  }
  if (wp->w_redr_type) {
    if (! recursive___2) {
      {
      recursive___2 = 1;
      win_update(wp);
      recursive___2 = 0;
      }
    }
  }
  return;
}
}
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) 
{ 
  char_u *screenp ;
  int c ;
  int col ;
  long vcol ;
  long v ;
  int rcol ;
  int row ;
  int screen_row ;
  char_u *ptr ;
  char_u *line ;
  char_u extra[16] ;
  int n_extra ;
  char_u *p_extra ;
  int c_extra ;
  char_u *showbreak ;
  int saved_attr1 ;
  int n_attr ;
  int n_skip ;
  int n_number ;
  int fromcol ;
  int tocol ;
  int noinvcur ;
  FPOS *top ;
  FPOS *bot ;
  int area_highlighting ;
  int attr ;
  int area_attr ;
  int search_attr ;
  int syntax_attr ;
  int has_syntax ;
  int extra_check ;
  int char_attr ;
  int saved_attr2 ;
  int extra_attr ;
  char_u *matchp ;
  char_u *search_hl_start ;
  char_u *search_hl_end ;
  char_u *trail ;
  int need_showbreak ;
  int save_got_int ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FPOS pos___0 ;
  size_t tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int x___0 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char_u *tmp___12 ;
  int tmp___13 ;

  {
  c = 0;
  n_extra = 0;
  p_extra = (char_u *)((void *)0);
  c_extra = '\000';
  showbreak = (char_u *)((void *)0);
  saved_attr1 = 0;
  n_attr = 0;
  n_skip = 0;
  n_number = 0;
  noinvcur = 0;
  area_attr = 0;
  search_attr = 0;
  syntax_attr = 0;
  has_syntax = 0;
  saved_attr2 = 0;
  extra_attr = 0;
  search_hl_start = (char_u *)((void *)0);
  search_hl_end = (char_u *)((void *)0);
  trail = (char_u *)((void *)0);
  need_showbreak = 0;
  if (startrow > endrow) {

  }
  row = startrow;
  screen_row = row + wp->w_winpos;
  attr = highlight_attr[14];
  if (clipboard.available) {








  }
  {
  extra_check = wp->w_p_lbr;
  save_got_int = got_int;
  got_int = 0;
  tmp___0 = syntax_present(wp->w_buffer);
  }
  if (tmp___0) {
    {



    }
  }
  col = 0;
  vcol = 0L;
  fromcol = -10;
  tocol = 2147483647;
  area_highlighting = 0;
  char_attr = 0;
  if (VIsual_active) {
    if ((unsigned long )wp->w_buffer == (unsigned long )curwin->w_buffer) {
      if (curwin->w_cursor.lnum != VIsual.lnum) {

      } else {
        tmp___1 = curwin->w_cursor.col <= VIsual.col;
      }
      if (tmp___1) {
        top = & curwin->w_cursor;
        bot = & VIsual;
      } else {
        top = & VIsual;
        bot = & curwin->w_cursor;
      }
      if (VIsual_mode == 22) {






      } else {
        if (lnum > top->lnum) {
          if (lnum <= bot->lnum) {

          } else {
            goto _L;
          }
        } else { //Added block
        _L: ;
        if (lnum == top->lnum) {
          if (VIsual_mode == 86) {

          } else {
            {
            getvcol(wp, top, (colnr_t *)(& fromcol), (colnr_t *)((void *)0), (colnr_t *)((void *)0));
            }
          }
        }
        }
        if (VIsual_mode != 86) {
          if (lnum == bot->lnum) {
            if ((int )*p_sel == 101) {






            } else {
              _L___0: ;
              pos___0 = *bot;
              if ((int )*p_sel == 101) {

              }
              {
              getvcol(wp, & pos___0, (colnr_t *)((void *)0), (colnr_t *)((void *)0),
                      (colnr_t *)(& tocol));
              tocol ++;
              }
            }
          }
        }
      }
      if (! highlight_match) {
        if (lnum == curwin->w_cursor.lnum) {
          if ((unsigned long )wp == (unsigned long )curwin) {
            noinvcur = 1;
          }
        }
      }
      if (fromcol >= 0) {
        area_highlighting = 1;
      }
    } else {

    }
  } else { //Added block
  _L___1: ;
  if (highlight_match) {



















  }
  }
  {
  ptr = ml_get_buf(wp->w_buffer, lnum, 0);
  matchp = ptr;
  line = ptr;
  rcol = 0;
  }
  if (wp->w_p_list) {
    if (lcs_trail) {
      {


      }
      {













      while_break: ;/* CIL Label */ ;
      }

    }
  }
  if (wp->w_p_wrap) {
    v = (long )wp->w_skipcol;
  } else {
    v = (long )wp->w_leftcol;
  }
  if (v > 0L) {
    {
















    while_break___0: ;/* CIL Label */ ;
    }


















  }
  if ((unsigned long )search_hl_prog != (unsigned long )((void *)0)) {

    {
















































    while_break___1: ;/* CIL Label */ ;
    }



  }
  screenp = current_LinePointer;
  if (wp->w_p_nu) {
    {
    sprintf((char * __restrict  )((char *)(extra)), (char const   * __restrict  )"%7ld ",
            lnum);
    n_number = 8;
    n_extra = 8;
    p_extra = extra;
    c_extra = '\000';
    vcol -= 8L;
    n_attr = 8;
    extra_attr = highlight_attr[9];
    saved_attr2 = 0;
    }
  }
  {
  while (1) {
    while_continue___2: ;/* CIL Label */ ;
    if (area_highlighting) {
      if (n_number <= 0) {
        if (vcol == (long )fromcol) {
          if (noinvcur) {
            if ((colnr_t )vcol == wp->w_virtcol) {
              goto _L___6;
            } else {
              goto _L___3;
            }
          } else {

          }
        } else { //Added block
        _L___6: ;
        if (noinvcur) {
          if ((colnr_t )vcol == wp->w_virtcol + 1U) {
            if (vcol >= (long )fromcol) {
              _L___3: ;
              if (vcol < (long )tocol) {
                area_attr = attr;
              } else {
                goto _L___5;
              }
            } else {

            }
          } else {
            goto _L___5;
          }
        } else { //Added block
        _L___5: ;
        if (area_attr) {
          if (vcol == (long )tocol) {

          } else { //Added block
          if (noinvcur) {
            if ((colnr_t )vcol == wp->w_virtcol) {
              area_attr = 0;
            }
          }
          }
        }
        }
        }
        if (! n_extra) {
          {
          while (1) {
            while_continue___3: ;/* CIL Label */ ;
            if ((unsigned long )search_hl_start != (unsigned long )((void *)0)) {









            } else { //Added block
            _L___8: ;
            if ((unsigned long )ptr == (unsigned long )search_hl_end) {
              {



              }























              if (x___0) {






                if ((int )*search_hl_start == 0) {




                }
              }
            }
            }
            goto while_break___3;
            __Cont___0: ;;
          }
          while_break___3: ;/* CIL Label */ ;
          }
        }
        if (area_attr) {
          char_attr = area_attr;
        } else { //Added block
        if (! search_attr) {
          if (has_syntax) {

          } else {
            char_attr = search_attr;
          }
        } else {

        }
        }
      }
    }
    if ((int )*p_sbr != 0) {













































    }
    if ((unsigned long )showbreak == (unsigned long )((void *)0)) {
      if (n_extra) {
        if (c_extra) {
          c = c_extra;
        } else {
          tmp___7 = p_extra;
          p_extra ++;
          c = (int )*tmp___7;
        }
        n_extra --;
      } else {
        tmp___8 = ptr;
        ptr ++;
        c = (int )*tmp___8;
        if (extra_check) {
          if (has_syntax) {
            {



            }





          }
          if (wp->w_p_lbr) {
            if (breakat_flags[(char_u )c]) {
              if (! breakat_flags[*ptr]) {
                if (! wp->w_p_list) {
                  {
                  tmp___10 = win_lbr_chartabsize(wp, ptr - 1, (colnr_t )vcol, (int *)((void *)0));
                  n_extra = tmp___10 - 1;
                  c_extra = ' ';
                  }
                  if (c == 32) {
                    c = ' ';
                  } else { //Added block
                  if (c == 9) {
                    c = ' ';
                  }
                  }
                }
              }
            }
          }
          if ((unsigned long )trail != (unsigned long )((void *)0)) {












          }
        }
        {
        tmp___13 = safe_vim_isprintc(c);
        }
        if (! tmp___13) {
          if (c == 9) {
            if (! wp->w_p_list) {
              goto _L___15;
            } else { //Added block
            if (lcs_tab1) {
              _L___15: ;
              n_extra = (int )(((long )((int )(wp->w_buffer)->b_p_ts) - vcol % (long )((int )(wp->w_buffer)->b_p_ts)) - 1L);
              if (wp->w_p_list) {









              } else {
                c_extra = ' ';
                c = ' ';
              }
            } else {
              goto _L___14;
            }
            }
          } else { //Added block
          _L___14: ;
          if (c == 0) {
            if (wp->w_p_list) {
              if (lcs_eol != 0) {
                p_extra = (char_u *)"";
                n_extra = 1;
                c_extra = '\000';
                c = lcs_eol;
                ptr --;
                char_attr = highlight_attr[1];
              } else {

              }
            } else {
              goto _L___13;
            }
          } else { //Added block
          _L___13: ;
          if (c != 0) {
            {
            p_extra = transchar(c);
            tmp___11 = charsize(c);
            n_extra = tmp___11 - 1;
            c_extra = '\000';
            tmp___12 = p_extra;
            p_extra ++;
            c = (int )*tmp___12;
            }
          }
          }
          }
        }
      }
      if (n_attr) {
        char_attr = extra_attr;
      }
    }
    if (c == 0) {
      if (area_attr) {





      } else { //Added block
      _L___17: ;
      if (search_attr) {












      }
      }
      {
      screen_line(screen_row, col, 1);
      row ++;
      }
      if ((unsigned long )wp == (unsigned long )curwin) {
        if (lnum == curwin->w_cursor.lnum) {
          curwin->w_cline_row = startrow;
          curwin->w_cline_height = row - startrow;
          curwin->w_valid |= 24;
        }
      }
      goto while_break___2;
    }
    if ((long )col >= Columns) {
      {
      screen_line(screen_row, col, 1);
      col = 0;
      row ++;
      screen_row ++;
      }
      if (! wp->w_p_wrap) {
        goto while_break___2;
      }
      if (row == endrow) {


      }
      if (p_tf) {
        if (screen_cur_row == screen_row - 1) {
          if ((long )screen_cur_col != Columns) {
            {
            screen_char((*(LinePointers + (screen_row - 1)) + Columns) - 1, screen_row - 1,
                        (int )(Columns - 1L));
            }
          }
          {
          screen_char(*(LinePointers + screen_row), screen_row - 1, (int )Columns);
          screen_start();
          }
        }
      }
      screenp = current_LinePointer;
    }
    if (lcs_ext) {






























    }
    if (n_number > 0) {
      *screenp = (char_u )c;
      *(screenp + Columns) = (char_u )char_attr;
      screenp ++;
      col ++;
      n_number --;
    } else { //Added block
    if (n_skip <= 0) {
      *screenp = (char_u )c;
      *(screenp + Columns) = (char_u )char_attr;
      screenp ++;
      col ++;
      n_number --;
    } else {

    }
    }
    vcol ++;
    if (n_attr) {
      n_attr --;
      if (n_attr == 0) {
        char_attr = saved_attr2;
      }
    }
    if (dollar_vcol) {








    }
  }
  while_break___2: ;/* CIL Label */ ;
  }
  if (! got_int) {
    got_int = save_got_int;
  }
  return (row);
}
}
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) 
{ 


  {
  if (len___0 > 0) {
    if ((int )*screenp_from != (int )*screenp_to) {
      return (1);
    } else { //Added block
    if ((int )*(screenp_from + Columns) != (int )*(screenp_to + Columns)) {
      return (1);
    }
    }
  }
  return (0);
}
}
static void screen_line(int row , int endcol , int clear_rest ) 
{ 
  char_u *screenp_from ;
  char_u *screenp_to ;
  int col ;
  int hl ;
  int force ;
  int redraw_this ;
  int redraw_next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  col = 0;
  force = 0;
  screenp_from = current_LinePointer;
  screenp_to = *(LinePointers + row);
  redraw_next = char_needs_redraw(screenp_from, screenp_to, endcol - col);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (col < endcol)) {
      goto while_break;
    }
    redraw_this = redraw_next;
    if (force) {

    } else {
      {
      tmp = char_needs_redraw(screenp_from + 1, screenp_to + 1, (endcol - col) - 1);
      }
      if (tmp) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    }
    redraw_next = tmp___0;
    if (redraw_this) {
      if (p_wiv) {


























      }
      {
      *screenp_to = *screenp_from;
      tmp___1 = vim_is_xterm(term_strings[0]);
      }
      if (tmp___1) {
        hl = (int )*(screenp_to + Columns);
        if (hl > 31) {
          redraw_next = 1;
        } else { //Added block
        if (hl & 2) {
          redraw_next = 1;
        }
        }
      }
      {
      *(screenp_to + Columns) = *(screenp_from + Columns);
      screen_char(screenp_to, row, col);
      }
    } else { //Added block
    if (p_wiv) {











    }
    }
    screenp_to ++;
    screenp_from ++;
    col ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (clear_rest) {
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if ((long )col < Columns) {
        if ((int )*screenp_to == 32) {
          if (! ((int )*(screenp_to + Columns) == 0)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      screenp_to ++;
      col ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((long )col < Columns) {
      {
      screen_fill(row, row + 1, col, (int )Columns, ' ', ' ', 0);
      }
    }
  }
  return;
}
}
void status_redraw_all(void) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_status_height) {
      {
      wp->w_redr_status = 1;
      redraw_later(40);
      }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
void redraw_statuslines(void) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    if (wp->w_redr_status) {
      {

      }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static char_u *m_gettail(char_u *s ) ;
static int status_match_len(char_u *s ) ;
static char_u *m_gettail(char_u *s ) 
{
































































}
static int status_match_len(char_u *s ) 
{






































}
static int first_match___0  =    0;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) 
{
















































































































































































































































































































}
void win_redr_status(WIN *wp ) 
{ 
  int row ;
  char_u *p___0 ;
  int len___0 ;
  int fillchar ;
  int attr ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  wp->w_redr_status = 0;
  if (wp->w_status_height == 0) {
    redraw_cmdline = 1;
  } else {
    {
    tmp___3 = redrawing();
    }
    if (tmp___3) {
      if (*p_stl) {
        {

        }
      } else {
        {
        fillchar = highlight_status(& attr, (unsigned long )wp == (unsigned long )curwin);
        p___0 = (wp->w_buffer)->b_fname;
        }
        if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
          {

          }
        } else {
          {
          home_replace(wp->w_buffer, p___0, NameBuff, 1024, 1);
          trans_characters(NameBuff, 1024);
          }
        }
        {
        p___0 = NameBuff;
        tmp = strlen((char const   *)((char *)p___0));
        len___0 = (int )tmp;
        }
        if ((wp->w_buffer)->b_help) {



        } else { //Added block
        if (wp->w_preview) {



        } else {
          {
          tmp___1 = buf_changed(wp->w_buffer);
          }
          if (tmp___1) {



          } else { //Added block
          if ((wp->w_buffer)->b_p_ro) {



          }
          }
        }
        }
        if ((wp->w_buffer)->b_help) {
          {


          }
        }
        if (wp->w_preview) {
          {


          }
        }
        {
        tmp___2 = buf_changed(wp->w_buffer);
        }
        if (tmp___2) {
          {


          }
        }
        if ((wp->w_buffer)->b_p_ro) {
          {


          }
        }
        if (len___0 > ru_col - 1) {



        }
        {
        row = wp->w_winpos + wp->w_height;
        screen_puts(p___0, row, 0, attr);
        screen_fill(row, row + 1, len___0, ru_col, fillchar, fillchar, attr);
        win_redr_ruler(wp, 1);
        }
      }
    } else {

    }
  }
  return;
}
}
static void win_redr_custom(WIN *wp , int Ruler ) 
{


























































































































}
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) 
{








}
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) 
{









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
void screen_putchar(int c , int row , int col , int attr ) 
{ 
  char_u buf___3[2] ;

  {
  {
  buf___3[0] = (char_u )c;
  buf___3[1] = (char_u )'\000';
  screen_puts(buf___3, row, col, attr);
  }
  return;
}
}
void screen_puts(char_u *text , int row , int col , int attr ) 
{ 
  char_u *screenp ;

  {
  if ((unsigned long )NextScreen != (unsigned long )((void *)0)) {
    if ((long )row < Rows) {
      screenp = *(LinePointers + row) + col;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (*text) {
          if (! ((long )col < Columns)) {

          }
        } else {
          goto while_break;
        }
        if ((int )*screenp != (int )*text) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        } else { //Added block
        if ((int )*(screenp + Columns) != attr) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        } else { //Added block
        if (exmode_active) {
          {
          *screenp = *text;
          *(screenp + Columns) = (char_u )attr;
          screen_char(screenp, row, col);
          }
        }
        }
        }
        screenp ++;
        col ++;
        text ++;
      }
      while_break: ;/* CIL Label */ ;
      }
    }
  }
  return;
}
}
static void start_search_hl(void) 
{ 


  {
  if (p_hls) {
    if (! no_hlsearch) {
      {
      search_hl_prog = last_pat_prog();
      search_hl_attr = highlight_attr[6];
      search_hl_ic = reg_ic;
      }
    }
  }
  return;
}
}
static void end_search_hl(void) 
{ 


  {
  if ((unsigned long )search_hl_prog != (unsigned long )((void *)0)) {
    {


    }
  }
  return;
}
}
void screen_start(void) 
{ 


  {
  screen_cur_col = 9999;
  screen_cur_row = screen_cur_col;
  return;
}
}
void screen_down(void) 
{ 


  {
  screen_cur_col = 0;
  if ((long )screen_cur_row < Rows - 1L) {

  }
  return;
}
}
static void screen_start_highlight(int attr ) 
{ 
  struct attr_entry *aep ;

  {
  aep = (struct attr_entry *)((void *)0);
  screen_attr = attr;
  if (full_screen) {
    if (attr > 31) {
      if ((int )*(term_strings[34]) != 0) {
        {
        aep = syn_cterm_attr2entry(attr);
        }
      } else {
        {

        }
      }
      if ((unsigned long )aep == (unsigned long )((void *)0)) {

      } else {
        attr = (int )aep->ae_attr;
      }
    }
    if (attr & 2) {
      if ((unsigned long )term_strings[16] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[16]);
        }
      }
    }
    if (attr & 16) {





    }
    if (attr & 8) {





    }
    if (attr & 4) {





    }
    if (attr & 1) {
      if ((unsigned long )term_strings[15] != (unsigned long )((void *)0)) {
        {
        out_str(term_strings[15]);
        }
      }
    }
    if ((unsigned long )aep != (unsigned long )((void *)0)) {
      if ((int )*(term_strings[34]) != 0) {
        if (aep->ae_u.cterm.fg_color) {
          {
          term_fg_color((int )aep->ae_u.cterm.fg_color - 1);
          }
        }
        if (aep->ae_u.cterm.bg_color) {
          {
          term_bg_color((int )aep->ae_u.cterm.bg_color - 1);
          }
        }
      } else { //Added block





      }
    }
  }
  return;
}
}
void screen_stop_highlight(void) 
{ 
  int do_ME ;
  struct attr_entry *aep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  do_ME = 0;
  if (screen_attr) {
    if (screen_attr > 31) {
      if ((int )*(term_strings[34]) != 0) {
        {
        aep = syn_cterm_attr2entry(screen_attr);
        }
        if ((unsigned long )aep != (unsigned long )((void *)0)) {
          if (aep->ae_u.cterm.fg_color) {
            do_ME = 1;
          } else { //Added block



          }
        }
      } else {
        {

        }














      }
      if ((unsigned long )aep == (unsigned long )((void *)0)) {

      } else {
        screen_attr = (int )aep->ae_attr;
      }
    }
    if (screen_attr & 16) {
      {

      }







    }
    if (screen_attr & 8) {
      {

      }







    }
    if (screen_attr & 4) {
      {

      }







    }
    if (do_ME) {
      {
      out_str(term_strings[14]);
      }
    } else { //Added block
    if (screen_attr & 2) {
      {
      out_str(term_strings[14]);
      }
    } else { //Added block
    if (screen_attr & 1) {
      {
      out_str(term_strings[14]);
      }
    }
    }
    }
    if ((int )*(term_strings[34]) != 0) {
      if (cterm_normal_fg_color) {
        {

        }
      }
      if (cterm_normal_bg_color) {
        {

        }
      }
      if (cterm_normal_fg_bold) {
        {

        }
      }
    }
  }
  screen_attr = 0;
  return;
}
}
void reset_cterm_colors(void) 
{ 


  {
  if ((int )*(term_strings[34]) != 0) {
    if (cterm_normal_fg_color) {
      {

      }
    } else { //Added block
    if (cterm_normal_bg_color) {
      {

      }
    }
    }
    if (cterm_normal_fg_bold) {
      {

      }
    }
  }
  return;
}
}
static void screen_char(char_u *p___0 , int row , int col ) 
{ 


  {
  if ((long )col == Columns - 1L) {
    if ((long )row == Rows - 1L) {

    }
  }
  if (screen_attr != (int )*(p___0 + Columns)) {
    {
    screen_stop_highlight();
    }
  }
  {
  windgoto(row, col);
  }
  if (screen_attr != (int )*(p___0 + Columns)) {
    {
    screen_start_highlight((int )*(p___0 + Columns));
    }
  }
  {
  out_char((unsigned int )*p___0);
  screen_cur_col ++;
  }
  return;
}
}
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) 
{ 
  int row ;
  int col ;
  char_u *screenp ;
  char_u *attrp ;
  int did_delete ;
  int c ;
  int norm_term ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  if ((long )end_row > Rows) {

  }
  if ((long )end_col > Columns) {

  }
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {

  } else { //Added block
  if (start_row >= end_row) {
    return;
  } else { //Added block
  if (start_col >= end_col) {

  }
  }
  }
  norm_term = (int )*(term_strings[34]) == 0;
  row = start_row;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (row < end_row)) {
      goto while_break;
    }
    did_delete = 0;
    if (c2 == 32) {
      if ((long )end_col == Columns) {
        if ((int )*(term_strings[1]) != 0) {
          if (attr == 0) {
            goto _L;
          } else { //Added block
          if (norm_term) {
            if (attr <= 31) {
              if ((attr & -7) == 0) {
                _L: ;
                col = start_col;
                screenp = *(LinePointers + row) + start_col;
                if (c1 != 32) {


                }
                attrp = screenp + Columns;
                {
                while (1) {
                  while_continue___0: ;/* CIL Label */ ;
                  if (col < end_col) {
                    if ((int )*screenp == 32) {
                      if (! ((int )*attrp == 0)) {
                        goto while_break___0;
                      }
                    } else {
                      goto while_break___0;
                    }
                  } else {
                    goto while_break___0;
                  }
                  col ++;
                  screenp ++;
                  attrp ++;
                }
                while_break___0: ;/* CIL Label */ ;
                }
                if (col < end_col) {
                  {
                  screen_stop_highlight();
                  term_windgoto(row, col);
                  out_str(term_strings[1]);
                  screen_start();
                  col = end_col - col;
                  }
                  {
                  while (1) {
                    while_continue___1: ;/* CIL Label */ ;
                    tmp___1 = col;
                    col --;
                    if (! tmp___1) {
                      goto while_break___1;
                    }
                    tmp = attrp;
                    attrp ++;
                    *tmp = (char_u )0;
                    tmp___0 = screenp;
                    screenp ++;
                    *tmp___0 = (char_u )' ';
                  }
                  while_break___1: ;/* CIL Label */ ;
                  }
                }
                did_delete = 1;
              }
            }
          }
          }
        }
      }
    }
    screenp = *(LinePointers + row) + start_col;
    c = c1;
    col = start_col;
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      if (! (col < end_col)) {
        goto while_break___2;
      }
      if ((int )*screenp != c) {
        goto _L___0;
      } else { //Added block
      if ((int )*(screenp + Columns) != attr) {
        _L___0: ;
        *screenp = (char_u )c;
        *(screenp + Columns) = (char_u )attr;
        if (! did_delete) {
          {
          screen_char(screenp, row, col);
          }
        } else { //Added block





        }
      }
      }
      screenp ++;
      if (col == start_col) {
        if (did_delete) {
          goto while_break___2;
        }
        c = c2;
      }
      col ++;
    }
    while_break___2: ;/* CIL Label */ ;
    }
    if ((long )row == Rows - 1L) {
      redraw_cmdline = 1;
      if (c1 == 32) {
        if (c2 == 32) {
          clear_cmdline = 0;
        }
      }
    }
    row ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static void comp_botline(void) 
{ 
  int n ;
  linenr_t lnum ;
  int done___0 ;

  {
  {
  check_cursor_moved(curwin);
  }
  if (curwin->w_valid & 16) {
    lnum = curwin->w_cursor.lnum;
    done___0 = curwin->w_cline_row;
  } else {
    lnum = curwin->w_topline;
    done___0 = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (lnum <= (curwin->w_buffer)->b_ml.ml_line_count)) {
      goto while_break;
    }
    {
    n = plines(lnum);
    }
    if (lnum == curwin->w_cursor.lnum) {
      curwin->w_cline_row = done___0;
      curwin->w_cline_height = n;
      curwin->w_valid |= 24;
    }
    if (done___0 + n > curwin->w_height) {
      goto while_break;
    }
    done___0 += n;
    lnum ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  curwin->w_botline = lnum;
  curwin->w_valid |= 96;
  if (done___0 == 0) {

  } else {
    curwin->w_empty_rows = curwin->w_height - done___0;
  }
  return;
}
}
static int entered___2  =    0;
void screenalloc(int clear ) 
{ 
  int new_row ;
  int old_row ;
  WIN *wp ;
  int outofmem ;
  int len___0 ;
  char_u *new_NextScreen ;
  char_u **new_LinePointers ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  outofmem = 0;
  if ((unsigned long )NextScreen != (unsigned long )((void *)0)) {
    if (Rows == (long )screen_Rows) {
      if (Columns == (long )screen_Columns) {
        return;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else { //Added block
  _L___0: ;
  if (Rows == 0L) {

  } else { //Added block
  if (Columns == 0L) {

  } else { //Added block
  if (! full_screen) {



  }
  }
  }
  }
  if (entered___2) {

  }
  {
  entered___2 = 1;
  comp_col();
  wp = firstwin;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    {
    win_free_lsize(wp);
    wp = wp->w_next;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  tmp = lalloc((long_u )(((Rows + 1L) * Columns) * 2L), 0);
  new_NextScreen = tmp;
  tmp___0 = lalloc(sizeof(char_u *) * (unsigned long )Rows, 0);
  new_LinePointers = (char_u **)tmp___0;
  wp = firstwin;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break___0;
    }
    {
    tmp___1 = win_alloc_lsize(wp);
    }
    if (tmp___1 == 0) {


    }
    wp = wp->w_next;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if ((unsigned long )new_NextScreen == (unsigned long )((void *)0)) {
    {





    }
  } else { //Added block
  if ((unsigned long )new_LinePointers == (unsigned long )((void *)0)) {
    {





    }
  } else { //Added block
  if (outofmem) {
    {





    }
  } else {
    new_row = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! ((long )new_row < Rows)) {
        goto while_break___1;
      }
      *(new_LinePointers + new_row) = new_NextScreen + ((long )new_row * Columns) * 2L;
      if (! clear) {
        {
        lineclear(*(new_LinePointers + new_row));
        old_row = (int )((long )new_row + ((long )screen_Rows - Rows));
        }
        if (old_row >= 0) {





          {




          }
        }
      }
      new_row ++;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    current_LinePointer = new_NextScreen + (Rows * Columns) * 2L;
  }
  }
  }
  {
  vim_free((void *)NextScreen);
  vim_free((void *)LinePointers);
  NextScreen = new_NextScreen;
  LinePointers = new_LinePointers;
  must_redraw = 50;
  }
  if (clear) {
    {
    screenclear2();
    }
  }
  screen_Rows = (int )Rows;
  screen_Columns = (int )Columns;
  entered___2 = 0;
  return;
}
}
void screenclear(void) 
{ 


  {
  {
  check_for_delay(0);
  screenalloc(0);
  screenclear2();
  }
  return;
}
}
static void screenclear2(void) 
{ 
  int i___0 ;

  {
  if (starting == 2) {
    return;
  } else { //Added block
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {

  }
  }
  {
  screen_stop_highlight();
  out_str(term_strings[7]);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((long )i___0 < Rows)) {
      goto while_break;
    }
    {
    lineclear(*(LinePointers + i___0));
    i___0 ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  screen_cleared = 1;
  win_rest_invalid(firstwin);
  clear_cmdline = 0;
  redraw_cmdline = 1;
  }
  if (must_redraw == 50) {
    must_redraw = 40;
  }
  {
  compute_cmdrow();
  msg_row = cmdline_row;
  msg_col = 0;
  screen_start();
  msg_scrolled = 0;
  msg_didany = 0;
  msg_didout = 0;
  }
  return;
}
}
static void lineclear(char_u *p___0 ) 
{ 


  {
  {
  memset((void *)p___0, ' ', (size_t )Columns);
  memset((void *)(p___0 + Columns), 0, (size_t )Columns);
  }
  return;
}
}
void update_topline_redraw(void) 
{













}
void update_topline(void) 
{ 
  long line_count ;
  int temp ;
  linenr_t old_topline___0 ;
  int check_botline ;
  int save_so ;
  int tmp ;
  char_u *tmp___0 ;

  {
  {
  check_botline = 0;
  save_so = (int )p_so;
  tmp = screen_valid(1);
  }
  if (! tmp) {

  }
  if (mouse_dragging) {

  }
  old_topline___0 = curwin->w_topline;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {
    tmp___0 = ml_get((linenr_t )1);
    }
    if ((int )*tmp___0 == 0) {
      if (curwin->w_topline != 1L) {
        {

        }
      }
      curwin->w_topline = (linenr_t )1;
      curwin->w_botline = (linenr_t )2;
      curwin->w_valid |= 96;
      curwin->w_scbind_pos = 1L;
    } else {

    }
  } else { //Added block
  _L: ;
  if (curwin->w_cursor.lnum < curwin->w_topline + p_so) {
    if (curwin->w_topline > 1L) {
      temp = curwin->w_height / 2 - 1;
      if (temp < 2) {

      }
      if ((curwin->w_topline + p_so) - curwin->w_cursor.lnum >= (linenr_t )temp) {
        {
        scroll_cursor_halfway(0);
        }
      } else {
        {


        }
      }
    } else {
      check_botline = 1;
    }
  } else {
    check_botline = 1;
  }
  }
  if (check_botline) {
    if (! (curwin->w_valid & 64)) {
      {
      validate_botline();
      }
    }
    if (curwin->w_cursor.lnum >= curwin->w_botline - p_so) {
      if (curwin->w_botline <= curbuf->b_ml.ml_line_count) {
        line_count = ((curwin->w_cursor.lnum - curwin->w_botline) + 1L) + p_so;
        if (line_count <= (long )(curwin->w_height + 1)) {
          {
          scroll_cursor_bot((int )p_sj, 0);
          }
        } else {
          {
          scroll_cursor_halfway(0);
          }
        }
      }
    }
  }
  if (curwin->w_topline != old_topline___0) {
    if (curwin->w_skipcol) {
      {


      }
    } else {
      {
      redraw_later(10);
      }
    }
  }
  p_so = (long )save_so;
  return;
}
}
void update_curswant(void) 
{ 


  {
  if (curwin->w_set_curswant) {
    {
    validate_virtcol();
    curwin->w_curswant = curwin->w_virtcol;
    curwin->w_set_curswant = 0;
    }
  }
  return;
}
}
void windgoto(int row , int col ) 
{ 
  char_u *p___0 ;
  int i___0 ;
  int plan ;
  int cost ;
  int wouldbe_col ;
  int noinvcurs ;
  char_u *bs ;
  int goto_cost ;
  int attr ;
  size_t tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )NextScreen == (unsigned long )((void *)0)) {

  }
  if (row < 0) {

  }
  if (col != screen_cur_col) {
    goto _L___1;
  } else { //Added block
  if (row != screen_cur_row) {
    _L___1: ;
    if (screen_attr) {
      if ((int )*(term_strings[23]) == 0) {

      } else {
        noinvcurs = 0;
      }
    } else {
      noinvcurs = 0;
    }
    goto_cost = 7 + noinvcurs;
    if (row >= screen_cur_row) {
      if ((long )screen_cur_col < Columns) {
        bs = (char_u *)((void *)0);
        attr = screen_attr;
        if (row == screen_cur_row) {
          if (col < screen_cur_col) {
            if (*(term_strings[41])) {
              bs = term_strings[41];
            } else {

            }
            if (*bs) {
              {
              tmp = strlen((char const   *)((char *)bs));
              cost = (int )((size_t )(screen_cur_col - col) * tmp);
              }
            } else {

            }
            if (col + 1 < cost) {
              plan = 2;
              wouldbe_col = 0;
              cost = 1;
            } else {
              plan = 1;
              wouldbe_col = col;
            }
            if (noinvcurs) {


            }
          } else {
            goto _L;
          }
        } else { //Added block
        _L: ;
        if (row > screen_cur_row) {
          plan = 3;
          wouldbe_col = 0;
          cost = (row - screen_cur_row) * 2;
          if (noinvcurs) {


          }
        } else {
          plan = 4;
          wouldbe_col = screen_cur_col;
          cost = 0;
        }
        }
        i___0 = col - wouldbe_col;
        if (i___0 > 0) {
          cost += i___0;
        }
        if (cost < goto_cost) {
          if (i___0 > 0) {
            p___0 = (*(LinePointers + row) + wouldbe_col) + Columns;
            {
            while (1) {
              while_continue: ;/* CIL Label */ ;
              if (i___0) {
                tmp___0 = p___0;
                p___0 ++;
                if (! ((int )*tmp___0 == attr)) {
                  goto while_break;
                }
              } else {
                goto while_break;
              }
              i___0 --;
            }
            while_break: ;/* CIL Label */ ;
            }
            if (i___0) {
              p___0 --;
              if ((int )*p___0 == 0) {
                cost += noinvcurs;
                {
                while (1) {
                  while_continue___0: ;/* CIL Label */ ;
                  if (i___0) {
                    tmp___1 = p___0;
                    p___0 ++;
                    if (! ((int )*tmp___1 == 0)) {

                    }
                  } else {
                    goto while_break___0;
                  }
                  i___0 --;
                }
                while_break___0: ;/* CIL Label */ ;
                }
              }
              if (i___0) {

              }
            }
          }
        }
        if (cost < goto_cost) {
          if (plan == 1) {
            if (noinvcurs) {
              {

              }
            }
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              if (! (screen_cur_col > col)) {
                goto while_break___1;
              }
              {
              out_str(bs);
              screen_cur_col --;
              }
            }
            while_break___1: ;/* CIL Label */ ;
            }
          } else { //Added block
          if (plan == 2) {
            if (noinvcurs) {
              {

              }
            }
            {
            out_char((unsigned int )'\r');
            screen_cur_col = 0;
            }
          } else { //Added block
          if (plan == 3) {
            if (noinvcurs) {
              {

              }
            }
            {
            while (1) {
              while_continue___2: ;/* CIL Label */ ;
              if (! (screen_cur_row < row)) {
                goto while_break___2;
              }
              {
              out_char((unsigned int )'\n');
              screen_cur_row ++;
              }
            }
            while_break___2: ;/* CIL Label */ ;
            }
            screen_cur_col = 0;
          }
          }
          }
          i___0 = col - screen_cur_col;
          if (i___0 > 0) {
            if ((int )*(term_strings[42] + 0) != 0) {
              if ((int )*(term_strings[42] + 1) == 0) {
                {











                while_break___3: ;/* CIL Label */ ;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: ;
              p___0 = *(LinePointers + row) + screen_cur_col;
              {
              while (1) {
                while_continue___4: ;/* CIL Label */ ;
                tmp___4 = i___0;
                i___0 --;
                if (! tmp___4) {
                  goto while_break___4;
                }
                if ((int )*(p___0 + Columns) != screen_attr) {
                  {
                  screen_stop_highlight();
                  }
                }
                {
                tmp___3 = p___0;
                p___0 ++;
                out_char((unsigned int )*tmp___3);
                }
              }
              while_break___4: ;/* CIL Label */ ;
              }
            }
          }
        }
      } else {
        cost = 999;
      }
    } else {
      cost = 999;
    }
    if (cost >= goto_cost) {
      if (noinvcurs) {
        {

        }
      }
      if (row == screen_cur_row) {
        if (col > screen_cur_col) {
          if ((int )*(term_strings[26]) != 0) {
            {
            term_cursor_right(col - screen_cur_col);
            }
          } else {
            {

            }
          }
        } else {
          {
          term_windgoto(row, col);
          }
        }
      } else {
        {
        term_windgoto(row, col);
        }
      }
    }
    screen_cur_row = row;
    screen_cur_col = col;
  }
  }
  return;
}
}
void setcursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    {
    validate_cursor();
    windgoto(curwin->w_winpos + curwin->w_wrow, curwin->w_wcol);
    }
  }
  return;
}
}
void scroll_cursor_top(int min_scroll , int always ) 
{

























































































}
void scroll_cursor_bot(int min_scroll , int set_topbot ) 
{ 
  int used ;
  int scrolled ;
  int extra ;
  int sline ;
  int i___0 ;
  linenr_t lnum ;
  linenr_t line_count ;
  linenr_t old_topline___0 ;
  linenr_t old_botline ;
  linenr_t old_valid ;
  int old_empty_rows ;
  linenr_t cln ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  scrolled = 0;
  extra = 0;
  old_topline___0 = curwin->w_topline;
  old_botline = curwin->w_botline;
  old_valid = (linenr_t )curwin->w_valid;
  old_empty_rows = curwin->w_empty_rows;
  cln = curwin->w_cursor.lnum;
  if (set_topbot) {



    {














    while_break: ;/* CIL Label */ ;
    }





  } else {
    {
    validate_botline();
    }
  }
  {
  validate_cheight();
  used = curwin->w_cline_height;
  }
  if (cln >= curwin->w_botline) {
    scrolled = used;
    if (cln == curwin->w_botline) {
      scrolled -= curwin->w_empty_rows;
    }
  }
  sline = 1;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((linenr_t )sline < cln)) {

    }
    if (scrolled <= 0) {

    } else { //Added block
    if (scrolled >= min_scroll) {
      _L___1: ;
      if (mouse_dragging) {

      } else {
        tmp = p_so;
      }
      if ((long )extra >= tmp) {
        goto _L;
      } else {

      }
    } else { //Added block
    _L___0: ;
    if (cln + (linenr_t )sline > curbuf->b_ml.ml_line_count) {
      _L: ;
      if (cln - (linenr_t )sline < curwin->w_botline) {
        goto while_break___0;
      }
    }
    }
    }
    {
    i___0 = plines(cln - (linenr_t )sline);
    used += i___0;
    }
    if (used > curwin->w_height) {
      goto while_break___0;
    }
    if (cln - (linenr_t )sline >= curwin->w_botline) {
      scrolled += i___0;
      if (cln - (linenr_t )sline == curwin->w_botline) {
        scrolled -= curwin->w_empty_rows;
      }
    }
    if (cln + (linenr_t )sline <= curbuf->b_ml.ml_line_count) {
      {
      i___0 = plines(cln + (linenr_t )sline);
      used += i___0;
      }
      if (used > curwin->w_height) {

      }
      if (mouse_dragging) {

      } else {
        tmp___0 = p_so;
      }
      if ((long )extra < tmp___0) {

      } else { //Added block
      if (scrolled < min_scroll) {
        _L___2: ;







      }
      }
    }
    sline ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (scrolled <= 0) {

  } else { //Added block
  if (used > curwin->w_height) {
    line_count = (linenr_t )used;
  } else {
    i___0 = 0;
    lnum = curwin->w_topline;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (i___0 < scrolled) {
        if (! (lnum < curwin->w_botline)) {

        }
      } else {
        goto while_break___1;
      }
      {
      tmp___1 = plines(lnum);
      i___0 += tmp___1;
      lnum ++;
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
    if (i___0 >= scrolled) {
      line_count = lnum - curwin->w_topline;
    } else {

    }
  }
  }
  if (line_count >= (linenr_t )curwin->w_height) {
    if (line_count > (linenr_t )min_scroll) {
      {
      scroll_cursor_halfway(0);
      }
    } else {
      {

      }
    }
  } else {
    {
    scrollup(line_count);
    }
  }
  if (curwin->w_topline == old_topline___0) {





  }
  return;
}
}
void scroll_cursor_halfway(int atend ) 
{ 
  int above ;
  linenr_t topline ;
  int below ;
  linenr_t botline ;
  int used ;
  int i___0 ;
  linenr_t cln ;

  {
  {
  above = 0;
  below = 0;
  cln = curwin->w_cursor.lnum;
  botline = cln;
  topline = botline;
  used = plines(cln);
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (topline > 1L)) {
      goto while_break;
    }
    if (below <= above) {
      if (botline + 1L <= curbuf->b_ml.ml_line_count) {
        {
        i___0 = plines(botline + 1L);
        used += i___0;
        }
        if (used > curwin->w_height) {
          goto while_break;
        }
        below += i___0;
        botline ++;
      } else {
        below ++;
        if (atend) {

        }
      }
    }
    if (below > above) {
      {
      i___0 = plines(topline - 1L);
      used += i___0;
      }
      if (used > curwin->w_height) {
        goto while_break;
      }
      above += i___0;
      topline --;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  curwin->w_topline = topline;
  curwin->w_valid &= -114;
  return;
}
}
void cursor_correct(void) 
{ 
  int above ;
  linenr_t topline ;
  int below ;
  linenr_t botline ;
  int above_wanted ;
  int below_wanted ;
  linenr_t cln ;
  int max_off ;
  int tmp ;
  int tmp___0 ;

  {
  above = 0;
  below = 0;
  above_wanted = (int )p_so;
  below_wanted = (int )p_so;
  if (mouse_dragging) {


  }
  if (curwin->w_topline == 1L) {
    above_wanted = 0;
    max_off = curwin->w_height / 2;
    if (below_wanted > max_off) {

    }
  }
  {
  validate_botline();
  }
  if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1L) {
    below_wanted = 0;
    max_off = (curwin->w_height - 1) / 2;
    if (above_wanted > max_off) {

    }
  }
  cln = curwin->w_cursor.lnum;
  if (cln >= curwin->w_topline + (linenr_t )above_wanted) {
    if (cln < curwin->w_botline - (linenr_t )below_wanted) {
      return;
    }
  }
  topline = curwin->w_topline;
  botline = curwin->w_botline - 1L;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (above < above_wanted) {

    } else { //Added block
    if (below < below_wanted) {
      _L: ;



    } else {
      goto while_break;
    }
    }


































  }
  while_break: ;/* CIL Label */ ;
  }
  if (topline == botline) {
    curwin->w_cursor.lnum = topline;
  } else { //Added block
  if (botline == 0L) {

  } else { //Added block
  if (topline > botline) {

  } else {
    if (cln < topline) {
      if (curwin->w_topline > 1L) {
        curwin->w_cursor.lnum = topline;
        curwin->w_valid &= -28;
      }
    }
    if (cln > botline) {
      if (curwin->w_botline <= curbuf->b_ml.ml_line_count) {
        curwin->w_cursor.lnum = botline;
        curwin->w_valid &= -28;
      }
    }
  }
  }
  }
  return;
}
}
static void check_cursor_moved(WIN *wp ) 
{ 


  {
  if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum) {
    wp->w_valid &= -32;
    wp->w_valid_cursor = wp->w_cursor;
    wp->w_valid_leftcol = wp->w_leftcol;
  } else { //Added block
  if (wp->w_cursor.col != wp->w_valid_cursor.col) {
    wp->w_valid &= -8;
    wp->w_valid_cursor.col = wp->w_cursor.col;
    wp->w_valid_leftcol = wp->w_leftcol;
  } else { //Added block
  if (wp->w_leftcol != wp->w_valid_leftcol) {



  }
  }
  }
  return;
}
}
void changed_cline_bef_curs(void) 
{ 


  {
  curwin->w_valid &= -16;
  return;
}
}
void changed_line_abv_curs(void) 
{ 


  {
  curwin->w_valid &= -32;
  return;
}
}
void set_topline(WIN *wp , linenr_t lnum ) 
{ 


  {
  wp->w_botline += lnum - wp->w_topline;
  wp->w_topline = lnum;
  wp->w_valid &= -50;
  return;
}
}
void validate_botline(void) 
{ 


  {
  if (! (curwin->w_valid & 32)) {
    {
    comp_botline();
    }
  }
  return;
}
}
void invalidate_botline(void) 
{ 


  {
  curwin->w_valid &= -97;
  return;
}
}
void invalidate_botline_win(WIN *wp ) 
{ 


  {
  wp->w_valid &= -97;
  return;
}
}
void approximate_botline(void) 
{ 


  {
  curwin->w_valid &= -33;
  return;
}
}
int botline_approximated(void) 
{





}
int cursor_valid(void) 
{








}
void validate_cursor(void) 
{ 


  {
  {
  check_cursor_moved(curwin);
  }
  if ((curwin->w_valid & 3) != 3) {
    {
    curs_columns(1);
    }
  }
  return;
}
}
void validate_cline_row(void) 
{














}
int may_validate_crow(void) 
{




























}
static void curs_rows(int do_botline ) 
{ 
  linenr_t lnum ;
  int i___0 ;
  int lsize_invalid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (curwin->w_lsize_valid == 0) {
      tmp___0 = 1;
    } else { //Added block
    if (*(curwin->w_lsize_lnum + 0) != curwin->w_topline) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    }
  } else {
    tmp___0 = 1;
  }
  lsize_invalid = tmp___0;
  i___0 = 0;
  curwin->w_cline_row = 0;
  lnum = curwin->w_topline;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (lnum < curwin->w_cursor.lnum)) {
      goto while_break;
    }
    if (lsize_invalid) {
      {
      tmp___1 = plines(lnum);
      curwin->w_cline_row += tmp___1;
      }
    } else {
      tmp___2 = i___0;
      i___0 ++;
      curwin->w_cline_row += (int )*(curwin->w_lsize + tmp___2);
    }
    lnum ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 8)) {
    if (lsize_invalid) {
      {
      curwin->w_cline_height = plines(lnum);
      }
    } else { //Added block
    if (i___0 > curwin->w_lsize_valid) {

    } else {
      curwin->w_cline_height = (int )*(curwin->w_lsize + i___0);
    }
    }
  }
  curwin->w_valid |= 24;
  if (do_botline) {





  }
  return;
}
}
void validate_virtcol(void) 
{ 


  {
  {
  validate_virtcol_win(curwin);
  }
  return;
}
}
static void validate_virtcol_win(WIN *wp ) 
{ 


  {
  {
  check_cursor_moved(wp);
  }
  if (! (wp->w_valid & 4)) {
    {
    getvcol(wp, & wp->w_cursor, (colnr_t *)((void *)0), & wp->w_virtcol, (colnr_t *)((void *)0));
    wp->w_valid |= 4;
    }
  }
  return;
}
}
void validate_cheight(void) 
{ 


  {
  {
  check_cursor_moved(curwin);
  }
  if (! (curwin->w_valid & 8)) {
    {
    curwin->w_cline_height = plines(curwin->w_cursor.lnum);
    curwin->w_valid |= 8;
    }
  }
  return;
}
}
void validate_cursor_col(void) 
{ 


  {
  {
  validate_virtcol();
  }
  if (! (curwin->w_valid & 2)) {
    curwin->w_wcol = (int )curwin->w_virtcol;
    if (curwin->w_p_nu) {

    }
    if (curwin->w_p_wrap) {
      if ((long )curwin->w_wcol >= Columns) {

      }
    }
    curwin->w_valid |= 2;
  }
  return;
}
}
void curs_columns(int scroll ) 
{ 
  int diff ;
  int extra ;
  int new_leftcol ;
  colnr_t startcol ;
  colnr_t endcol ;
  colnr_t prev_skipcol ;
  char_u *tmp ;
  size_t tmp___0 ;

  {
  {
  update_topline();
  }
  if (! (curwin->w_valid & 16)) {
    {
    curs_rows(0);
    }
  }
  {
  getvcol(curwin, & curwin->w_cursor, & startcol, & curwin->w_virtcol, & endcol);
  }
  if (startcol > dollar_vcol) {
    dollar_vcol = (colnr_t )0;
  }
  curwin->w_wcol = (int )curwin->w_virtcol;
  if (curwin->w_p_nu) {
    curwin->w_wcol += 8;
    endcol += 8U;
  }
  curwin->w_wrow = curwin->w_cline_row;
  if (curwin->w_p_wrap) {
    if ((long )curwin->w_wcol >= Columns) {
      extra = (int )((long )curwin->w_wcol / Columns);
      curwin->w_wcol = (int )((long )curwin->w_wcol - (long )extra * Columns);
      curwin->w_wrow += extra;
      if (*p_sbr) {
        {

        }








      }
    }
  } else { //Added block
  if (scroll) {
    extra = (int )startcol - (int )curwin->w_leftcol;
    if (extra < 0) {

    } else {
      extra = ((int )endcol - (int )((long )curwin->w_leftcol + Columns)) + 1;
      if (extra > 0) {
        _L: ;


























        {

        }
      }
    }
    curwin->w_wcol = (int )((colnr_t )curwin->w_wcol - curwin->w_leftcol);
  } else { //Added block





  }
  }
  prev_skipcol = curwin->w_skipcol;
  if (curwin->w_wrow > curwin->w_height - 1) {

  } else { //Added block
  if (prev_skipcol) {
    _L___0: ;



























  } else {
    curwin->w_skipcol = (colnr_t )0;
  }
  }
  if (prev_skipcol != curwin->w_skipcol) {
    {

    }
  }
  curwin->w_valid |= 7;
  return;
}
}
void scrolldown(long line_count ) 
{ 
  long done___0 ;
  int wrow ;
  int moved ;
  int tmp ;
  long tmp___0 ;
  linenr_t tmp___1 ;
  int tmp___2 ;

  {
  {
  done___0 = 0L;
  moved = 0;
  validate_cursor();
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___0 = line_count;
    line_count --;
    if (! tmp___0) {
      goto while_break;
    }
    if (curwin->w_topline == 1L) {
      goto while_break;
    }
    {
    (curwin->w_topline) --;
    tmp = plines(curwin->w_topline);
    done___0 += (long )tmp;
    (curwin->w_botline) --;
    curwin->w_valid &= -33;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  curwin->w_wrow = (int )((long )curwin->w_wrow + done___0);
  curwin->w_cline_row = (int )((long )curwin->w_cline_row + done___0);
  wrow = curwin->w_wrow;
  if (curwin->w_p_wrap) {
    {
    validate_virtcol();
    validate_cheight();
    wrow = (int )((long )wrow + ((long )(curwin->w_cline_height - 1) - (long )curwin->w_virtcol / Columns));
    }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (wrow >= curwin->w_height) {
      if (! (curwin->w_cursor.lnum > 1L)) {

      }
    } else {
      goto while_break___0;
    }
    {
    tmp___1 = curwin->w_cursor.lnum;
    (curwin->w_cursor.lnum) --;
    tmp___2 = plines(tmp___1);
    wrow -= tmp___2;
    curwin->w_valid &= -32;
    moved = 1;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (moved) {
    {
    coladvance(curwin->w_curswant);
    }
  }
  return;
}
}
void scrollup(long line_count ) 
{ 


  {
  curwin->w_topline += line_count;
  curwin->w_botline += line_count;
  curwin->w_valid &= -50;
  if (curwin->w_topline > curbuf->b_ml.ml_line_count) {

  }
  if (curwin->w_cursor.lnum < curwin->w_topline) {
    {
    curwin->w_cursor.lnum = curwin->w_topline;
    curwin->w_valid &= -32;
    coladvance(curwin->w_curswant);
    }
  }
  return;
}
}
void scrolldown_clamp(void) 
{


























}
void scrollup_clamp(void) 
{

























}
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{ 
  int did_delete ;
  int nextrow ;
  int lastrow ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (invalid) {
    wp->w_lsize_valid = 0;
  }
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (line_count <= 0) {

    } else { //Added block
    if (wp->w_height < 5) {

    }
    }
  } else {

  }
  if (line_count > wp->w_height - row) {

  }
  if (mayclear) {
    if (Rows - (long )line_count < 5L) {
      {

      }

    }
  }
  if (row + line_count >= wp->w_height) {
    {


    }

  }
  clear_cmdline = 1;
  if (scroll_region) {
    {
    scroll_region_set(wp, row);
    retval = screen_ins_lines(wp->w_winpos + row, 0, line_count, wp->w_height - row);
    scroll_region_reset();
    }
    return (retval);
  }





































  {

  }










}
}
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{ 
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (invalid) {

  }
  {
  tmp = redrawing();
  }
  if (tmp) {
    if (line_count <= 0) {

    }
  } else {

  }
  if (line_count > wp->w_height - row) {

  }
  if (mayclear) {
    if (Rows - (long )line_count < 5L) {
      {
      screenclear();
      }
      return (0);
    }
  }
  if (row + line_count >= wp->w_height) {
    {


    }

  }
  clear_cmdline = 1;
  if (scroll_region) {
    {
    scroll_region_set(wp, row);
    retval = screen_del_lines(wp->w_winpos + row, 0, line_count, wp->w_height - row,
                              0);
    scroll_region_reset();
    }
    return (retval);
  }





  {

  }



























}
}
void win_rest_invalid(WIN *wp ) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    wp->w_lsize_valid = 0;
    wp->w_redr_type = 40;
    wp->w_redr_status = 1;
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  redraw_cmdline = 1;
  return;
}
}
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) 
{ 
  int i___0 ;
  int j ;
  char_u *temp ;
  int cursor_row ;
  int type ;
  int result_empty ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (tmp) {
    if (line_count <= 0) {

    } else { //Added block
    if ((long )line_count > p_ttyscroll) {

    }
    }
  } else {

  }
  result_empty = row + line_count >= end;
  if ((int )*(term_strings[8]) != 0) {
    if (result_empty) {

    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: ;
  if ((int )*(term_strings[3]) != 0) {
    if (line_count > 1) {
      type = 1;
    } else { //Added block
    if ((int )*(term_strings[2]) == 0) {

    } else {
      goto _L___3;
    }
    }
  } else { //Added block
  _L___3: ;
  if ((int )*(term_strings[5]) != 0) {
    if (result_empty) {
      if (line_count > 1) {

      } else { //Added block





      }
    } else {
      goto _L___2;
    }
  } else { //Added block
  _L___2: ;
  if ((int )*(term_strings[2]) != 0) {
    type = 3;
  } else { //Added block
  if ((int )*(term_strings[1]) != 0) {





  } else { //Added block
  _L___0: ;
  if ((int )*(term_strings[4]) != 0) {





  } else { //Added block
  _L: ;

















  }
  }
  }
  }
  }
  }
  if (type == 8) {
    {

    }

  } else { //Added block
  if (type == 2) {
    {

    }

  } else { //Added block
  if (type == 4) {
    {

    }

  } else { //Added block
  if (type == 5) {
    {

    }

  }
  }
  }
  }
  if (*(term_strings[10])) {
    {

    }
  }
  if ((int )*(term_strings[33]) != 0) {

  } else {
    cursor_row = row + off___0;
  }
  row += off___0;
  end += off___0;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < line_count)) {
      goto while_break;
    }
    j = (end - 1) - i___0;
    temp = *(LinePointers + j);
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      j -= line_count;
      if (! (j >= row)) {
        goto while_break___0;
      }
      *(LinePointers + (j + line_count)) = *(LinePointers + j);
    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    *(LinePointers + (j + line_count)) = temp;
    lineclear(temp);
    i___0 ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  screen_stop_highlight();
  windgoto(cursor_row, 0);
  }
  if (type == 1) {
    {
    term_append_lines(line_count);
    screen_start();
    }
  } else {
    i___0 = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! (i___0 < line_count)) {
        goto while_break___1;
      }
      if (type == 3) {
        if (i___0) {





        }
        {
        out_str(term_strings[2]);
        }
      } else {
        {

        }
      }
      {
      screen_start();
      i___0 ++;
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
  }
  if (type == 6) {


















  }
  return (1);
}
}
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) 
{ 
  int j ;
  int i___0 ;
  char_u *temp ;
  int cursor_row ;
  int cursor_end ;
  int result_empty ;
  int can_delete ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = screen_valid(1);
  }
  if (tmp) {
    if (line_count <= 0) {

    } else { //Added block
    if (! force) {
      if ((long )line_count > p_ttyscroll) {

      }
    }
    }
  } else {

  }
  result_empty = row + line_count >= end;
  if ((int )*(term_strings[10]) == 0) {
    tmp___0 = 1;
  } else { //Added block





  }
  can_delete = tmp___0;
  if ((int )*(term_strings[8]) != 0) {
    if (result_empty) {

    } else {
      goto _L___4;
    }
  } else { //Added block
  _L___4: ;
  if (row == 0) {
    if (line_count == 1) {
      type = 7;
    } else { //Added block
    if ((int )*(term_strings[5]) == 0) {

    } else {
      goto _L___3;
    }
    }
  } else { //Added block
  _L___3: ;
  if ((int )*(term_strings[5]) != 0) {
    if (line_count > 1) {
      if (can_delete) {
        type = 2;
      } else {

      }
    } else {

    }
  } else { //Added block
  _L___2: ;
  if ((int )*(term_strings[1]) != 0) {





  } else { //Added block
  _L___0: ;
  if ((int )*(term_strings[4]) != 0) {





  } else { //Added block
  _L: ;









  }
  }
  }
  }
  }
  if ((int )*(term_strings[33]) != 0) {


  } else {
    cursor_row = row + off___0;
    cursor_end = end + off___0;
  }
  row += off___0;
  end += off___0;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < line_count)) {
      goto while_break;
    }
    j = row + i___0;
    temp = *(LinePointers + j);
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      j += line_count;
      if (! (j <= end - 1)) {
        goto while_break___0;
      }
      *(LinePointers + (j - line_count)) = *(LinePointers + j);
    }
    while_break___0: ;/* CIL Label */ ;
    }
    {
    *(LinePointers + (j - line_count)) = temp;
    lineclear(temp);
    i___0 ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  screen_stop_highlight();
  }
  if (type == 8) {
    {



    }
  } else { //Added block
  if (type == 2) {
    {
    windgoto(cursor_row, 0);
    term_delete_lines(line_count);
    screen_start();
    }
  } else { //Added block
  if (type == 7) {
    {
    windgoto(cursor_end - 1, 0);
    i___0 = line_count;
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      i___0 --;
      if (! (i___0 >= 0)) {
        goto while_break___1;
      }
      {
      out_char((unsigned int )'\n');
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
  } else {

    {





















    while_break___2: ;/* CIL Label */ ;
    }
  }
  }
  }
  if (*(term_strings[10])) {























  }
  return (1);
}
}
int showmode(void) 
{ 
  int need_clear ;
  int length ;
  int do_mode ;
  int attr ;
  int nwr_save ;
  int sub_attr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  length = 0;
  if (p_smd) {
    if (State & 16) {

    } else { //Added block
    if (restart_edit) {

    } else { //Added block
    if (VIsual_active) {

    } else {
      tmp = 0;
    }
    }
    }
  } else {
    tmp = 0;
  }
  do_mode = tmp;
  if (do_mode) {

  } else { //Added block
  if (Recording) {
    _L: ;
    {

    }














    {



    }







    {



    }

















































































































  } else { //Added block
  if (clear_cmdline) {
    {
    msg_clr_cmdline();
    }
  }
  }
  }
  if (lastwin->w_status_height == 0) {
    {
    win_redr_ruler(lastwin, 1);
    }
  }
  redraw_cmdline = 0;
  clear_cmdline = 0;
  return (length);
}
}
static void msg_pos_mode(void) 
{







}
void unshowmode(int force ) 
{








































}
static int highlight_status(int *attr , int is_curwin ) 
{ 


  {
  if (is_curwin) {
    *attr = highlight_attr[11];
  } else {
    *attr = highlight_attr[12];
  }
  if (*attr) {
    if (highlight_attr[11] != highlight_attr[12]) {
      return (' ');
    } else { //Added block







    }
  }




}
}
void showruler(int always ) 
{ 
  int tmp ;

  {
  if (! always) {
    {
    tmp = redrawing();
    }
    if (! tmp) {

    }
  }
  if (*p_stl) {









  } else {
    {
    win_redr_ruler(curwin, always);
    }
  }
  if (p_icon) {
    goto _L;
  } else { //Added block
  if (p_title) {
    _L: ;
    if (stl_syntax & 3) {
      {

      }
    }
  }
  }
  return;
}
}
static void win_redr_ruler(WIN *wp , int always ) 
{ 
  char_u buffer[30] ;
  int row ;
  int fillchar ;
  int attr ;
  int empty_line ;
  colnr_t virtcol ;
  int i___0 ;
  int o ;
  char_u *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  empty_line = 0;
  if (! p_ru) {
    return;
  }
  if (wp->w_cursor.lnum > (wp->w_buffer)->b_ml.ml_line_count) {

  }
  if (*p_ruf) {
    {

    }

  }
  {
  tmp = ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, 0);
  }
  if ((int )*tmp == 0) {

  }
  {
  validate_virtcol_win(wp);
  }
  if (redraw_cmdline) {
    goto _L;
  } else { //Added block
  if (always) {

  } else { //Added block
  if (wp->w_cursor.lnum != wp->w_ru_cursor.lnum) {

  } else { //Added block
  if (wp->w_cursor.col != wp->w_ru_cursor.col) {

  } else { //Added block
  if (wp->w_virtcol != wp->w_ru_virtcol) {

  } else { //Added block
  if (wp->w_topline != wp->w_ru_topline) {

  } else { //Added block
  if (empty_line != (int )wp->w_ru_empty) {
    _L: ;
    {
    cursor_off();
    }
    if (wp->w_status_height) {
      {


      }
    } else {
      row = (int )(Rows - 1L);
      fillchar = ' ';
      attr = 0;
    }
    virtcol = wp->w_virtcol;
    if (wp->w_p_list) {







    }
    if ((wp->w_buffer)->b_ml.ml_flags & 1) {

    } else {
      tmp___0 = wp->w_cursor.lnum;
    }
    {
    sprintf((char * __restrict  )((char *)(buffer)), (char const   * __restrict  )"%ld,",
            tmp___0);
    }
    if (! (State & 16)) {
      if (empty_line) {

      } else {
        tmp___1 = (int )wp->w_cursor.col + 1;
      }
    } else {

    }
    {
    tmp___2 = strlen((char const   *)((char *)(buffer)));
    col_print(buffer + tmp___2, tmp___1, (int )virtcol + 1);
    tmp___3 = strlen((char const   *)((char *)(buffer)));
    i___0 = (int )tmp___3;
    }
    if (wp->w_status_height) {

    } else {
      o = 4;
    }
    if ((long )((ru_col + i___0) + o) < Columns) {
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! ((long )((ru_col + i___0) + o) < Columns)) {
          goto while_break;
        }
        tmp___4 = i___0;
        i___0 ++;
        buffer[tmp___4] = (char_u )fillchar;
      }
      while_break: ;/* CIL Label */ ;
      }
      {
      get_rel_pos(wp, buffer + i___0);
      }
    }
    {
    screen_puts(buffer, row, ru_col, attr);
    tmp___5 = strlen((char const   *)((char *)(buffer)));
    screen_fill(row, row + 1, ru_col + (int )tmp___5, (int )Columns, fillchar, fillchar,
                attr);
    wp->w_ru_cursor = wp->w_cursor;
    wp->w_ru_virtcol = wp->w_virtcol;
    wp->w_ru_empty = (char )empty_line;
    wp->w_ru_topline = wp->w_topline;
    }
  }
  }
  }
  }
  }
  }
  }
  return;
}
}
static void get_rel_pos(WIN *wp , char_u *str___1 ) 
{ 
  long above ;
  long below ;
  char const   *tmp ;

  {
  above = wp->w_topline - 1L;
  below = ((wp->w_buffer)->b_ml.ml_line_count - wp->w_botline) + 1L;
  if (below <= 0L) {





    {

    }
  } else { //Added block
  if (above <= 0L) {
    {
    strcpy((char * __restrict  )((char *)str___1), (char const   * __restrict  )((char *)"Top"));
    }
  } else {
    {


    }
  }
  }
  return;
}
}
void check_for_delay(int check_msg_scroll ) 
{ 


  {
  if (emsg_on_display) {
    goto _L;
  } else { //Added block
  if (check_msg_scroll) {
    if (msg_scroll) {
      _L: ;
      {
      out_flush();
      ui_delay(1000L, 1);
      emsg_on_display = 0;
      }
      if (check_msg_scroll) {

      }
    }
  }
  }
  return;
}
}
int screen_valid(int clear ) 
{ 


  {
  {
  screenalloc(clear);
  }
  return ((unsigned long )NextScreen != (unsigned long )((void *)0));
}
}
static int on_status_line  =    0;
static int prev_row___0  =    -1;
static int prev_col___0  =    -1;
int jump_to_mouse(int flags___0 , int *inclusive ) 
{

























































































































































































































































}
int redrawing(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! RedrawingDisabled) {
    if (p_lz) {
      {
      tmp = char_avail();
      }
      if (tmp) {
        if (! KeyTyped) {

        } else {
          tmp___0 = 1;
        }
      } else {

      }
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int messaging(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (p_lz) {
    {

    }









  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
int onepage(int dir , long count___2 ) 
{ 
  linenr_t lp ;
  long n ;
  int off___0 ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  retval = 1;
  if (curbuf->b_ml.ml_line_count == 1L) {
    {

    }

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (count___2 > 0L)) {
      goto while_break;
    }
    {
    validate_botline();
    }
    if (dir == 1) {
      if (curwin->w_topline >= curbuf->b_ml.ml_line_count - p_so) {
        if (curwin->w_botline > curbuf->b_ml.ml_line_count) {
          tmp = 1;
        } else {

        }
      } else {
        tmp = 0;
      }
      tmp___0 = tmp;
    } else {
      tmp___0 = curwin->w_topline == 1L;
    }
    if (tmp___0) {
      {
      beep_flush();
      retval = 0;
      }
      goto while_break;
    }
    if (dir == 1) {
      if (curwin->w_botline > curbuf->b_ml.ml_line_count) {
        curwin->w_topline = curbuf->b_ml.ml_line_count;
        curwin->w_valid &= -18;
      } else {
        {
        lp = curwin->w_botline;
        off___0 = get_scroll_overlap(lp, -1);
        curwin->w_topline = curwin->w_botline - (linenr_t )off___0;
        curwin->w_cursor.lnum = curwin->w_topline;
        curwin->w_valid &= -124;
        }
      }
    } else {
      {
      lp = curwin->w_topline - 1L;
      off___0 = get_scroll_overlap(lp, 1);
      lp += (linenr_t )off___0;
      }
      if (lp > curbuf->b_ml.ml_line_count) {

      }
      curwin->w_cursor.lnum = lp;
      n = 0L;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        if (n <= (long )curwin->w_height) {
          if (! (lp >= 1L)) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        {
        tmp___1 = plines(lp);
        n += (long )tmp___1;
        lp --;
        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
      if (n <= (long )curwin->w_height) {
        curwin->w_topline = (linenr_t )1;
        curwin->w_valid &= -50;
      } else { //Added block
      if (lp >= curwin->w_topline - 2L) {
        {




        }
      } else {
        curwin->w_topline = lp + 2L;
        curwin->w_valid &= -50;
      }
      }
    }
    count___2 --;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  cursor_correct();
  beginline(6);
  curwin->w_valid &= -8;
  }
  if (dir == 1) {
    if (curwin->w_cursor.lnum < curwin->w_topline + p_so) {
      {

      }
    }
  }
  {
  update_screen(10);
  }
  return (retval);
}
}
static int get_scroll_overlap(linenr_t lnum , int dir ) 
{ 
  int h1 ;
  int h2 ;
  int h3 ;
  int h4 ;
  int min_height ;

  {
  {
  min_height = curwin->w_height - 2;
  h1 = plines_check(lnum);
  }
  if (h1 > min_height) {

  } else {
    {
    h2 = plines_check(lnum + (linenr_t )dir);
    }
    if (h2 + h1 > min_height) {

    } else {
      {
      h3 = plines_check(lnum + (linenr_t )(dir * 2));
      }
      if (h3 + h2 > min_height) {

      } else {
        {
        h4 = plines_check(lnum + (linenr_t )(dir * 3));
        }
        if ((h4 + h3) + h2 > min_height) {

        } else { //Added block
        if ((h3 + h2) + h1 > min_height) {

        } else {
          return (2);
        }
        }
      }
    }
  }
}
}
void halfpage(int flag , linenr_t Prenum ) 
{ 
  long scrolled ;
  int i___0 ;
  int n ;
  int room ;

  {
  scrolled = 0L;
  if (Prenum) {
    if (Prenum > (linenr_t )curwin->w_height) {

    } else {
      curwin->w_p_scroll = Prenum;
    }
  }
  if (curwin->w_p_scroll <= (long )curwin->w_height) {
    n = (int )curwin->w_p_scroll;
  } else {

  }
  {
  validate_botline();
  room = curwin->w_empty_rows;
  }
  if (flag) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (n > 0) {
        if (! (curwin->w_botline <= curbuf->b_ml.ml_line_count)) {

        }
      } else {
        goto while_break;
      }
      {
      i___0 = plines(curwin->w_topline);
      n -= i___0;
      }
      if (n < 0) {
        if (scrolled) {
          goto while_break;
        }
      }
      (curwin->w_topline) ++;
      curwin->w_valid &= -18;
      scrolled += (long )i___0;
      room += i___0;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        i___0 = plines(curwin->w_botline);
        }
        if (i___0 > room) {
          goto while_break___0;
        }
        (curwin->w_botline) ++;
        room -= i___0;
        if (! (curwin->w_botline <= curbuf->b_ml.ml_line_count)) {

        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
      if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {
        (curwin->w_cursor.lnum) ++;
        curwin->w_valid &= -15;
      }
    }
    while_break: ;/* CIL Label */ ;
    }
    if (n > 0) {




    }
  } else {
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (n > 0) {
        if (! (curwin->w_topline > 1L)) {
          goto while_break___1;
        }
      } else {
        goto while_break___1;
      }
      {
      i___0 = plines(curwin->w_topline - 1L);
      n -= i___0;
      }
      if (n < 0) {



      }
      scrolled += (long )i___0;
      (curwin->w_topline) --;
      curwin->w_valid &= -114;
      if (curwin->w_cursor.lnum > 1L) {
        (curwin->w_cursor.lnum) --;
        curwin->w_valid &= -15;
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
    if (n > 0) {
      if (curwin->w_cursor.lnum > (linenr_t )n) {

      } else {
        curwin->w_cursor.lnum = (linenr_t )1;
      }
    }
  }
  {
  cursor_correct();
  beginline(6);
  update_screen(10);
  }
  return;
}
}
static char *lines[16]  = 
  {      (char *)"VIM - Vi IMproved",      (char *)"",      (char *)"version ",      (char *)"by Bram Moolenaar et al.", 
        (char *)"",      (char *)"Vim is freely distributable",      (char *)"type  :help uganda<Enter>     if you like Vim ",      (char *)"", 
        (char *)"type  :q<Enter>               to exit         ",      (char *)"type  :help<Enter>  or  <F1>  for on-line help",      (char *)"type  :help version5<Enter>   for version info",      (char *)((void *)0), 
        (char *)"",      (char *)"Running in Vi compatible mode",      (char *)"type  :set nocp<Enter>        for Vim defaults",      (char *)"type  :help cp-default<Enter> for info on this"};
static void intro_message(void) 
{





















































































}
void do_intro(void) 
{










}
#pragma merger("0","/tmp/cil-myjHm73r.i","-O0")
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) ;
static void save_re_pat(int idx , char_u *pat , int magic ) ;
static int inmacro(char_u *opt , char_u *s ) ;
static int check_linecomment(char_u *line ) ;
static int cls(void) ;
static int skip_chars(int cclass , int dir ) ;
static void back_in_line(void) ;
static void find_first_blank(FPOS *posp ) ;
static void findsent_forward(long count___2 , int at_start_sent ) ;
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) ;
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) ;
static char_u *top_bot_msg  =    (char_u *)"search hit TOP, continuing at BOTTOM";
static char_u *bot_top_msg  =    (char_u *)"search hit BOTTOM, continuing at TOP";
static struct spat spats[2]  = {      {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}, 
        {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}};
static int last_idx  =    0;
static struct spat saved_spats[2]  ;
static int saved_last_idx  =    0;
static int saved_no_hlsearch  =    0;
static char_u *mr_pattern  =    (char_u *)((void *)0);
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) 
{ 
  int magic ;
  int i___0 ;
  vim_regexp *tmp ;

  {
  rc_did_emsg = 0;
  magic = p_magic;
  if ((unsigned long )pat == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*pat == 0) {
    _L: ;
    if (pat_use == 2) {
      i___0 = last_idx;
    } else {

    }
    if ((unsigned long )spats[i___0].pat == (unsigned long )((void *)0)) {











    }
    pat = spats[i___0].pat;
    magic = spats[i___0].magic;
    no_smartcase = spats[i___0].no_scs;
  } else { //Added block
  if (options___0 & 32) {
    {
    add_to_history(1, pat, 1);
    }
  }
  }
  }
  mr_pattern = pat;
  if (! (options___0 & 1024)) {
    if (pat_save == 0) {
      {
      save_re_pat(0, pat, magic);
      }
    } else { //Added block





    }
    if (pat_save == 1) {
      {

      }
    } else { //Added block
    if (pat_save == 2) {
      {

      }
    }
    }
  }
  {
  set_reg_ic(pat);
  tmp = vim_regcomp(pat, magic);
  }
  return (tmp);
}
}
char_u *get_search_pat(void) 
{





}
static void save_re_pat(int idx , char_u *pat , int magic ) 
{ 


  {
  if ((unsigned long )spats[idx].pat != (unsigned long )pat) {
    {
    vim_free((void *)spats[idx].pat);
    spats[idx].pat = vim_strsave(pat);
    spats[idx].magic = magic;
    spats[idx].no_scs = no_smartcase;
    last_idx = idx;
    }
    if (p_hls) {
      {

      }
    }
    no_hlsearch = 0;
  }
  return;
}
}
static int save_level___0  =    0;
void save_search_patterns(void) 
{























}
void restore_search_patterns(void) 
{
















}
void set_reg_ic(char_u *pat ) 
{ 
  char_u *p___0 ;
  unsigned short const   **tmp ;
  char_u *tmp___0 ;

  {
  reg_ic = p_ic;
  if (reg_ic) {





























  }
  no_smartcase = 0;
  return;
}
}
char_u *last_search_pat(void) 
{ 


  {
  return (spats[last_idx].pat);
}
}
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) 
{







































}
vim_regexp *last_pat_prog(void) 
{ 
  vim_regexp *prog ;

  {
  if ((unsigned long )spats[last_idx].pat == (unsigned long )((void *)0)) {
    return ((vim_regexp *)((void *)0));
  }
  {



  }

}
}
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) 
{ 
  int found ;
  linenr_t lnum ;
  vim_regexp *prog ;
  char_u *ptr ;
  char_u *match ;
  char_u *matchend ;
  int loop ;
  FPOS start_pos ;
  int at_first_line ;
  int extra_col ;
  int match_ok ;
  char_u *p___0 ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  match = (char_u *)((void *)0);
  matchend = (char_u *)((void *)0);
  prog = search_regcomp(str___1, 0, pat_use, options___0 & 1056);
  }
  if ((unsigned long )prog == (unsigned long )((void *)0)) {








  }
  if (options___0 & 256) {
    extra_col = 0;
  } else {
    extra_col = 1;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    start_pos = *pos___0;
    found = 0;
    at_first_line = 1;
    if (pos___0->lnum == 0L) {



    }
    if (dir == -1) {
      if (start_pos.col == 0U) {
        lnum = pos___0->lnum - 1L;
        at_first_line = 0;
      } else {
        lnum = pos___0->lnum;
      }
    } else {
      lnum = pos___0->lnum;
    }
    loop = 0;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (! (loop <= 1)) {
        goto while_break___0;
      }
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (lnum > 0L) {
          if (! (lnum <= buf___3->b_ml.ml_line_count)) {
            goto while_break___1;
          }
        } else {
          goto while_break___1;
        }
        {
        ptr = ml_get_buf(buf___3, lnum, 0);
        tmp___5 = vim_regexec(prog, ptr, 1);
        }
        if (tmp___5) {
          match = prog->startp[0];
          matchend = prog->endp[0];
          if (dir == 1) {
            if (at_first_line) {
              match_ok = 1;
              {
              while (1) {
                while_continue___2: ;/* CIL Label */ ;
                if (options___0 & 64) {

                } else {
                  tmp___1 = (int )(match - ptr) - ((int )*match == 0) < (int )start_pos.col + extra_col;
                }
                if (! tmp___1) {
                  goto while_break___2;
                }
                {
                tmp = vim_strchr(p_cpo, 'c');
                }
                if ((unsigned long )tmp != (unsigned long )((void *)0)) {
                  p___0 = matchend;
                  if ((unsigned long )match == (unsigned long )p___0) {



                  }
                } else {




                }
                if ((int )*p___0 != 0) {
                  {
                  tmp___0 = vim_regexec(prog, p___0, 0);
                  }
                  if (tmp___0) {
                    match = prog->startp[0];
                    matchend = prog->endp[0];
                  } else {
                    match_ok = 0;
                    goto while_break___2;
                  }
                } else {
                  match_ok = 0;
                  goto while_break___2;
                }
              }
              while_break___2: ;/* CIL Label */ ;
              }
              if (! match_ok) {
                goto __Cont;
              }
            }
          }
          if (dir == -1) {
            match_ok = 0;
            {
            while (1) {
              while_continue___3: ;/* CIL Label */ ;
              if (! at_first_line) {
                match_ok = 1;
                match = prog->startp[0];
                matchend = prog->endp[0];
              } else {
                if (options___0 & 64) {

                } else {
                  tmp___2 = (prog->startp[0] - ptr) + (long )extra_col <= (long )((int )start_pos.col);
                }
                if (tmp___2) {
                  match_ok = 1;
                  match = prog->startp[0];
                  matchend = prog->endp[0];
                } else {
                  goto while_break___3;
                }
              }
              {
              tmp___3 = vim_strchr(p_cpo, 'c');
              }
              if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
                p___0 = matchend;
                if ((unsigned long )p___0 == (unsigned long )match) {



                }
              } else {




              }
              if ((int )*p___0 == 0) {
                goto while_break___3;
              } else {
                {
                tmp___4 = vim_regexec(prog, p___0, 0);
                }
                if (! tmp___4) {

                }
              }
            }
            while_break___3: ;/* CIL Label */ ;
            }
            if (! match_ok) {

            }
          }
          pos___0->lnum = lnum;
          if (options___0 & 64) {





          } else {
            pos___0->col = (colnr_t )((int )(match - ptr));
          }
          found = 1;
          goto while_break___1;
        }
        {
        line_breakcheck();
        }
        if (got_int) {

        }
        if (loop) {
          if (lnum == start_pos.lnum) {
            goto while_break___1;
          }
        }
        __Cont: ;
        lnum += (linenr_t )dir;
        at_first_line = 0;
      }
      while_break___1: ;/* CIL Label */ ;
      }
      at_first_line = 0;
      if (! p_ws) {

      } else { //Added block
      if (got_int) {

      } else { //Added block
      if (found) {
        goto while_break___0;
      }
      }
      }
      if (dir == -1) {
        {
        lnum = buf___3->b_ml.ml_line_count;
        tmp___6 = shortmess('s');
        }
        if (! tmp___6) {
          if (options___0 & 12) {
            {
            give_warning(top_bot_msg, 1);
            }
          }
        }
      } else {
        {
        lnum = (linenr_t )1;
        tmp___7 = shortmess('s');
        }
        if (! tmp___7) {
          if (options___0 & 12) {
            {
            give_warning(bot_top_msg, 1);
            }
          }
        }
      }
      loop ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (got_int) {

    }
    count___2 --;
    if (count___2 > 0L) {
      if (! found) {

      }
    } else {
      goto while_break;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)prog);
  }
  if (! found) {
    if (got_int) {
      {

      }
    } else { //Added block
    if ((options___0 & 12) == 12) {
      if (p_ws) {
        {
        emsg2(e_patnotf2, mr_pattern);
        }
      } else { //Added block









      }
    }
    }
    return (0);
  }
  search_match_len = (int )(matchend - match);
  return (1);
}
}
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) 
{ 
  FPOS pos___0 ;
  char_u *searchstr ;
  struct soffset old_off ;
  int retval ;
  char_u *p___0 ;
  long c ;
  char_u *dircp ;
  char_u *tmp ;
  char_u *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char_u *msgbuf ;
  char_u *trunc ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char_u *tmp___8 ;
  char_u *tmp___9 ;
  char_u *tmp___10 ;
  char_u *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  if (spats[0].off.line) {
    {

    }




  }
  old_off = spats[0].off;
  pos___0 = curwin->w_cursor;
  if (dirc == 0) {
    dirc = spats[0].off.dir;
  } else {
    spats[0].off.dir = dirc;
  }
  if (options___0 & 1) {
    if (dirc == 47) {
      dirc = '?';
    } else {

    }
  }
  if (no_hlsearch) {






  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    searchstr = str___1;
    dircp = (char_u *)((void *)0);
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto _L;
    } else { //Added block
    if ((int )*str___1 == 0) {
      goto _L;
    } else { //Added block
    if ((int )*str___1 == dirc) {
      _L: ;
      if ((unsigned long )spats[0].pat == (unsigned long )((void *)0)) {
        {
        emsg(e_noprevre);
        retval = 0;
        }
        goto end_do_search;
      }
      searchstr = (char_u *)"";
    }
    }
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if ((int )*str___1 != 0) {
        {
        p___0 = skip_regexp(str___1, dirc, p_magic);
        }
        if ((int )*p___0 == dirc) {




        }
        spats[0].off.line = 0;
        spats[0].off.end = 0;
        spats[0].off.off = 0L;
        if ((int )*p___0 == 43) {

        } else { //Added block
        if ((int )*p___0 == 45) {

        } else {
          {
          tmp___1 = __ctype_b_loc();
          }
          if ((int const   )*(*tmp___1 + (int )*p___0) & 2048) {

          } else { //Added block
          if (options___0 & 16) {
            if ((int )*p___0 == 101) {

            } else { //Added block
            if ((int )*p___0 == 115) {

            } else { //Added block
            if ((int )*p___0 == 98) {
              _L___0: ;




            }
            }
            }
          }
          }
        }
        }
        {
        tmp___5 = __ctype_b_loc();
        }
        if ((int const   )*(*tmp___5 + (int )*p___0) & 2048) {

        } else { //Added block
        if ((int )*p___0 == 43) {

        } else { //Added block
        if ((int )*p___0 == 45) {
          _L___1: ;
          {

          }





















          {










          while_break___0: ;/* CIL Label */ ;
          }
        }
        }
        }
        searchcmdlen = (int )(p___0 - str___1);
        str___1 = p___0;
      }
    }
    if (options___0 & 2) {
      {
      tmp___12 = messaging();
      }
      if (tmp___12) {
        if ((int )*searchstr == 0) {
          p___0 = spats[last_idx].pat;
        } else {
          p___0 = searchstr;
        }
        {
        tmp___6 = strlen((char const   *)((char *)p___0));
        msgbuf = alloc((unsigned int )(tmp___6 + 40UL));
        }
        if ((unsigned long )msgbuf != (unsigned long )((void *)0)) {
          {
          *(msgbuf + 0) = (char_u )dirc;
          strcpy((char * __restrict  )((char *)(msgbuf + 1)), (char const   * __restrict  )((char *)p___0));
          }
          if (spats[0].off.line) {

          } else { //Added block
          if (spats[0].off.end) {

          } else { //Added block
          if (spats[0].off.off) {
            _L___2: ;
            {





            }





































          }
          }
          }
          {
          msg_start();
          trunc = msg_strtrunc(msgbuf);
          }
          if ((unsigned long )trunc != (unsigned long )((void *)0)) {
            {


            }
          } else {
            {
            msg_outtrans(msgbuf);
            }
          }
          {
          msg_clr_eos();
          msg_check();
          vim_free((void *)msgbuf);
          gotocmdline(0);
          out_flush();
          msg_nowait = 1;
          }
        }
      }
    }
    if (! spats[0].off.line) {
      if (spats[0].off.off) {













































      }
    }
    if ((unsigned long )str___1 != (unsigned long )((void *)0)) {
      if ((int )*str___1 == 59) {

      } else {
        tmp___15 = 128;
      }
    } else {
      tmp___15 = 128;
    }
    if (dirc == 47) {
      tmp___16 = 1;
    } else {
      tmp___16 = -1;
    }
    {
    tmp___17 = searchit(curbuf, & pos___0, tmp___16, searchstr, count___2, spats[0].off.end + (options___0 & (1324 + tmp___15)),
                        2);
    c = (long )tmp___17;
    }
    if ((unsigned long )dircp != (unsigned long )((void *)0)) {

    }
    if (c == 0L) {
      retval = 0;
      goto end_do_search;
    }
    if (spats[0].off.end) {



    }
    retval = 1;
    if (! (options___0 & 128)) {
      goto _L___3;
    } else { //Added block
    if ((int )*str___1 == 59) {
      _L___3: ;
      if (spats[0].off.line) {












      } else { //Added block
      if (spats[0].off.off > 0L) {

        {













        while_break___3: ;/* CIL Label */ ;
        }
      } else {
        c = (long )pos___0.col + spats[0].off.off;
        if (c >= 0L) {
          pos___0.col = (colnr_t )c;
        } else {

          {













          while_break___4: ;/* CIL Label */ ;
          }
        }
      }
      }
    }
    }
    if (! (options___0 & 16)) {
      goto while_break;
    } else { //Added block
    if ((unsigned long )str___1 == (unsigned long )((void *)0)) {
      goto while_break;
    } else { //Added block
    if ((int )*str___1 != 59) {
      goto while_break;
    }
    }
    }












  }
  while_break: ;/* CIL Label */ ;
  }
  if (options___0 & 512) {
    {
    setpcmark();
    }
  }
  curwin->w_cursor = pos___0;
  curwin->w_set_curswant = 1;
  end_do_search: ;
  if (options___0 & 1024) {

  }
  return (retval);
}
}
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) 
{













































































































































}
static int lastc___0  =    '\000';
static int lastcdir  ;
static int lastctype  ;
int searchc(int c , int dir , int type , long count___2 ) 
{ 
  int col ;
  char_u *p___0 ;
  int len___0 ;
  size_t tmp ;
  long tmp___0 ;

  {
  if (c != 0) {
    if (! KeyStuffed) {
      lastc___0 = c;
      lastcdir = dir;
      lastctype = type;
    }
  } else {
    if (lastc___0 == 0) {

    }
    if (dir) {
      dir = - lastcdir;
    } else {
      dir = lastcdir;
    }
    type = lastctype;
    c = lastc___0;
  }
  {
  p___0 = ml_get_curline();
  col = (int )curwin->w_cursor.col;
  tmp = strlen((char const   *)((char *)p___0));
  len___0 = (int )tmp;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___0 = count___2;
    count___2 --;
    if (! tmp___0) {
      goto while_break;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      col += dir;
      if (col < 0) {
        return (0);
      } else { //Added block
      if (col >= len___0) {
        return (0);
      }
      }
      if ((int )*(p___0 + col) == c) {
        goto while_break___0;
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (type) {
    col -= dir;
  }
  curwin->w_cursor.col = (colnr_t )col;
  return (1);
}
}
FPOS *findmatch(OPARG *oap , int initc ) 
{ 
  FPOS *tmp ;

  {
  {
  tmp = findmatchlimit(oap, initc, 0, 0);
  }
  return (tmp);
}
}
static FPOS pos  ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) 
{ 
  int findc ;
  int c ;
  int count___2 ;
  int backwards ;
  int inquote ;
  char_u *linep ;
  char_u *ptr ;
  int do_quotes ;
  int at_start___0 ;
  int hash_dir ;
  int comment_dir ;
  FPOS match_pos ;
  int start_in_quotes ;
  int traveled ;
  int ignore_cend ;
  int cpo_match ;
  int dir ;
  int comment_col ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  char_u *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;

  {
  {
  findc = 0;
  count___2 = 0;
  backwards = 0;
  inquote = 0;
  hash_dir = 0;
  comment_dir = 0;
  traveled = 0;
  ignore_cend = 0;
  comment_col = 2147483647;
  pos = curwin->w_cursor;
  linep = ml_get(pos.lnum);
  tmp = vim_strchr(p_cpo, '%');
  cpo_match = (unsigned long )tmp != (unsigned long )((void *)0);
  }
  if (flags___0 & 1) {

  } else { //Added block
  if (flags___0 & 2) {
    dir = 1;
  } else {
    dir = 0;
  }
  }
  if (initc == 47) {
    goto _L___2;
  } else { //Added block
  if (initc == 42) {
    _L___2: ;
    comment_dir = dir;
    if (initc == 47) {
      ignore_cend = 1;
    }
    if (dir == 1) {
      backwards = 0;
    } else {

    }
    initc = '\000';
  } else { //Added block
  if (initc != 35) {
    if (initc != 0) {
      ptr = curbuf->b_p_mps;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! *ptr) {

        }
        if ((int )*ptr == initc) {




        }
        ptr += 2;
        if ((int )*ptr == initc) {
          findc = initc;
          initc = (int )*(ptr + -2);
          backwards = 0;
          goto while_break;
        }
        ptr += 2;
      }
      while_break: ;/* CIL Label */ ;
      }
      if (! findc) {

      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: ;
    if (initc == 35) {

    } else {
      if (! cpo_match) {
        {

        }





























































      }
      if (! hash_dir) {
        if (! comment_dir) {
          if ((int )*(linep + pos.col) == 0) {



          }
          {
          while (1) {
            while_continue___0: ;/* CIL Label */ ;
            initc = (int )*(linep + pos.col);
            if (initc == 0) {
              goto while_break___0;
            }
            ptr = curbuf->b_p_mps;
            {
            while (1) {
              while_continue___1: ;/* CIL Label */ ;
              if (! *ptr) {

              }
              if ((int )*ptr == initc) {



              }
              ptr += 2;
              if ((int )*ptr == initc) {



              }
              ptr ++;
              if (! *ptr) {
                goto while_break___1;
              }
              ptr ++;
            }
            while_break___1: ;/* CIL Label */ ;
            }
            if (findc) {

            }
            (pos.col) ++;
          }
          while_break___0: ;/* CIL Label */ ;
          }
          if (! findc) {
            if (! cpo_match) {
              {

              }





            } else {
              return ((FPOS *)((void *)0));
            }
          }
        }
      }
    }
    if (hash_dir) {

































      {




























































































      while_break___2: ;/* CIL Label */ ;
      }

    }
  }
  }
  }
  do_quotes = -1;
  start_in_quotes = 2;
  if (backwards) {





  }
  {
  while (1) {
    while_continue___3: ;/* CIL Label */ ;
    if (! (! got_int)) {

    }
    if (backwards) {



























    } else { //Added block
    if ((int )*(linep + pos.col) == 0) {
      if (pos.lnum == curbuf->b_ml.ml_line_count) {
        goto while_break___3;
      }
      (pos.lnum) ++;
      if (maxtravel) {





      }
      {
      linep = ml_get(pos.lnum);
      pos.col = (colnr_t )0;
      do_quotes = -1;
      line_breakcheck();
      }
    } else {
      (pos.col) ++;
    }
    }
    if (pos.col == 0U) {
      if (flags___0 & 4) {













      }
    }
    if (comment_dir) {
      if (comment_dir == 1) {
        if ((int )*(linep + pos.col) == 42) {
          if ((int )*(linep + (pos.col + 1U)) == 47) {
            (pos.col) ++;
            return (& pos);
          }
        }
      } else { //Added block










































      }
      goto while_continue___3;
    }
    if (cpo_match) {
      do_quotes = 0;
    } else { //Added block













































































    }
    if (start_in_quotes == 2) {
      start_in_quotes = 0;
    }
    c = (int )*(linep + pos.col);
    {
    if (c == 0) {
      goto case_0;
    }
    if (c == 34) {
      goto case_34;
    }
    if (c == 39) {

    }
    goto switch_default;
    case_0: ;/* CIL Label */ 
    if (pos.col == 0U) {
      inquote = 0;
      start_in_quotes = 0;
    } else { //Added block
    if ((int )*(linep + (pos.col - 1U)) != 92) {
      inquote = 0;
      start_in_quotes = 0;
    }
    }
    goto switch_break;
    case_34: ;/* CIL Label */ 
    if (do_quotes) {









    }
    goto switch_break;
    case_39: ;/* CIL Label */ 
    if (! cpo_match) {
      if (initc != 39) {
        if (findc != 39) {
          if (backwards) {















          } else { //Added block
          if (*(linep + (pos.col + 1U))) {
            if ((int )*(linep + (pos.col + 1U)) == 92) {










            } else { //Added block
            _L___9: ;




            }
          }
          }
        }
      }
    }
    switch_default: ;/* CIL Label */ 
    if (! inquote) {
      goto _L___10;
    } else { //Added block
    if (start_in_quotes == 1) {
      _L___10: ;
      if (c == initc) {
        count___2 ++;
      } else { //Added block
      if (c == findc) {
        if (count___2 == 0) {

        }
        count___2 --;
      }
      }
    }
    }
    switch_break: ;/* CIL Label */ ;
    }
  }
  while_break___3: ;/* CIL Label */ ;
  }
  if (comment_dir == -1) {




  }
  return ((FPOS *)((void *)0));
}
}
static int check_linecomment(char_u *line ) 
{

























}
void showmatch(void) 
{

































































}
int findsent(int dir , long count___2 ) 
{ 
  FPOS pos___0 ;
  FPOS tpos ;
  int c ;
  int (*func)(FPOS * ) ;
  int startlnum ;
  int noskip ;
  int cpo_J ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;

  {
  noskip = 0;
  pos___0 = curwin->w_cursor;
  if (dir == 1) {
    func = & incl;
  } else {
    func = & decl;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___14 = count___2;
    count___2 --;
    if (! tmp___14) {
      goto while_break;
    }
    {
    tmp___2 = gchar_pos(& pos___0);
    }
    if (tmp___2 == 0) {
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        tmp = (*func)(& pos___0);
        }
        if (tmp == -1) {

        }
        {
        tmp___0 = gchar_pos(& pos___0);
        }
        if (! (tmp___0 == 0)) {
          goto while_break___0;
        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
      if (dir == 1) {
        goto found;
      }
    } else { //Added block
    if (dir == 1) {
      if (pos___0.col == 0U) {
        {
        tmp___1 = startPS(pos___0.lnum, '\000', 0);
        }
        if (tmp___1) {





        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else { //Added block
    _L___0: ;
    if (dir == -1) {
      {
      decl(& pos___0);
      }
    }
    }
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      {
      c = gchar_pos(& pos___0);
      }
      if (! (c == 32)) {
        if (! (c == 9)) {
          if (dir == -1) {
            {
            tmp___5 = vim_strchr((char_u *)".!?)]\"\'", c);
            }
            if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
              goto while_break___1;
            }
          } else {
            goto while_break___1;
          }
        }
      }
      {
      tmp___3 = decl(& pos___0);
      }
      if (tmp___3 == -1) {

      }
      {
      tmp___4 = ml_get(pos___0.lnum);
      }
      if ((int )*tmp___4 == 0) {






      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
    {
    startlnum = (int )pos___0.lnum;
    tmp___6 = vim_strchr(p_cpo, 'J');
    cpo_J = (unsigned long )tmp___6 != (unsigned long )((void *)0);
    }
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      {
      c = gchar_pos(& pos___0);
      }
      if (c == 0) {
        goto _L___1;
      } else { //Added block
      if (pos___0.col == 0U) {
        {
        tmp___7 = startPS(pos___0.lnum, '\000', 0);
        }
        if (tmp___7) {
          _L___1: ;
          if (dir == -1) {
            if (pos___0.lnum != (linenr_t )startlnum) {
              (pos___0.lnum) ++;
            }
          }
          goto while_break___2;
        }
      }
      }
      if (c == 46) {
        goto _L___4;
      } else { //Added block
      if (c == 33) {
        goto _L___4;
      } else { //Added block
      if (c == 63) {
        _L___4: ;
        tpos = pos___0;
        {
        while (1) {
          while_continue___3: ;/* CIL Label */ ;
          {
          c = inc(& tpos);
          }
          if (c == -1) {

          }
          {
          c = gchar_pos(& tpos);
          tmp___8 = vim_strchr((char_u *)")]\"\'", c);
          }
          if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
            goto while_break___3;
          }
        }
        while_break___3: ;/* CIL Label */ ;
        }
        if (c == -1) {

        } else { //Added block
        if (! cpo_J) {
          if (c == 32) {

          } else { //Added block





          }
        } else { //Added block
        _L___3: ;
        if (c == 0) {
          goto _L___2;
        } else { //Added block
        if (cpo_J) {
          if (c == 32) {
            {

            }
            if (tmp___10 >= 0) {
              {

              }
              if (tmp___11 == 32) {
                _L___2: ;
                {
                pos___0 = tpos;
                tmp___9 = gchar_pos(& pos___0);
                }
                if (tmp___9 == 0) {
                  {
                  inc(& pos___0);
                  }
                }
                goto while_break___2;
              }
            }
          }
        }
        }
        }
        }
      }
      }
      }
      {
      tmp___12 = (*func)(& pos___0);
      }
      if (tmp___12 == -1) {
        if (count___2) {
          return (0);
        }
        noskip = 1;
        goto while_break___2;
      }
    }
    while_break___2: ;/* CIL Label */ ;
    }
    found: ;
    {
    while (1) {
      while_continue___4: ;/* CIL Label */ ;
      if (! noskip) {
        {
        c = gchar_pos(& pos___0);
        }
        if (! (c == 32)) {
          if (! (c == 9)) {
            goto while_break___4;
          }
        }
      } else {
        goto while_break___4;
      }
      {
      tmp___13 = incl(& pos___0);
      }
      if (tmp___13 == -1) {

      }
    }
    while_break___4: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  setpcmark();
  curwin->w_cursor = pos___0;
  }
  return (1);
}
}
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) 
{ 
  linenr_t curr ;
  int did_skip ;
  int first___0 ;
  char_u *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char_u *tmp___2 ;
  colnr_t tmp___3 ;
  char_u *tmp___4 ;
  size_t tmp___5 ;

  {
  curr = curwin->w_cursor.lnum;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    tmp___1 = count___2;
    count___2 --;
    if (! tmp___1) {
      goto while_break;
    }
    did_skip = 0;
    first___0 = 1;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      tmp = ml_get(curr);
      }
      if ((int )*tmp != 0) {
        did_skip = 1;
      }
      if (! first___0) {
        if (did_skip) {
          {
          tmp___0 = startPS(curr, what, both);
          }
          if (tmp___0) {
            goto while_break___0;
          }
        }
      }
      curr += (linenr_t )dir;
      if (curr < 1L) {
        goto _L;
      } else { //Added block
      if (curr > curbuf->b_ml.ml_line_count) {
        _L: ;
        if (count___2) {
          return (0);
        }
        curr -= (linenr_t )dir;
        goto while_break___0;
      }
      }
      first___0 = 0;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  setpcmark();
  }
  if (both) {
    {

    }



  }
  curwin->w_cursor.lnum = curr;
  if (curr == curbuf->b_ml.ml_line_count) {
    {
    tmp___4 = ml_get(curr);
    tmp___5 = strlen((char const   *)((char *)tmp___4));
    tmp___3 = (colnr_t )tmp___5;
    curwin->w_cursor.col = tmp___3;
    }
    if (tmp___3 != 0U) {
      (curwin->w_cursor.col) --;
      oap->inclusive = 1;
    }
  } else {
    curwin->w_cursor.col = (colnr_t )0;
  }
  return (1);
}
}
static int inmacro(char_u *opt , char_u *s ) 
{











































}
int startPS(linenr_t lnum , int para , int both ) 
{ 
  char_u *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
  s = ml_get(lnum);
  }
  if ((int )*s == para) {
    return (1);
  } else { //Added block
  if ((int )*s == 12) {

  } else { //Added block
  if (both) {



  }
  }
  }
  if ((int )*s == 46) {
    {

    }
    if (tmp) {

    } else { //Added block
    if (! para) {
      {

      }



    }
    }
  }
  return (0);
}
}
static int stype  ;
static int cls(void) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
  c = gchar_cursor();
  }
  if (c == 32) {
    return (0);
  } else { //Added block
  if (c == 9) {

  } else { //Added block
  if (c == 0) {
    return (0);
  }
  }
  }
  {
  tmp = vim_iswordc(c);
  }
  if (tmp) {
    return (1);
  }
  if (stype == 0) {
    tmp___0 = 2;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
int fwd_word(long count___2 , int type , int eol ) 
{ 
  int sclass ;
  int i___0 ;
  int last_line ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    last_line = curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count;
    i___0 = inc_cursor();
    }
    if (i___0 == -1) {

    } else { //Added block
    if (i___0 == 1) {
      if (last_line) {
        return (0);
      }
    }
    }
    if (i___0 == 1) {
      if (eol) {



      }
    }
    if (sclass != 0) {
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        tmp = cls();
        }
        if (! (tmp == sclass)) {
          goto while_break___0;
        }
        {
        i___0 = inc_cursor();
        }
        if (i___0 == -1) {

        } else { //Added block
        if (i___0 == 1) {
          if (eol) {



          }
        }
        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      {
      tmp___1 = cls();
      }
      if (! (tmp___1 == 0)) {
        goto while_break___1;
      }
      if (curwin->w_cursor.col == 0U) {
        {
        tmp___0 = ml_get_curline();
        }
        if ((int )*tmp___0 == 0) {
          goto while_break___1;
        }
      }
      {
      i___0 = inc_cursor();
      }
      if (i___0 == -1) {

      } else { //Added block
      if (i___0 == 1) {
        if (eol) {



        }
      }
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
int bck_word(long count___2 , int type , int stop ) 
{ 
  int sclass ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    tmp = dec_cursor();
    }
    if (tmp == -1) {
      return (0);
    }
    if (! stop) {
      goto _L;
    } else {
      {

      }
      if (sclass == tmp___5) {

      } else { //Added block
      if (sclass == 0) {
        _L: ;
        {
        while (1) {
          while_continue___0: ;/* CIL Label */ ;
          {
          tmp___2 = cls();
          }
          if (! (tmp___2 == 0)) {
            goto while_break___0;
          }
          if (curwin->w_cursor.col == 0U) {
            {

            }



          }
          {
          tmp___1 = dec_cursor();
          }
          if (tmp___1 == -1) {

          }
        }
        while_break___0: ;/* CIL Label */ ;
        }
        {
        tmp___3 = cls();
        tmp___4 = skip_chars(tmp___3, -1);
        }
        if (tmp___4) {
          return (1);
        }
      }
      }
    }
    {
    inc_cursor();
    }
    finished: ;
    stop = 0;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
int end_word(long count___2 , int type , int stop , int empty ) 
{ 
  int sclass ;
  int tmp ;
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    tmp = inc_cursor();
    }
    if (tmp == -1) {

    }
    {
    tmp___6 = cls();
    }
    if (tmp___6 == sclass) {
      if (sclass != 0) {
        {
        tmp___0 = skip_chars(sclass, 1);
        }
        if (tmp___0) {

        }
      } else {

      }
    } else { //Added block
    _L___0: ;
    if (! stop) {
      goto _L;
    } else { //Added block
    if (sclass == 0) {
      _L: ;
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        tmp___3 = cls();
        }
        if (! (tmp___3 == 0)) {
          goto while_break___0;
        }
        if (empty) {
          if (curwin->w_cursor.col == 0U) {
            {

            }



          }
        }
        {
        tmp___2 = inc_cursor();
        }
        if (tmp___2 == -1) {

        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
      {
      tmp___4 = cls();
      tmp___5 = skip_chars(tmp___4, 1);
      }
      if (tmp___5) {

      }
    }
    }
    }
    {
    dec_cursor();
    }
    finished: ;
    stop = 0;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
int bckend_word(long count___2 , int type , int eol ) 
{ 
  int sclass ;
  int i___0 ;
  int tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;

  {
  stype = type;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0L)) {
      goto while_break;
    }
    {
    sclass = cls();
    i___0 = dec_cursor();
    }
    if (i___0 == -1) {
      return (0);
    }
    if (eol) {



    }
    if (sclass != 0) {
      {
      while (1) {
        while_continue___0: ;/* CIL Label */ ;
        {
        tmp = cls();
        }
        if (! (tmp == sclass)) {
          goto while_break___0;
        }
        {
        i___0 = dec_cursor();
        }
        if (i___0 == -1) {
          return (1);
        } else { //Added block
        if (eol) {



        }
        }
      }
      while_break___0: ;/* CIL Label */ ;
      }
    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      {
      tmp___1 = cls();
      }
      if (! (tmp___1 == 0)) {
        goto while_break___1;
      }
      if (curwin->w_cursor.col == 0U) {
        {

        }



      }
      {
      i___0 = dec_cursor();
      }
      if (i___0 == -1) {

      } else { //Added block
      if (eol) {



      }
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (1);
}
}
static int skip_chars(int cclass , int dir ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    {
    tmp___2 = cls();
    }
    if (! (tmp___2 == cclass)) {
      goto while_break;
    }
    if (dir == 1) {
      {
      tmp = inc_cursor();
      tmp___1 = tmp;
      }
    } else {
      {
      tmp___0 = dec_cursor();
      tmp___1 = tmp___0;
      }
    }
    if (tmp___1 == -1) {
      return (1);
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  return (0);
}
}
static void back_in_line(void) 
{ 
  int sclass ;
  int tmp ;

  {
  {
  sclass = cls();
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (! (curwin->w_cursor.col == 0U))) {
      goto while_break;
    }
    {


    }




  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static void find_first_blank(FPOS *posp ) 
{





























}
static void findsent_forward(long count___2 , int at_start_sent ) 
{




































}
int current_word(OPARG *oap , long count___2 , int include , int type ) 
{ 
  FPOS start_pos ;
  FPOS pos___0 ;
  int inclusive ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  inclusive = 1;
  stype = type;
  if (VIsual_active) {
    if ((int )*p_sel == 101) {










    }
  }
  if (! VIsual_active) {

  } else { //Added block
  if (curwin->w_cursor.lnum == VIsual.lnum) {
    if (curwin->w_cursor.col == VIsual.col) {
      _L: ;
      {
      back_in_line();
      start_pos = curwin->w_cursor;
      tmp___6 = cls();
      }
      if ((tmp___6 == 0) == include) {
        {

        }



      } else {
        {
        tmp___1 = fwd_word(1L, type, 1);
        }
        if (tmp___1 == 0) {

        }
        {
        tmp___5 = oneleft();
        }
        if (tmp___5 == 0) {

        } else { //Added block
        if (include) {
          {
          tmp___4 = cls();
          }
          if (tmp___4 != 0) {
            {



            }












          }
        }
        }
      }
      if (VIsual_active) {
        {
        VIsual = start_pos;
        VIsual_mode = 'v';
        update_curbuf(40);
        }
      } else {


      }
      count___2 --;
    }
  }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (count___2 > 0L)) {
      goto while_break;
    }








































































  }
  while_break: ;/* CIL Label */ ;
  }
  if (VIsual_active) {
    if ((int )*p_sel == 101) {












    }
  } else {

  }
  return (1);
}
}
int current_sent(OPARG *oap , long count___2 , int include ) 
{




























































































































































































































































































}
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) 
{









































































































































































































}
int current_par(OPARG *oap , long count___2 , int include , int type ) 
{
































































































































































































































































































































}
int linewhite(linenr_t lnum ) 
{










}
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) 
{









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) 
{




























































































}
static int hlsearch_on  =    0;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) 
{






























































































}
void write_viminfo_search_pattern(FILE *fp___0 ) 
{ 
  int tmp___0 ;
  char_u *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___2 = get_viminfo_parameter('/');
  }
  if (tmp___2 != 0) {
    if (no_hlsearch) {

    } else {
      {
      tmp___1 = find_viminfo_parameter('h');
      }
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {

      } else {
        tmp___0 = 'H';
      }
    }
    {
    fprintf((FILE * __restrict  )fp___0, (char const   * __restrict  )"\n# hlsearch on (H) or off (h):\n~%c",
            tmp___0);
    wvsp_one(fp___0, 0, (char *)"", '/');
    wvsp_one(fp___0, 1, (char *)"Substitute ", '&');
    }
  }
  return;
}
}
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )spats[idx].pat != (unsigned long )((void *)0)) {
    {


    }

























    {



    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-aNPjgWpH.i","-O0")
int syn_check_group(char_u *pp , int len___0 ) ;
static struct growarray highlight_ga  ;
static int include_link  =    0;
static char *hl_name_table[7]  = {      (char *)"bold",      (char *)"standout",      (char *)"underline",      (char *)"italic", 
        (char *)"reverse",      (char *)"inverse",      (char *)"NONE"};
static int hl_attr_table[7]  = {      2,      16,      8,      4, 
        1,      1,      0};
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) ;
static int syn_namen2id(char_u *linep , int len___0 ) ;
static void syn_unadd_group(void) ;
static void set_hl_attr(int idx ) ;
static void highlight_list_one(int id ) ;
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) ;
static int syn_add_group(char_u *name___1 ) ;
static int syn_list_header(int did_header , int outlen , int id ) ;
static int hl_has_settings(int idx , int check_link ) ;
static void highlight_clear(int idx ) ;
static char *spo_name_tab[7]  = {      (char *)"ms=",      (char *)"me=",      (char *)"hs=",      (char *)"he=", 
        (char *)"rs=",      (char *)"re=",      (char *)"lc="};
static int current_attr  =    0;
static int current_id  =    0;
static int current_trans_id  =    0;
static char_u **syn_cmdlinep  ;
static int current_syn_inc_tag  =    0;
static int running_syn_inc_tag  =    0;
static int keepend_level  =    -1;
static int next_match_col  ;
static int next_match_m_endcol  ;
static int next_match_h_startcol  ;
static int next_match_h_endcol  ;
static int next_match_idx  ;
static int next_match_flags  ;
static int next_match_eos_col  ;
static int next_match_eoe_col  ;
static int next_match_end_idx  ;
static BUF *syn_buf  ;
static linenr_t current_lnum  =    (linenr_t )0;
static int current_state_stored  =    0;
static colnr_t current_col  =    (colnr_t )0;
static int current_finished  =    0;
static struct growarray current_state  =    {0, 0, 0, 0, (void *)0};
static short *current_next_list  =    (short *)((void *)0);
static int current_next_flags  =    0;
static int current_line_id  =    0;
static void syn_sync(WIN *wp , linenr_t start_lnum ) ;
static int syn_match_linecont(linenr_t lnum ) ;
static void syn_start_line(void) ;
static void syn_free_all_states(BUF *buf___3 ) ;
static void syn_clear_states(int start___0 , int end ) ;
static void store_current_state(void) ;
static void invalidate_current_state(void) ;
static void validate_current_state(void) ;
static void copy_state_to_current(struct syn_state *from ) ;
static void move_state(int from , int to ) ;
static int syn_finish_line(int syncing ) ;
static int syn_current_attr(int syncing , char_u *line ) ;
static int did_match_already(int idx ) ;
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) ;
static void check_state_ends(char_u *line ) ;
static void update_si_attr(int idx ) ;
static void check_keepend(void) ;
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) ;
static short *copy_id_list(short *list ) ;
static int in_id_list(short *list , int id , int inctag , int contained ) ;
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
static int push_current(int idx ) ;
static void pop_current(void) ;
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) ;
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) ;
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) ;
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) ;
static void syn_cmd_case(EXARG *eap , int syncing ) ;
static void syntax_sync_clear(void) ;
static void syn_remove_pattern(BUF *buf___3 , int idx ) ;
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) ;
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) ;
static void syn_cmd_clear(EXARG *eap , int syncing ) ;
static void syn_clear_one(int id , int syncing ) ;
static void syn_cmd_on(EXARG *eap , int syncing ) ;
static void syn_cmd_manual(EXARG *eap , int syncing ) ;
static void syn_cmd_off(EXARG *eap , int syncing ) ;
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) ;
static void syn_cmd_list(EXARG *eap , int syncing ) ;
static void syn_lines_msg(void) ;
static void syn_list_one(int id , int syncing , int link_only ) ;
static void syn_list_cluster(int id ) ;
static void put_id_list(char_u *name___1 , short *list , int attr ) ;
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) ;
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) ;
static void syn_clear_keyword(int id , struct keyentry **ktabp ) ;
static void free_keywtab(struct keyentry **ktabp ) ;
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) ;
static char_u *get_group_name(char_u *arg , char_u **name_end ) ;
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) ;
static void syn_cmd_include(EXARG *eap , int syncing ) ;
static void syn_cmd_keyword(EXARG *eap , int syncing ) ;
static void syn_cmd_match(EXARG *eap , int syncing ) ;
static void syn_cmd_region(EXARG *eap , int syncing ) ;
static int syn_compare_stub(void const   *v1 , void const   *v2 ) ;
static void syn_cmd_cluster(EXARG *eap , int syncing ) ;
static int syn_scl_name2id(char_u *name___1 ) ;
static int syn_scl_namen2id(char_u *linep , int len___0 ) ;
static int syn_check_cluster(char_u *pp , int len___0 ) ;
static int syn_add_cluster(char_u *name___1 ) ;
static void init_syn_patterns(void) ;
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) ;
static void syn_cmd_sync(EXARG *eap , int syncing ) ;
static int get_id_list(char_u **arg , int keylen , short **list ) ;
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) ;
static void syn_incl_toplevel(int id , int *flagsp ) ;
void syntax_start(WIN *wp , linenr_t lnum ) 
{













































































































































































































}
static void syn_sync(WIN *wp , linenr_t start_lnum ) 
{






















































































































































































































































}
static int syn_match_linecont(linenr_t lnum ) 
{














}
static void syn_start_line(void) 
{












































}
static void syn_free_all_states(BUF *buf___3 ) 
{ 
  int idx ;

  {
  if ((unsigned long )buf___3->b_syn_states != (unsigned long )((void *)0)) {

    {










    while_break: ;/* CIL Label */ ;
    }
    {



    }
  }
  return;
}
}
static void syn_clear_states(int start___0 , int end ) 
{






















}
static void store_current_state(void) 
{

















































}
static void copy_state_to_current(struct syn_state *from ) 
{

















































}
static void invalidate_current_state(void) 
{ 


  {
  {
  ga_clear(& current_state);
  current_state.ga_itemsize = 0;
  current_next_list = (short *)((void *)0);
  keepend_level = -1;
  }
  return;
}
}
static void validate_current_state(void) 
{







}
static void move_state(int from , int to ) 
{











}
void syn_changed(linenr_t lnum ) 
{ 


  {
  if (curbuf->b_syn_change_lnum > lnum) {

  }
  return;
}
}
int syntax_check_changed(linenr_t lnum ) 
{


























































}
static int syn_finish_line(int syncing ) 
{





































}
int get_syntax_attr(colnr_t col , char_u *line ) 
{





























}
static int try_next_column  =    0;
static int syn_current_attr(int syncing , char_u *line ) 
{
































































































































































































































































































































































































}
static int did_match_already(int idx ) 
{























}
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) 
{





































































}
static void check_state_ends(char_u *line ) 
{

































































}
static void update_si_attr(int idx ) 
{







































}
static void check_keepend(void) 
{










































}
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) 
{




































}
static int push_current(int idx ) 
{


















}
static void pop_current(void) 
{













}
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) 
{




















































































































































































}
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) 
{








}
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) 
{








}
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) 
{

























































































































































}
static void syn_cmd_case(EXARG *eap , int syncing ) 
{














































}
void syntax_clear(BUF *buf___3 ) 
{ 
  int i___0 ;

  {
  {
  curbuf->b_syn_ic = 0;
  free_keywtab(buf___3->b_keywtab);
  buf___3->b_keywtab = (struct keyentry **)((void *)0);
  free_keywtab(buf___3->b_keywtab_ic);
  buf___3->b_keywtab_ic = (struct keyentry **)((void *)0);
  i___0 = buf___3->b_syn_patterns.ga_len;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    {

    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  ga_clear(& buf___3->b_syn_patterns);
  i___0 = buf___3->b_syn_clusters.ga_len;
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break___0;
    }
    {

    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  ga_clear(& buf___3->b_syn_clusters);
  buf___3->b_syn_sync_flags = 0;
  buf___3->b_syn_sync_minlines = 0L;
  buf___3->b_syn_sync_maxlines = 0L;
  vim_free((void *)buf___3->b_syn_linecont_prog);
  buf___3->b_syn_linecont_prog = (vim_regexp *)((void *)0);
  vim_free((void *)buf___3->b_syn_linecont_pat);
  buf___3->b_syn_linecont_pat = (char_u *)((void *)0);
  syn_free_all_states(buf___3);
  invalidate_current_state();
  }
  return;
}
}
static void syntax_sync_clear(void) 
{






























}
static void syn_remove_pattern(BUF *buf___3 , int idx ) 
{












}
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) 
{






















}
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) 
{










}
static void syn_cmd_clear(EXARG *eap , int syncing ) 
{
























































































}
static void syn_clear_one(int id , int syncing ) 
{



































}
static void syn_cmd_on(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_manual(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_off(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) 
{

















}
static void syn_cmd_list(EXARG *eap , int syncing ) 
{








































































































































































}
static void syn_lines_msg(void) 
{




























}
static int last_matchgroup  ;
static void syn_list_one(int id , int syncing , int link_only ) 
{












































































































































































































}
static void syn_list_cluster(int id ) 
{






























}
static void put_id_list(char_u *name___1 , short *list , int attr ) 
{

























































}
static char *sepchars  =    (char *)"/+=-#@\"|\'^&";
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) 
{














































































































}
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) 
{



























































































































}
static void syn_clear_keyword(int id , struct keyentry **ktabp ) 
{
















































}
static void free_keywtab(struct keyentry **ktabp ) 
{ 
  int i___0 ;
  struct keyentry *ktab ;
  struct keyentry *ktab_next ;

  {
  if ((unsigned long )ktabp != (unsigned long )((void *)0)) {

    {























    while_break: ;/* CIL Label */ ;
    }
    {

    }
  }
  return;
}
}
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) 
{








































































}
static char_u *get_group_name(char_u *arg , char_u **name_end ) 
{


















}
static struct flag flagtab[13]  = 
  {      {(char *)"contained", 9, 1}, 
        {(char *)"oneline", 7, 4}, 
        {(char *)"keepend", 7, 1024}, 
        {(char *)"excludenl", 9, 2048}, 
        {(char *)"transparent", 11, 2}, 
        {(char *)"skipnl", 6, 128}, 
        {(char *)"skipwhite", 9, 256}, 
        {(char *)"skipempty", 9, 512}, 
        {(char *)"grouphere", 9, 16}, 
        {(char *)"groupthere", 10, 32}, 
        {(char *)"display", 7, 4096}, 
        {(char *)"extend", 6, 8192}, 
        {(char *)"fold", 4, 16384}};
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) 
{


















































































































































































































}
static void syn_incl_toplevel(int id , int *flagsp ) 
{






























}
static void syn_cmd_include(EXARG *eap , int syncing ) 
{


































































}
static void syn_cmd_keyword(EXARG *eap , int syncing ) 
{


































































































































































}
static void syn_cmd_match(EXARG *eap , int syncing ) 
{













































































































}
static void syn_cmd_region(EXARG *eap , int syncing ) 
{

































































































































































































































































































































































































}
static int syn_compare_stub(void const   *v1 , void const   *v2 ) 
{




















}
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) 
{




































































































































































}
static int syn_scl_name2id(char_u *name___1 ) 
{









































}
static int syn_scl_namen2id(char_u *linep , int len___0 ) 
{
















}
static int syn_check_cluster(char_u *pp , int len___0 ) 
{
























}
static int syn_add_cluster(char_u *name___1 ) 
{





























}
static void syn_cmd_cluster(EXARG *eap , int syncing ) 
{
























































































































































}
static void init_syn_patterns(void) 
{







}
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) 
{































































































































































}
static void syn_cmd_sync(EXARG *eap , int syncing ) 
{












































































































































































































































}
static int get_id_list(char_u **arg , int keylen , short **list ) 
{









































































































































































































































































}
static short *copy_id_list(short *list ) 
{
































}
static int in_id_list(short *list , int id , int inctag , int contained ) 
{

















































}
static struct subcommand subcommands[14]  = 
  {      {(char *)"case", & syn_cmd_case}, 
        {(char *)"clear", & syn_cmd_clear}, 
        {(char *)"cluster", & syn_cmd_cluster}, 
        {(char *)"include", & syn_cmd_include}, 
        {(char *)"keyword", & syn_cmd_keyword}, 
        {(char *)"list", & syn_cmd_list}, 
        {(char *)"manual", & syn_cmd_manual}, 
        {(char *)"match", & syn_cmd_match}, 
        {(char *)"on", & syn_cmd_on}, 
        {(char *)"off", & syn_cmd_off}, 
        {(char *)"region", & syn_cmd_region}, 
        {(char *)"sync", & syn_cmd_sync}, 
        {(char *)"", & syn_cmd_list}, 
        {(char *)((void *)0), (void (*)(EXARG * , int  ))((void *)0)}};
void do_syntax(EXARG *eap , char_u **cmdlinep ) 
{
































































}
int syntax_present(BUF *buf___3 ) 
{ 
  int tmp ;

  {
  if (buf___3->b_syn_patterns.ga_len != 0) {

  } else { //Added block
  if (buf___3->b_syn_clusters.ga_len != 0) {

  } else { //Added block
  if ((unsigned long )curbuf->b_keywtab != (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )curbuf->b_keywtab_ic != (unsigned long )((void *)0)) {

  } else {
    tmp = 0;
  }
  }
  }
  }
  return (tmp);
}
}
static enum __anonenum_expand_what_169 expand_what  ;
void set_context_in_syntax_cmd(char_u *arg ) 
{







































































}
static char *case_args[3]  = {      (char *)"match",      (char *)"ignore",      (char *)((void *)0)};
char_u *get_syntax_name(int idx ) 
{








}
int syn_get_id(long line , long col , int trans___0 ) 
{
































}
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{












}
static char *highlight_init_both[9]  = 
  {      (char *)"ErrorMsg term=standout ctermbg=DarkRed ctermfg=White guibg=Red guifg=White",      (char *)"IncSearch term=reverse cterm=reverse gui=reverse",      (char *)"ModeMsg term=bold cterm=bold gui=bold",      (char *)"NonText term=bold ctermfg=Blue gui=bold guifg=Blue", 
        (char *)"StatusLine term=reverse,bold cterm=reverse,bold gui=reverse,bold",      (char *)"StatusLineNC term=reverse cterm=reverse gui=reverse",      (char *)"Visual term=reverse cterm=reverse gui=reverse guifg=Grey guibg=fg",      (char *)"VisualNOS term=underline,bold cterm=underline,bold gui=underline,bold", 
        (char *)((void *)0)};
static char *highlight_init_light[11]  = 
  {      (char *)"Directory term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"LineNr term=underline ctermfg=Brown guifg=Brown",      (char *)"MoreMsg term=bold ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE",      (char *)"SpecialKey term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"Title term=bold ctermfg=DarkMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=DarkRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static char *highlight_init_dark[11]  = 
  {      (char *)"Directory term=bold ctermfg=LightCyan guifg=Cyan",      (char *)"LineNr term=underline ctermfg=Yellow guifg=Yellow",      (char *)"MoreMsg term=bold ctermfg=LightGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=LightGreen gui=bold guifg=Green",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)"SpecialKey term=bold ctermfg=LightBlue guifg=Cyan",      (char *)"Title term=bold ctermfg=LightMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=LightRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static int had_both  =    0;
void init_highlight(int both ) 
{ 
  int i___0 ;
  char **pp ;
  int tmp ;

  {
  if (both) {
    had_both = 1;
    pp = highlight_init_both;
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((unsigned long )*(pp + i___0) != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {
      do_highlight((char_u *)*(pp + i___0), 0, 1);
      i___0 ++;
      }
    }
    while_break: ;/* CIL Label */ ;
    }
  } else { //Added block
  if (! had_both) {

  }
  }
  {
  tmp = tolower((int )*p_bg);
  }
  if (tmp == 108) {
    pp = highlight_init_light;
  } else {
    pp = highlight_init_dark;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )*(pp + i___0) != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    {
    do_highlight((char_u *)*(pp + i___0), 0, 1);
    i___0 ++;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  return;
}
}
static char *color_names[26]  = 
  {      (char *)"Black",      (char *)"DarkBlue",      (char *)"DarkGreen",      (char *)"DarkCyan", 
        (char *)"DarkRed",      (char *)"DarkMagenta",      (char *)"Brown",      (char *)"Gray", 
        (char *)"Grey",      (char *)"LightGray",      (char *)"LightGrey",      (char *)"DarkGray", 
        (char *)"DarkGrey",      (char *)"Blue",      (char *)"LightBlue",      (char *)"Green", 
        (char *)"LightGreen",      (char *)"Cyan",      (char *)"LightCyan",      (char *)"Red", 
        (char *)"LightRed",      (char *)"Magenta",      (char *)"LightMagenta",      (char *)"Yellow", 
        (char *)"White",      (char *)"NONE"};
static int color_numbers_16[26]  = 
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        7,      7,      7,      8, 
        8,      9,      9,      10, 
        10,      11,      11,      12, 
        12,      13,      13,      14, 
        15,      -1};
static int color_numbers_8[26]  = 
  {      0,      4,      2,      6, 
        1,      5,      3,      7, 
        7,      7,      7,      8, 
        8,      12,      12,      10, 
        10,      14,      14,      9, 
        9,      13,      13,      11, 
        15,      -1};
void do_highlight(char_u *line , int forceit , int init ) 
{ 
  char_u *name_end ;
  char_u *p___0 ;
  char_u *linep ;
  char_u *key_start ;
  char_u *arg_start ;
  char_u *key ;
  char_u *arg ;
  long i___0 ;
  int off___0 ;
  int len___0 ;
  int attr ;
  int id ;
  int idx ;
  int dodefault ;
  int doclear ;
  int dolink ;
  int error ;
  int color ;
  int is_normal_group ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *from_start ;
  char_u *from_end ;
  char_u *to_start ;
  char_u *to_end ;
  int from_id ;
  int to_id ;
  int tmp___4 ;
  int tmp___5 ;
  char_u *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char_u *tmp___26 ;
  char_u buf___3[100] ;
  char_u *tname ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char_u *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
  {
  key = (char_u *)((void *)0);
  arg = (char_u *)((void *)0);
  dodefault = 0;
  doclear = 0;
  dolink = 0;
  error = 0;
  is_normal_group = 0;
  tmp = ends_excmd((int )*line);
  }
  if (tmp) {

    {














    while_break: ;/* CIL Label */ ;
    }

  }
  {
  name_end = skiptowhite(line);
  linep = skipwhite(name_end);
  tmp___0 = strncmp((char const   *)((char *)line), (char const   *)((char *)"default"),
                    (size_t )(name_end - line));
  }
  if (tmp___0 == 0) {
    {




    }
  }
  {
  tmp___1 = strncmp((char const   *)((char *)line), (char const   *)((char *)"clear"),
                    (size_t )(name_end - line));
  }
  if (tmp___1 == 0) {

  }
  {
  tmp___2 = strncmp((char const   *)((char *)line), (char const   *)((char *)"link"),
                    (size_t )(name_end - line));
  }
  if (tmp___2 == 0) {

  }
  if (! doclear) {
    if (! dolink) {
      {
      tmp___3 = ends_excmd((int )*linep);
      }
      if (tmp___3) {
        {

        }










      }
    }
  }
  if (dolink) {
    {





    }
















    {


    }






    {



    }














































    {

    }

  }
  if (doclear) {
    {


    }






    {


    }
  }
  {
  id = syn_check_group(line, (int )(name_end - line));
  }
  if (id == 0) {

  }
  idx = id - 1;
  if (dodefault) {
    {

    }



  }
  {
  tmp___12 = strcmp((char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_name_u),
                    (char const   *)((char *)"NORMAL"));
  }
  if (tmp___12 == 0) {
    is_normal_group = 1;
  }
  if (doclear) {
    {

    }
  } else {
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      {
      tmp___43 = ends_excmd((int )*linep);
      }
      if (tmp___43) {
        goto while_break___0;
      }
      key_start = linep;
      if ((int )*linep == 61) {
        {


        }

      }
      {
      while (1) {
        while_continue___1: ;/* CIL Label */ ;
        if (*linep) {
          if ((int )*linep == 32) {

          } else { //Added block
          if ((int )*linep == 9) {

          } else { //Added block
          if (! ((int )*linep != 61)) {
            goto while_break___1;
          }
          }
          }
        } else {

        }
        linep ++;
      }
      while_break___1: ;/* CIL Label */ ;
      }
      {
      vim_free((void *)key);
      key = vim_strnsave_up(key_start, (int )(linep - key_start));
      }
      if ((unsigned long )key == (unsigned long )((void *)0)) {


      }
      {
      linep = skipwhite(linep);
      tmp___13 = strcmp((char const   *)((char *)key), (char const   *)((char *)"NONE"));
      }
      if (tmp___13 == 0) {














      }
      if ((int )*linep != 61) {
        {


        }

      }
      {
      linep ++;
      linep = skipwhite(linep);
      }
      if ((int )*linep == 39) {
        {



        }
      } else {
        {
        arg_start = linep;
        linep = skiptowhite(linep);
        }
      }
      if ((unsigned long )linep == (unsigned long )arg_start) {
        {


        }

      }
      {
      vim_free((void *)arg);
      arg = vim_strnsave(arg_start, (int )(linep - arg_start));
      }
      if ((unsigned long )arg == (unsigned long )((void *)0)) {


      }
      if ((int )*linep == 39) {

      }
      {
      tmp___40 = strcmp((char const   *)((char *)key), (char const   *)((char *)"TERM"));
      }
      if (tmp___40 == 0) {
        goto _L___9;
      } else {
        {
        tmp___41 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERM"));
        }
        if (tmp___41 == 0) {
          goto _L___9;
        } else {
          {
          tmp___42 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUI"));
          }
          if (tmp___42 == 0) {
            _L___9: ;
            attr = 0;
            off___0 = 0;
            {
            while (1) {
              while_continue___2: ;/* CIL Label */ ;
              if (! ((int )*(arg + off___0) != 0)) {
                goto while_break___2;
              }
              i___0 = (long )(sizeof(hl_attr_table) / sizeof(int ));
              {
              while (1) {
                while_continue___3: ;/* CIL Label */ ;
                i___0 --;
                if (! (i___0 >= 0L)) {

                }
                {
                tmp___14 = strlen((char const   *)hl_name_table[i___0]);
                len___0 = (int )tmp___14;
                tmp___15 = strncasecmp((char const   *)((char *)(arg + off___0)),
                                       (char const   *)hl_name_table[i___0], (size_t )len___0);
                }
                if (tmp___15 == 0) {
                  attr |= hl_attr_table[i___0];
                  off___0 += len___0;
                  goto while_break___3;
                }
              }
              while_break___3: ;/* CIL Label */ ;
              }
              if (i___0 < 0L) {
                {


                }

              }
              if ((int )*(arg + off___0) == 44) {
                off___0 ++;
              }
            }
            while_break___2: ;/* CIL Label */ ;
            }
            if (error) {

            }
            if ((int )*key == 84) {
              if (! init) {

              } else { //Added block
              if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 1)) {
                _L___4: ;
                if (! init) {

                }
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term = attr;
              }
              }
            } else { //Added block
            if ((int )*key == 67) {
              if (! init) {

              } else { //Added block
              if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 2)) {
                _L___5: ;
                if (! init) {

                }
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm = attr;
                ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 0;
              }
              }
            }
            }
          } else {
            {
            tmp___39 = strcmp((char const   *)((char *)key), (char const   *)((char *)"FONT"));
            }
            if (! (tmp___39 == 0)) {
              {
              tmp___37 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERMFG"));
              }
              if (tmp___37 == 0) {
                goto _L___8;
              } else {
                {
                tmp___38 = strcmp((char const   *)((char *)key), (char const   *)((char *)"CTERMBG"));
                }
                if (tmp___38 == 0) {
                  _L___8: ;
                  if (! init) {

                  } else { //Added block
                  if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 2)) {
                    _L___6: ;
                    if (! init) {

                    }
                    if ((int )*(key + 5) == 70) {
                      if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold) {


                      }
                    }
                    {
                    tmp___22 = __ctype_b_loc();
                    }
                    if ((int const   )*(*tmp___22 + (int )*arg) & 2048) {
                      {

                      }
                    } else {
                      {
                      tmp___21 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"fg"));
                      }
                      if (tmp___21 == 0) {









                      } else {
                        {
                        tmp___20 = strcasecmp((char const   *)((char *)arg), (char const   *)((char *)"bg"));
                        }
                        if (tmp___20 == 0) {









                        } else {
                          {
                          off___0 = toupper((int )*arg);
                          i___0 = (long )(sizeof(color_names) / sizeof(char *));
                          }
                          {
                          while (1) {
                            while_continue___4: ;/* CIL Label */ ;
                            i___0 --;
                            if (! (i___0 >= 0L)) {

                            }
                            if (off___0 == (int )*(color_names[i___0] + 0)) {
                              {
                              tmp___16 = strcasecmp((char const   *)((char *)(arg + 1)),
                                                    (char const   *)(color_names[i___0] + 1));
                              }
                              if (tmp___16 == 0) {
                                goto while_break___4;
                              }
                            }
                          }
                          while_break___4: ;/* CIL Label */ ;
                          }
                          if (i___0 < 0L) {
                            {



                            }

                          }
                          color = color_numbers_16[i___0];
                          if (color >= 0) {
                            {
                            tmp___19 = atoi((char const   *)((char *)term_strings[34]));
                            }
                            if (tmp___19 == 8) {
                              color = color_numbers_8[i___0];
                              if ((int )*(key + 5) == 70) {
                                if (color & 8) {
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm |= 2;
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bold = 1;
                                } else {
                                  ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm &= -3;
                                }
                              }
                              color &= 7;
                            } else {
                              {

                              }















                            }
                          }
                        }
                      }
                    }
                    if ((int )*(key + 5) == 70) {
                      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg = color + 1;
                      if (is_normal_group) {
                        {




                        }
                      }
                    } else {
                      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg = color + 1;
                      if (is_normal_group) {
                        {




                        }




























                        {

                        }
                      }
                    }
                  }
                  }
                } else {
                  {
                  tmp___36 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUIFG"));
                  }
                  if (! (tmp___36 == 0)) {
                    {
                    tmp___35 = strcmp((char const   *)((char *)key), (char const   *)((char *)"GUIBG"));
                    }
                    if (! (tmp___35 == 0)) {
                      {

                      }
                      if (tmp___33 == 0) {

                      } else {
                        {

                        }


































































































































                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (! init) {

      } else { //Added block
      if (! (((struct hl_group *)highlight_ga.ga_data + idx)->sg_set & 8)) {
        ((struct hl_group *)highlight_ga.ga_data + idx)->sg_link = 0;
      }
      }
      {
      linep = skipwhite(linep);
      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  if (error) {







  } else {
    _L___10: ;
    if (is_normal_group) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = 0;
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = 0;
    } else {
      {
      set_hl_attr(idx);
      }
    }
    {
    redraw_all_later(40);
    }
  }
  {
  vim_free((void *)key);
  vim_free((void *)arg);
  need_highlight_changed = 1;
  }
  return;
}
}
static int hl_has_settings(int idx , int check_link ) 
{






















}
static void highlight_clear(int idx ) 
{


















}
struct growarray term_attr_table  =    {0, 0, 0, 0, (void *)0};
struct growarray cterm_attr_table  =    {0, 0, 0, 0, (void *)0};
static int recursive___3  =    0;
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) 
{ 
  int i___0 ;
  struct attr_entry *gap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  table->ga_itemsize = (int )sizeof(struct attr_entry );
  table->ga_growsize = 7;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < table->ga_len)) {
      goto while_break;
    }
    gap = (struct attr_entry *)table->ga_data + i___0;
    if ((int )aep->ae_attr == (int )gap->ae_attr) {
      if ((unsigned long )table == (unsigned long )(& term_attr_table)) {

































      } else { //Added block
      _L___3: ;
      if ((unsigned long )table == (unsigned long )(& cterm_attr_table)) {
        if ((int )aep->ae_u.cterm.fg_color == (int )gap->ae_u.cterm.fg_color) {
          if ((int )aep->ae_u.cterm.bg_color == (int )gap->ae_u.cterm.bg_color) {
            return (i___0 + 32);
          }
        }
      }
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (table->ga_len + 32 == 256) {






    {





    }
    {










    while_break___0: ;/* CIL Label */ ;
    }

  }
  {
  tmp___1 = ga_grow(table, 1);
  }
  if (tmp___1 == 0) {

  }
  {
  gap = (struct attr_entry *)table->ga_data + table->ga_len;
  memset((void *)gap, 0, sizeof(struct attr_entry ));
  gap->ae_attr = aep->ae_attr;
  }
  if ((unsigned long )table == (unsigned long )(& term_attr_table)) {














  } else { //Added block
  if ((unsigned long )table == (unsigned long )(& cterm_attr_table)) {
    gap->ae_u.cterm.fg_color = aep->ae_u.cterm.fg_color;
    gap->ae_u.cterm.bg_color = aep->ae_u.cterm.bg_color;
  }
  }
  (table->ga_len) ++;
  (table->ga_room) --;
  return ((table->ga_len - 1) + 32);
}
}
struct attr_entry *syn_term_attr2entry(int attr ) 
{









}
struct attr_entry *syn_cterm_attr2entry(int attr ) 
{ 


  {
  attr -= 32;
  if (attr >= cterm_attr_table.ga_len) {

  }
  return ((struct attr_entry *)cterm_attr_table.ga_data + attr);
}
}
static void highlight_list_one(int id ) 
{


























}
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) 
{





























































}
char_u *highlight_has_attr(int id , int flag , int modec ) 
{




















}
static char_u name___0[20]  ;
char_u *highlight_color(int id , char_u *what , int modec ) 
{


































}
static int syn_list_header(int did_header , int outlen , int id ) 
{




































}
static void set_hl_attr(int idx ) 
{ 
  struct attr_entry at_en ;
  int tmp ;

  {
  {
  tmp = strcmp((char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + idx)->sg_name_u),
               (char const   *)((char *)"NORMAL"));
  }
  if (tmp == 0) {

  }
  if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + idx)->sg_start == (unsigned long )((void *)0)) {
    if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + idx)->sg_stop == (unsigned long )((void *)0)) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term_attr = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_term;
    } else {
      {





      }
    }
  } else {
    {





    }
  }
  if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg == 0) {
    if (((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg == 0) {
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
    } else {
      {
      at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
      at_en.ae_u.cterm.fg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg;
      at_en.ae_u.cterm.bg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg;
      ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = get_attr_entry(& cterm_attr_table,
                                                                                      & at_en);
      }
    }
  } else {
    {
    at_en.ae_attr = (short )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm;
    at_en.ae_u.cterm.fg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_fg;
    at_en.ae_u.cterm.bg_color = (char_u )((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_bg;
    ((struct hl_group *)highlight_ga.ga_data + idx)->sg_cterm_attr = get_attr_entry(& cterm_attr_table,
                                                                                    & at_en);
    }
  }
  return;
}
}
int syn_name2id(char_u *name___1 ) 
{ 
  int i___0 ;
  char_u *name_u ;
  int tmp ;

  {
  {
  name_u = vim_strsave_up(name___1);
  }
  if ((unsigned long )name_u == (unsigned long )((void *)0)) {

  }
  i___0 = highlight_ga.ga_len;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    i___0 --;
    if (! (i___0 >= 0)) {
      goto while_break;
    }
    if ((unsigned long )((struct hl_group *)highlight_ga.ga_data + i___0)->sg_name_u != (unsigned long )((void *)0)) {
      {
      tmp = strcmp((char const   *)((char *)name_u), (char const   *)((char *)((struct hl_group *)highlight_ga.ga_data + i___0)->sg_name_u));
      }
      if (tmp == 0) {
        goto while_break;
      }
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)name_u);
  }
  return (i___0 + 1);
}
}
int highlight_exists(char_u *name___1 ) 
{








}
static int syn_namen2id(char_u *linep , int len___0 ) 
{
















}
int syn_check_group(char_u *pp , int len___0 ) 
{ 
  int id ;
  char_u *name___1 ;

  {
  {
  name___1 = vim_strnsave(pp, len___0);
  }
  if ((unsigned long )name___1 == (unsigned long )((void *)0)) {

  }
  {
  id = syn_name2id(name___1);
  }
  if (id == 0) {
    {
    id = syn_add_group(name___1);
    }
  } else {
    {
    vim_free((void *)name___1);
    }
  }
  return (id);
}
}
static int syn_add_group(char_u *name___1 ) 
{ 
  int tmp ;

  {
  if ((unsigned long )highlight_ga.ga_data == (unsigned long )((void *)0)) {
    highlight_ga.ga_itemsize = (int )sizeof(struct hl_group );
    highlight_ga.ga_growsize = 10;
  }
  {
  tmp = ga_grow(& highlight_ga, 1);
  }
  if (tmp == 0) {
    {

    }

  }
  {
  memset((void *)((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len),
         0, sizeof(struct hl_group ));
  ((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name = name___1;
  ((struct hl_group *)highlight_ga.ga_data + highlight_ga.ga_len)->sg_name_u = vim_strsave_up(name___1);
  (highlight_ga.ga_len) ++;
  (highlight_ga.ga_room) --;
  }
  return (highlight_ga.ga_len);
}
}
static void syn_unadd_group(void) 
{











}
int syn_id2attr(int hl_id ) 
{ 
  int attr ;
  struct hl_group *sgp ;

  {
  {
  hl_id = syn_get_final_id(hl_id);
  sgp = (struct hl_group *)highlight_ga.ga_data + (hl_id - 1);
  }
  if (*(term_strings[34])) {
    attr = sgp->sg_cterm_attr;
  } else {
    attr = sgp->sg_term_attr;
  }
  return (attr);
}
}
int syn_get_final_id(int hl_id ) 
{ 
  int count___2 ;
  struct hl_group *sgp ;

  {
  if (hl_id > highlight_ga.ga_len) {

  } else { //Added block
  if (hl_id < 1) {

  }
  }
  count___2 = 100;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    count___2 --;
    if (! (count___2 >= 0)) {

    }
    sgp = (struct hl_group *)highlight_ga.ga_data + (hl_id - 1);
    if (sgp->sg_link == 0) {
      goto while_break;
    } else { //Added block



    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return (hl_id);
}
}
static int hl_flags[18]  = 
  {      '8',      '@',      'd',      'e', 
        'h',      'i',      'l',      'm', 
        'M',      'n',      'r',      's', 
        'S',      't',      'v',      'V', 
        'w',      'W'};
int highlight_changed(void) 
{ 
  int hlf ;
  int i___0 ;
  char_u *p___0 ;
  int attr ;
  char_u *end ;
  int id ;
  char_u userhl[10] ;
  int id_SNC ;
  int id_S ;
  int hlcnt ;
  size_t tmp ;
  int tmp___0 ;
  struct hl_group *hlt ;

  {
  id_SNC = -1;
  id_S = -1;
  need_highlight_changed = 0;
  hlf = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (hlf < 18)) {
      goto while_break;
    }
    highlight_attr[hlf] = 0;
    hlf ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < 2)) {
      goto while_break___0;
    }
    if (i___0) {
      p___0 = p_hl;
    } else {
      {
      p___0 = get_highlight_default();
      }
    }
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {

    }
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! *p___0) {
        goto while_break___1;
      }
      hlf = 0;
      {
      while (1) {
        while_continue___2: ;/* CIL Label */ ;
        if (! (hlf < 18)) {

        }
        if (hl_flags[hlf] == (int )*p___0) {
          goto while_break___2;
        }
        hlf ++;
      }
      while_break___2: ;/* CIL Label */ ;
      }
      p___0 ++;
      if (hlf == 18) {

      } else { //Added block
      if ((int )*p___0 == 0) {

      }
      }
      attr = 0;
      {
      while (1) {
        while_continue___3: ;/* CIL Label */ ;
        if (*p___0) {
          if (! ((int )*p___0 != 44)) {
            goto while_break___3;
          }
        } else {
          goto while_break___3;
        }
        if ((int )*p___0 == 32) {

        } else { //Added block
        if ((int )*p___0 == 9) {

        }
        }
        if (attr > 31) {

        }
        {
        if ((int )*p___0 == 98) {

        }
        if ((int )*p___0 == 105) {

        }
        if ((int )*p___0 == 45) {

        }
        if ((int )*p___0 == 110) {

        }
        if ((int )*p___0 == 114) {

        }
        if ((int )*p___0 == 115) {

        }
        if ((int )*p___0 == 117) {

        }
        if ((int )*p___0 == 58) {
          goto case_58;
        }

        case_98: ;/* CIL Label */ 


        case_105: ;/* CIL Label */ 


        case_45: ;/* CIL Label */ 
        case_110: ;/* CIL Label */ 

        case_114: ;/* CIL Label */ 


        case_115: ;/* CIL Label */ 


        case_117: ;/* CIL Label */ 


        case_58: ;/* CIL Label */ 
        p___0 ++;
        if (attr) {

        } else { //Added block
        if ((int )*p___0 == 0) {

        }
        }
        {
        end = vim_strchr(p___0, ',');
        }
        if ((unsigned long )end == (unsigned long )((void *)0)) {
          {
          tmp = strlen((char const   *)((char *)p___0));
          end = p___0 + tmp;
          }
        }
        {
        id = syn_check_group(p___0, (int )(end - p___0));
        }
        if (id == 0) {

        }
        {
        attr = syn_id2attr(id);
        p___0 = end - 1;
        }
        if (hlf == 12) {
          {
          id_SNC = syn_get_final_id(id);
          }
        } else { //Added block
        if (hlf == 11) {
          {
          id_S = syn_get_final_id(id);
          }
        }
        }
        goto switch_break;
        switch_default: ;/* CIL Label */ 

        switch_break: ;/* CIL Label */ ;
        }
        __Cont___0: ;
        p___0 ++;
      }
      while_break___3: ;/* CIL Label */ ;
      }
      {
      highlight_attr[hlf] = attr;
      p___0 = skip_to_option_part(p___0);
      }
    }
    while_break___1: ;/* CIL Label */ ;
    }
    __Cont: ;
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  tmp___0 = ga_grow(& highlight_ga, 10);
  }
  if (tmp___0 == 0) {

  }
  hlcnt = highlight_ga.ga_len;
  if (id_S == 0) {
    {



    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___4: ;/* CIL Label */ ;
    if (! (i___0 < 9)) {
      goto while_break___4;
    }
    {
    sprintf((char * __restrict  )((char *)(userhl)), (char const   * __restrict  )"User%d",
            i___0 + 1);
    id = syn_name2id(userhl);
    }
    if (id == 0) {
      highlight_user[i___0] = 0;
      highlight_stlnc[i___0] = 0;
    } else {
      {


      }



























      {



      }
    }
    i___0 ++;
  }
  while_break___4: ;/* CIL Label */ ;
  }
  highlight_ga.ga_len = hlcnt;
  return (1);
}
}
static void highlight_list(void) ;
static void highlight_list_two(int cnt , int attr ) ;
void set_context_in_highlight_cmd(char_u *arg ) 
{





















































}
static void highlight_list(void) 
{

































}
static void highlight_list_two(int cnt , int attr ) 
{


















}
char_u *get_highlight_name(int idx ) 
{






















}
#pragma merger("0","/tmp/cil-FIDR198i.i","-O0")
extern void rewind(FILE *__stream ) ;
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
extern __off_t ftello(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
void simplify_filename(char_u *filename ) ;
static char *mt_names[8]  = 
  {      (char *)"FSC",      (char *)"F C",      (char *)"F  ",      (char *)"FS ", 
        (char *)" SC",      (char *)"  C",      (char *)"   ",      (char *)" S "};
static char_u *nofile_fname  =    (char_u *)((void *)0);
static void taglen_advance(int l ) ;
static int get_tagfname(int first___0 , char_u *buf___3 ) ;
static int jumpto_tag(char_u *lbuf , int forceit ) ;
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) ;
static int test_for_static(struct tag_pointers *tagp ) ;
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) ;
static char_u *tag_full_fname(struct tag_pointers *tagp ) ;
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) ;
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) ;
static int find_extra(char_u **pp ) ;
static char_u *bottommsg  =    (char_u *)"at bottom of tag stack";
static char_u *topmsg  =    (char_u *)"at top of tag stack";
static char_u *tagmatchname  =    (char_u *)((void *)0);
static int num_matches  =    0;
static int max_num_matches  =    0;
static char_u **matches  =    (char_u **)((void *)0);
static int flags  ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) 
{
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
void tag_freematch(void) 
{ 


  {
  {
  vim_free((void *)tagmatchname);
  tagmatchname = (char_u *)((void *)0);
  }
  return;
}
}
static void taglen_advance(int l ) 
{















}
void do_tags(void) 
{




































































}
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) 
{ 
  FILE *fp___0 ;
  char_u *lbuf ;
  char_u *tag_fname ;
  int first_file ;
  struct tag_pointers tagp ;
  int did_open ;
  int stop_searching ;
  int retval ;
  int is_static ;
  int is_current ;
  int eof ;
  char_u *p___0 ;
  char_u *s ;
  int i___0 ;
  vim_regexp *prog ;
  struct tag_search_info search_info ;
  off_t filesize ;
  int tagcmp ;
  off_t offset ;
  enum __anonenum_state_169 state ;
  int cmplen ;
  int match ;
  int match_no_ic ;
  int match_re ;
  int matchoff ;
  struct growarray ga_match[16] ;
  int match_count ;
  char_u **matches___0 ;
  int mtt ;
  int len___0 ;
  int help_save ;
  int patlen ;
  char_u *pathead ;
  int patheadlen ;
  int findall ;
  int tmp ;
  int sort_error ;
  int linear ;
  int has_re ;
  int help_only ;
  int name_only ;
  int noic ;
  int get_it_again ;
  int verbose ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char_u *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  __off_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int cc___0 ;
  int tmp___19 ;
  int tmp___20 ;
  char_u *temp_end ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char_u *tmp___28 ;
  int tmp___29 ;

  {
  did_open = 0;
  stop_searching = 0;
  retval = 0;
  eof = 0;
  prog = (vim_regexp *)((void *)0);
  match_no_ic = 0;
  matchoff = 0;
  match_count = 0;
  if (mincount == 2147483647) {
    tmp = 1;
  } else { //Added block





  }
  findall = tmp;
  sort_error = 0;
  has_re = flags___0 & 4;
  help_only = flags___0 & 1;
  name_only = flags___0 & 2;
  noic = flags___0 & 8;
  get_it_again = 0;
  verbose = flags___0 & 32;
  help_save = curbuf->b_help;
  if (has_re) {
    {
    prog = vim_regcomp(pat, p_magic);
    }
  }
  {
  lbuf = alloc(512U);
  tag_fname = alloc(513U);
  mtt = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (mtt < 16)) {
      goto while_break;
    }
    {
    ga_init2(& ga_match[mtt], (int )sizeof(char_u *), 100);
    mtt ++;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )tag_fname == (unsigned long )((void *)0)) {

  }
  }
  if (help_only) {
    curbuf->b_help = 1;
  }
  {
  tmp___0 = strlen((char const   *)((char *)pat));
  patlen = (int )tmp___0;
  }
  if (p_tl != 0L) {



  }
  pathead = pat;
  patheadlen = patlen;
  if (has_re) {
    if ((int )*(pat + 0) == 94) {

    } else { //Added block
    if ((int )*(pat + 0) == 92) {



    }
    }
    if ((unsigned long )pathead == (unsigned long )pat) {
      patheadlen = 0;
    } else {

      {


















      while_break___0: ;/* CIL Label */ ;
      }
    }
    if (p_tl != 0L) {



    }
  }
  if (p_ic) {

  } else { //Added block
  if (! noic) {
    _L: ;
    if (findall) {
      tmp___3 = 1;
    } else { //Added block









    }
  } else {

  }
  }
  reg_ic = tmp___3;
  {
  while (1) {
    while_continue___1: ;/* CIL Label */ ;
    if (reg_ic) {
      tmp___4 = 1;
    } else { //Added block









    }
    linear = tmp___4;
    first_file = 1;
    {
    while (1) {
      while_continue___2: ;/* CIL Label */ ;
      {
      tmp___27 = get_tagfname(first_file, tag_fname);
      }
      if (! (tmp___27 == 1)) {
        goto while_break___2;
      }
      {
      fp___0 = fopen((char const   * __restrict  )((char *)tag_fname), (char const   * __restrict  )"r");
      }
      if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
        goto __Cont;
      }


      {









































































































































































































































































































































































































































































































































































      while_break___3: ;/* CIL Label */ ;
      }
      {

      }













      __Cont: ;
      first_file = 0;
    }
    while_break___2: ;/* CIL Label */ ;
    }
    if (stop_searching) {

    } else { //Added block
    if (linear) {
      goto while_break___1;
    } else { //Added block





    }
    }

  }
  while_break___1: ;/* CIL Label */ ;
  }
  if (! stop_searching) {
    if (! did_open) {
      if (verbose) {
        {
        emsg((char_u *)"No tags file");
        }
      }
    }
    retval = 1;
  }
  findtag_end: ;
  {
  vim_free((void *)lbuf);
  vim_free((void *)prog);
  vim_free((void *)tag_fname);
  }
  if (retval == 0) {

  }
  if (match_count > 0) {
    {


    }
  } else {
    matches___0 = (char_u **)((void *)0);
  }
  match_count = 0;
  mtt = 0;
  {
  while (1) {
    while_continue___9: ;/* CIL Label */ ;
    if (! (mtt < 16)) {
      goto while_break___9;
    }
    i___0 = 0;
    {
    while (1) {
      while_continue___10: ;/* CIL Label */ ;
      if (! (i___0 < ga_match[mtt].ga_len)) {
        goto while_break___10;
      }











    }
    while_break___10: ;/* CIL Label */ ;
    }
    {
    ga_clear(& ga_match[mtt]);
    mtt ++;
    }
  }
  while_break___9: ;/* CIL Label */ ;
  }
  *matchesp = matches___0;
  *num_matches___0 = match_count;
  curbuf->b_help = help_save;
  return (retval);
}
}
static char_u *np  =    (char_u *)((void *)0);
static struct visited *first_visited  =    (struct visited *)((void *)0);
static int get_tagfname(int first___0 , char_u *buf___3 ) 
{ 
  char_u *fname ;
  size_t path_len ;
  size_t fname_len ;
  struct visited *vp ;
  struct stat st ;
  char_u *tmp ;
  char_u *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char_u *tmp___3 ;
  int tmp___4 ;
  char_u *tmp___5 ;

  {
  if (first___0) {
    np = p_tags;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((unsigned long )first_visited != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {



      }
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    return (0);
  }
  if (curbuf->b_help) {
    {
    tmp = gettail(p_hf);
    path_len = (size_t )(tmp - p_hf);
    }
    if (path_len + 9UL >= 512UL) {

    }
    {
    memmove((void *)((char *)buf___3), (void const   *)((char *)p_hf), path_len);
    strcpy((char * __restrict  )((char *)(buf___3 + path_len)), (char const   * __restrict  )((char *)"tags"));
    np = (char_u *)((void *)0);
    }
  } else {
    {

























































































    while_break___0: ;/* CIL Label */ ;
    }
  }
  return (1);
}
}
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) 
{































}
static int test_for_static(struct tag_pointers *tagp ) 
{











































}
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) 
{































































































}
static char_u *tag_full_fname(struct tag_pointers *tagp ) 
{












}
static int jumpto_tag(char_u *lbuf , int forceit ) 
{

























































































































































































































































































































}
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) 
{



































































}
void simplify_filename(char_u *filename ) 
{







































































































































































































}
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) 
{
























}
static int find_extra(char_u **pp ) 
{






































































}
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) 
{














































































}
#pragma merger("0","/tmp/cil-x_nT2aar.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
void del_termcode(char_u *name___1 ) ;
int find_term_bykeys(char_u *src ) ;
void ui_write(char_u *s , int len___0 ) ;
void screen_new_rows(void) ;
extern char PC ;
extern char *UP ;
extern char *BC ;
extern short ospeed ;
extern char *tgoto(char const   * , int  , int  ) ;
extern int tgetent(char * , char const   * ) ;
extern int tgetflag(char const   * ) ;
extern int tgetnum(char const   * ) ;
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
static struct builtin_term *find_builtin_term(char_u *term ) ;
static void parse_builtin_tcap(char_u *term ) ;
static void term_color(char_u *s , int n ) ;
static void gather_termleader(void) ;
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) ;
static int term_is_builtin(char_u *name___1 ) ;
static int term_7to8bit(char_u *p___0 ) ;
static char_u *tgetent_error(char_u *tbuf , char_u *term ) ;
extern char *tgetstr(char * , char ** ) ;
static int need_get_crv  =    1;
static char_u *vim_tgetstr(char *s , char_u **pp ) ;
struct builtin_term builtin_termcaps[181]  = 
  {      {0, (char *)"ansi"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {14, (char *)"\033[0m"}, 
        {15, (char *)"\033[7m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {0, (char *)"xterm"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {6, (char *)"\033[%i%p1%d;%p2%dr"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {8, (char *)"\033[J"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {28, (char *)"\033[?1h\033="}, 
        {29, (char *)"\033[?1l\033>"}, 
        {43, (char *)"\033]1;"}, 
        {44, (char *)"\a"}, 
        {45, (char *)"\033]2;"}, 
        {46, (char *)"\a"}, 
        {48, (char *)"\033[8;%p1%d;%p2%dt"}, 
        {47, (char *)"\033[3;%p1%d;%p2%dt"}, 
        {49, (char *)"\033[>c"}, 
        {107 + (117 << 8), (char *)"\033OA"}, 
        {107 + (100 << 8), (char *)"\033OB"}, 
        {107 + (114 << 8), (char *)"\033OC"}, 
        {107 + (108 << 8), (char *)"\033OD"}, 
        {253 + (4 << 8), (char *)"\033O2A"}, 
        {253 + (5 << 8), (char *)"\033O2B"}, 
        {37 + (105 << 8), (char *)"\033O2C"}, 
        {35 + (52 << 8), (char *)"\033O2D"}, 
        {253 + (55 << 8), (char *)"\033OP"}, 
        {253 + (56 << 8), (char *)"\033OQ"}, 
        {253 + (57 << 8), (char *)"\033OR"}, 
        {253 + (58 << 8), (char *)"\033OS"}, 
        {107 + (49 << 8), (char *)"\033[11~"}, 
        {107 + (50 << 8), (char *)"\033[12~"}, 
        {107 + (51 << 8), (char *)"\033[13~"}, 
        {107 + (52 << 8), (char *)"\033[14~"}, 
        {107 + (53 << 8), (char *)"\033[15~"}, 
        {107 + (54 << 8), (char *)"\033[17~"}, 
        {107 + (55 << 8), (char *)"\033[18~"}, 
        {107 + (56 << 8), (char *)"\033[19~"}, 
        {107 + (57 << 8), (char *)"\033[20~"}, 
        {107 + (59 << 8), (char *)"\033[21~"}, 
        {70 + (49 << 8), (char *)"\033[23~"}, 
        {70 + (50 << 8), (char *)"\033[24~"}, 
        {253 + (63 << 8), (char *)"\033O2P"}, 
        {253 + (64 << 8), (char *)"\033O2Q"}, 
        {253 + (65 << 8), (char *)"\033O2R"}, 
        {253 + (66 << 8), (char *)"\033O2S"}, 
        {253 + (6 << 8), (char *)"\033[11;2~"}, 
        {253 + (7 << 8), (char *)"\033[12;2~"}, 
        {253 + (8 << 8), (char *)"\033[13;2~"}, 
        {253 + (9 << 8), (char *)"\033[14;2~"}, 
        {253 + (10 << 8), (char *)"\033[15;2~"}, 
        {253 + (11 << 8), (char *)"\033[17;2~"}, 
        {253 + (12 << 8), (char *)"\033[18;2~"}, 
        {253 + (13 << 8), (char *)"\033[19;2~"}, 
        {253 + (14 << 8), (char *)"\033[20;2~"}, 
        {253 + (15 << 8), (char *)"\033[21;2~"}, 
        {253 + (16 << 8), (char *)"\033[23;2~"}, 
        {253 + (17 << 8), (char *)"\033[24;2~"}, 
        {37 + (49 << 8), (char *)"\033[28~"}, 
        {38 + (56 << 8), (char *)"\033[26~"}, 
        {107 + (73 << 8), (char *)"\033[2~"}, 
        {107 + (104 << 8), (char *)"\033[7~"}, 
        {35 + (50 << 8), (char *)"\033O2H"}, 
        {75 + (49 << 8), (char *)"\033[1~"}, 
        {253 + (60 << 8), (char *)"\033OH"}, 
        {64 + (55 << 8), (char *)"\033[8~"}, 
        {42 + (55 << 8), (char *)"\033O2F"}, 
        {75 + (52 << 8), (char *)"\033[4~"}, 
        {253 + (59 << 8), (char *)"\033OF"}, 
        {107 + (80 << 8), (char *)"\033[5~"}, 
        {107 + (78 << 8), (char *)"\033[6~"}, 
        {75 + (54 << 8), (char *)"\033Ok"}, 
        {75 + (55 << 8), (char *)"\033Om"}, 
        {75 + (56 << 8), (char *)"\033Oo"}, 
        {75 + (57 << 8), (char *)"\033Oj"}, 
        {75 + (65 << 8), (char *)"\033OM"}, 
        {253 + (70 << 8), (char *)"\033[3~"}, 
        {257, (char *)""}, 
        {107 + (48 << 8), (char *)"\033[10~"}, 
        {70 + (51 << 8), (char *)"\033[25~"}, 
        {70 + (54 << 8), (char *)"\033[29~"}, 
        {70 + (55 << 8), (char *)"\033[31~"}, 
        {70 + (56 << 8), (char *)"\033[32~"}, 
        {70 + (57 << 8), (char *)"\033[33~"}, 
        {70 + (65 << 8), (char *)"\033[34~"}, 
        {0, (char *)"iris-ansi"}, 
        {1, (char *)"\033[K"}, 
        {8, (char *)"\033[J"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {12, (char *)"\033[9/y\033[12/y"}, 
        {13, (char *)"\033[10/y\033[=1h\033[=2l"}, 
        {30, (char *)"\033[=6h"}, 
        {31, (char *)"\033[=6l"}, 
        {17, (char *)"\033[m"}, 
        {18, (char *)"\033[1;7m"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {34, (char *)"8"}, 
        {40, (char *)"\033[4%p1%dm"}, 
        {39, (char *)"\033[3%p1%dm"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {43, (char *)"\033P3.y"}, 
        {44, (char *)"\234"}, 
        {45, (char *)"\033P1.y"}, 
        {46, (char *)"\234"}, 
        {48, (char *)"\033[203;%p1%d;%p2%d/y"}, 
        {107 + (117 << 8), (char *)"\033[A"}, 
        {107 + (100 << 8), (char *)"\033[B"}, 
        {107 + (108 << 8), (char *)"\033[D"}, 
        {107 + (114 << 8), (char *)"\033[C"}, 
        {253 + (4 << 8), (char *)"\033[161q"}, 
        {253 + (5 << 8), (char *)"\033[164q"}, 
        {35 + (52 << 8), (char *)"\033[158q"}, 
        {37 + (105 << 8), (char *)"\033[167q"}, 
        {107 + (49 << 8), (char *)"\033[001q"}, 
        {107 + (50 << 8), (char *)"\033[002q"}, 
        {107 + (51 << 8), (char *)"\033[003q"}, 
        {107 + (52 << 8), (char *)"\033[004q"}, 
        {107 + (53 << 8), (char *)"\033[005q"}, 
        {107 + (54 << 8), (char *)"\033[006q"}, 
        {107 + (55 << 8), (char *)"\033[007q"}, 
        {107 + (56 << 8), (char *)"\033[008q"}, 
        {107 + (57 << 8), (char *)"\033[009q"}, 
        {107 + (59 << 8), (char *)"\033[010q"}, 
        {70 + (49 << 8), (char *)"\033[011q"}, 
        {70 + (50 << 8), (char *)"\033[012q"}, 
        {253 + (6 << 8), (char *)"\033[013q"}, 
        {253 + (7 << 8), (char *)"\033[014q"}, 
        {253 + (8 << 8), (char *)"\033[015q"}, 
        {253 + (9 << 8), (char *)"\033[016q"}, 
        {253 + (10 << 8), (char *)"\033[017q"}, 
        {253 + (11 << 8), (char *)"\033[018q"}, 
        {253 + (12 << 8), (char *)"\033[019q"}, 
        {253 + (13 << 8), (char *)"\033[020q"}, 
        {253 + (14 << 8), (char *)"\033[021q"}, 
        {253 + (15 << 8), (char *)"\033[022q"}, 
        {253 + (16 << 8), (char *)"\033[023q"}, 
        {253 + (17 << 8), (char *)"\033[024q"}, 
        {107 + (73 << 8), (char *)"\033[139q"}, 
        {107 + (104 << 8), (char *)"\033[H"}, 
        {64 + (55 << 8), (char *)"\033[146q"}, 
        {107 + (80 << 8), (char *)"\033[150q"}, 
        {107 + (78 << 8), (char *)"\033[154q"}, 
        {0, (char *)"dumb"}, 
        {7, (char *)"\f"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {0, (char *)((void *)0)}};
static int need_gather  =    0;
static char_u termleader[257]  ;
static struct builtin_term *find_builtin_term(char_u *term ) 
{ 
  struct builtin_term *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  p___0 = builtin_termcaps;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )p___0->bt_string != (unsigned long )((void *)0))) {

    }
    if (p___0->bt_entry == 0) {
      {
      tmp___2 = strcmp((char const   *)p___0->bt_string, (char const   *)((char *)"iris-ansi"));
      }
      if (tmp___2 == 0) {
        {

        }





      } else {
        _L___0: ;
        {
        tmp___0 = strcmp((char const   *)p___0->bt_string, (char const   *)((char *)"xterm"));
        }
        if (tmp___0 == 0) {
          {
          tmp___1 = vim_is_xterm(term);
          }
          if (tmp___1) {
            return (p___0);
          } else {

          }
        } else {
          _L: ;
          {
          tmp = strcmp((char const   *)((char *)term), (char const   *)p___0->bt_string);
          }
          if (tmp == 0) {

          }
        }
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }

}
}
static void parse_builtin_tcap(char_u *term ) 
{ 
  struct builtin_term *p___0 ;
  char_u name___1[2] ;
  int term_8bit ;
  char_u *s ;
  char_u *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  {
  p___0 = find_builtin_term(term);
  term_8bit = term_is_8bit(term);
  p___0 ++;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (p___0->bt_entry != 0) {
      if (! (p___0->bt_entry != 257)) {
        goto while_break;
      }
    } else {

    }
    if (p___0->bt_entry < 256) {
      if ((unsigned long )term_strings[p___0->bt_entry] == (unsigned long )((void *)0)) {

      } else { //Added block
      if ((unsigned long )term_strings[p___0->bt_entry] == (unsigned long )empty_option) {
        _L: ;
        if (term_8bit) {
          {

          }


































        } else {
          term_strings[p___0->bt_entry] = (char_u *)p___0->bt_string;
        }
      }
      }
    } else {
      {
      name___1[0] = (char_u )(p___0->bt_entry & 255);
      name___1[1] = (char_u )(((unsigned int )p___0->bt_entry >> 8) & 255U);
      tmp___2 = find_termcode(name___1);
      }
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
        add_termcode(name___1, (char_u *)p___0->bt_string, term_8bit);
        }
      }
    }
    p___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static char nr_colors[15]  ;
static char_u tstrbuf[2048]  ;
static char *key_names[31]  = 
  {      (char *)"ku",      (char *)"kd",      (char *)"kr",      (char *)"#4", 
        (char *)"%i",      (char *)"k1",      (char *)"k2",      (char *)"k3", 
        (char *)"k4",      (char *)"k5",      (char *)"k6",      (char *)"k7", 
        (char *)"k8",      (char *)"k9",      (char *)"k;",      (char *)"F1", 
        (char *)"F2",      (char *)"%1",      (char *)"&8",      (char *)"kb", 
        (char *)"kI",      (char *)"kD",      (char *)"kh",      (char *)"@7", 
        (char *)"kP",      (char *)"kN",      (char *)"K1",      (char *)"K3", 
        (char *)"K4",      (char *)"K5",      (char *)((void *)0)};
static struct __anonstruct_string_names_169 string_names[45]  = 
  {      {(enum SpecialKey )1, (char *)"ce"}, 
        {(enum SpecialKey )2, (char *)"al"}, 
        {(enum SpecialKey )3, (char *)"AL"}, 
        {(enum SpecialKey )4, (char *)"dl"}, 
        {(enum SpecialKey )5, (char *)"DL"}, 
        {(enum SpecialKey )6, (char *)"cs"}, 
        {(enum SpecialKey )7, (char *)"cl"}, 
        {(enum SpecialKey )8, (char *)"cd"}, 
        {(enum SpecialKey )11, (char *)"vi"}, 
        {(enum SpecialKey )12, (char *)"ve"}, 
        {(enum SpecialKey )38, (char *)"mb"}, 
        {(enum SpecialKey )13, (char *)"vs"}, 
        {(enum SpecialKey )14, (char *)"me"}, 
        {(enum SpecialKey )15, (char *)"mr"}, 
        {(enum SpecialKey )16, (char *)"md"}, 
        {(enum SpecialKey )17, (char *)"se"}, 
        {(enum SpecialKey )18, (char *)"so"}, 
        {(enum SpecialKey )19, (char *)"ZH"}, 
        {(enum SpecialKey )20, (char *)"ZR"}, 
        {(enum SpecialKey )21, (char *)"ue"}, 
        {(enum SpecialKey )22, (char *)"us"}, 
        {(enum SpecialKey )24, (char *)"cm"}, 
        {(enum SpecialKey )25, (char *)"sr"}, 
        {(enum SpecialKey )26, (char *)"RI"}, 
        {(enum SpecialKey )27, (char *)"vb"}, 
        {(enum SpecialKey )28, (char *)"ks"}, 
        {(enum SpecialKey )29, (char *)"ke"}, 
        {(enum SpecialKey )30, (char *)"ti"}, 
        {(enum SpecialKey )31, (char *)"te"}, 
        {(enum SpecialKey )32, (char *)"bc"}, 
        {(enum SpecialKey )36, (char *)"Sb"}, 
        {(enum SpecialKey )35, (char *)"Sf"}, 
        {(enum SpecialKey )40, (char *)"AB"}, 
        {(enum SpecialKey )39, (char *)"AF"}, 
        {(enum SpecialKey )41, (char *)"le"}, 
        {(enum SpecialKey )42, (char *)"nd"}, 
        {(enum SpecialKey )50, (char *)"op"}, 
        {(enum SpecialKey )49, (char *)"RV"}, 
        {(enum SpecialKey )43, (char *)"IS"}, 
        {(enum SpecialKey )44, (char *)"IE"}, 
        {(enum SpecialKey )45, (char *)"ts"}, 
        {(enum SpecialKey )46, (char *)"fs"}, 
        {(enum SpecialKey )47, (char *)"WP"}, 
        {(enum SpecialKey )48, (char *)"WS"}, 
        {(enum SpecialKey )0, (char *)((void *)0)}};
int set_termname(char_u *term ) 
{ 
  struct builtin_term *termp ;
  int builtin_first ;
  int try ;
  int termcap_cleared ;
  int width ;
  int height ;
  char_u *error_msg ;
  char_u *bs_p ;
  char_u *del_p ;
  int tmp ;
  char_u *p___0 ;
  int i___0 ;
  char_u tbuf[2048] ;
  char_u *tp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  char_u *tmp___6 ;
  char_u *tmp___7 ;
  char_u *tmp___8 ;
  int tmp___9 ;
  char_u *p___1 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  BUF *old_curbuf ;
  int tmp___13 ;

  {
  {
  builtin_first = p_tbi;
  termcap_cleared = 0;
  width = 0;
  height = 0;
  error_msg = (char_u *)((void *)0);
  tmp = term_is_builtin(term);
  }
  if (tmp) {


  }
  if (builtin_first) {
    try = 0;
  } else {

  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (try < 3)) {

    }
    if (try == 1) {
      {
      error_msg = tgetent_error(tbuf, term);
      }
      if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
        tp = tstrbuf;
        if (! termcap_cleared) {
          {


          }
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___0: ;/* CIL Label */ ;
          if (! ((unsigned long )string_names[i___0].name != (unsigned long )((void *)0))) {
            goto while_break___0;
          }
          if ((unsigned long )term_strings[(int )string_names[i___0].dest] == (unsigned long )((void *)0)) {
            {


            }
          } else { //Added block
          if ((unsigned long )term_strings[(int )string_names[i___0].dest] == (unsigned long )empty_option) {
            {
            term_strings[(int )string_names[i___0].dest] = vim_tgetstr(string_names[i___0].name,
                                                                       & tp);
            }
          }
          }
          i___0 ++;
        }
        while_break___0: ;/* CIL Label */ ;
        }
        if ((unsigned long )term_strings[23] == (unsigned long )((void *)0)) {

        } else { //Added block
        if ((unsigned long )term_strings[23] == (unsigned long )empty_option) {
          _L: ;
          {

          }



        }
        }
        if ((unsigned long )term_strings[37] == (unsigned long )((void *)0)) {

        } else { //Added block
        if ((unsigned long )term_strings[37] == (unsigned long )empty_option) {
          _L___0: ;
          {
          tmp___1 = tgetflag("xs");
          }
          if (tmp___1) {

          }
        }
        }
        if ((unsigned long )term_strings[10] == (unsigned long )((void *)0)) {

        } else { //Added block
        if ((unsigned long )term_strings[10] == (unsigned long )empty_option) {
          _L___1: ;
          {
          tmp___2 = tgetflag("db");
          }
          if (tmp___2) {

          }
        }
        }
        if ((unsigned long )term_strings[9] == (unsigned long )((void *)0)) {

        } else { //Added block
        if ((unsigned long )term_strings[9] == (unsigned long )empty_option) {
          _L___2: ;
          {
          tmp___3 = tgetflag("da");
          }
          if (tmp___3) {

          }
        }
        }
        i___0 = 0;
        {
        while (1) {
          while_continue___1: ;/* CIL Label */ ;
          if (! ((unsigned long )key_names[i___0] != (unsigned long )((void *)0))) {
            goto while_break___1;
          }
          {
          tmp___5 = find_termcode((char_u *)key_names[i___0]);
          }
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
            tmp___4 = vim_tgetstr(key_names[i___0], & tp);
            add_termcode((char_u *)key_names[i___0], tmp___4, 0);
            }
          }
          i___0 ++;
        }
        while_break___1: ;/* CIL Label */ ;
        }
        {
        tmp___6 = find_termcode((char_u *)"kl");
        }
        if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
          {

          }







        }
        if (height == 0) {
          {
          height = tgetnum("li");
          }
        }
        if (width == 0) {
          {
          width = tgetnum("co");
          }
        }
        {
        i___0 = tgetnum("Co");
        }
        if (i___0 > 0) {
          {
          sprintf((char * __restrict  )(nr_colors), (char const   * __restrict  )"%d",
                  i___0);
          term_strings[34] = (char_u *)(nr_colors);
          }
        }
        {
        tmp___7 = vim_tgetstr((char *)"bc", & tp);
        BC = (char *)tmp___7;
        tmp___8 = vim_tgetstr((char *)"up", & tp);
        UP = (char *)tmp___8;
        p___0 = vim_tgetstr((char *)"pc", & tp);
        }
        if (p___0) {

        }
      }
    } else {
      if (try == 2) {
        if (builtin_first) {
          if (termcap_cleared) {
            goto while_break;
          }
        }
      }
      {
      termp = find_builtin_term(term);
      }
      if ((unsigned long )termp->bt_string == (unsigned long )((void *)0)) {






        {

        }








        {




        }
        {

















        while_break___2: ;/* CIL Label */ ;
        }







        {









        }
      }
      {
      out_flush();
      }
      if (! termcap_cleared) {
        {
        clear_termoptions();
        termcap_cleared = 1;
        }
      }
      {
      parse_builtin_tcap(term);
      }
    }
    __Cont: ;
    try ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  tmp___9 = strcmp((char const   *)((char *)term), (char const   *)((char *)"pcterm"));
  }
  if (tmp___9 == 0) {

  } else {
    term_strings[33] = empty_option;
  }
  {
  get_stty();
  bs_p = find_termcode((char_u *)"kb");
  del_p = find_termcode((char_u *)"kD");
  }
  if ((unsigned long )bs_p == (unsigned long )((void *)0)) {
    {


    }
  } else { //Added block
  if ((int )*bs_p == 0) {
    {


    }
  }
  }
  if ((unsigned long )del_p == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*del_p == 0) {
    _L___3: ;











  }
  }
  {
  p___1 = (char_u *)"";
  clip_init(0);
  tmp___11 = vim_is_xterm(term);
  }
  if (tmp___11) {
    {
    tmp___10 = use_xterm_mouse();
    }
    if (tmp___10) {

    } else {
      p___1 = (char_u *)"xterm";
    }
    {
    setup_xterm_clip();
    }
  }
  if ((unsigned long )p___1 != (unsigned long )((void *)0)) {
    {
    set_option_value((char_u *)"ttym", 0L, p___1);
    }
  } else {
    {

    }
  }
  {
  tmp___12 = vim_is_fastterm(term);
  }
  if (tmp___12) {
    p_tf = 1;
  }
  {
  ttest(1);
  full_screen = 1;
  set_term_defaults();
  need_get_crv = 1;
  }
  if (starting != 2) {
    {



    }
  }
  if (width <= 0) {


  } else { //Added block
  if (height <= 0) {


  }
  }
  {
  set_winsize(width, height, 0);
  }
  if (starting != 2) {





    {



    }
    {













    while_break___3: ;/* CIL Label */ ;
    }
    {

    }



  }
  return (1);
}
}
static int has_mouse_termcode  =    0;
void set_mouse_termcode(int n , char_u *s ) 
{ 
  char_u name___1[2] ;

  {
  {
  name___1[0] = (char_u )n;
  name___1[1] = (char_u )'X';
  add_termcode(name___1, s, 0);
  has_mouse_termcode |= 1;
  }
  return;
}
}
void del_mouse_termcode(int n ) 
{











}
static char_u *tgetent_error(char_u *tbuf , char_u *term ) 
{ 
  int i___0 ;

  {
  {
  i___0 = tgetent((char *)tbuf, (char const   *)((char *)term));
  }
  if (i___0 < 1) {
    {

    }






  }
  return ((char_u *)((void *)0));
}
}
static char_u *vim_tgetstr(char *s , char_u **pp ) 
{ 
  char *p___0 ;

  {
  {
  p___0 = tgetstr(s, (char **)pp);
  }
  if ((unsigned long )p___0 == (unsigned long )((char *)-1)) {

  }
  return ((char_u *)p___0);
}
}
void getlinecol(void) 
{





























}
int add_termcap_entry(char_u *name___1 , int force ) 
{












































































































}
static int term_is_builtin(char_u *name___1 ) 
{ 
  int tmp ;

  {
  {
  tmp = strncmp((char const   *)((char *)name___1), (char const   *)((char *)"builtin_"),
                (size_t )8);
  }
  return (tmp == 0);
}
}
int term_is_8bit(char_u *name___1 ) 
{ 
  char *tmp ;

  {
  {
  tmp = strstr((char const   *)((char *)name___1), "8bit");
  }
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
static int term_7to8bit(char_u *p___0 ) 
{
















}
void termcapinit(char_u *name___1 ) 
{ 
  char_u *term ;
  char *tmp ;
  char_u *tmp___0 ;

  {
  if ((unsigned long )name___1 != (unsigned long )((void *)0)) {



  }
  term = name___1;
  if ((unsigned long )term == (unsigned long )((void *)0)) {
    {
    tmp = getenv((char const   *)((char *)((char_u *)"TERM")));
    term = (char_u *)tmp;
    }
  }
  if ((unsigned long )term == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((int )*term == 0) {

  }
  }
  {
  set_string_option_direct((char_u *)"term", -1, term, 1);
  set_string_default((char *)"term", term);
  set_string_default((char *)"ttytype", term);
  }
  if ((unsigned long )term_strings[0] != (unsigned long )((void *)0)) {
    tmp___0 = term_strings[0];
  } else {

  }
  {
  set_termname(tmp___0);
  }
  return;
}
}
static char_u out_buf[2048]  ;
static int out_pos  =    0;
void out_flush(void) 
{ 
  int len___0 ;

  {
  if (out_pos != 0) {
    {
    len___0 = out_pos;
    out_pos = 0;
    ui_write(out_buf, len___0);
    }
  }
  return;
}
}
void out_char(unsigned int c ) 
{ 
  int tmp ;

  {
  if (c == 10U) {
    {
    out_char((unsigned int )'\r');
    }
  }
  tmp = out_pos;
  out_pos ++;
  out_buf[tmp] = (char_u )c;
  if (out_pos >= 2047) {
    {
    out_flush();
    }
  } else { //Added block
  if (p_wd) {
    {

    }
  }
  }
  return;
}
}
static void out_char_nf(unsigned int c ) ;
static void out_char_nf(unsigned int c ) 
{ 
  int tmp ;

  {
  if (c == 10U) {
    {

    }
  }
  tmp = out_pos;
  out_pos ++;
  out_buf[tmp] = (char_u )c;
  if (out_pos >= 2047) {
    {

    }
  }
  return;
}
}
void out_str_nf(char_u *s ) 
{ 
  char_u *tmp ;

  {
  if (out_pos > 2027) {
    {

    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *s) {
      goto while_break;
    }
    {
    tmp = s;
    s ++;
    out_char_nf((unsigned int )*tmp);
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if (p_wd) {
    {

    }
  }
  return;
}
}
void out_str(char_u *s ) 
{ 


  {
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    if (*s) {
      if (out_pos > 2027) {
        {

        }
      }
      {
      tputs((char const   *)((char *)s), 1, (int (*)(int  ))((int (*)())(& out_char_nf)));
      }
      if (p_wd) {
        {

        }
      }
    }
  }
  return;
}
}
void term_windgoto(int row , int col ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[24]), col, row);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_cursor_right(int i___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[26]), 0, i___0);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_append_lines(int line_count ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[3]), 0, line_count);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_delete_lines(int line_count ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[5]), 0, line_count);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_set_winpos(int x___0 , int y ) 
{















}
void term_set_winsize(int width , int height ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[48]), height, width);
  out_str((char_u *)tmp);
  }
  return;
}
}
void term_fg_color(int n ) 
{ 


  {
  if (*(term_strings[39])) {
    {
    term_color(term_strings[39], n);
    }
  } else { //Added block





  }
  return;
}
}
void term_bg_color(int n ) 
{ 


  {
  if (*(term_strings[40])) {
    {
    term_color(term_strings[40], n);
    }
  } else { //Added block





  }
  return;
}
}
static void term_color(char_u *s , int n ) 
{ 
  int i___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  i___0 = 2;
  if (n > 7) {
    {

    }
    if (tmp___3 == 16) {
      if ((int )*(s + 0) == 27) {





      } else { //Added block
      _L___1: ;
      if ((int )*(s + 0) == 155) {

        if (i___0 == 1) {
          _L___0: ;
          if ((int )*(s + i___0) != 0) {
            {

            }
            if (tmp___4 == 0) {

            } else {
              {

              }
              if (tmp___5 == 0) {
                _L: ;
























              }
            }
          }
        }
      }
      }
    }
  }
  {
  tmp___6 = tgoto((char const   *)((char *)s), 0, n);
  out_str((char_u *)tmp___6);
  }
  return;
}
}
void term_settitle(char_u *title ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[45]), 0, 0);
  out_str((char_u *)tmp);
  out_str_nf(title);
  out_str(term_strings[46]);
  out_flush();
  }
  return;
}
}
void ttest(int pairs ) 
{ 
  char *t ;

  {
  {
  t = (char *)((void *)0);
  check_options();
  }
  if ((int )*(term_strings[7]) == 0) {

  }
  if ((int )*(term_strings[24]) == 0) {

  }
  if ((unsigned long )t != (unsigned long )((void *)0)) {
    {

    }
  }
  if ((int )*(term_strings[6]) != 0) {
    scroll_region = 1;
  } else {

  }
  if (pairs) {
    if ((int )*(term_strings[14]) == 0) {




    }
    if ((int )*(term_strings[18]) == 0) {


    } else { //Added block
    if ((int )*(term_strings[17]) == 0) {


    }
    }
    if ((int )*(term_strings[22]) == 0) {


    } else { //Added block
    if ((int )*(term_strings[21]) == 0) {


    }
    }
    if ((int )*(term_strings[19]) == 0) {


    } else { //Added block
    if ((int )*(term_strings[20]) == 0) {


    }
    }
    if ((int )*(term_strings[12]) == 0) {

    }
    if ((int )*(term_strings[14]) == 0) {



    }
    if ((int )*(term_strings[18]) == 0) {






    }
    if ((int )*(term_strings[19]) == 0) {






    }
    if ((int )*(term_strings[36]) == 0) {


    } else { //Added block
    if ((int )*(term_strings[35]) == 0) {


    }
    }
    if ((int )*(term_strings[40]) == 0) {


    } else { //Added block
    if ((int )*(term_strings[39]) == 0) {


    }
    }
    if ((int )*(term_strings[36]) == 0) {



    }
    p_wiv = (int )*(term_strings[37]) != 0;
  }
  need_gather = 1;
  return;
}
}
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) 
{











































}
static int old_Rows  =    0;
void check_winsize(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (Columns < 12L) {

  }
  {
  tmp___0 = min_rows();
  }
  if (Rows < (long )tmp___0) {
    {


    }
  }
  if ((long )old_Rows != Rows) {
    {
    old_Rows = (int )Rows;
    screen_new_rows();
    }
  }
  return;
}
}
static int busy  =    0;
void set_winsize(int width , int height , int mustset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (busy) {

  }
  if (width < 0) {

  } else { //Added block
  if (height < 0) {

  }
  }
  if (State == 1537) {


  } else { //Added block
  if (State == 2048) {


  }
  }
  busy ++;
  if (State != 1792) {
    if (State != 2560) {
      if (State != 3072) {
        {
        screenclear();
        }
      } else {
        {

        }
      }
    } else {
      {

      }
    }
  } else {
    {

    }
  }
  if (mustset) {
    {




    }
  } else {
    {
    tmp = ui_get_winsize();
    }
    if (tmp == 0) {












    } else {
      {
      check_winsize();
      }
    }
  }
  if (starting != 2) {
    {



    }













































    {

    }
  }
  {
  out_flush();
  busy --;
  }
  return;
}
}
static int cur_tmode  =    0;
void settmode(int tmode ) 
{ 


  {
  if (full_screen) {
    if (exmode_active) {
      tmode = 0;
    }
    if (tmode != 0) {
      goto _L;
    } else { //Added block
    if (cur_tmode != 0) {
      _L: ;
      if (tmode != 2) {
        {
        mch_setmouse(0);
        }
      }
      {
      out_flush();
      mch_settmode(tmode);
      cur_tmode = tmode;
      }
      if (tmode == 2) {
        {
        setmouse();
        }
      }
      {
      out_flush();
      }
    }
    }
    if (cur_tmode == 2) {
      if (need_get_crv) {
        if (*(term_strings[49])) {
          {
          out_str(term_strings[49]);
          need_get_crv = 0;
          vpeekc();
          }
        }
      }
    }
  }
  return;
}
}
void starttermcap(void) 
{ 


  {
  {
  screen_stop_highlight();
  }
  if (full_screen) {
    if (! termcap_active) {
      {
      out_str(term_strings[30]);
      out_str(term_strings[28]);
      out_flush();
      termcap_active = 1;
      screen_start();
      }
    }
  }
  return;
}
}
void stoptermcap(void) 
{ 


  {
  {
  screen_stop_highlight();
  reset_cterm_colors();
  }
  if (termcap_active) {
    {
    out_str(term_strings[29]);
    out_flush();
    termcap_active = 0;
    cursor_on();
    out_str(term_strings[31]);
    screen_start();
    out_flush();
    }
  }
  return;
}
}
int swapping_screen(void) 
{ 


  {
  return ((int )*(term_strings[30]) != 0);
}
}
void setmouse(void) 
{ 
  int checkfor ;
  int tmp ;

  {
  if ((int )*p_mouse == 0) {
    return;
  } else { //Added block



  }







































  {

  }










}
}
int mouse_has(int c ) 
{ 
  char_u *p___0 ;
  char_u *tmp ;

  {
  p___0 = p_mouse;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! *p___0) {
      goto while_break;
    }
    {







    case_97: ;/* CIL Label */ 
    {

    }




    case_104: ;/* CIL Label */ 






    switch_default: ;/* CIL Label */ 




    switch_break: ;/* CIL Label */ ;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  return (0);
}
}
int mouse_model_popup(void) 
{





}
void scroll_start(void) 
{ 


  {
  if ((int )*(term_strings[13]) != 0) {
    {
    out_str(term_strings[13]);
    out_str(term_strings[12]);
    screen_start();
    }
  }
  return;
}
}
static int cursor_is_off  =    0;
void cursor_on(void) 
{ 


  {
  if (cursor_is_off) {
    {
    out_str(term_strings[12]);
    cursor_is_off = 0;
    }
  }
  return;
}
}
void cursor_off(void) 
{ 


  {
  if (full_screen) {
    if (! cursor_is_off) {
      {
      out_str(term_strings[11]);
      }
    }
    cursor_is_off = 1;
  }
  return;
}
}
void scroll_region_set(WIN *wp , int off___0 ) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[6]), (wp->w_winpos + wp->w_height) - 1,
              wp->w_winpos + off___0);
  out_str((char_u *)tmp);
  screen_start();
  }
  return;
}
}
void scroll_region_reset(void) 
{ 
  char *tmp ;

  {
  {
  tmp = tgoto((char const   *)((char *)term_strings[6]), (int )Rows - 1, 0);
  out_str((char_u *)tmp);
  screen_start();
  }
  return;
}
}
struct termcode *termcodes  =    (struct termcode *)((void *)0);
static int tc_max_len  =    0;
static int tc_len  =    0;
void clear_termcodes(void) 
{ 


  {
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (tc_len > 0)) {
      goto while_break;
    }
    {


    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  vim_free((void *)termcodes);
  termcodes = (struct termcode *)((void *)0);
  tc_max_len = 0;
  BC = (char *)empty_option;
  UP = (char *)empty_option;
  PC = (char )'\000';
  ospeed = (short)0;
  need_gather = 1;
  }
  return;
}
}
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) 
{ 
  struct termcode *new_tc ;
  int i___0 ;
  int j ;
  char_u *s ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  size_t tmp___3 ;

  {
  if ((unsigned long )string___0 == (unsigned long )((void *)0)) {
    {
    del_termcode(name___1);
    }
    return;
  } else { //Added block
  if ((int )*string___0 == 0) {
    {

    }

  }
  }
  {
  s = vim_strsave(string___0);
  }
  if ((unsigned long )s == (unsigned long )((void *)0)) {

  }
  if (use_8bit) {
    {

    }








  }
  need_gather = 1;
  if (tc_len == tc_max_len) {
    {
    tc_max_len += 20;
    tmp___2 = alloc((unsigned int )((unsigned long )tc_max_len * sizeof(struct termcode )));
    new_tc = (struct termcode *)tmp___2;
    }
    if ((unsigned long )new_tc == (unsigned long )((void *)0)) {


    }
    i___0 = 0;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! (i___0 < tc_len)) {
        goto while_break;
      }
      *(new_tc + i___0) = *(termcodes + i___0);
      i___0 ++;
    }
    while_break: ;/* CIL Label */ ;
    }
    {
    vim_free((void *)termcodes);
    termcodes = new_tc;
    }
  }
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break___0;
    }
    if ((int )(termcodes + i___0)->name[0] < (int )*(name___1 + 0)) {
      goto __Cont;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] < (int )*(name___1 + 1)) {
        goto __Cont;
      }
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        {
        vim_free((void *)(termcodes + i___0)->code);
        tc_len --;
        }
        goto while_break___0;
      }
    }
    j = tc_len;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! (j > i___0)) {
        goto while_break___1;
      }
      *(termcodes + j) = *(termcodes + (j - 1));
      j --;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    goto while_break___0;
    __Cont: ;
    i___0 ++;
  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  (termcodes + i___0)->name[0] = *(name___1 + 0);
  (termcodes + i___0)->name[1] = *(name___1 + 1);
  (termcodes + i___0)->code = s;
  tmp___3 = strlen((char const   *)((char *)s));
  (termcodes + i___0)->len = (int )tmp___3;
  tc_len ++;
  }
  return;
}
}
char_u *find_termcode(char_u *name___1 ) 
{ 
  int i___0 ;

  {
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        return ((termcodes + i___0)->code);
      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return ((char_u *)((void *)0));
}
}
char_u *get_termcode(int i___0 ) 
{








}
void del_termcode(char_u *name___1 ) 
{ 
  int i___0 ;

  {
  if ((unsigned long )termcodes == (unsigned long )((void *)0)) {

  }
  need_gather = 1;
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    if ((int )(termcodes + i___0)->name[0] == (int )*(name___1 + 0)) {
      if ((int )(termcodes + i___0)->name[1] == (int )*(name___1 + 1)) {
        {


        }
        {








        while_break___0: ;/* CIL Label */ ;
        }

      }
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
static int held_button  =    3;
static int orig_num_clicks  =    1;
static int orig_mouse_code  =    0;
static int orig_mouse_col  =    0;
static int orig_mouse_row  =    0;
static linenr_t orig_topline  =    (linenr_t )0;
static struct timeval orig_mouse_time  =    {(__time_t )0, (__suseconds_t )0};
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) 
{ 
  char_u *tp ;
  char_u *p___0 ;
  int slen ;
  int len___0 ;
  int offset ;
  char_u key_name[2] ;
  int new_slen ;
  int extra ;
  char_u string___0[7] ;
  int i___0 ;
  int j ;
  char_u bytes[3] ;
  int num_bytes ;
  int mouse_code___0 ;
  int modifiers ;
  int is_click ;
  int is_drag ;
  int wheel_code ;
  int current_button ;
  struct timeval mouse_time ;
  long timediff ;
  int cpo_koffset ;
  char_u *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
  slen = 0;
  mouse_code___0 = 0;
  wheel_code = 0;
  tmp = vim_strchr(p_cpo, 'K');
  cpo_koffset = (unsigned long )tmp != (unsigned long )((void *)0);
  }
  if (need_gather) {
    {
    gather_termleader();
    }
  }
  offset = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (offset < max_offset)) {
      goto while_break;
    }
    if ((unsigned long )buf___3 == (unsigned long )((void *)0)) {
      if (offset >= typelen) {

      }
      tp = (typebuf + typeoff) + offset;
      len___0 = typelen - offset;
    } else {





    }
    if ((int )*tp == 128) {


    }
    i___0 = (int )*tp;
    p___0 = termleader;
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if (*p___0) {
        if (! ((int )*p___0 != i___0)) {
          goto while_break___0;
        }
      } else {
        goto while_break___0;
      }
      p___0 ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if ((int )*p___0 == 0) {
      goto __Cont;
    }
    if ((int )*tp == 27) {
      if (! p_ek) {
        if (State & 16) {
          goto __Cont;
        }
      }
    }
    new_slen = 0;
    key_name[0] = (char_u )'\000';
    i___0 = 0;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! (i___0 < tc_len)) {
        goto while_break___1;
      }
      slen = (termcodes + i___0)->len;
      if (cpo_koffset) {
        if (offset) {



        }
      }
      if (slen > len___0) {
        tmp___2 = len___0;
      } else {
        tmp___2 = slen;
      }
      {
      tmp___3 = strncmp((char const   *)((char *)(termcodes + i___0)->code), (char const   *)((char *)tp),
                        (size_t )tmp___2);
      }
      if (tmp___3 == 0) {
        if (len___0 < slen) {
          return (-1);
        }
































      }
      __Cont___0: ;
      i___0 ++;
    }
    while_break___1: ;/* CIL Label */ ;
    }
    if ((int )key_name[0] == 0) {
      if ((int )*(term_strings[49]) != 0) {
        if ((int )*(tp + 0) == 27) {
          if ((int )*(tp + 1) == 91) {





          } else {
            goto _L___1;
          }
        } else { //Added block
        _L___1: ;
        if ((int )*(tp + 0) == 155) {


























































        } else {
          goto __Cont;
        }
        }
      } else {

      }
    }






























































































































































































    __Cont: ;
    offset ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (0);
}
}
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) 
{ 
  int i___0 ;
  int slen ;
  int key ;
  int dlen ;
  char_u *src ;
  int do_backslash ;
  int do_special ;
  int do_key_code ;
  char_u *result___0 ;
  char_u *tmp ;
  char_u *tmp___0 ;
  char_u *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char_u *tmp___17 ;
  char_u *tmp___18 ;

  {
  {
  dlen = 0;
  tmp = vim_strchr(p_cpo, 'B');
  do_backslash = (unsigned long )tmp == (unsigned long )((void *)0);
  tmp___0 = vim_strchr(p_cpo, '<');
  do_special = (unsigned long )tmp___0 == (unsigned long )((void *)0);
  tmp___1 = vim_strchr(p_cpo, 'k');
  do_key_code = (unsigned long )tmp___1 == (unsigned long )((void *)0);
  tmp___2 = strlen((char const   *)((char *)from));
  result___0 = alloc((unsigned int )tmp___2 * 6U + 1U);
  }
  if ((unsigned long )result___0 == (unsigned long )((void *)0)) {


  }
  src = from;
  if (from_part) {
    if ((int )*(src + 0) == 35) {
      {

      }


















    }
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((int )*src != 0)) {
      goto while_break;
    }
    if (do_special) {
      if (do_lt) {
        goto _L;
      } else {
        {


        }
        if (tmp___8) {
          _L: ;
          {
          slen = trans_special(& src, result___0 + dlen, 1);
          }
          if (slen) {
            dlen += slen;
            goto while_continue;
          }
        }
      }
    }
    if (do_key_code) {
      {

      }













    }
    if ((int )*src == 128) {











    }
    key = (int )*src;
    if (key == 22) {

    } else { //Added block
    if (do_backslash) {
      if (key == 92) {
        _L___0: ;









      }
    }
    }
    tmp___16 = dlen;
    dlen ++;
    tmp___17 = src;
    src ++;
    *(result___0 + tmp___16) = *tmp___17;
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  *(result___0 + dlen) = (char_u )'\000';
  tmp___18 = vim_strsave(result___0);
  *bufp = tmp___18;
  }
  if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
    from = *bufp;
  }
  {
  vim_free((void *)result___0);
  }
  return (from);
}
}
int find_term_bykeys(char_u *src ) 
{




























}
static void gather_termleader(void) 
{ 
  int i___0 ;
  int len___0 ;
  int tmp ;
  char_u *tmp___0 ;

  {
  len___0 = 0;
  termleader[len___0] = (char_u )'\000';
  i___0 = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < tc_len)) {
      goto while_break;
    }
    {
    tmp___0 = vim_strchr(termleader, (int )*((termcodes + i___0)->code + 0));
    }
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      tmp = len___0;
      len___0 ++;
      termleader[tmp] = *((termcodes + i___0)->code + 0);
      termleader[len___0] = (char_u )'\000';
    }
    i___0 ++;
  }
  while_break: ;/* CIL Label */ ;
  }
  need_gather = 0;
  return;
}
}
void show_termcodes(void) 
{




































































































































}
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) 
{







































































}
char_u *translate_mapping(char_u *str___1 , int expmap ) 
{



















































































































































































}
#pragma merger("0","/tmp/cil-LeEIQNhP.i","-O0")
extern Atom XInternAtom(Display * , char const   * , int  ) ;
extern void XFreeStringList(char ** ) ;
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
extern int XmbTextListToTextProperty(Display *display , char **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
extern int XmbTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     char ***list_return , int *count_return ) ;
extern Boolean XtDispatchEvent(XEvent * ) ;
extern Boolean XtOwnSelection(Widget  , Atom  , Time  , Boolean (*)(Widget  , Atom * ,
                                                                    Atom * , Atom * ,
                                                                    XtPointer * ,
                                                                    unsigned long * ,
                                                                    int * ) , void (*)(Widget  ,
                                                                                       Atom * ) ,
                              void (*)(Widget  , Atom * , Atom * ) ) ;
extern void XtToolkitInitialize(void) ;
extern XtAppContext XtCreateApplicationContext(void) ;
extern char *XtMalloc(Cardinal  ) ;
extern void XtFree(char * ) ;
extern void XtDisownSelection(Widget  , Atom  , Time  ) ;
extern void XtGetSelectionValue(Widget  , Atom  , Atom  , void (*)(Widget  , XtPointer  ,
                                                                   Atom * , Atom * ,
                                                                   XtPointer  , unsigned long * ,
                                                                   int * ) , XtPointer  ,
                                Time  ) ;
void clip_lose_selection(void) ;
void clip_copy_selection(void) ;
void clip_clear_selection(void) ;
int clip_gen_own_selection(void) ;
void clip_gen_lose_selection(void) ;
void read_error_exit(void) ;
void ui_write(char_u *s , int len___0 ) 
{ 


  {
  if (! silent_mode) {
    {
    mch_write(s, len___0);
    }
  }
  return;
}
}
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{ 
  int tmp ;

  {
  {
  tmp = mch_inchar(buf___3, maxlen, wtime);
  }
  return (tmp);
}
}
int ui_char_avail(void) 
{








}
void ui_delay(long msec , int ignoreinput ) 
{ 


  {
  {
  mch_delay(msec, ignoreinput);
  }
  return;
}
}
void ui_suspend(void) 
{








}
int ui_get_winsize(void) 
{ 
  int retval ;

  {
  {
  retval = mch_get_winsize();
  }
  if (retval == 1) {
    {
    set_number_default((char *)"lines", Rows);
    set_number_default((char *)"columns", Columns);
    }
  }
  return (retval);
}
}
void ui_set_winsize(void) 
{ 


  {
  {
  mch_set_winsize();
  }
  return;
}
}
void ui_breakcheck(void) 
{ 


  {
  {
  mch_breakcheck();
  }
  return;
}
}
void clip_init(int can_use ) 
{ 


  {
  clipboard.available = can_use;
  clipboard.owned = 0;
  clipboard.start.lnum = (linenr_t )0;
  clipboard.start.col = (colnr_t )0;
  clipboard.end.lnum = (linenr_t )0;
  clipboard.end.col = (colnr_t )0;
  clipboard.state = (short_u )0;
  return;
}
}
void clip_update_selection(void) 
{



















































}
void clip_own_selection(void) 
{
































}
void clip_lose_selection(void) 
{


































}
void clip_copy_selection(void) 
{





























}
void clip_auto_select(void) 
{













}
int clip_isautosel(void) 
{








}
void clip_clear_selection(void) 
{






}
int clip_gen_own_selection(void) 
{








}
void clip_gen_lose_selection(void) 
{








}
void clip_gen_set_selection(void) 
{








}
void clip_gen_request_selection(void) 
{








}
static char_u inbuf[256]  ;
static int inbufcount  =    0;
int vim_is_input_buf_full(void) 
{ 


  {
  return (inbufcount >= 250);
}
}
int vim_is_input_buf_empty(void) 
{ 


  {
  return (inbufcount == 0);
}
}
void add_to_input_buf(char_u *s , int len___0 ) 
{


























}
int read_from_input_buf(char_u *buf___3 , long maxlen ) 
{ 


  {
  if (inbufcount == 0) {
    {
    fill_input_buf(1);
    }
  }
  if (maxlen > (long )inbufcount) {
    maxlen = (long )inbufcount;
  }
  {
  memmove((void *)((char *)buf___3), (void const   *)((char *)(inbuf)), (size_t )maxlen);
  inbufcount = (int )((long )inbufcount - maxlen);
  }
  if (inbufcount) {
    {
    memmove((void *)((char *)(inbuf)), (void const   *)((char *)(inbuf + maxlen)),
            (size_t )inbufcount);
    }
  }
  return ((int )maxlen);
}
}
static int did_read_something  =    0;
void fill_input_buf(int exit_on_error ) 
{ 
  int len___0 ;
  int try ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = vim_is_input_buf_full();
  }
  if (tmp) {

  }
  len___0 = 0;
  try = 0;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (try < 100)) {

    }
    {
    tmp___0 = read(read_cmd_fd, (void *)((char *)(inbuf) + inbufcount), (size_t )(250 - inbufcount));
    len___0 = (int )tmp___0;
    }
    if (len___0 > 0) {
      goto while_break;
    } else { //Added block



    }














  }
  while_break: ;/* CIL Label */ ;
  }
  if (len___0 <= 0) {





  }
  did_read_something = 1;
  if (got_int) {


  } else {
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      tmp___2 = len___0;
      len___0 --;
      if (! (tmp___2 > 0)) {
        goto while_break___0;
      }
      if ((int )inbuf[inbufcount] == 3) {
        {




        }
      }
      inbufcount ++;
    }
    while_break___0: ;/* CIL Label */ ;
    }
  }
  return;
}
}
void read_error_exit(void) 
{














}
int check_col(int col ) 
{











}
int check_row(int row ) 
{











}
void open_app_context(void) 
{ 


  {
  if ((unsigned long )app_context == (unsigned long )((void *)0)) {
    {
    XtToolkitInitialize();
    app_context = XtCreateApplicationContext();
    }
  }
  return;
}
}
void x11_setup_atoms(Display *dpy ) 
{











}
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) ;
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) 
{















































































}
static int success  ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) 
{





































































}
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) ;
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) 
{






































































































}
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) ;
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) 
{








}
void clip_x11_lose_selection(Widget myShell ) 
{








}
int clip_x11_own_selection(Widget myShell ) 
{













}
void clip_x11_set_selection(void) 
{





}
#pragma merger("0","/tmp/cil-3y2lZ3a4.i","-O0")
void u_saveline(linenr_t lnum ) ;
static void u_getbot(void) ;
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) ;
static void u_doit(int count___2 ) ;
static void u_undoredo(void) ;
static void u_undo_end(void) ;
static void u_freelist(struct u_header *uhp ) ;
static void u_freeentry(struct u_entry *uep , long n ) ;
static char_u *u_blockalloc(long_u size ) ;
static void u_free_line(char_u *ptr ) ;
static char_u *u_alloc_line(unsigned int size ) ;
static char_u *u_save_line(linenr_t lnum ) ;
static long u_newcount  ;
static long u_oldcount  ;
static int undo_undoes  =    0;
int u_save_cursor(void) 
{ 
  int tmp ;

  {
  {
  tmp = u_save(curwin->w_cursor.lnum - 1L, curwin->w_cursor.lnum + 1L);
  }
  return (tmp);
}
}
int u_save(linenr_t top , linenr_t bot ) 
{ 
  int tmp ;

  {
  if (undo_off) {

  }
  if (top > curbuf->b_ml.ml_line_count) {

  } else { //Added block
  if (top >= bot) {

  } else { //Added block
  if (bot > curbuf->b_ml.ml_line_count + 1L) {

  }
  }
  }
  if (top + 2L == bot) {
    {
    u_saveline(top + 1L);
    }
  }
  {
  tmp = u_savecommon(top, bot, (linenr_t )0);
  }
  return (tmp);
}
}
int u_savesub(linenr_t lnum ) 
{











}
int u_inssub(linenr_t lnum ) 
{











}
int u_savedel(linenr_t lnum , long nlines ) 
{

















}
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) 
{ 
  linenr_t lnum ;
  long i___0 ;
  struct u_header *uhp ;
  struct u_entry *uep ;
  long size ;
  char_u *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char_u *tmp___2 ;
  char_u **tmp___3 ;
  char_u *tmp___4 ;
  char_u *tmp___5 ;
  linenr_t tmp___6 ;
  int tmp___7 ;

  {
  if (sandbox != 0) {
    {

    }

  }
  if (curbuf->b_u_synced) {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((unsigned long )curbuf->b_u_curhead != (unsigned long )((void *)0))) {
        goto while_break;
      }
      {

      }
    }
    while_break: ;/* CIL Label */ ;
    }
    {
    while (1) {
      while_continue___0: ;/* CIL Label */ ;
      if ((long )curbuf->b_u_numhead > p_ul) {



      } else {
        goto while_break___0;
      }
      {

      }
    }
    while_break___0: ;/* CIL Label */ ;
    }
    if (p_ul < 0L) {

    }
    {
    tmp = u_alloc_line((unsigned int )sizeof(struct u_header ));
    uhp = (struct u_header *)tmp;
    }
    if ((unsigned long )uhp == (unsigned long )((void *)0)) {

    }
    uhp->uh_prev = (struct u_header *)((void *)0);
    uhp->uh_next = curbuf->b_u_newhead;
    if ((unsigned long )curbuf->b_u_newhead != (unsigned long )((void *)0)) {
      (curbuf->b_u_newhead)->uh_prev = uhp;
    }
    uhp->uh_entry = (struct u_entry *)((void *)0);
    uhp->uh_cursor = curwin->w_cursor;
    if (curbuf->b_changed) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (curbuf->b_ml.ml_flags & 1) {

    } else {
      tmp___1 = 0;
    }
    {
    uhp->uh_flags = tmp___0 + tmp___1;
    memmove((void *)((char *)(uhp->uh_namedm)), (void const   *)((char *)(curbuf->b_namedm)),
            sizeof(FPOS ) * 26UL);
    curbuf->b_u_newhead = uhp;
    }
    if ((unsigned long )curbuf->b_u_oldhead == (unsigned long )((void *)0)) {
      curbuf->b_u_oldhead = uhp;
    }
    (curbuf->b_u_numhead) ++;
  } else {
    {

    }
  }
  {
  size = (bot - top) - 1L;
  tmp___2 = u_alloc_line((unsigned int )sizeof(struct u_entry ));
  uep = (struct u_entry *)tmp___2;
  }
  if ((unsigned long )uep == (unsigned long )((void *)0)) {

  }
  uep->ue_size = size;
  uep->ue_top = top;
  uep->ue_lcount = (linenr_t )0;
  if (newbot) {

  } else { //Added block
  if (bot > curbuf->b_ml.ml_line_count) {
    uep->ue_bot = (linenr_t )0;
  } else {
    uep->ue_lcount = curbuf->b_ml.ml_line_count;
  }
  }
  if (size) {
    {
    tmp___4 = u_alloc_line((unsigned int )(sizeof(char_u *) * (unsigned long )size));
    tmp___3 = (char_u **)tmp___4;
    uep->ue_array = tmp___3;
    }
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {

      }

    }
    i___0 = 0L;
    lnum = top + 1L;
    {
    while (1) {
      while_continue___1: ;/* CIL Label */ ;
      if (! (i___0 < size)) {
        goto while_break___1;
      }
      {
      tmp___6 = lnum;
      lnum ++;
      tmp___5 = u_save_line(tmp___6);
      *(uep->ue_array + i___0) = tmp___5;
      }
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        {

        }

      }
      i___0 ++;
    }
    while_break___1: ;/* CIL Label */ ;
    }
  }
  uep->ue_next = (curbuf->b_u_newhead)->uh_entry;
  (curbuf->b_u_newhead)->uh_entry = uep;
  curbuf->b_u_synced = 0;
  undo_undoes = 0;
  return (1);
  nomem: ;
  {

  }




  {

  }

}
}
void u_undo(int count___2 ) 
{






















}
void u_redo(int count___2 ) 
{














}
static void u_doit(int count___2 ) 
{








































































}
static void u_undoredo(void) 
{


















































































































































































































































































}
static void u_undo_end(void) 
{






















}
void u_sync(void) 
{ 


  {
  if (curbuf->b_u_synced) {
    return;
  }
  {
  u_getbot();
  curbuf->b_u_curhead = (struct u_header *)((void *)0);
  }
  return;
}
}
void u_unchanged(BUF *buf___3 ) 
{ 
  struct u_header *uh ;

  {
  uh = buf___3->b_u_newhead;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! uh) {
      goto while_break;
    }
    uh->uh_flags |= 1;
    uh = uh->uh_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  buf___3->b_did_warn = 0;
  return;
}
}
static void u_getbot(void) 
{ 
  struct u_entry *uep ;

  {
  if ((unsigned long )curbuf->b_u_newhead == (unsigned long )((void *)0)) {
    {

    }

  } else {
    uep = (curbuf->b_u_newhead)->uh_entry;
    if ((unsigned long )uep == (unsigned long )((void *)0)) {
      {

      }

    }
  }
  if (uep->ue_lcount != 0L) {
    uep->ue_bot = ((uep->ue_top + uep->ue_size) + 1L) + (curbuf->b_ml.ml_line_count - uep->ue_lcount);
    if (uep->ue_bot < 1L) {
      {


      }
    } else { //Added block
    if (uep->ue_bot > curbuf->b_ml.ml_line_count) {
      {


      }
    }
    }
    uep->ue_lcount = (linenr_t )0;
  }
  curbuf->b_u_synced = 1;
  return;
}
}
static void u_freelist(struct u_header *uhp ) 
{






































}
static void u_freeentry(struct u_entry *uep , long n ) 
{





















}
void u_clearall(BUF *buf___3 ) 
{ 
  struct u_header *tmp ;
  struct u_header *tmp___0 ;

  {
  tmp___0 = (struct u_header *)((void *)0);
  buf___3->b_u_curhead = tmp___0;
  tmp = tmp___0;
  buf___3->b_u_oldhead = tmp;
  buf___3->b_u_newhead = tmp;
  buf___3->b_u_synced = 1;
  buf___3->b_u_numhead = 0;
  buf___3->b_u_line_ptr = (char_u *)((void *)0);
  buf___3->b_u_line_lnum = (linenr_t )0;
  return;
}
}
void u_saveline(linenr_t lnum ) 
{ 
  char_u *tmp ;

  {
  if (lnum == curbuf->b_u_line_lnum) {
    return;
  }
  if (lnum < 1L) {

  } else { //Added block
  if (lnum > curbuf->b_ml.ml_line_count) {

  }
  }
  {
  u_clearline();
  curbuf->b_u_line_lnum = lnum;
  }
  if (curwin->w_cursor.lnum == lnum) {
    curbuf->b_u_line_colnr = curwin->w_cursor.col;
  } else {

  }
  {
  tmp = u_save_line(lnum);
  curbuf->b_u_line_ptr = tmp;
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {

    }
  }
  return;
}
}
void u_clearline(void) 
{ 


  {
  if ((unsigned long )curbuf->b_u_line_ptr != (unsigned long )((void *)0)) {
    {
    u_free_line(curbuf->b_u_line_ptr);
    curbuf->b_u_line_ptr = (char_u *)((void *)0);
    curbuf->b_u_line_lnum = (linenr_t )0;
    }
  }
  return;
}
}
void u_undoline(void) 
{
























































}
static char_u *u_blockalloc(long_u size ) 
{ 
  struct m_block *p___0 ;
  struct m_block *mp ;
  struct m_block *next ;
  char_u *tmp ;

  {
  {
  tmp = lalloc(size + sizeof(struct m_block ), 0);
  p___0 = (struct m_block *)tmp;
  }
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    mp = & curbuf->b_block_head;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      next = mp->mb_next;
      if ((unsigned long )next != (unsigned long )((void *)0)) {
        if (! ((unsigned long )next < (unsigned long )p___0)) {

        }
      } else {
        goto while_break;
      }
      mp = next;
    }
    while_break: ;/* CIL Label */ ;
    }
    p___0->mb_next = next;
    mp->mb_next = p___0;
    p___0->mb_info.m_next = (info_t *)((void *)0);
    p___0->mb_info.m_size = (long_u )0;
    curbuf->b_mb_current = p___0;
    curbuf->b_m_search = (info_t *)((void *)0);
    p___0 ++;
  }
  return ((char_u *)p___0);
}
}
void u_blockfree(BUF *buf___3 ) 
{ 
  struct m_block *p___0 ;
  struct m_block *np___0 ;

  {
  p___0 = buf___3->b_block_head.mb_next;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
      goto while_break;
    }
    {
    np___0 = p___0->mb_next;
    vim_free((void *)p___0);
    p___0 = np___0;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  buf___3->b_block_head.mb_next = (struct m_block *)((void *)0);
  buf___3->b_m_search = (info_t *)((void *)0);
  buf___3->b_mb_current = (struct m_block *)((void *)0);
  return;
}
}
static void u_free_line(char_u *ptr ) 
{ 
  info_t *next ;
  info_t *prev ;
  info_t *curr ;
  info_t *mp ;
  struct m_block *nextb ;

  {
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {

  } else { //Added block
  if ((unsigned long )ptr == (unsigned long )IObuff) {

  }
  }
  mp = (info_t *)(ptr - sizeof(long_u ));
  if ((unsigned long )curbuf->b_mb_current == (unsigned long )((void *)0)) {


  } else { //Added block
  if ((unsigned long )mp < (unsigned long )((info_t *)curbuf->b_mb_current)) {


  }
  }
  nextb = (curbuf->b_mb_current)->mb_next;
  if ((unsigned long )nextb != (unsigned long )((void *)0)) {




  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    nextb = (curbuf->b_mb_current)->mb_next;
    if ((unsigned long )nextb != (unsigned long )((void *)0)) {



    } else {
      goto while_break;
    }

  }
  while_break: ;/* CIL Label */ ;
  }
  curr = (info_t *)((void *)0);
  if ((unsigned long )curbuf->b_m_search == (unsigned long )((void *)0)) {
    next = & (curbuf->b_mb_current)->mb_info;
  } else { //Added block
  if ((unsigned long )mp < (unsigned long )(curbuf->b_m_search)->m_next) {
    next = & (curbuf->b_mb_current)->mb_info;
  } else {

  }
  }
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    prev = next->m_next;
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
      prev = curr;
      curr = next;
      next = next->m_next;
      goto while_break___0;
    } else { //Added block
    if ((unsigned long )mp <= (unsigned long )prev) {
      prev = curr;
      curr = next;
      next = next->m_next;
      goto while_break___0;
    }
    }






















  }
  while_break___0: ;/* CIL Label */ ;
  }
  if ((unsigned long )((char_u *)mp + mp->m_size) == (unsigned long )((char_u *)next)) {


  } else {
    mp->m_next = next;
  }
  if ((unsigned long )prev != (unsigned long )((void *)0)) {








  } else {
    curr->m_next = mp;
    curbuf->b_m_search = curr;
  }
  return;
}
}
static char_u *u_alloc_line(unsigned int size ) 
{ 
  info_t *mp ;
  info_t *mprev ;
  info_t *mp2 ;
  struct m_block *mbp ;
  int size_align ;
  info_t *tmp ;
  info_t *tmp___0 ;
  int n ;
  int tmp___1 ;
  char_u *tmp___2 ;

  {
  size = (unsigned int )((unsigned long )size + (sizeof(long_u ) + 1UL));
  if ((unsigned long )size < sizeof(info_t ) + 1UL) {
    size = (unsigned int )(sizeof(info_t ) + 1UL);
  }
  size_align = (int )(((unsigned long )size + (sizeof(long ) - 1UL)) & ~ (sizeof(long ) - 1UL));
  if ((unsigned long )curbuf->b_mb_current == (unsigned long )((void *)0)) {
    curbuf->b_mb_current = & curbuf->b_block_head;
    curbuf->b_m_search = & curbuf->b_block_head.mb_info;
  } else { //Added block
  if ((unsigned long )curbuf->b_m_search == (unsigned long )((void *)0)) {


  }
  }
  mprev = curbuf->b_m_search;
  mbp = curbuf->b_mb_current;
  mp = (curbuf->b_m_search)->m_next;
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
    if (mbp->mb_next) {

    } else {
      mbp = & curbuf->b_block_head;
    }
    tmp = & mbp->mb_info;
    curbuf->b_m_search = tmp;
    mp = tmp;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (mp->m_size < (long_u )size)) {
      goto while_break;
    }
    if ((unsigned long )mp == (unsigned long )curbuf->b_m_search) {
      if (mbp->mb_next) {
        mbp = mbp->mb_next;
      } else {
        mbp = & curbuf->b_block_head;
      }
      tmp___0 = & mbp->mb_info;
      curbuf->b_m_search = tmp___0;
      mp = tmp___0;
      if ((unsigned long )mbp == (unsigned long )curbuf->b_mb_current) {
        if (size_align > 511) {

        } else {
          tmp___1 = 2044;
        }
        {
        n = tmp___1;
        tmp___2 = u_blockalloc((long_u )n);
        mp = (info_t *)tmp___2;
        }
        if ((unsigned long )mp == (unsigned long )((void *)0)) {

        }
        {
        mp->m_size = (long_u )n;
        u_free_line((char_u *)mp + sizeof(long_u ));
        mp = curbuf->b_m_search;
        mbp = curbuf->b_mb_current;
        }
      }
    }
    mprev = mp;
    mp = mp->m_next;
    if ((unsigned long )mp == (unsigned long )((void *)0)) {
      mp = & mbp->mb_info;
    }
  }
  while_break: ;/* CIL Label */ ;
  }
  if ((long )mp->m_size - (long )size_align >= (long )(sizeof(info_t ) + 1UL)) {
    mp2 = (info_t *)((char_u *)mp + size_align);
    mp2->m_size = mp->m_size - (long_u )size_align;
    mp2->m_next = mp->m_next;
    mprev->m_next = mp2;
    mp->m_size = (long_u )size_align;
  } else {

  }
  curbuf->b_m_search = mprev;
  curbuf->b_mb_current = mbp;
  mp = (info_t *)((char_u *)mp + sizeof(long_u ));
  *((char_u *)mp) = (char_u )'\000';
  return ((char_u *)mp);
}
}
static char_u *u_save_line(linenr_t lnum ) 
{ 
  char_u *src ;
  char_u *dst ;
  unsigned int len___0 ;
  size_t tmp ;

  {
  {
  src = ml_get(lnum);
  tmp = strlen((char const   *)((char *)src));
  len___0 = (unsigned int )tmp;
  dst = u_alloc_line(len___0);
  }
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
    memmove((void *)((char *)dst), (void const   *)((char *)src), (size_t )(len___0 + 1U));
    }
  }
  return (dst);
}
}
int buf_changed(BUF *buf___3 ) 
{ 
  int tmp ;

  {
  if (buf___3->b_changed) {
    tmp = 1;
  } else { //Added block
  if ((int )*(buf___3->b_p_ff) != buf___3->b_start_ffc) {

  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
int curbuf_changed(void) 
{ 
  int tmp ;

  {
  if (curbuf->b_changed) {
    tmp = 1;
  } else { //Added block
  if ((int )*(curbuf->b_p_ff) != curbuf->b_start_ffc) {

  } else {
    tmp = 0;
  }
  }
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-kWECkjeW.i","-O0")
void win_free(WIN *wp ) ;
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) ;
static int path_is_url(char_u *p___0 ) ;
static void reset_VIsual(void) ;
static int win_comp_pos(void) ;
static void win_exchange(long Prenum ) ;
static void win_rotate(int upwards , int count___2 ) ;
static void win_goto(WIN *wp ) ;
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) ;
static void win_append(WIN *after , WIN *wp ) ;
static void win_remove(WIN *wp ) ;
static void win_new_height(WIN *wp , int height ) ;
static WIN *prevwin  =    (WIN *)((void *)0);
void do_window(int nchar , long Prenum ) 
{















































































































































































































































































































































































































































































































































}
static void reset_VIsual(void) 
{












}
int win_split(int new_height , int redraw , int req_room ) 
{ 
  WIN *wp ;
  int i___0 ;
  int need_status ;
  int do_equal ;
  int tmp ;
  int needed ;
  int available ;
  int curwin_height ;

  {
  if (p_ea) {
    if (new_height == 0) {
      tmp = 1;
    } else {

    }
  } else {

  }
  do_equal = tmp;
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    if (p_ls == 1L) {
      if (curwin->w_status_height == 0) {
        need_status = 1;
      } else {

      }
    } else {

    }
  } else {
    need_status = 0;
  }
  available = curwin->w_height;
  needed = (int )((2L * p_wmh + 1L) + (long )need_status);
  if (req_room) {
    needed = (int )((long )needed + (p_wh - p_wmh));
  }
  if (p_ea) {
    wp = firstwin;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
        goto while_break;
      }
      if ((unsigned long )wp != (unsigned long )curwin) {
        available += wp->w_height;
        needed = (int )((long )needed + p_wmh);
      }
      wp = wp->w_next;
    }
    while_break: ;/* CIL Label */ ;
    }
  }
  if (available < needed) {
    {

    }

  }
  curwin_height = curwin->w_height;
  if (need_status) {
    curwin->w_status_height = 1;
    curwin_height --;
  }
  if (new_height == 0) {
    new_height = curwin_height / 2;
  }
  if ((long )new_height > ((long )curwin_height - p_wmh) - 1L) {

  }
  if ((long )new_height < p_wmh) {

  }
  if ((long )((curwin_height - new_height) - 1) < p_wmh) {

  }
  if (p_sb) {
    {
    wp = win_alloc(curwin);
    }
  } else {
    {
    wp = win_alloc(curwin->w_prev);
    }
  }
  if ((unsigned long )wp == (unsigned long )((void *)0)) {

  }
  {
  win_new_height(wp, new_height);
  win_new_height(curwin, curwin_height - (new_height + 1));
  }
  if (p_sb) {
    wp->w_winpos = (curwin->w_winpos + curwin->w_height) + 1;
    wp->w_status_height = curwin->w_status_height;
    curwin->w_status_height = 1;
  } else {
    wp->w_winpos = curwin->w_winpos;
    wp->w_status_height = 1;
    curwin->w_winpos = (wp->w_winpos + wp->w_height) + 1;
  }
  wp->w_buffer = curbuf;
  (curbuf->b_nwindows) ++;
  wp->w_cursor = curwin->w_cursor;
  wp->w_valid = 0;
  wp->w_curswant = curwin->w_curswant;
  wp->w_set_curswant = curwin->w_set_curswant;
  wp->w_topline = curwin->w_topline;
  wp->w_leftcol = curwin->w_leftcol;
  wp->w_pcmark = curwin->w_pcmark;
  wp->w_prev_pcmark = curwin->w_prev_pcmark;
  wp->w_alt_fnum = curwin->w_alt_fnum;
  wp->w_fraction = curwin->w_fraction;
  wp->w_prev_fraction_row = curwin->w_prev_fraction_row;
  wp->w_arg_idx = curwin->w_arg_idx;
  i___0 = 0;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! (i___0 < curwin->w_tagstacklen)) {
      goto while_break___0;
    }







  }
  while_break___0: ;/* CIL Label */ ;
  }
  {
  wp->w_tagstackidx = curwin->w_tagstackidx;
  wp->w_tagstacklen = curwin->w_tagstacklen;
  win_copy_options(curwin, wp);
  wp->w_redr_type = 40;
  wp->w_redr_status = 1;
  curwin->w_redr_type = 40;
  curwin->w_redr_status = 1;
  }
  if (need_status) {
    {
    msg_row = (int )(Rows - 1L);
    msg_col = sc_col;
    msg_clr_eos();
    comp_col();
    msg_row = (int )(Rows - 1L);
    msg_col = 0;
    }
  }
  if (do_equal) {
    {
    win_equal(wp, 0);
    }
  }
  {
  win_enter(wp, 0);
  }
  if (redraw) {
    {

    }
  } else {
    {
    redraw_later(40);
    }
  }
  return (1);
}
}
int win_valid(WIN *win ) 
{ 
  WIN *wp ;

  {
  if ((unsigned long )win == (unsigned long )((void *)0)) {

  }
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {

    }
    if ((unsigned long )wp == (unsigned long )win) {
      return (1);
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }

}
}
int win_count(void) 
{



















}
int make_windows(int count___2 ) 
{





















































}
static void win_exchange(long Prenum ) 
{































































}
static void win_rotate(int upwards , int count___2 ) 
{
















































}
void win_move_after(WIN *win1 , WIN *win2 ) 
{






























}
void win_equal(WIN *next_curwin , int redraw ) 
{ 
  int total ;
  int less ;
  int wincount ;
  int winpos ;
  int temp ;
  WIN *wp ;
  int new_height ;

  {
  total = 0;
  wincount = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! wp) {
      goto while_break;
    }
    total = (int )((long )total + ((long )wp->w_height - p_wmh));
    wincount ++;
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  less = 0;
  if ((unsigned long )next_curwin != (unsigned long )((void *)0)) {
    if (p_wh - p_wmh > (long )total) {

    } else {
      less = (int )((p_wh - p_wmh) - (long )(total / wincount));
      if (less < 0) {
        less = 0;
      }
    }
  }
  winpos = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue___0: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break___0;
    }
    if ((unsigned long )wp == (unsigned long )next_curwin) {
      if (less) {





      } else {
        temp = (int )(((unsigned int )(total - less) + ((unsigned int )wincount >> 1)) / (unsigned int )wincount);
      }
    } else {
      temp = (int )(((unsigned int )(total - less) + ((unsigned int )wincount >> 1)) / (unsigned int )wincount);
    }
    new_height = (int )(p_wmh + (long )temp);
    if (wp->w_winpos != winpos) {
      wp->w_redr_type = 40;
      wp->w_redr_status = 1;
    } else { //Added block
    if (wp->w_height != new_height) {
      wp->w_redr_type = 40;
      wp->w_redr_status = 1;
    }
    }
    {
    wp->w_winpos = winpos;
    win_new_height(wp, new_height);
    total -= temp;
    wincount --;
    winpos += wp->w_height + wp->w_status_height;
    wp = wp->w_next;
    }
  }
  while_break___0: ;/* CIL Label */ ;
  }
  if (redraw) {

  }
  return;
}
}
void close_windows(BUF *buf___3 ) 
{





























}
void close_window(WIN *win , int free_buf ) 
{ 
  WIN *wp ;
  int other_buffer ;
  int close_curwin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  other_buffer = 0;
  close_curwin = 0;
  if ((unsigned long )lastwin == (unsigned long )firstwin) {
    {

    }

  }
  if ((unsigned long )win == (unsigned long )curwin) {
    if (! p_sb) {
      if ((unsigned long )win->w_next != (unsigned long )((void *)0)) {
        wp = win->w_next;
      } else {

      }
    } else { //Added block
    _L: ;





    }
    if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
      {
      other_buffer = 1;
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      tmp = win_valid(win);
      }
      if (tmp) {
        if ((unsigned long )firstwin == (unsigned long )lastwin) {

        }
      } else {

      }
    }
    {
    apply_autocmds((EVENT_T )37, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                   curbuf);
    tmp___0 = win_valid(win);
    }
    if (tmp___0) {
      if ((unsigned long )firstwin == (unsigned long )lastwin) {

      }
    } else {

    }
  }
  if (! p_sb) {
    if ((unsigned long )win->w_next != (unsigned long )((void *)0)) {
      wp = win->w_next;
      wp->w_winpos = win->w_winpos;
    } else {

    }
  } else { //Added block
  _L___0: ;






  }
  {
  close_buffer(win, win->w_buffer, free_buf, 0);
  tmp___1 = win_valid(win);
  }
  if (tmp___1) {
    if ((unsigned long )firstwin == (unsigned long )lastwin) {

    }
  } else {

  }
  {
  win_new_height(wp, (wp->w_height + win->w_height) + win->w_status_height);
  win_free(win);
  }
  if ((unsigned long )win == (unsigned long )curwin) {
    curwin = wp;
    curbuf = wp->w_buffer;
    close_curwin = 1;
  }
  if (p_ea) {
    {
    win_equal(wp, 0);
    }
  }
  if (close_curwin) {
    {
    win_enter_ext(wp, 0, 1);
    }
    if (other_buffer) {
      {
      apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      }
    }
  }
  if (lastwin->w_status_height) {
    if (p_ls == 0L) {
      {



      }
    } else { //Added block
    if (p_ls == 1L) {
      if ((unsigned long )firstwin == (unsigned long )lastwin) {
        {
        win_new_height(lastwin, lastwin->w_height + lastwin->w_status_height);
        lastwin->w_status_height = 0;
        comp_col();
        }
      }
    }
    }
  }
  {
  update_screen(40);
  }
  return;
}
}
void close_others(int message , int forceit ) 
{





















































































































}
void win_init(WIN *wp ) 
{ 
  colnr_t tmp ;

  {
  wp->w_redr_type = 40;
  wp->w_cursor.lnum = (linenr_t )1;
  tmp = (colnr_t )0;
  wp->w_cursor.col = tmp;
  wp->w_curswant = tmp;
  wp->w_pcmark.lnum = (linenr_t )1;
  wp->w_pcmark.col = (colnr_t )0;
  wp->w_prev_pcmark.lnum = (linenr_t )0;
  wp->w_prev_pcmark.col = (colnr_t )0;
  wp->w_topline = (linenr_t )1;
  wp->w_botline = (linenr_t )2;
  return;
}
}
static void win_goto(WIN *wp ) 
{

















}
void win_enter(WIN *wp , int undo_sync ) 
{ 


  {
  {
  win_enter_ext(wp, undo_sync, 0);
  }
  return;
}
}
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) 
{ 
  int other_buffer ;
  int tmp ;
  int tmp___0 ;

  {
  other_buffer = 0;
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (! curwin_invalid) {
      return;
    }
  }
  if (! curwin_invalid) {
    if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
      {
      apply_autocmds((EVENT_T )5, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                     curbuf);
      other_buffer = 1;
      tmp = win_valid(wp);
      }
      if (! tmp) {

      }
    }
    {
    apply_autocmds((EVENT_T )37, (char_u *)((void *)0), (char_u *)((void *)0), 0,
                   curbuf);
    tmp___0 = win_valid(wp);
    }
    if (! tmp___0) {

    }
  }
  if (undo_sync) {





  }
  if ((unsigned long )wp->w_buffer != (unsigned long )curbuf) {
    {
    buf_copy_options(curbuf, wp->w_buffer, 5);
    }
  }
  if (! curwin_invalid) {
    prevwin = curwin;
    curwin->w_redr_status = 1;
  }
  {
  curwin = wp;
  curbuf = wp->w_buffer;
  adjust_cursor();
  changed_line_abv_curs();
  apply_autocmds((EVENT_T )36, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
  }
  if (other_buffer) {
    {
    apply_autocmds((EVENT_T )2, (char_u *)((void *)0), (char_u *)((void *)0), 0, curbuf);
    }
  }
  {
  maketitle();
  curwin->w_redr_status = 1;
  }
  if (restart_edit) {
    {

    }
  }
  if ((long )curwin->w_height < p_wh) {
    {

    }
  }
  {
  setmouse();
  }
  return;
}
}
WIN *buf_jump_open_win(BUF *buf___3 ) 
{
























}
WIN *win_alloc(WIN *after ) 
{ 
  WIN *newwin ;
  char_u *tmp ;
  int tmp___0 ;

  {
  {
  tmp = alloc_clear((unsigned int )sizeof(WIN ));
  newwin = (WIN *)tmp;
  }
  if ((unsigned long )newwin != (unsigned long )((void *)0)) {
    {
    tmp___0 = win_alloc_lsize(newwin);
    }
    if (tmp___0 == 0) {
      {


      }
    }
  }
  if ((unsigned long )newwin != (unsigned long )((void *)0)) {
    {
    win_append(after, newwin);
    newwin->w_topline = (linenr_t )1;
    newwin->w_botline = (linenr_t )2;
    newwin->w_cursor.lnum = (linenr_t )1;
    newwin->w_scbind_pos = 1L;
    newwin->w_fraction = 0;
    newwin->w_prev_fraction_row = -1;
    var_init(& newwin->w_vars);
    }
  }
  return (newwin);
}
}
void win_free(WIN *wp ) 
{ 
  int i___0 ;

  {
  {
  var_clear(& wp->w_vars);
  }
  if ((unsigned long )prevwin == (unsigned long )wp) {

  }
  {
  win_free_lsize(wp);
  i___0 = 0;
  }
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! (i___0 < wp->w_tagstacklen)) {
      goto while_break;
    }
    {


    }
  }
  while_break: ;/* CIL Label */ ;
  }
  {
  win_remove(wp);
  vim_free((void *)wp);
  }
  return;
}
}
static void win_append(WIN *after , WIN *wp ) 
{ 
  WIN *before ;

  {
  if ((unsigned long )after == (unsigned long )((void *)0)) {
    before = firstwin;
  } else {
    before = after->w_next;
  }
  wp->w_next = before;
  wp->w_prev = after;
  if ((unsigned long )after == (unsigned long )((void *)0)) {
    firstwin = wp;
  } else {
    after->w_next = wp;
  }
  if ((unsigned long )before == (unsigned long )((void *)0)) {
    lastwin = wp;
  } else {
    before->w_prev = wp;
  }
  return;
}
}
static void win_remove(WIN *wp ) 
{ 


  {
  if (wp->w_prev) {

  } else {
    firstwin = wp->w_next;
  }
  if (wp->w_next) {
    (wp->w_next)->w_prev = wp->w_prev;
  } else {

  }
  return;
}
}
int win_alloc_lsize(WIN *wp ) 
{ 
  char_u *tmp ;

  {
  {
  wp->w_lsize_valid = 0;
  tmp = alloc((unsigned int )((unsigned long )Rows * sizeof(linenr_t )));
  wp->w_lsize_lnum = (linenr_t *)tmp;
  wp->w_lsize = alloc((unsigned int )Rows);
  }
  if ((unsigned long )wp->w_lsize_lnum == (unsigned long )((void *)0)) {
    {

    }

  } else { //Added block
  if ((unsigned long )wp->w_lsize == (unsigned long )((void *)0)) {
    {

    }

  }
  }
  return (1);
}
}
void win_free_lsize(WIN *wp ) 
{ 


  {
  {
  vim_free((void *)wp->w_lsize_lnum);
  vim_free((void *)wp->w_lsize);
  wp->w_lsize_lnum = (linenr_t *)((void *)0);
  wp->w_lsize = (char_u *)((void *)0);
  }
  return;
}
}
void screen_new_rows(void) 
{ 
  WIN *wp ;
  int extra_lines ;

  {
  if ((unsigned long )firstwin == (unsigned long )((void *)0)) {

  }
  extra_lines = (int )((Rows - p_ch) - (long )((lastwin->w_winpos + lastwin->w_height) + lastwin->w_status_height));
  if (extra_lines < 0) {
    wp = lastwin;
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (! wp) {

      }
      if ((long )wp->w_height - p_wmh < (long )(- extra_lines)) {
        {


        }
      } else {
        {
        win_new_height(wp, wp->w_height + extra_lines);
        }
        goto while_break;
      }

    }
    while_break: ;/* CIL Label */ ;
    }
    {
    win_comp_pos();
    }
  } else { //Added block
  if (extra_lines > 0) {
    {
    win_new_height(lastwin, lastwin->w_height + extra_lines);
    }
  }
  }
  {
  compute_cmdrow();
  }
  if (p_ea) {
    {
    win_equal(curwin, 0);
    }
  }
  return;
}
}
static int win_comp_pos(void) 
{ 
  WIN *wp ;
  int row ;

  {
  row = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (wp->w_winpos != row) {



    }
    row += wp->w_height + wp->w_status_height;
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (row);
}
}
void win_setheight(int height ) 
{


















































































































}
void win_setminheight(void) 
{








































}
void win_drag_status_line(int offset ) 
{
































































































































}
static void win_new_height(WIN *wp , int height ) 
{ 
  linenr_t lnum ;
  int sline ;
  int line_size ;
  int tmp ;

  {
  if (wp->w_wrow != wp->w_prev_fraction_row) {
    if (wp->w_height > 0) {

    }
  }
  wp->w_height = height;
  wp->w_skipcol = (colnr_t )0;
  lnum = wp->w_cursor.lnum;
  if (lnum < 1L) {

  }
  {
  wp->w_wrow = (int )(((long )wp->w_fraction * (long )height - 1L) / 16384L);
  tmp = plines_win_col(wp, lnum, (long )wp->w_cursor.col);
  line_size = tmp - 1;
  sline = wp->w_wrow - line_size;
  }
  if (sline < 0) {

  } else {
    {
    while (1) {
      while_continue: ;/* CIL Label */ ;
      if (sline > 0) {



      } else {
        goto while_break;
      }
      {



      }
    }
    while_break: ;/* CIL Label */ ;
    }
    if (sline < 0) {


    } else { //Added block
    if (sline > 0) {


    }
    }
  }
  {
  set_topline(wp, lnum);
  }
  if ((unsigned long )wp == (unsigned long )curwin) {
    if (p_so) {
      {

      }
    }
    {
    curs_columns(0);
    }
  }
  {
  wp->w_prev_fraction_row = wp->w_wrow;
  win_comp_scroll(wp);
  }
  if (wp->w_redr_type < 40) {
    wp->w_redr_type = 40;
  }
  {
  wp->w_redr_status = 1;
  invalidate_botline_win(wp);
  }
  return;
}
}
void win_comp_scroll(WIN *wp ) 
{ 


  {
  wp->w_p_scroll = (long )((unsigned int )wp->w_height >> 1);
  if (wp->w_p_scroll == 0L) {
    wp->w_p_scroll = 1L;
  }
  return;
}
}
void command_height(long old_p_ch ) 
{ 
  WIN *wp ;
  int h ;

  {
  if (starting != 2) {
    cmdline_row = (int )(Rows - p_ch);
    if (p_ch > old_p_ch) {
      wp = lastwin;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! (p_ch > old_p_ch)) {
          goto while_break;
        }
        if ((unsigned long )wp == (unsigned long )((void *)0)) {
          {


          }

        }
        h = (int )((long )wp->w_height - (p_ch - old_p_ch));
        if (p_wmh == 0L) {





        } else { //Added block
        if ((long )h < p_wmh) {

        }
        }
        {
        old_p_ch += (long )(wp->w_height - h);
        win_new_height(wp, h);
        wp = wp->w_prev;
        }
      }
      while_break: ;/* CIL Label */ ;
      }
      {
      win_comp_pos();
      }
      if (full_screen) {
        {
        screen_fill(cmdline_row, (int )Rows, 0, (int )Columns, ' ', ' ', 0);
        }
      }
      msg_row = cmdline_row;
      redraw_cmdline = 1;
      return;
    }




  }
  {

  }

}
}
void last_status(void) 
{ 
  WIN *wp ;

  {
  if (lastwin->w_status_height) {

















  } else { //Added block
  if (p_ls == 2L) {
    goto _L;
  } else { //Added block
  if (p_ls == 1L) {
    if ((unsigned long )firstwin != (unsigned long )lastwin) {
      _L: ;
      wp = lastwin;
      {
      while (1) {
        while_continue: ;/* CIL Label */ ;
        if (! ((long )wp->w_height <= p_wmh)) {
          goto while_break;
        }







      }
      while_break: ;/* CIL Label */ ;
      }
      {
      win_new_height(wp, wp->w_height - 1);
      win_comp_pos();
      lastwin->w_status_height = 1;
      comp_col();
      redraw_all_later(40);
      }
    }
  }
  }
  }
  return;
}
}
char_u *file_name_at_cursor(int options___0 , long count___2 ) 
{










}
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) 
{















































































































































}
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) 
{











































































































































































}
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) 
{































































































































































































}
static int path_is_url(char_u *p___0 ) 
{





















}
int min_rows(void) 
{ 
  WIN *wp ;
  int total ;

  {
  if ((unsigned long )firstwin == (unsigned long )((void *)0)) {

  }
  total = (int )p_ch;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    total = (int )((long )total + (p_wmh + (long )wp->w_status_height));
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  if (p_wmh == 0L) {

  }
  return (total);
}
}
int only_one_window(void) 
{ 
  int count___2 ;
  WIN *wp ;

  {
  count___2 = 0;
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (! (wp->w_buffer)->b_help) {
      count___2 ++;
    } else { //Added block



    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return (count___2 <= 1);
}
}
void check_lnums(int do_curwin ) 
{ 
  WIN *wp ;

  {
  wp = firstwin;
  {
  while (1) {
    while_continue: ;/* CIL Label */ ;
    if (! ((unsigned long )wp != (unsigned long )((void *)0))) {
      goto while_break;
    }
    if (do_curwin) {

    } else { //Added block
    if ((unsigned long )wp != (unsigned long )curwin) {
      _L: ;
      if ((unsigned long )wp->w_buffer == (unsigned long )curbuf) {
        if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count) {

        }
        if (wp->w_topline > curbuf->b_ml.ml_line_count) {

        }
      }
    }
    }
    wp = wp->w_next;
  }
  while_break: ;/* CIL Label */ ;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-avUm5A6g.i","-O0")
char *Version  =    (char *)"5.8";
char *mediumVersion  =    (char *)"5.8";
char *longVersion  =    (char *)"VIM - Vi IMproved 5.8 (2001 May 31, compiled Dec 18 2020 01:10:01)";
static void version_msg(char *s ) ;
static char *features[64]  = 
  {      (char *)"+autocmd",      (char *)"-browse",      (char *)"+builtin_terms",      (char *)"+byte_offset", 
        (char *)"+cindent",      (char *)"+cmdline_compl",      (char *)"+cmdline_info",      (char *)"+comments", 
        (char *)"+cryptv",      (char *)"-cscope",      (char *)"+dialog_con",      (char *)"+digraphs", 
        (char *)"-emacs_tags",      (char *)"+eval",      (char *)"+ex_extra",      (char *)"+extra_search", 
        (char *)"-farsi",      (char *)"+file_in_path",      (char *)"-osfiletype",      (char *)"+find_in_path", 
        (char *)"+fork()",      (char *)"-GUI",      (char *)"-hangul_input",      (char *)"+insert_expand", 
        (char *)"-langmap",      (char *)"+linebreak",      (char *)"+lispindent",      (char *)"+menu", 
        (char *)"+mksession",      (char *)"+modify_fname",      (char *)"+mouse",      (char *)"-mouse_dec", 
        (char *)"-mouse_gpm",      (char *)"-mouse_netterm",      (char *)"+mouse_xterm",      (char *)"-multi_byte", 
        (char *)"-perl",      (char *)"-python",      (char *)"+quickfix",      (char *)"-rightleft", 
        (char *)"+scrollbind",      (char *)"+smartindent",      (char *)"-sniff",      (char *)"+statusline", 
        (char *)"+syntax",      (char *)"+tag_binary",      (char *)"+tag_old_static",      (char *)"-tag_any_white", 
        (char *)"-tcl",      (char *)"+terminfo",      (char *)"+textobjects",      (char *)"+title", 
        (char *)"+user_commands",      (char *)"+visualextra",      (char *)"+viminfo",      (char *)"+wildignore", 
        (char *)"+wildmenu",      (char *)"+writebackup",      (char *)"+X11",      (char *)"-xfontset", 
        (char *)"-xim",      (char *)"+xterm_clipboard",      (char *)"-xterm_save",      (char *)((void *)0)};
static int included_patches[1]  = {      0};
int highest_patch(void) 
{





















}
void do_version(char_u *arg ) 
{











}
void list_version(void) 
{



































































































































}
static void version_msg(char *s ) 
{




















}
