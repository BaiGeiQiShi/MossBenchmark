/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
typedef __ino_t ino_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef unsigned char char_u;
typedef unsigned long long_u;
enum auto_event {
    EVENT_BUFCREATE = 0,
    EVENT_BUFDELETE = 1,
    EVENT_BUFENTER = 2,
    EVENT_BUFFILEPOST = 3,
    EVENT_BUFFILEPRE = 4,
    EVENT_BUFLEAVE = 5,
    EVENT_BUFNEWFILE = 6,
    EVENT_BUFREADPOST = 7,
    EVENT_BUFREADPRE = 8,
    EVENT_BUFUNLOAD = 9,
    EVENT_BUFHIDDEN = 10,
    EVENT_BUFWRITEPOST = 11,
    EVENT_BUFWRITEPRE = 12,
    EVENT_FILEAPPENDPOST = 13,
    EVENT_FILEAPPENDPRE = 14,
    EVENT_FILECHANGEDSHELL = 15,
    EVENT_FILEREADPOST = 16,
    EVENT_FILEREADPRE = 17,
    EVENT_FILETYPE = 18,
    EVENT_FILEWRITEPOST = 19,
    EVENT_FILEWRITEPRE = 20,
    EVENT_FILTERREADPOST = 21,
    EVENT_FILTERREADPRE = 22,
    EVENT_FILTERWRITEPOST = 23,
    EVENT_FILTERWRITEPRE = 24,
    EVENT_FOCUSGAINED = 25,
    EVENT_FOCUSLOST = 26,
    EVENT_GUIENTER = 27,
    EVENT_STDINREADPOST = 28,
    EVENT_STDINREADPRE = 29,
    EVENT_SYNTAX = 30,
    EVENT_TERMCHANGED = 31,
    EVENT_USER = 32,
    EVENT_VIMENTER = 33,
    EVENT_VIMLEAVE = 34,
    EVENT_VIMLEAVEPRE = 35,
    EVENT_WINENTER = 36,
    EVENT_WINLEAVE = 37,
    EVENT_FILEENCODING = 38,
    EVENT_CURSORHOLD = 39,
    NUM_EVENTS = 40
} ;
typedef enum auto_event EVENT_T;
typedef long linenr_t;
typedef unsigned int colnr_t;
struct __anonstruct_vim_regexp_55 {
   char_u *startp[10] ;
   char_u *endp[10] ;
   char_u regstart ;
   char_u reganch ;
   char_u *regmust ;
   int regmlen ;
   char_u program[1] ;
};
typedef struct __anonstruct_vim_regexp_55 vim_regexp;
struct fpos;
struct fpos;
typedef struct fpos FPOS;
struct fpos {
   linenr_t lnum ;
   colnr_t col ;
};
struct filemark {
   FPOS mark ;
   int fnum ;
};
struct taggy {
   char_u *tagname ;
   struct filemark fmark ;
   int cur_match ;
};
struct window;
struct window;
typedef struct window WIN;
struct winfpos;
struct winfpos;
typedef struct winfpos WINFPOS;
struct winfpos {
   WINFPOS *wl_next ;
   WINFPOS *wl_prev ;
   WIN *wl_win ;
   FPOS wl_fpos ;
};
struct u_entry {
   struct u_entry *ue_next ;
   linenr_t ue_top ;
   linenr_t ue_bot ;
   linenr_t ue_lcount ;
   char_u **ue_array ;
   long ue_size ;
};
struct u_header {
   struct u_header *uh_next ;
   struct u_header *uh_prev ;
   struct u_entry *uh_entry ;
   FPOS uh_cursor ;
   int uh_flags ;
   FPOS uh_namedm[26] ;
};
struct m_info;
struct m_info;
typedef struct m_info info_t;
struct m_info {
   long_u m_size ;
   info_t *m_next ;
};
struct m_block {
   struct m_block *mb_next ;
   info_t mb_info ;
};
struct growarray {
   int ga_len ;
   int ga_room ;
   int ga_itemsize ;
   int ga_growsize ;
   void *ga_data ;
};
struct block_hdr;
struct block_hdr;
typedef struct block_hdr BHDR;
struct memfile;
struct memfile;
typedef struct memfile MEMFILE;
typedef long blocknr_t;
struct block_hdr {
   BHDR *bh_next ;
   BHDR *bh_prev ;
   BHDR *bh_hash_next ;
   BHDR *bh_hash_prev ;
   blocknr_t bh_bnum ;
   char_u *bh_data ;
   int bh_page_count ;
   char bh_flags ;
};
struct nr_trans;
struct nr_trans;
typedef struct nr_trans NR_TRANS;
struct nr_trans {
   NR_TRANS *nt_next ;
   NR_TRANS *nt_prev ;
   blocknr_t nt_old_bnum ;
   blocknr_t nt_new_bnum ;
};
struct memfile {
   char_u *mf_fname ;
   char_u *mf_ffname ;
   int mf_fd ;
   BHDR *mf_free_first ;
   BHDR *mf_used_first ;
   BHDR *mf_used_last ;
   unsigned int mf_used_count ;
   unsigned int mf_used_count_max ;
   BHDR *mf_hash[64] ;
   NR_TRANS *mf_trans[64] ;
   blocknr_t mf_blocknr_max ;
   blocknr_t mf_blocknr_min ;
   blocknr_t mf_neg_count ;
   blocknr_t mf_infile_count ;
   unsigned int mf_page_size ;
   int mf_dirty ;
};
struct info_pointer;
struct info_pointer;
typedef struct info_pointer IPTR;
struct info_pointer {
   blocknr_t ip_bnum ;
   linenr_t ip_low ;
   linenr_t ip_high ;
   int ip_index ;
};
struct ml_chunksize {
   int mlcs_numlines ;
   int mlcs_totalsize ;
};
typedef struct ml_chunksize ML_CHUNKSIZE;
struct memline;
struct memline;
typedef struct memline MEMLINE;
struct memline {
   linenr_t ml_line_count ;
   MEMFILE *ml_mfp ;
   int ml_flags ;
   IPTR *ml_stack ;
   int ml_stack_top ;
   int ml_stack_size ;
   linenr_t ml_line_lnum ;
   char_u *ml_line_ptr ;
   BHDR *ml_locked ;
   linenr_t ml_locked_low ;
   linenr_t ml_locked_high ;
   int ml_locked_lineadd ;
   ML_CHUNKSIZE *ml_chunksize ;
   int ml_numchunks ;
   int ml_usedchunks ;
};
struct keyentry {
   struct keyentry *next ;
   int syn_inc_tag ;
   short syn_id ;
   short *next_list ;
   short flags ;
   char_u keyword[1] ;
};
struct syn_state {
   struct growarray sst_ga ;
   short *sst_next_list ;
   int sst_next_flags ;
};
struct buffer;
struct buffer;
typedef struct buffer BUF;
struct buffer {
   MEMLINE b_ml ;
   BUF *b_next ;
   BUF *b_prev ;
   int b_changed ;
   int b_nwindows ;
   int b_flags ;
   char_u *b_ffname ;
   char_u *b_sfname ;
   char_u *b_fname ;
   int b_dev ;
   ino_t b_ino ;
   int b_fnum ;
   WINFPOS *b_winfpos ;
   long b_mtime ;
   long b_mtime_read ;
   FPOS b_namedm[26] ;
   FPOS b_visual_start ;
   FPOS b_visual_end ;
   int b_visual_mode ;
   FPOS b_last_cursor ;
   char b_chartab[256] ;
   FPOS b_op_start ;
   FPOS b_op_end ;
   int b_marks_read ;
   struct u_header *b_u_oldhead ;
   struct u_header *b_u_newhead ;
   struct u_header *b_u_curhead ;
   int b_u_numhead ;
   int b_u_synced ;
   char_u *b_u_line_ptr ;
   linenr_t b_u_line_lnum ;
   colnr_t b_u_line_colnr ;
   struct m_block b_block_head ;
   info_t *b_m_search ;
   struct m_block *b_mb_current ;
   int b_scanned ;
   int b_p_initialized ;
   int b_p_ai ;
   int b_p_ro ;
   int b_p_lisp ;
   int b_p_inf ;
   char_u *b_p_cpt ;
   int b_p_bin ;
   int b_p_eol ;
   int b_p_et ;
   int b_p_ml ;
   int b_p_tx ;
   int b_p_swf ;
   int b_p_sn ;
   long b_p_sw ;
   long b_p_sts ;
   long b_p_ts ;
   long b_p_tw ;
   long b_p_wm ;
   char_u *b_p_ff ;
   char_u *b_p_fo ;
   char_u *b_p_com ;
   char_u *b_p_isk ;
   char_u *b_p_key ;
   char_u *b_p_nf ;
   char_u *b_p_mps ;
   long b_p_wm_nobin ;
   long b_p_tw_nobin ;
   int b_p_ml_nobin ;
   int b_p_et_nobin ;
   int b_p_ai_save ;
   int b_p_lisp_save ;
   long b_p_tw_save ;
   long b_p_wm_save ;
   long b_p_sts_save ;
   int b_p_si ;
   int b_p_si_save ;
   int b_p_cin ;
   int b_p_cin_save ;
   char_u *b_p_cino ;
   char_u *b_p_cink ;
   char_u *b_p_cinw ;
   char_u *b_p_syn ;
   char_u *b_p_ft ;
   int b_start_ffc ;
   struct growarray b_vars ;
   int b_may_swap ;
   int b_did_warn ;
   int b_help ;
   int b_shortname ;
   struct keyentry **b_keywtab ;
   struct keyentry **b_keywtab_ic ;
   int b_syn_ic ;
   struct growarray b_syn_patterns ;
   struct growarray b_syn_clusters ;
   int b_syn_sync_flags ;
   short b_syn_sync_id ;
   long b_syn_sync_minlines ;
   long b_syn_sync_maxlines ;
   char_u *b_syn_linecont_pat ;
   vim_regexp *b_syn_linecont_prog ;
   int b_syn_linecont_ic ;
   int b_syn_topgrp ;
   struct syn_state *b_syn_states ;
   int b_syn_states_len ;
   linenr_t b_syn_states_lnum ;
   linenr_t b_syn_change_lnum ;
};
struct window {
   BUF *w_buffer ;
   WIN *w_prev ;
   WIN *w_next ;
   FPOS w_cursor ;
   int w_valid ;
   FPOS w_valid_cursor ;
   colnr_t w_valid_leftcol ;
   int w_wrow ;
   int w_wcol ;
   int w_cline_height ;
   int w_cline_row ;
   colnr_t w_virtcol ;
   colnr_t w_curswant ;
   int w_set_curswant ;
   linenr_t w_old_cursor_lnum ;
   colnr_t w_old_cursor_fcol ;
   colnr_t w_old_cursor_lcol ;
   linenr_t w_old_visual_lnum ;
   colnr_t w_old_curswant ;
   linenr_t w_topline ;
   linenr_t w_botline ;
   int w_empty_rows ;
   int w_winpos ;
   int w_height ;
   int w_status_height ;
   int w_redr_status ;
   int w_redr_type ;
   FPOS w_ru_cursor ;
   colnr_t w_ru_virtcol ;
   linenr_t w_ru_topline ;
   char w_ru_empty ;
   colnr_t w_leftcol ;
   colnr_t w_skipcol ;
   int w_lsize_valid ;
   linenr_t *w_lsize_lnum ;
   char_u *w_lsize ;
   int w_alt_fnum ;
   int w_arg_idx ;
   int w_arg_idx_invalid ;
   int w_p_list ;
   int w_p_nu ;
   int w_p_wrap ;
   int w_p_lbr ;
   long w_p_scroll ;
   int w_p_scb ;
   long w_scbind_pos ;
   int w_preview ;
   struct growarray w_vars ;
   FPOS w_pcmark ;
   FPOS w_prev_pcmark ;
   struct filemark w_jumplist[50] ;
   int w_jumplistlen ;
   int w_jumplistidx ;
   struct taggy w_tagstack[20] ;
   int w_tagstackidx ;
   int w_tagstacklen ;
   int w_fraction ;
   int w_prev_fraction_row ;
};
enum hlf_value {
    HLF_8 = 0,
    HLF_AT = 1,
    HLF_D = 2,
    HLF_E = 3,
    HLF_H = 4,
    HLF_I = 5,
    HLF_L = 6,
    HLF_M = 7,
    HLF_CM = 8,
    HLF_N = 9,
    HLF_R = 10,
    HLF_S = 11,
    HLF_SNC = 12,
    HLF_T = 13,
    HLF_V = 14,
    HLF_VNC = 15,
    HLF_W = 16,
    HLF_WM = 17,
    HLF_COUNT = 18
} ;
struct oparg {
   int op_type ;
   int regname ;
   int motion_type ;
   int inclusive ;
   int end_adjusted ;
   FPOS start ;
   FPOS end ;
   long line_count ;
   int empty ;
   int is_VIsual ;
   int block_mode ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
};
typedef struct oparg OPARG;
struct Completion {
   struct Completion *next ;
   struct Completion *prev ;
   char_u *str ;
   char_u *fname ;
   int original ;
};
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
enum CMD_index {
    CMD_append = 0,
    CMD_abbreviate = 1,
    CMD_abclear = 2,
    CMD_all = 3,
    CMD_amenu = 4,
    CMD_anoremenu = 5,
    CMD_args = 6,
    CMD_argument = 7,
    CMD_ascii = 8,
    CMD_autocmd = 9,
    CMD_augroup = 10,
    CMD_aunmenu = 11,
    CMD_buffer = 12,
    CMD_bNext = 13,
    CMD_ball = 14,
    CMD_badd = 15,
    CMD_bdelete = 16,
    CMD_behave = 17,
    CMD_blast = 18,
    CMD_bmodified = 19,
    CMD_bnext = 20,
    CMD_bprevious = 21,
    CMD_brewind = 22,
    CMD_break = 23,
    CMD_browse = 24,
    CMD_buffers = 25,
    CMD_bunload = 26,
    CMD_change = 27,
    CMD_cNext = 28,
    CMD_cabbrev = 29,
    CMD_cabclear = 30,
    CMD_call = 31,
    CMD_cc = 32,
    CMD_cd = 33,
    CMD_center = 34,
    CMD_cfile = 35,
    CMD_chdir = 36,
    CMD_checkpath = 37,
    CMD_clist = 38,
    CMD_clast = 39,
    CMD_close = 40,
    CMD_cmap = 41,
    CMD_cmapclear = 42,
    CMD_cmenu = 43,
    CMD_cnext = 44,
    CMD_cnewer = 45,
    CMD_cnfile = 46,
    CMD_cnoremap = 47,
    CMD_cnoreabbrev = 48,
    CMD_cnoremenu = 49,
    CMD_copy = 50,
    CMD_colder = 51,
    CMD_command = 52,
    CMD_comclear = 53,
    CMD_continue = 54,
    CMD_confirm = 55,
    CMD_cprevious = 56,
    CMD_cquit = 57,
    CMD_crewind = 58,
    CMD_cscope = 59,
    CMD_cstag = 60,
    CMD_cunmap = 61,
    CMD_cunabbrev = 62,
    CMD_cunmenu = 63,
    CMD_delete = 64,
    CMD_delcommand = 65,
    CMD_delfunction = 66,
    CMD_display = 67,
    CMD_digraphs = 68,
    CMD_djump = 69,
    CMD_dlist = 70,
    CMD_doautocmd = 71,
    CMD_doautoall = 72,
    CMD_dsearch = 73,
    CMD_dsplit = 74,
    CMD_edit = 75,
    CMD_echo = 76,
    CMD_echohl = 77,
    CMD_echon = 78,
    CMD_else = 79,
    CMD_elseif = 80,
    CMD_exemenu = 81,
    CMD_endif = 82,
    CMD_endfunction = 83,
    CMD_endwhile = 84,
    CMD_ex = 85,
    CMD_execute = 86,
    CMD_exit = 87,
    CMD_file = 88,
    CMD_files = 89,
    CMD_filetype = 90,
    CMD_find = 91,
    CMD_fixdel = 92,
    CMD_function = 93,
    CMD_global = 94,
    CMD_goto = 95,
    CMD_grep = 96,
    CMD_gui = 97,
    CMD_gvim = 98,
    CMD_help = 99,
    CMD_helpfind = 100,
    CMD_highlight = 101,
    CMD_hide = 102,
    CMD_history = 103,
    CMD_insert = 104,
    CMD_iabbrev = 105,
    CMD_iabclear = 106,
    CMD_if = 107,
    CMD_ijump = 108,
    CMD_ilist = 109,
    CMD_imap = 110,
    CMD_imapclear = 111,
    CMD_imenu = 112,
    CMD_inoremap = 113,
    CMD_inoreabbrev = 114,
    CMD_inoremenu = 115,
    CMD_intro = 116,
    CMD_isearch = 117,
    CMD_isplit = 118,
    CMD_iunmap = 119,
    CMD_iunabbrev = 120,
    CMD_iunmenu = 121,
    CMD_join = 122,
    CMD_jumps = 123,
    CMD_k = 124,
    CMD_list = 125,
    CMD_last = 126,
    CMD_left = 127,
    CMD_let = 128,
    CMD_ls = 129,
    CMD_move = 130,
    CMD_mark = 131,
    CMD_make = 132,
    CMD_map = 133,
    CMD_mapclear = 134,
    CMD_marks = 135,
    CMD_menu = 136,
    CMD_messages = 137,
    CMD_mkexrc = 138,
    CMD_mksession = 139,
    CMD_mkvimrc = 140,
    CMD_mode = 141,
    CMD_next = 142,
    CMD_new = 143,
    CMD_nmap = 144,
    CMD_nmapclear = 145,
    CMD_nmenu = 146,
    CMD_nnoremap = 147,
    CMD_nnoremenu = 148,
    CMD_noremap = 149,
    CMD_nohlsearch = 150,
    CMD_noreabbrev = 151,
    CMD_noremenu = 152,
    CMD_normal = 153,
    CMD_number = 154,
    CMD_nunmap = 155,
    CMD_nunmenu = 156,
    CMD_open = 157,
    CMD_omap = 158,
    CMD_omapclear = 159,
    CMD_omenu = 160,
    CMD_only = 161,
    CMD_onoremap = 162,
    CMD_onoremenu = 163,
    CMD_options = 164,
    CMD_ounmap = 165,
    CMD_ounmenu = 166,
    CMD_print = 167,
    CMD_pclose = 168,
    CMD_perl = 169,
    CMD_perldo = 170,
    CMD_pop = 171,
    CMD_ppop = 172,
    CMD_preserve = 173,
    CMD_previous = 174,
    CMD_promptfind = 175,
    CMD_promptrepl = 176,
    CMD_ptag = 177,
    CMD_ptNext = 178,
    CMD_ptjump = 179,
    CMD_ptlast = 180,
    CMD_ptnext = 181,
    CMD_ptprevious = 182,
    CMD_ptrewind = 183,
    CMD_ptselect = 184,
    CMD_put = 185,
    CMD_pwd = 186,
    CMD_python = 187,
    CMD_pyfile = 188,
    CMD_quit = 189,
    CMD_qall = 190,
    CMD_read = 191,
    CMD_recover = 192,
    CMD_redo = 193,
    CMD_redir = 194,
    CMD_registers = 195,
    CMD_resize = 196,
    CMD_retab = 197,
    CMD_return = 198,
    CMD_rewind = 199,
    CMD_right = 200,
    CMD_rviminfo = 201,
    CMD_substitute = 202,
    CMD_sNext = 203,
    CMD_sargument = 204,
    CMD_sall = 205,
    CMD_sbuffer = 206,
    CMD_sbNext = 207,
    CMD_sball = 208,
    CMD_sblast = 209,
    CMD_sbmodified = 210,
    CMD_sbnext = 211,
    CMD_sbprevious = 212,
    CMD_sbrewind = 213,
    CMD_set = 214,
    CMD_sfind = 215,
    CMD_shell = 216,
    CMD_sleep = 217,
    CMD_slast = 218,
    CMD_smagic = 219,
    CMD_snext = 220,
    CMD_sniff = 221,
    CMD_snomagic = 222,
    CMD_source = 223,
    CMD_split = 224,
    CMD_sprevious = 225,
    CMD_srewind = 226,
    CMD_stop = 227,
    CMD_stag = 228,
    CMD_startinsert = 229,
    CMD_stjump = 230,
    CMD_stselect = 231,
    CMD_sunhide = 232,
    CMD_suspend = 233,
    CMD_sview = 234,
    CMD_swapname = 235,
    CMD_syntax = 236,
    CMD_syncbind = 237,
    CMD_t = 238,
    CMD_tNext = 239,
    CMD_tag = 240,
    CMD_tags = 241,
    CMD_tcl = 242,
    CMD_tcldo = 243,
    CMD_tclfile = 244,
    CMD_tearoff = 245,
    CMD_tjump = 246,
    CMD_tlast = 247,
    CMD_tmenu = 248,
    CMD_tnext = 249,
    CMD_tprevious = 250,
    CMD_trewind = 251,
    CMD_tselect = 252,
    CMD_tunmenu = 253,
    CMD_undo = 254,
    CMD_unabbreviate = 255,
    CMD_unhide = 256,
    CMD_unlet = 257,
    CMD_unmap = 258,
    CMD_unmenu = 259,
    CMD_update = 260,
    CMD_vglobal = 261,
    CMD_version = 262,
    CMD_visual = 263,
    CMD_view = 264,
    CMD_vmap = 265,
    CMD_vmapclear = 266,
    CMD_vmenu = 267,
    CMD_vnoremap = 268,
    CMD_vnoremenu = 269,
    CMD_vunmap = 270,
    CMD_vunmenu = 271,
    CMD_write = 272,
    CMD_wNext = 273,
    CMD_wall = 274,
    CMD_while = 275,
    CMD_winsize = 276,
    CMD_winpos = 277,
    CMD_wnext = 278,
    CMD_wprevious = 279,
    CMD_wq = 280,
    CMD_wqall = 281,
    CMD_wviminfo = 282,
    CMD_xit = 283,
    CMD_xall = 284,
    CMD_yank = 285,
    CMD_z = 286,
    CMD_bang = 287,
    CMD_pound = 288,
    CMD_and = 289,
    CMD_star = 290,
    CMD_lshift = 291,
    CMD_equal = 292,
    CMD_rshift = 293,
    CMD_at = 294,
    CMD_Next = 295,
    CMD_Print = 296,
    CMD_X = 297,
    CMD_tilde = 298,
    CMD_SIZE = 299,
    CMD_USER = -1
} ;
typedef enum CMD_index CMDIDX;
struct exarg {
   char_u *arg ;
   char_u *nextcmd ;
   char_u *cmd ;
   CMDIDX cmdidx ;
   long argt ;
   int skip ;
   int forceit ;
   int addr_count ;
   linenr_t line1 ;
   linenr_t line2 ;
   char_u *do_ecmd_cmd ;
   linenr_t do_ecmd_lnum ;
   int append ;
   int usefilter ;
   int amount ;
   int regname ;
   int useridx ;
};
typedef struct exarg EXARG;
typedef int var_number_type;
union __anonunion_var_val_170 {
   var_number_type var_number ;
   char_u *var_string ;
};
struct __anonstruct_var_169 {
   char_u *var_name ;
   char var_type ;
   union __anonunion_var_val_170 var_val ;
};
typedef struct __anonstruct_var_169 var;
typedef var *VAR;
struct ufunc {
   struct ufunc *next ;
   char_u *name ;
   int varargs ;
   int flags ;
   int calls ;
   struct growarray args ;
   struct growarray lines ;
};
struct funccall {
   struct ufunc *func ;
   int linenr ;
   int argcount ;
   VAR argvars ;
   var a0_var ;
   var firstline ;
   var lastline ;
   struct growarray l_vars ;
   VAR retvar ;
};
struct vimvar {
   char *name ;
   int len ;
   char_u *val ;
   char type ;
   char flags ;
};
enum exp_type {
    TYPE_UNKNOWN = 0,
    TYPE_EQUAL = 1,
    TYPE_NEQUAL = 2,
    TYPE_GREATER = 3,
    TYPE_GEQUAL = 4,
    TYPE_SMALLER = 5,
    TYPE_SEQUAL = 6,
    TYPE_MATCH = 7,
    TYPE_NOMATCH = 8
} ;
struct fst {
   char *f_name ;
   char f_min_argc ;
   char f_max_argc ;
   void (*f_func)(VAR args , VAR rvar ) ;
};
enum __anonenum_VAR_FLAVOUR_171 {
    VAR_FLAVOUR_DEFAULT = 0,
    VAR_FLAVOUR_SESSION = 1,
    VAR_FLAVOUR_VIMINFO = 2
} ;
typedef enum __anonenum_VAR_FLAVOUR_171 VAR_FLAVOUR;
typedef __mode_t mode_t;
struct cmdname {
   char_u *cmd_name ;
   long_u cmd_argt ;
};
struct condstack {
   char cs_flags[50] ;
   int cs_line[50] ;
   int cs_idx ;
   int cs_whilelevel ;
   char cs_had_while ;
   char cs_had_continue ;
   char cs_had_endwhile ;
};
struct ucmd {
   char_u *uc_name ;
   long uc_argt ;
   char_u *uc_rep ;
   long uc_def ;
   int uc_compl ;
};
typedef struct ucmd UCMD;
struct source_cookie {
   FILE *fp ;
   char_u *nextline ;
};
enum __anonenum_type_169 {
    ct_ARGS = 0,
    ct_BANG = 1,
    ct_COUNT = 2,
    ct_LINE1 = 3,
    ct_LINE2 = 4,
    ct_REGISTER = 5,
    ct_LT = 6,
    ct_NONE = 7
} ;
struct cmdline_info {
   char_u *cmdbuff ;
   int cmdbufflen ;
   int cmdlen ;
   int cmdpos ;
   int cmdspos ;
   int cmdfirstc ;
   int cmdindent ;
   char_u *cmdprompt ;
   int cmdattr ;
   int overstrike ;
};
struct hist_entry {
   int hisnum ;
   char_u *hisstr ;
};
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef __uid_t uid_t;
struct aco_save {
   WIN *save_curwin ;
   BUF *save_buf ;
   FPOS save_cursor ;
   linenr_t save_topline ;
};
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
struct AutoCmd {
   char_u *cmd ;
   char nested ;
   char last ;
   struct AutoCmd *next ;
};
typedef struct AutoCmd AutoCmd;
struct AutoPat {
   int group ;
   char_u *pat ;
   int patlen ;
   char_u *reg_pat ;
   char allow_dirs ;
   char last ;
   AutoCmd *cmds ;
   struct AutoPat *next ;
};
typedef struct AutoPat AutoPat;
struct event_name {
   char *name ;
   EVENT_T event ;
};
struct AutoPatCmd {
   AutoPat *curpat ;
   AutoCmd *nextcmd ;
   int group ;
   char_u *fname ;
   char_u *sfname ;
   char_u *tail ;
   EVENT_T event ;
};
typedef struct AutoPatCmd AutoPatCmd;
struct bufblock {
   struct bufblock *b_next ;
   char_u b_str[1] ;
};
struct buffheader {
   struct bufblock bh_first ;
   struct bufblock *bh_curr ;
   int bh_index ;
   int bh_space ;
};
struct mapblock {
   struct mapblock *m_next ;
   char_u *m_keys ;
   int m_keylen ;
   char_u *m_str ;
   int m_mode ;
   int m_noremap ;
};
struct initmap {
   char_u *arg ;
   int mode ;
};
typedef unsigned short short_u;
typedef unsigned long Atom;
struct _XDisplay;
struct _XDisplay;
typedef struct _XDisplay Display;
struct _XtAppStruct;
struct _XtAppStruct;
typedef struct _XtAppStruct *XtAppContext;
struct VimMenu {
   int modes ;
   char_u *name ;
   char_u *dname ;
   int mnemonic ;
   char_u *actext ;
   int priority ;
   char_u *strings[6] ;
   int noremap[6] ;
   struct VimMenu *children ;
   struct VimMenu *next ;
};
typedef struct VimMenu VimMenu;
struct VimClipboard {
   int available ;
   int owned ;
   FPOS start ;
   FPOS end ;
   int vmode ;
   short_u origin_row ;
   short_u origin_start_col ;
   short_u origin_end_col ;
   short_u word_start_col ;
   short_u word_end_col ;
   FPOS prev ;
   short_u state ;
   short_u mode ;
   Atom xatom ;
   Atom xa_targets ;
   Atom xa_text ;
   Atom xa_compound_text ;
};
typedef struct VimClipboard VimClipboard;
typedef __off_t off_t;
typedef int __pid_t;
typedef __pid_t pid_t;
struct block0;
struct block0;
typedef struct block0 ZERO_BL;
struct pointer_block;
struct pointer_block;
typedef struct pointer_block PTR_BL;
struct data_block;
struct data_block;
typedef struct data_block DATA_BL;
struct pointer_entry;
struct pointer_entry;
typedef struct pointer_entry PTR_EN;
struct pointer_entry {
   blocknr_t pe_bnum ;
   linenr_t pe_line_count ;
   linenr_t pe_old_lnum ;
   int pe_page_count ;
};
struct pointer_block {
   short_u pb_id ;
   short_u pb_count ;
   short_u pb_count_max ;
   PTR_EN pb_pointer[1] ;
};
struct data_block {
   short_u db_id ;
   unsigned int db_free ;
   unsigned int db_txt_start ;
   unsigned int db_txt_end ;
   linenr_t db_line_count ;
   unsigned int db_index[1] ;
};
struct block0 {
   char_u b0_id[2] ;
   char_u b0_version[10] ;
   char_u b0_page_size[4] ;
   char_u b0_mtime[4] ;
   char_u b0_ino[4] ;
   char_u b0_pid[4] ;
   char_u b0_uname[40] ;
   char_u b0_hname[40] ;
   char_u b0_fname[900] ;
   long b0_magic_long ;
   int b0_magic_int ;
   short b0_magic_short ;
   char_u b0_magic_char ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct msg_hist {
   struct msg_hist *next ;
   char_u *msg ;
   int attr ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct modmasktable {
   int mod_mask ;
   char_u name ;
};
struct key_name_entry {
   int key ;
   char_u *name ;
};
struct mousetable {
   int pseudo_code ;
   int button ;
   int is_click ;
   int is_drag ;
};
typedef unsigned short ush;
typedef unsigned long ulg;
struct cmdarg {
   OPARG *oap ;
   int prechar ;
   int cmdchar ;
   int nchar ;
   int extra_char ;
   long count0 ;
   long count1 ;
};
typedef struct cmdarg CMDARG;
typedef unsigned int int_u;
struct yankreg {
   char_u **y_array ;
   linenr_t y_size ;
   char_u y_type ;
};
struct block_def {
   int startspaces ;
   int endspaces ;
   int textlen ;
   char_u *textstart ;
   colnr_t textcol ;
   colnr_t start_vcol ;
   colnr_t end_vcol ;
   int is_short ;
   int is_MAX ;
   int is_EOL ;
   int is_oneChar ;
   int pre_whitesp ;
   int pre_whitesp_c ;
   colnr_t end_char_vcols ;
   colnr_t start_char_vcols ;
};
struct vimoption {
   char *fullname ;
   char *shortname ;
   short_u flags ;
   char_u *var ;
   char_u *def_val[2] ;
};
struct lcstab {
   int *lcsp ;
   char *name ;
};
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_8 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_8 fd_set;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
struct __dirstream;
typedef struct __dirstream DIR;
typedef unsigned long XID;
typedef unsigned long VisualID;
typedef XID Window;
typedef XID Colormap;
typedef char *XPointer;
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
typedef struct _XExtData XExtData;
struct _XGC;
struct _XGC;
typedef struct _XGC *GC;
struct __anonstruct_Visual_60 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
typedef struct __anonstruct_Visual_60 Visual;
struct __anonstruct_Depth_61 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
typedef struct __anonstruct_Depth_61 Depth;
struct __anonstruct_Screen_62 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
typedef struct __anonstruct_Screen_62 Screen;
struct __anonstruct_ScreenFormat_63 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
typedef struct __anonstruct_ScreenFormat_63 ScreenFormat;
struct _XPrivate;
struct _XPrivate;
struct _XrmHashBucketRec;
struct _XrmHashBucketRec;
struct __anonstruct__XPrivDisplay_78 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
typedef struct __anonstruct__XPrivDisplay_78 *_XPrivDisplay;
struct __anonstruct_XErrorEvent_109 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
typedef struct __anonstruct_XErrorEvent_109 XErrorEvent;
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
struct __anonstruct_min_aspect_138 {
   int x ;
   int y ;
};
struct __anonstruct_XSizeHints_137 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_138 min_aspect ;
   struct __anonstruct_min_aspect_138 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
typedef struct __anonstruct_XSizeHints_137 XSizeHints;
struct __anonstruct_XTextProperty_140 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
typedef struct __anonstruct_XTextProperty_140 XTextProperty;
enum __anonenum_XrmOptionKind_148 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
typedef enum __anonenum_XrmOptionKind_148 XrmOptionKind;
struct __anonstruct_XrmOptionDescRec_149 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
typedef struct __anonstruct_XrmOptionDescRec_149 XrmOptionDescRec;
struct _WidgetRec;
struct _WidgetRec;
typedef struct _WidgetRec *Widget;
struct _WidgetClassRec;
struct _WidgetClassRec;
typedef struct _WidgetClassRec *WidgetClass;
typedef unsigned int Cardinal;
typedef unsigned long XtInputMask;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct signalinfo {
   int sig ;
   char *name ;
   char deadly ;
};
struct dir_stack_t {
   struct dir_stack_t *next ;
   char_u *dirname ;
};
struct qf_line {
   struct qf_line *qf_next ;
   struct qf_line *qf_prev ;
   linenr_t qf_lnum ;
   int qf_fnum ;
   int qf_col ;
   int qf_nr ;
   char_u *qf_text ;
   char_u qf_cleared ;
   char_u qf_type ;
   char_u qf_valid ;
};
struct qf_list {
   struct qf_line *qf_start ;
   struct qf_line *qf_ptr ;
   int qf_count ;
   int qf_index ;
   int qf_nonevalid ;
};
struct eformat {
   vim_regexp *prog ;
   struct eformat *next ;
   char_u addr[7] ;
   char_u prefix ;
   char_u flags ;
};
struct fmtpattern {
   char_u convchar ;
   char *pattern ;
};
struct __anonstruct_namedata_t_169 {
   size_t len ;
   int (*func)(int  ) ;
   char_u name[sizeof("backspace:]")] ;
};
typedef struct __anonstruct_namedata_t_169 namedata_t;
typedef void (*(*fptr)(char_u * , int  ))();
struct __anonstruct_term_167 {
   char_u *start ;
   char_u *stop ;
};
struct __anonstruct_cterm_168 {
   char_u fg_color ;
   char_u bg_color ;
};
union __anonunion_ae_u_166 {
   struct __anonstruct_term_167 term ;
   struct __anonstruct_cterm_168 cterm ;
};
struct attr_entry {
   short ae_attr ;
   union __anonunion_ae_u_166 ae_u ;
};
struct stl_hlrec {
   char_u *start ;
   int userhl ;
};
enum __anonenum_type_169___0 {
    Normal = 0,
    Empty = 1,
    Group = 2,
    Middle = 3,
    Highlight = 4,
    Trunc = 5
} ;
struct stl_item {
   char_u *start ;
   int minwid ;
   int maxwid ;
   enum __anonenum_type_169___0 type ;
};
struct soffset {
   int dir ;
   int line ;
   int end ;
   long off ;
};
struct spat {
   char_u *pat ;
   int magic ;
   int no_scs ;
   struct soffset off ;
};
struct SearchedFile {
   FILE *fp ;
   char_u *name ;
   linenr_t lnum ;
   int matched ;
};
typedef struct SearchedFile SearchedFile;
struct hl_group {
   char_u *sg_name ;
   char_u *sg_name_u ;
   int sg_term ;
   char_u *sg_start ;
   char_u *sg_stop ;
   int sg_term_attr ;
   int sg_cterm ;
   int sg_cterm_bold ;
   int sg_cterm_fg ;
   int sg_cterm_bg ;
   int sg_cterm_attr ;
   int sg_link ;
   int sg_set ;
};
struct syn_pattern {
   char sp_type ;
   char sp_syncing ;
   short sp_flags ;
   int sp_syn_inc_tag ;
   short sp_syn_id ;
   short sp_syn_match_id ;
   char_u *sp_pattern ;
   vim_regexp *sp_prog ;
   int sp_ic ;
   short sp_off_flags ;
   int sp_offsets[7] ;
   short *sp_cont_list ;
   short *sp_next_list ;
   int sp_sync_idx ;
   int sp_line_id ;
   int sp_startcol ;
};
struct buf_state {
   int bs_idx ;
   int bs_flags ;
};
struct syn_cluster {
   char_u *scl_name ;
   char_u *scl_name_u ;
   short *scl_list ;
};
struct state_item {
   int si_idx ;
   int si_id ;
   int si_trans_id ;
   int si_m_lnum ;
   int si_m_startcol ;
   int si_m_endcol ;
   int si_h_startcol ;
   int si_h_endcol ;
   int si_eoe_col ;
   int si_end_idx ;
   int si_ends ;
   int si_attr ;
   int si_flags ;
   short *si_cont_list ;
   short *si_next_list ;
};
struct flag {
   char *name ;
   int len ;
   int val ;
};
struct pat_ptr {
   struct syn_pattern *pp_synp ;
   int pp_matchgroup_id ;
   struct pat_ptr *pp_next ;
};
struct subcommand {
   char *name ;
   void (*func)(EXARG * , int  ) ;
};
enum __anonenum_expand_what_169 {
    EXP_SUBCMD = 0,
    EXP_CASE = 1
} ;
struct tag_pointers {
   char_u *tagname ;
   char_u *tagname_end ;
   char_u *fname ;
   char_u *fname_end ;
   char_u *command ;
   char_u *command_end ;
   char_u *tag_fname ;
   char_u *tagkind ;
   char_u *tagkind_end ;
};
struct tag_search_info {
   off_t low_offset ;
   off_t high_offset ;
   off_t curr_offset ;
   off_t match_offset ;
   int low_char ;
   int high_char ;
};
enum __anonenum_state_169 {
    TS_START = 0,
    TS_LINEAR = 1,
    TS_BINARY = 2,
    TS_SKIP_BACK = 3,
    TS_STEP_FORWARD = 4
} ;
struct visited {
   struct visited *v_next ;
   struct stat v_st ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
enum SpecialKey {
    KS_NAME = 0,
    KS_CE = 1,
    KS_AL = 2,
    KS_CAL = 3,
    KS_DL = 4,
    KS_CDL = 5,
    KS_CS = 6,
    KS_CL = 7,
    KS_CD = 8,
    KS_DA = 9,
    KS_DB = 10,
    KS_VI = 11,
    KS_VE = 12,
    KS_VS = 13,
    KS_ME = 14,
    KS_MR = 15,
    KS_MD = 16,
    KS_SE = 17,
    KS_SO = 18,
    KS_CZH = 19,
    KS_CZR = 20,
    KS_UE = 21,
    KS_US = 22,
    KS_MS = 23,
    KS_CM = 24,
    KS_SR = 25,
    KS_CRI = 26,
    KS_VB = 27,
    KS_KS = 28,
    KS_KE = 29,
    KS_TI = 30,
    KS_TE = 31,
    KS_BC = 32,
    KS_CCS = 33,
    KS_CCO = 34,
    KS_CSF = 35,
    KS_CSB = 36,
    KS_XS = 37,
    KS_MB = 38,
    KS_CAF = 39,
    KS_CAB = 40,
    KS_LE = 41,
    KS_ND = 42,
    KS_CIS = 43,
    KS_CIE = 44,
    KS_TS = 45,
    KS_FS = 46,
    KS_CWP = 47,
    KS_CWS = 48,
    KS_CRV = 49,
    KS_OP = 50
} ;
struct builtin_term {
   int bt_entry ;
   char *bt_string ;
};
struct __anonstruct_string_names_169 {
   enum SpecialKey dest ;
   char *name ;
};
struct termcode {
   char_u name[2] ;
   char_u *code ;
   int len ;
};
typedef unsigned long Time;
typedef XID Drawable;
struct __anonstruct_XKeyEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
typedef struct __anonstruct_XKeyEvent_79 XKeyEvent;
struct __anonstruct_XButtonEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
typedef struct __anonstruct_XButtonEvent_80 XButtonEvent;
struct __anonstruct_XMotionEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
typedef struct __anonstruct_XMotionEvent_81 XMotionEvent;
struct __anonstruct_XCrossingEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
typedef struct __anonstruct_XCrossingEvent_82 XCrossingEvent;
struct __anonstruct_XFocusChangeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
typedef struct __anonstruct_XFocusChangeEvent_83 XFocusChangeEvent;
struct __anonstruct_XKeymapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
typedef struct __anonstruct_XKeymapEvent_84 XKeymapEvent;
struct __anonstruct_XExposeEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
typedef struct __anonstruct_XExposeEvent_85 XExposeEvent;
struct __anonstruct_XGraphicsExposeEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XGraphicsExposeEvent_86 XGraphicsExposeEvent;
struct __anonstruct_XNoExposeEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
typedef struct __anonstruct_XNoExposeEvent_87 XNoExposeEvent;
struct __anonstruct_XVisibilityEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
typedef struct __anonstruct_XVisibilityEvent_88 XVisibilityEvent;
struct __anonstruct_XCreateWindowEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
typedef struct __anonstruct_XCreateWindowEvent_89 XCreateWindowEvent;
struct __anonstruct_XDestroyWindowEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
typedef struct __anonstruct_XDestroyWindowEvent_90 XDestroyWindowEvent;
struct __anonstruct_XUnmapEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
typedef struct __anonstruct_XUnmapEvent_91 XUnmapEvent;
struct __anonstruct_XMapEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
typedef struct __anonstruct_XMapEvent_92 XMapEvent;
struct __anonstruct_XMapRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
typedef struct __anonstruct_XMapRequestEvent_93 XMapRequestEvent;
struct __anonstruct_XReparentEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
typedef struct __anonstruct_XReparentEvent_94 XReparentEvent;
struct __anonstruct_XConfigureEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
typedef struct __anonstruct_XConfigureEvent_95 XConfigureEvent;
struct __anonstruct_XGravityEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
typedef struct __anonstruct_XGravityEvent_96 XGravityEvent;
struct __anonstruct_XResizeRequestEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
typedef struct __anonstruct_XResizeRequestEvent_97 XResizeRequestEvent;
struct __anonstruct_XConfigureRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
typedef struct __anonstruct_XConfigureRequestEvent_98 XConfigureRequestEvent;
struct __anonstruct_XCirculateEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateEvent_99 XCirculateEvent;
struct __anonstruct_XCirculateRequestEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
typedef struct __anonstruct_XCirculateRequestEvent_100 XCirculateRequestEvent;
struct __anonstruct_XPropertyEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
typedef struct __anonstruct_XPropertyEvent_101 XPropertyEvent;
struct __anonstruct_XSelectionClearEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
typedef struct __anonstruct_XSelectionClearEvent_102 XSelectionClearEvent;
struct __anonstruct_XSelectionRequestEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionRequestEvent_103 XSelectionRequestEvent;
struct __anonstruct_XSelectionEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
typedef struct __anonstruct_XSelectionEvent_104 XSelectionEvent;
struct __anonstruct_XColormapEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
typedef struct __anonstruct_XColormapEvent_105 XColormapEvent;
union __anonunion_data_107 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
struct __anonstruct_XClientMessageEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_107 data ;
};
typedef struct __anonstruct_XClientMessageEvent_106 XClientMessageEvent;
struct __anonstruct_XMappingEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
typedef struct __anonstruct_XMappingEvent_108 XMappingEvent;
struct __anonstruct_XAnyEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
typedef struct __anonstruct_XAnyEvent_110 XAnyEvent;
struct __anonstruct_XGenericEvent_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
typedef struct __anonstruct_XGenericEvent_111 XGenericEvent;
struct __anonstruct_XGenericEventCookie_112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
typedef struct __anonstruct_XGenericEventCookie_112 XGenericEventCookie;
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
typedef union _XEvent XEvent;
enum __anonenum_XICCEncodingStyle_141 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
typedef enum __anonenum_XICCEncodingStyle_141 XICCEncodingStyle;
typedef char Boolean;
typedef void *XtPointer;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-iFTblII1.i","-O0")
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
long Columns ;
int cmdline_row  ;
int msg_row  ;
int need_fileinfo ;
int msg_scroll ;
char_u *sourcing_name ;
linenr_t sourcing_lnum ;
int autocmd_no_enter ;
int autocmd_no_leave ;
int modified_was_set  ;
BUF *au_new_curbuf ;
WIN *firstwin  ;
WIN *lastwin  ;
WIN *curwin  ;
BUF *firstbuf ;
BUF *lastbuf ;
BUF *curbuf ;
char_u **arg_files  ;
int arg_file_count  ;
int arg_had_last ;
int swap_exists_action ;
char_u *IObuff  ;
char_u *NameBuff  ;
int RedrawingDisabled ;
int readonlymode ;
int got_int ;
int reg_ic ;
char_u no_lines_msg[23] ;
int stl_syntax ;
char_u e_noalt[18] ;
char_u e_nowrtmsg[47] ;
char_u e_trailing[20] ;
int p_ea  ;
int p_hid  ;
int p_icon  ;
char_u *p_iconstring  ;
int p_magic  ;
long p_mls  ;
int p_ru  ;
int p_sb  ;
int p_sol  ;
char_u *p_swb  ;
int p_title  ;
long p_titlelen  ;
char_u *p_titlestring  ;
void mch_settitle(char_u *title , char_u *icon ) ;
int mch_dirname(char_u *buf___3 , int len___0 ) ;
int open_buffer(int read_stdin ) ;
int buf_valid(BUF *buf___3 ) ;
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) ;
void buf_clear(BUF *buf___3 ) ;
void buf_freeall(BUF *buf___3 , int del_buf ) ;
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) ;
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) ;
void enter_buffer(BUF *buf___3 ) ;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) ;
void free_buf_options(BUF *buf___3 , int free_p_ff ) ;
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) ;
void buflist_getfpos(void) ;
BUF *buflist_findname(char_u *ffname ) ;
int buflist_findpat(char_u *pattern , char_u *pattern_end ) ;
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) ;
BUF *buflist_findnr(int nr ) ;
char_u *buflist_nr2name(int n , int fullname , int helptail ) ;
FPOS *buflist_findfpos(BUF *buf___3 ) ;
linenr_t buflist_findlnum(BUF *buf___3 ) ;
void buflist_list(void) ;
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) ;
int setfname(char_u *ffname , char_u *sfname , int message ) ;
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) ;
char_u *getaltfname(int errmsg ) ;
int buflist_add(char_u *fname ) ;
void buflist_altfpos(void) ;
int otherfile(char_u *ffname ) ;
void fileinfo(int fullname , int shorthelp , int dont_truncate ) ;
void cursor_pos_info(void) ;
void col_print(char_u *buf___3 , int col , int vcol ) ;
void maketitle(void) ;
void resettitle(void) ;
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) ;
char_u *fix_fname(char_u *fname ) ;
void fname_expand(char_u **ffname , char_u **sfname ) ;
void do_arg_all(int count___2 , int forceit ) ;
void do_buffer_all(int count___2 , int all ) ;
void do_modelines(void) ;
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_bufferlist(FILE *fp___0 ) ;
int init_chartab(void) ;
char_u *transchar(int c ) ;
int vim_strsize(char_u *s ) ;
int linetabsize(char_u *s ) ;
char_u *skipwhite(char_u *p___0 ) ;
char_u *skiptowhite_esc(char_u *p___0 ) ;
long getdigits(char_u **pp ) ;
void var_init(struct growarray *gap ) ;
void var_clear(struct growarray *gap ) ;
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) ;
void viminfo_writestring(FILE *fd , char_u *p___0 ) ;
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) ;
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) ;
int autowrite(BUF *buf___3 , int forceit ) ;
int can_abandon(BUF *buf___3 , int forceit ) ;
void check_arg_idx(WIN *win ) ;
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) ;
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) ;
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) ;
int buf_check_timestamp(BUF *buf___3 , int focus ) ;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) ;
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) ;
int vgetc(void) ;
void getout(int r ) ;
void setpcmark(void) ;
void fmarks_check_names(BUF *buf___3 ) ;
void clrallmarks(BUF *buf___3 ) ;
void set_last_cursor(WIN *win ) ;
int removable(char_u *name___1 ) ;
int smsg(char_u *s  , ...) ;
int ml_open(void) ;
void ml_setname(void) ;
void ml_close(BUF *buf___3 , int del_file ) ;
void ml_timestamp(BUF *buf___3 ) ;
void ml_recover(void) ;
char_u *ml_get(linenr_t lnum ) ;
char_u *ml_get_curline(void) ;
int msg(char_u *s ) ;
int emsg(char_u *s ) ;
int emsg2(char_u *s , char_u *a1 ) ;
int emsgn(char_u *s , long n ) ;
char_u *msg_trunc_attr(char_u *s , int force , int attr ) ;
void msg_putchar(int c ) ;
int msg_outtrans(char_u *str___1 ) ;
void msg_puts(char_u *s ) ;
char *plural(long n ) ;
void changed(void) ;
void unchanged(BUF *buf___3 , int ff ) ;
void expand_env(char_u *src , char_u *dst , int dstlen ) ;
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) ;
char_u *home_replace_save(BUF *buf___3 , char_u *src ) ;
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) ;
char_u *gettail(char_u *fname ) ;
char_u *FullName_save(char_u *fname , int force ) ;
void check_cursor_lnum(void) ;
void check_cursor_col(void) ;
char_u *alloc(unsigned int size ) ;
char_u *alloc_clear(unsigned int size ) ;
char_u *vim_strsave(char_u *string___0 ) ;
void vim_free(void *x___0 ) ;
char_u *vim_strchr(char_u *string___0 , int n ) ;
char_u *vim_strrchr(char_u *string___0 , int n ) ;
int vim_isspace(int x___0 ) ;
int get_fileformat(BUF *buf___3 ) ;
int do_set(char_u *arg , int modeline ) ;
char_u *find_viminfo_parameter(int type ) ;
void free_string_option(char_u *p___0 ) ;
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) ;
int shortmess(int x___0 ) ;
vim_regexp *vim_regcomp(char_u *expr , int magic ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
void update_screen(int type ) ;
void status_redraw_all(void) ;
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) ;
void scroll_cursor_halfway(int atend ) ;
void validate_virtcol(void) ;
void syntax_clear(BUF *buf___3 ) ;
void out_flush(void) ;
void ui_delay(long msec , int ignoreinput ) ;
void ui_breakcheck(void) ;
void u_sync(void) ;
void u_clearall(BUF *buf___3 ) ;
void u_blockfree(BUF *buf___3 ) ;
int buf_changed(BUF *buf___3 ) ;
int curbuf_changed(void) ;
int win_split(int new_height , int redraw , int req_room ) ;
int win_valid(WIN *win ) ;
void win_move_after(WIN *win1 , WIN *win2 ) ;
void close_windows(BUF *buf___3 ) ;
void close_window(WIN *win , int free_buf ) ;
void close_others(int message , int forceit ) ;
void win_enter(WIN *wp , int undo_sync ) ;
WIN *buf_jump_open_win(BUF *buf___3 ) ;
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) ;
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) ;
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) ;
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) ;
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) ;
static void buf_setino(BUF *buf___3 ) ;
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) ;
static int ti_change(char_u *str___1 , char_u **last ) ;
static void free_buffer(BUF *buf___3 ) ;
int open_buffer(int read_stdin ) 
{




















































































































}
int buf_valid(BUF *buf___3 ) 
{



















}
void close_buffer(WIN *win , BUF *buf___3 , int free_buf , int del_buf ) 
{
























































































}
void buf_clear(BUF *buf___3 ) 
{













}
void buf_freeall(BUF *buf___3 , int del_buf ) 
{




































}
static void free_buffer(BUF *buf___3 ) 
{
























}
char_u *do_bufdel(int command , char_u *arg , int addr_count , int start_bnr , int end_bnr ,
                  int forceit ) 
{






















































































































}
int do_buffer(int action , int start___0 , int dir , int count___2 , int forceit ) 
{





















































































































































































































































































































































































































































}
void enter_buffer(BUF *buf___3 ) 
{




































}
static int top_file_num  =    1;
BUF *buflist_new(char_u *ffname , char_u *sfname , linenr_t lnum , int use_curbuf ) 
{



























































































































































































}
void free_buf_options(BUF *buf___3 , int free_p_ff ) 
{
























}
int buflist_getfile(int n , linenr_t lnum , int options___0 , int forceit ) 
{























































































}
void buflist_getfpos(void) 
{


















}
BUF *buflist_findname(char_u *ffname ) 
{
















}
static BUF *buflist_findname_stat(char_u *ffname , struct stat *stp ) 
{























}
int buflist_findpat(char_u *pattern , char_u *pattern_end ) 
{
































































































































}
int ExpandBufnames(char_u *pat , int *num_file , char_u ***file , int options___0 ) 
{














































































































}
static char_u *buflist_match(vim_regexp *prog , BUF *buf___3 ) 
{

















}
static char_u *buflist_match_try(vim_regexp *prog , char_u *name___1 ) 
{
































}
BUF *buflist_findnr(int nr ) 
{











































}
char_u *buflist_nr2name(int n , int fullname , int helptail ) 
{



























}
static void buflist_setfpos(BUF *buf___3 , linenr_t lnum , colnr_t col ) 
{















































}
static FPOS no_position  =    {(linenr_t )1, (colnr_t )0};
FPOS *buflist_findfpos(BUF *buf___3 ) 
{


























}
linenr_t buflist_findlnum(BUF *buf___3 ) 
{








}
void buflist_list(void) 
{



























































































































}
int buflist_name_nr(int fnum , char_u **fname , linenr_t *lnum ) 
{



















}
int setfname(char_u *ffname , char_u *sfname , int message ) 
{








































































































}
void setaltfname(char_u *ffname , char_u *sfname , linenr_t lnum ) 
{











}
char_u *getaltfname(int errmsg ) 
{


















}
int buflist_add(char_u *fname ) 
{











}
void buflist_altfpos(void) 
{








}
int otherfile(char_u *ffname ) 
{








}
static int otherfile_buf(BUF *buf___3 , char_u *ffname , struct stat *stp ) 
{



















































}
static void buf_setino(BUF *buf___3 ) 
{



















}
static int buf_same_ino(BUF *buf___3 , struct stat *stp ) 
{


















}
void fileinfo(int fullname , int shorthelp , int dont_truncate ) 
{





























































































































































































}
void cursor_pos_info(void) 
{















































































}
void col_print(char_u *buf___3 , int col , int vcol ) 
{
















}
static char_u *lasttitle  =    (char_u *)((void *)0);
static char_u *lasticon  =    (char_u *)((void *)0);
void maketitle(void) 
{
















































































































































}
static int ti_change(char_u *str___1 , char_u **last ) 
{






























}
void resettitle(void) 
{








}
int append_arg_number(WIN *wp , char_u *buf___3 , int add_file , int maxlen ) 
{










































}
char_u *fix_fname(char_u *fname ) 
{








}
void fname_expand(char_u **ffname , char_u **sfname ) 
{














}
void do_arg_all(int count___2 , int forceit ) 
{






















































































































































































































































}
void do_buffer_all(int count___2 , int all ) 
{
























































































































































































}
static int chk_modeline(linenr_t lnum ) ;
static int entered  =    0;
void do_modelines(void) 
{



































































}
static int chk_modeline(linenr_t lnum ) 
{

































































































































































}
int read_viminfo_bufferlist(char_u *line , FILE *fp___0 , int writing ) 
{










































































}
void write_viminfo_bufferlist(FILE *fp___0 ) 
{












































































}
#pragma merger("0","/tmp/cil-TCvMZy5O.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
int VIsual_active ;
int State ;
char_u chartab[256]  ;
char breakat_flags[256]  ;
int lcs_tab1 ;
char_u *p_isf  ;
char_u *p_isi  ;
char_u *p_isp  ;
char_u *p_sel  ;
char_u *p_sbr  ;
void trans_characters(char_u *buf___3 , int bufsize ) ;
char_u *transstr(char_u *s ) ;
void transchar_nonprint(char_u *buf___3 , int c ) ;
int charsize(int c ) ;
int chartabsize(int c , colnr_t col ) ;
int win_linetabsize(WIN *wp , char_u *s ) ;
int vim_isIDc(int c ) ;
int vim_iswordc(int c ) ;
int vim_iswordc_buf(int c , BUF *buf___3 ) ;
int vim_isfilec(int c ) ;
int vim_isprintc(int c ) ;
int safe_vim_isprintc(int c ) ;
int lbr_chartabsize(unsigned char *s , colnr_t col ) ;
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) ;
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) ;
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) ;
char_u *skipdigits(char_u *p___0 ) ;
int vim_isdigit(int c ) ;
char_u *skiptowhite(char_u *p___0 ) ;
int vim_isblankline(char_u *lbuf ) ;
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) ;
int hex2nr(int c ) ;
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) ;
char_u *skip_to_option_part(char_u *p___0 ) ;
static int win_chartabsize(WIN *wp , int c , colnr_t col ) ;
static int chartab_initialized  =    0;
int init_chartab(void) 
{












































































































































































































































}
void trans_characters(char_u *buf___3 , int bufsize ) 
{












































}
char_u *transstr(char_u *s ) 
{






























}
static char_u buf[5]  ;
char_u *transchar(int c ) 
{












































}
void transchar_nonprint(char_u *buf___3 , int c ) 
{






































}
int charsize(int c ) 
{



















}
int vim_strsize(char_u *s ) 
{























}
int chartabsize(int c , colnr_t col ) 
{


























}
static int win_chartabsize(WIN *wp , int c , colnr_t col ) 
{


























}
int linetabsize(char_u *s ) 
{























}
int win_linetabsize(WIN *wp , char_u *s ) 
{























}
int vim_isIDc(int c ) 
{














}
int vim_iswordc(int c ) 
{














}
int vim_iswordc_buf(int c , BUF *buf___3 ) 
{














}
int vim_isfilec(int c ) 
{














}
int vim_isprintc(int c ) 
{














}
int safe_vim_isprintc(int c ) 
{





}
int lbr_chartabsize(unsigned char *s , colnr_t col ) 
{



































}
int win_lbr_chartabsize(WIN *wp , unsigned char *s , colnr_t col , int *head ) 
{


























































































































}
void getvcol(WIN *wp , FPOS *pos___0 , colnr_t *start___0 , colnr_t *cursor , colnr_t *end ) 
{











































































































}
void getvcols(FPOS *pos1 , FPOS *pos2 , colnr_t *left , colnr_t *right ) 
{






















}
char_u *skipwhite(char_u *p___0 ) 
{

















}
char_u *skipdigits(char_u *p___0 ) 
{


















}
int vim_isdigit(int c ) 
{






















}
char_u *skiptowhite(char_u *p___0 ) 
{























}
char_u *skiptowhite_esc(char_u *p___0 ) 
{

































}
long getdigits(char_u **pp ) 
{

















}
int vim_isblankline(char_u *lbuf ) 
{






















}
void vim_str2nr(char_u *start___0 , int *hexp , int *len___0 , int dooct , int dohex ,
                long *nptr , unsigned long *unptr ) 
{





































































































































}
int hex2nr(int c ) 
{











}
#pragma merger("0","/tmp/cil-_1DEHuqF.i","-O0")
int must_redraw ;
char_u e_number[16] ;
int p_dg  ;
int do_digraph(int c ) ;
int getdigraph(int char1 , int char2 , int meta ) ;
void putdigraph(char_u *str___1 ) ;
void listdigraphs(void) ;
static int getexactdigraph(int char1 , int char2 , int meta ) ;
static void printdigraph(char_u *p___0 ) ;
static char_u (*digraphnew)[3]  ;
static int digraphcount  =    0;
char_u digraphdefault[101][3]  = 
  { {        (char_u )'~',        (char_u )'!',        (char_u )161}, 
   {        (char_u )'c',        (char_u )'|',        (char_u )162}, 
   {        (char_u )'$',        (char_u )'$',        (char_u )163}, 
   {        (char_u )'o',        (char_u )'x',        (char_u )164}, 
   {        (char_u )'e',        (char_u )'=',        (char_u )164}, 
   {        (char_u )'Y',        (char_u )'-',        (char_u )165}, 
   {        (char_u )'|',        (char_u )'|',        (char_u )166}, 
   {        (char_u )'p',        (char_u )'a',        (char_u )167}, 
   {        (char_u )'\"',        (char_u )'\"',        (char_u )168}, 
   {        (char_u )'c',        (char_u )'O',        (char_u )169}, 
   {        (char_u )'a',        (char_u )'-',        (char_u )170}, 
   {        (char_u )'<',        (char_u )'<',        (char_u )171}, 
   {        (char_u )'-',        (char_u )',',        (char_u )172}, 
   {        (char_u )'-',        (char_u )'-',        (char_u )173}, 
   {        (char_u )'r',        (char_u )'O',        (char_u )174}, 
   {        (char_u )'-',        (char_u )'=',        (char_u )175}, 
   {        (char_u )'~',        (char_u )'o',        (char_u )176}, 
   {        (char_u )'+',        (char_u )'-',        (char_u )177}, 
   {        (char_u )'2',        (char_u )'2',        (char_u )178}, 
   {        (char_u )'3',        (char_u )'3',        (char_u )179}, 
   {        (char_u )'\'',        (char_u )'\'',        (char_u )180}, 
   {        (char_u )'j',        (char_u )'u',        (char_u )181}, 
   {        (char_u )'p',        (char_u )'p',        (char_u )182}, 
   {        (char_u )'~',        (char_u )'.',        (char_u )183}, 
   {        (char_u )',',        (char_u )',',        (char_u )184}, 
   {        (char_u )'1',        (char_u )'1',        (char_u )185}, 
   {        (char_u )'o',        (char_u )'-',        (char_u )186}, 
   {        (char_u )'>',        (char_u )'>',        (char_u )187}, 
   {        (char_u )'1',        (char_u )'4',        (char_u )188}, 
   {        (char_u )'1',        (char_u )'2',        (char_u )189}, 
   {        (char_u )'3',        (char_u )'4',        (char_u )190}, 
   {        (char_u )'~',        (char_u )'?',        (char_u )191}, 
   {        (char_u )'A',        (char_u )'`',        (char_u )192}, 
   {        (char_u )'A',        (char_u )'\'',        (char_u )193}, 
   {        (char_u )'A',        (char_u )'^',        (char_u )194}, 
   {        (char_u )'A',        (char_u )'~',        (char_u )195}, 
   {        (char_u )'A',        (char_u )'\"',        (char_u )196}, 
   {        (char_u )'A',        (char_u )'@',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'A',        (char_u )197}, 
   {        (char_u )'A',        (char_u )'E',        (char_u )198}, 
   {        (char_u )'C',        (char_u )',',        (char_u )199}, 
   {        (char_u )'E',        (char_u )'`',        (char_u )200}, 
   {        (char_u )'E',        (char_u )'\'',        (char_u )201}, 
   {        (char_u )'E',        (char_u )'^',        (char_u )202}, 
   {        (char_u )'E',        (char_u )'\"',        (char_u )203}, 
   {        (char_u )'I',        (char_u )'`',        (char_u )204}, 
   {        (char_u )'I',        (char_u )'\'',        (char_u )205}, 
   {        (char_u )'I',        (char_u )'^',        (char_u )206}, 
   {        (char_u )'I',        (char_u )'\"',        (char_u )207}, 
   {        (char_u )'D',        (char_u )'-',        (char_u )208}, 
   {        (char_u )'N',        (char_u )'~',        (char_u )209}, 
   {        (char_u )'O',        (char_u )'`',        (char_u )210}, 
   {        (char_u )'O',        (char_u )'\'',        (char_u )211}, 
   {        (char_u )'O',        (char_u )'^',        (char_u )212}, 
   {        (char_u )'O',        (char_u )'~',        (char_u )213}, 
   {        (char_u )'O',        (char_u )'\"',        (char_u )214}, 
   {        (char_u )'/',        (char_u )'\\',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'E',        (char_u )215}, 
   {        (char_u )'O',        (char_u )'/',        (char_u )216}, 
   {        (char_u )'U',        (char_u )'`',        (char_u )217}, 
   {        (char_u )'U',        (char_u )'\'',        (char_u )218}, 
   {        (char_u )'U',        (char_u )'^',        (char_u )219}, 
   {        (char_u )'U',        (char_u )'\"',        (char_u )220}, 
   {        (char_u )'Y',        (char_u )'\'',        (char_u )221}, 
   {        (char_u )'I',        (char_u )'p',        (char_u )222}, 
   {        (char_u )'s',        (char_u )'s',        (char_u )223}, 
   {        (char_u )'a',        (char_u )'`',        (char_u )224}, 
   {        (char_u )'a',        (char_u )'\'',        (char_u )225}, 
   {        (char_u )'a',        (char_u )'^',        (char_u )226}, 
   {        (char_u )'a',        (char_u )'~',        (char_u )227}, 
   {        (char_u )'a',        (char_u )'\"',        (char_u )228}, 
   {        (char_u )'a',        (char_u )'@',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'a',        (char_u )229}, 
   {        (char_u )'a',        (char_u )'e',        (char_u )230}, 
   {        (char_u )'c',        (char_u )',',        (char_u )231}, 
   {        (char_u )'e',        (char_u )'`',        (char_u )232}, 
   {        (char_u )'e',        (char_u )'\'',        (char_u )233}, 
   {        (char_u )'e',        (char_u )'^',        (char_u )234}, 
   {        (char_u )'e',        (char_u )'\"',        (char_u )235}, 
   {        (char_u )'i',        (char_u )'`',        (char_u )236}, 
   {        (char_u )'i',        (char_u )'\'',        (char_u )237}, 
   {        (char_u )'i',        (char_u )'^',        (char_u )238}, 
   {        (char_u )'i',        (char_u )'\"',        (char_u )239}, 
   {        (char_u )'d',        (char_u )'-',        (char_u )240}, 
   {        (char_u )'n',        (char_u )'~',        (char_u )241}, 
   {        (char_u )'o',        (char_u )'`',        (char_u )242}, 
   {        (char_u )'o',        (char_u )'\'',        (char_u )243}, 
   {        (char_u )'o',        (char_u )'^',        (char_u )244}, 
   {        (char_u )'o',        (char_u )'~',        (char_u )245}, 
   {        (char_u )'o',        (char_u )'\"',        (char_u )246}, 
   {        (char_u )':',        (char_u )'-',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'e',        (char_u )247}, 
   {        (char_u )'o',        (char_u )'/',        (char_u )248}, 
   {        (char_u )'u',        (char_u )'`',        (char_u )249}, 
   {        (char_u )'u',        (char_u )'\'',        (char_u )250}, 
   {        (char_u )'u',        (char_u )'^',        (char_u )251}, 
   {        (char_u )'u',        (char_u )'\"',        (char_u )252}, 
   {        (char_u )'y',        (char_u )'\'',        (char_u )253}, 
   {        (char_u )'i',        (char_u )'p',        (char_u )254}, 
   {        (char_u )'y',        (char_u )'\"',        (char_u )255}, 
   {        (char_u )'\000',        (char_u )'\000',        (char_u )'\000'}};
static int backspaced  ;
static int lastchar  ;
int do_digraph(int c ) 
{




























}
static int getexactdigraph(int char1 , int char2 , int meta ) 
{
























































}
int getdigraph(int char1 , int char2 , int meta ) 
{


















}
void putdigraph(char_u *str___1 ) 
{







































































































}
void listdigraphs(void) 
{

























































}
static int len  ;
static void printdigraph(char_u *p___0 ) 
{




























}
#pragma merger("0","/tmp/cil-oAbd5Qx5.i","-O0")
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
char_u *NextScreen ;
int mod_mask ;
int redraw_cmdline ;
int clear_cmdline ;
colnr_t dollar_vcol ;
int completion_length ;
int continue_status ;
int completion_interrupted ;
int emsg_on_display ;
int intr_char ;
int highlight_attr[18]  ;
int sc_col  ;
int sandbox ;
FPOS where_paste_started  ;
int did_ai ;
colnr_t ai_col ;
int end_comment_pending ;
int did_si ;
int can_si ;
int can_si_back ;
FPOS Insstart  ;
int orig_line_count ;
int vr_lines_changed ;
colnr_t vr_virtcol ;
int Recording ;
int no_mapping ;
int allow_keys ;
int no_u_sync ;
int restart_edit ;
int arrow_used  ;
char_u *edit_submode ;
char_u *edit_submode_extra ;
enum hlf_value edit_submode_highl  ;
int ctrl_x_mode ;
int no_abbr ;
int fo_do_comments ;
int typelen  ;
int global_busy ;
int replace_offset ;
int no_hlsearch ;
char_u e_internal[15] ;
char_u e_noinstext[21] ;
char_u e_patnotf[18] ;
char_u e_sandbox[23] ;
char_u *p_cpo  ;
char_u *p_dict  ;
int p_hls  ;
int p_ic  ;
int p_im  ;
int p_js  ;
char_u *p_km  ;
int p_paste  ;
long p_so  ;
int p_sm  ;
int p_smd  ;
int p_scs  ;
int p_sta  ;
char_u *p_ww  ;
int p_ws  ;
int edit(int cmdchar , int startln , long count___2 ) ;
void display_dollar(colnr_t col ) ;
void change_indent(int type , int amount , int round , int replaced ) ;
void truncate_spaces(char_u *line ) ;
void backspace_until_column(int col ) ;
int vim_is_ctrl_x_key(int c ) ;
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) ;
void ins_compl_check_keys(void) ;
int get_literal(void) ;
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) ;
int comp_textwidth(int ff ) ;
void stop_arrow(void) ;
void set_last_insert(int c ) ;
void beginline(int flags___0 ) ;
int oneright(void) ;
int oneleft(void) ;
int cursor_up(long n , int upd_topline ) ;
int cursor_down(long n , int upd_topline ) ;
int stuff_inserted(int c , long count___2 , int no_esc ) ;
char_u *get_last_insert(void) ;
char_u *get_last_insert_save(void) ;
void replace_push(int c ) ;
int get_replace_stack_virtcol(void) ;
void fixthisline(int (*get_the_indent)(void) ) ;
int in_cinkeys(int keytyped , int when , int line_is_empty ) ;
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) ;
char_u *addstar(char_u *fname , int len___0 , int context ) ;
char_u *get_inserted(void) ;
int stuff_empty(void) ;
void ResetRedobuff(void) ;
void AppendToRedobuff(char_u *s ) ;
void AppendCharToRedobuff(int c ) ;
void AppendNumberToRedobuff(long n ) ;
void stuffReadbuff(char_u *s ) ;
void stuffcharReadbuff(int c ) ;
int start_redo_ins(void) ;
void stop_redo_ins(void) ;
int using_script(void) ;
int safe_vgetc(void) ;
int vpeekc(void) ;
int char_avail(void) ;
void vungetc(int c ) ;
int check_abbr(int c , char_u *ptr , int col , int mincol ) ;
char_u *ml_get_cursor(void) ;
int ml_replace(linenr_t lnum , char_u *line , int copy ) ;
int msg_attr(char_u *s , int attr ) ;
int get_indent(void) ;
void set_indent(int size , int del_first ) ;
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) ;
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) ;
void ins_char(int c ) ;
void ins_str(char_u *s ) ;
int del_char(int fixpos ) ;
int gchar_cursor(void) ;
void pchar_cursor(int c ) ;
int inindent(int extra ) ;
void change_warning(int col ) ;
void vim_beep(void) ;
int cin_islabel(int ind_maxcomment ) ;
int cin_iscase(char_u *s ) ;
int cin_isscopedecl(char_u *s ) ;
int get_c_indent(void) ;
void line_breakcheck(void) ;
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) ;
void FreeWild(int num , char_u **file ) ;
int goto_im(void) ;
int coladvance(colnr_t wcol ) ;
int inc_cursor(void) ;
int dec_cursor(void) ;
int dec(FPOS *lp ) ;
char_u *lalloc(long_u size , int message ) ;
char_u *vim_strnsave(char_u *string___0 , int len___0 ) ;
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) ;
char_u *get_special_key_name(int c , int modifiers ) ;
int get_special_key_code(char_u *name___1 ) ;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) ;
void clear_showcmd(void) ;
int add_to_showcmd(int c ) ;
void add_to_showcmd_c(int c ) ;
void do_check_scrollbind(int check ) ;
void scroll_redraw(int up , long count___2 ) ;
void start_selection(void) ;
void shift_line(int left , int round , int amount ) ;
int get_expr_register(void) ;
int insert_reg(int regname___0 , int literally ) ;
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) ;
int do_join(int insert_space , int redraw ) ;
int has_format_option(int x___0 ) ;
int can_bs(int what ) ;
void update_screenline(void) ;
void redraw_later(int type ) ;
void redraw_statuslines(void) ;
void win_redr_status(WIN *wp ) ;
void screen_putchar(int c , int row , int col , int attr ) ;
void update_topline(void) ;
void update_curswant(void) ;
void setcursor(void) ;
void changed_cline_bef_curs(void) ;
void set_topline(WIN *wp , linenr_t lnum ) ;
void validate_cursor(void) ;
void validate_cursor_col(void) ;
void curs_columns(int scroll ) ;
void scrolldown_clamp(void) ;
void scrollup_clamp(void) ;
int showmode(void) ;
void showruler(int always ) ;
void check_for_delay(int check_msg_scroll ) ;
int redrawing(void) ;
int onepage(int dir , long count___2 ) ;
void set_reg_ic(char_u *pat ) ;
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) ;
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) ;
FPOS *findmatch(OPARG *oap , int initc ) ;
int fwd_word(long count___2 , int type , int eol ) ;
int bck_word(long count___2 , int type , int stop ) ;
int linewhite(linenr_t lnum ) ;
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) ;
void syn_changed(linenr_t lnum ) ;
int syntax_present(BUF *buf___3 ) ;
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) ;
void setmouse(void) ;
int mouse_has(int c ) ;
void cursor_off(void) ;
int u_save_cursor(void) ;
int u_save(linenr_t top , linenr_t bot ) ;
static char *ctrl_x_msgs[10]  = 
  {      (char *)" Adding Keyword completion (^N/^P)",      (char *)" ^X mode (^E/^Y/^L/^]/^F/^I/^K/^D/^N/^P)",      (char *)" Adding Keyword Local completion (^N/^P)",      (char *)" Adding Whole line completion (^L/^N/^P)", 
        (char *)" Adding File name completion (^F/^N/^P)",      (char *)" Adding Tag completion (^]/^N/^P)",      (char *)" Adding Path pattern completion (^N/^P)",      (char *)" Adding Definition completion (^D/^N/^P)", 
        (char *)((void *)0),      (char *)" Adding Dictionary completion (^K/^N/^P)"};
static char_u e_hitend[21]  = 
  {      (char_u )'H',      (char_u )'i',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'p', 
        (char_u )'a',      (char_u )'r',      (char_u )'a',      (char_u )'g', 
        (char_u )'r',      (char_u )'a',      (char_u )'p',      (char_u )'h', 
        (char_u )'\000'};
static struct Completion *first_match  =    (struct Completion *)((void *)0);
static struct Completion *curr_match  =    (struct Completion *)((void *)0);
static struct Completion *shown_match  =    (struct Completion *)((void *)0);
static int started_completion  =    0;
static char_u *complete_pat  =    (char_u *)((void *)0);
static int complete_direction  =    1;
static int shown_direction  =    1;
static int completion_pending  =    0;
static FPOS initial_pos  ;
static colnr_t complete_col  =    (colnr_t )0;
static int save_sm  ;
static char_u *original_text  =    (char_u *)((void *)0);
static int continue_mode  =    0;
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) ;
static int ins_compl_make_cyclic(void) ;
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) ;
static void ins_compl_free(void) ;
static void ins_compl_clear(void) ;
static int ins_compl_prep(int c ) ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) ;
static int ins_compl_get_exp(FPOS *ini , int dir ) ;
static void ins_compl_delete(void) ;
static void ins_compl_insert(void) ;
static int ins_compl_next(int allow_get_expansion ) ;
static int ins_complete(int c ) ;
static int quote_meta(char_u *dest , char_u *src , int len___0 ) ;
static void edit_putchar(int c , int highlight ) ;
static void undisplay_dollar(void) ;
static void insert_special(int c , int allow_modmask , int ctrlv ) ;
static void redo_literal(int c ) ;
static void start_arrow(FPOS *end_insert_pos ) ;
static void stop_insert(FPOS *end_insert_pos ) ;
static int echeck_abbr(int c ) ;
static void replace_push_off(int c ) ;
static int replace_pop(void) ;
static void replace_join(int off___0 ) ;
static void replace_pop_ins(void) ;
static void replace_flush(void) ;
static void replace_do_bs(void) ;
static int ins_reg(void) ;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) ;
static void ins_shift(int c , int lastc___1 ) ;
static void ins_del(void) ;
static int ins_bs(int c , int mode , int *inserted_space_p ) ;
static void ins_mouse(int c ) ;
static void ins_mousescroll(int up ) ;
static void ins_left(void) ;
static void ins_home(void) ;
static void ins_end(void) ;
static void ins_s_left(void) ;
static void ins_right(void) ;
static void ins_s_right(void) ;
static void ins_up(void) ;
static void ins_pageup(void) ;
static void ins_down(void) ;
static void ins_pagedown(void) ;
static int ins_tab(void) ;
static int ins_eol(int c ) ;
static int ins_digraph(void) ;
static int ins_copychar(linenr_t lnum ) ;
static void ins_try_si(int c ) ;
static colnr_t get_nolist_virtcol(void) ;
static colnr_t Insstart_textlen  ;
static colnr_t Insstart_blank_vcol  ;
static char_u *last_insert  =    (char_u *)((void *)0);
static int last_insert_skip  ;
static int new_insert_skip  ;
static int can_cindent  ;
static int old_indent  =    0;
static linenr_t o_lnum  =    (linenr_t )0;
static int o_eol  =    0;
int edit(int cmdchar , int startln , long count___2 ) 
{


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void edit_putchar(int c , int highlight ) 
{



















}
void display_dollar(colnr_t col ) 
{

























}
static void undisplay_dollar(void) 
{











}
void change_indent(int type , int amount , int round , int replaced ) 
{







































































































































































































































}
void truncate_spaces(char_u *line ) 
{






































}
void backspace_until_column(int col ) 
{






























}
int vim_is_ctrl_x_key(int c ) 
{


















































































































































































}
int ins_compl_add_infercase(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                            int reuse ) 
{

























































































































}
static int ins_compl_add(char_u *str___1 , int len___0 , char_u *fname , int dir ,
                         int reuse ) 
{

































































































































}
static int ins_compl_make_cyclic(void) 
{



























}
static void ins_compl_dictionaries(char_u *dict , char_u *pat , int dir , int flags___0 ) 
{

















































































































































































}
static void ins_compl_free(void) 
{





































}
static void ins_compl_clear(void) 
{









}
static int ins_compl_prep(int c ) 
{




























































































































































































































































































}
static WIN *w  ;
static BUF *ins_compl_next_buf(BUF *buf___3 , int flag ) 
{


















































}
static FPOS first_match_pos  ;
static FPOS last_match_pos  ;
static char_u *e_cpt  =    (char_u *)"";
static int found_all  =    0;
static BUF *ins_buf  =    (BUF *)((void *)0);
static int ins_compl_get_exp(FPOS *ini , int dir ) 
{






























































































































































































































































































































































































































































































































































































































































}
static void ins_compl_delete(void) 
{
















}
static void ins_compl_insert(void) 
{
























}
static int ins_compl_next(int allow_get_expansion ) 
{








































































}
static int count  =    0;
void ins_compl_check_keys(void) 
{





























































}
static int ins_complete(int c ) 
{





































































































































































































































































































































































































































































































































}
static int quote_meta(char_u *dest , char_u *src , int len___0 ) 
{











































































}
int get_literal(void) 
{














































































































































}
static void insert_special(int c , int allow_modmask , int ctrlv ) 
{

































}
void insertchar(unsigned int c , int force_formatting , int second_indent , int ctrlv ) 
{


























































































































































































































































































































































































































































































































































































































































}
int comp_textwidth(int ff ) 
{






















}
static void redo_literal(int c ) 
{




















}
static void start_arrow(FPOS *end_insert_pos ) 
{












}
void stop_arrow(void) 
{


























}
static void stop_insert(FPOS *end_insert_pos ) 
{





















































































}
void set_last_insert(int c ) 
{























}
void beginline(int flags___0 ) 
{













































}
int oneright(void) 
{




















}
int oneleft(void) 
{










}
int cursor_up(long n , int upd_topline ) 
{























}
int cursor_down(long n , int upd_topline ) 
{






















}
int stuff_inserted(int c , long count___2 , int no_esc ) 
{

































































































}
char_u *get_last_insert(void) 
{








}
char_u *get_last_insert_save(void) 
{
























}
static int echeck_abbr(int c ) 
{



























}
char_u *replace_stack  =    (char_u *)((void *)0);
long replace_stack_nr  =    0L;
long replace_stack_len  =    0L;
void replace_push(int c ) 
{

































}
static void replace_push_off(int c ) 
{

























}
static int replace_pop(void) 
{










}
static void replace_join(int off___0 ) 
{





























}
static void replace_pop_ins(void) 
{

























}
static void replace_flush(void) 
{











}
static void replace_do_bs(void) 
{




















}
int get_replace_stack_virtcol(void) 
{


































































}
void fixthisline(int (*get_the_indent)(void) ) 
{














}
int in_cinkeys(int keytyped , int when , int line_is_empty ) 
{














































































































































































































































}
static int ins_reg(void) 
{








































































































}
static int disabled_redraw  =    0;
static int ins_esc(long *count___2 , int need_redraw , int cmdchar ) 
{
































































































}
static void ins_shift(int c , int lastc___1 ) 
{


























































}
static void ins_del(void) 
{
































































}
static int ins_bs(int c , int mode , int *inserted_space_p ) 
{























































































































































































































































































































































































































































































}
static void ins_mouse(int c ) 
{



























}
static void ins_mousescroll(int up ) 
{































}
static void ins_left(void) 
{







































}
static void ins_home(void) 
{

















}
static void ins_end(void) 
{

















}
static void ins_s_left(void) 
{



























}
static void ins_right(void) 
{







































}
static void ins_s_right(void) 
{






























}
static void ins_up(void) 
{




























}
static void ins_pageup(void) 
{





















}
static void ins_down(void) 
{




























}
static void ins_pagedown(void) 
{





















}
static int ins_tab(void) 
{




























































































































































































































































}
static int ins_eol(int c ) 
{


































}
static int ins_digraph(void) 
{
























































































}
static int ins_copychar(linenr_t lnum ) 
{























































}
static void ins_try_si(int c ) 
{
















































































































































}
static colnr_t get_nolist_virtcol(void) 
{






















}
#pragma merger("0","/tmp/cil-7getv7z7.i","-O0")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
char_u *term_strings[51]  ;
long Rows ;
int expand_context ;
char_u *expand_pattern ;
int msg_didout ;
int emsg_off ;
int did_emsg  ;
int need_wait_return ;
int didset_vim ;
int didset_vimruntime ;
int lines_left ;
int did_filetype ;
int starting ;
int KeyTyped  ;
char_u e_invarg2[21] ;
char_u e_invexpr2[23] ;
char_u e_letunexp[33] ;
char_u e_readonlyvar[35] ;
long p_mfd  ;
long p_verbose  ;
void mch_get_host_name(char_u *s , int len___0 ) ;
int mch_isFullName(char_u *fname ) ;
int mch_isdir(char_u *name___1 ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) ;
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) ;
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) ;
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) ;
void do_let(EXARG *eap ) ;
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) ;
void do_call(EXARG *eap ) ;
void do_unlet(char_u *arg , int forceit ) ;
char_u *get_user_var_name(int idx ) ;
char_u *get_function_name(int idx ) ;
char_u *get_expr_name(int idx ) ;
void set_vim_var_nr(int idx , long val ) ;
void set_vim_var_string(int idx , char_u *val ) ;
void do_echo(EXARG *eap , int echo ) ;
void do_echohl(char_u *arg ) ;
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
char_u *get_user_func_name(int idx ) ;
void do_delfunction(char_u *arg ) ;
void *save_funccal(void) ;
void restore_funccal(void *fc ) ;
void do_return(EXARG *eap ) ;
char_u *get_func_line(int c , void *cookie , int indent ) ;
int func_has_ended(void *cookie ) ;
int func_has_abort(void *cookie ) ;
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) ;
void write_viminfo_varlist(FILE *fp___0 ) ;
int store_session_globals(FILE *fd ) ;
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) ;
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) ;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) ;
int ends_excmd(int c ) ;
char_u *check_nextcmd(char_u *p___0 ) ;
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) ;
int put_eol(FILE *fd ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) ;
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) ;
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) ;
int get_histtype(char_u *name___1 ) ;
void add_to_history(int histype , char_u *new_entry , int in_map ) ;
int get_history_idx(int histype ) ;
char_u *get_history_entry(int histype , int idx ) ;
int clr_history(int histype ) ;
int del_history_entry(int histype , char_u *str___1 ) ;
int del_history_idx(int histype , int idx ) ;
int vim_rename(char_u *from , char_u *to ) ;
char_u *vim_tempname(int extra_char ) ;
void saveRedobuff(void) ;
void restoreRedobuff(void) ;
int get_map_mode(char_u **cmdp , int forceit ) ;
char_u *check_map(char_u *keys___0 , int mode , int exact ) ;
FPOS *getmark(int c , int changefile ) ;
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) ;
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) ;
void msg_start(void) ;
void msg_starthere(void) ;
void msg_putchar_attr(int c , int attr ) ;
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) ;
char_u *str2special(char_u **sp , int from ) ;
void msg_prt_line(char_u *s ) ;
void msg_puts_attr(char_u *s , int attr ) ;
void msg_clr_eos(void) ;
int msg_end(void) ;
void msg_advance(int col ) ;
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) ;
void init_homedir(void) ;
char_u *expand_env_save(char_u *src ) ;
void vim_setenv(char_u *name___1 , char_u *val ) ;
char_u *get_past_head(char_u *path ) ;
int vim_ispathsep(int c ) ;
char_u *get_cmd_output(char_u *cmd , int flags___0 ) ;
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) ;
void ga_clear(struct growarray *gap ) ;
void ga_clear_strings(struct growarray *gap ) ;
void ga_init(struct growarray *gap ) ;
void ga_init2(struct growarray *gap , int itemsize , int growsize ) ;
int ga_grow(struct growarray *gap , int n ) ;
void ga_concat(struct growarray *gap , char_u *s ) ;
void ga_append(struct growarray *gap , int c ) ;
int trans_special(char_u **srcp , char_u *dst , int keycode ) ;
char_u *get_reg_contents(int regname___0 ) ;
void write_reg_contents(int name___1 , char_u *str___1 ) ;
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) ;
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) ;
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) ;
void redraw_curbuf_later(int type ) ;
void update_curbuf(int type ) ;
void changed_line_abv_curs(void) ;
void approximate_botline(void) ;
void save_search_patterns(void) ;
void restore_search_patterns(void) ;
int syn_get_id(long line , long col , int trans___0 ) ;
char_u *highlight_has_attr(int id , int flag , int modec ) ;
char_u *highlight_color(int id , char_u *what , int modec ) ;
int syn_name2id(char_u *name___1 ) ;
int highlight_exists(char_u *name___1 ) ;
int syn_id2attr(int hl_id ) ;
int syn_get_final_id(int hl_id ) ;
char_u *get_highlight_name(int idx ) ;
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) ;
int u_savesub(linenr_t lnum ) ;
struct growarray variables  =    {0, 0, (int )sizeof(var ), 4, (void *)0};
static int echo_attr  =    0;
struct ufunc *firstfunc  =    (struct ufunc *)((void *)0);
struct funccall *current_funccal  =    (struct funccall *)((void *)0);
struct vimvar vimvars[8]  = 
  {      {(char *)"count", (int )(sizeof("count") - 1UL), (char_u *)((void *)0), (char)1,
      (char)3}, 
        {(char *)"count1", (int )(sizeof("count1") - 1UL), (char_u *)((void *)0), (char)1,
      (char)2}, 
        {(char *)"errmsg", (int )(sizeof("errmsg") - 1UL), (char_u *)((void *)0), (char)2,
      (char)1}, 
        {(char *)"warningmsg", (int )(sizeof("warningmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"statusmsg", (int )(sizeof("statusmsg") - 1UL), (char_u *)((void *)0),
      (char)2, (char)0}, 
        {(char *)"shell_error", (int )(sizeof("shell_error") - 1UL), (char_u *)((void *)0),
      (char)1, (char)3}, 
        {(char *)"this_session", (int )(sizeof("this_session") - 1UL), (char_u *)((void *)0),
      (char)2, (char)1}, 
        {(char *)"version", (int )(sizeof("version") - 1UL), (char_u *)508, (char)1,
      (char)3}};
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) ;
static int eval1(char_u **arg , VAR retvar , int evaluate ) ;
static int eval2(char_u **arg , VAR retvar , int evaluate ) ;
static int eval3(char_u **arg , VAR retvar , int evaluate ) ;
static int eval4(char_u **arg , VAR retvar , int evaluate ) ;
static int eval5(char_u **arg , VAR retvar , int evaluate ) ;
static int eval6(char_u **arg , VAR retvar , int evaluate ) ;
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) ;
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) ;
static int find_internal_func(char_u *name___1 ) ;
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) ;
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) ;
static void f_append(VAR argvars , VAR retvar ) ;
static void f_argc(VAR argvars , VAR retvar ) ;
static void f_argv(VAR argvars , VAR retvar ) ;
static void f_browse(VAR argvars , VAR retvar ) ;
static BUF *find_buffer(VAR avar ) ;
static void f_bufexists(VAR argvars , VAR retvar ) ;
static void f_bufloaded(VAR argvars , VAR retvar ) ;
static BUF *get_buf_var(VAR avar ) ;
static void f_bufname(VAR argvars , VAR retvar ) ;
static void f_bufnr(VAR argvars , VAR retvar ) ;
static void f_bufwinnr(VAR argvars , VAR retvar ) ;
static void f_byte2line(VAR argvars , VAR retvar ) ;
static void f_char2nr(VAR argvars , VAR retvar ) ;
static void f_col(VAR argvars , VAR retvar ) ;
static void f_confirm(VAR argvars , VAR retvar ) ;
static void f_delete(VAR argvars , VAR retvar ) ;
static void f_did_filetype(VAR argvars , VAR retvar ) ;
static void f_escape(VAR argvars , VAR retvar ) ;
static void f_exists(VAR argvars , VAR retvar ) ;
static void f_expand(VAR argvars , VAR retvar ) ;
static void f_filereadable(VAR argvars , VAR retvar ) ;
static void f_fnamemodify(VAR argvars , VAR retvar ) ;
static void f_getcwd(VAR argvars , VAR retvar ) ;
static void f_getftime(VAR argvars , VAR retvar ) ;
static void f_getline(VAR argvars , VAR retvar ) ;
static void f_getwinposx(VAR argvars , VAR retvar ) ;
static void f_getwinposy(VAR argvars , VAR retvar ) ;
static void f_glob(VAR argvars , VAR retvar ) ;
static void f_has(VAR argvars , VAR retvar ) ;
static void f_histadd(VAR argvars , VAR retvar ) ;
static void f_histdel(VAR argvars , VAR retvar ) ;
static void f_histget(VAR argvars , VAR retvar ) ;
static void f_histnr(VAR argvars , VAR retvar ) ;
static void f_hlexists(VAR argvars , VAR retvar ) ;
static void f_hlID(VAR argvars , VAR retvar ) ;
static void f_hostname(VAR argvars , VAR retvar ) ;
static void f_isdirectory(VAR argvars , VAR retvar ) ;
static void f_input(VAR argvars , VAR retvar ) ;
static void f_last_buffer_nr(VAR argvars , VAR retvar ) ;
static void f_libcall(VAR argvars , VAR retvar ) ;
static void f_line(VAR argvars , VAR retvar ) ;
static void f_line2byte(VAR argvars , VAR retvar ) ;
static void f_localtime(VAR argvars , VAR retvar ) ;
static void f_maparg(VAR argvars , VAR retvar ) ;
static void f_mapcheck(VAR argvars , VAR retvar ) ;
static void get_maparg(VAR argvars , VAR retvar , int exact ) ;
static void f_match(VAR argvars , VAR retvar ) ;
static void f_matchend(VAR argvars , VAR retvar ) ;
static void f_matchstr(VAR argvars , VAR retvar ) ;
static void f_nr2char(VAR argvars , VAR retvar ) ;
static void f_rename(VAR argvars , VAR retvar ) ;
static void f_setline(VAR argvars , VAR retvar ) ;
static void f_some_match(VAR argvars , VAR retvar , int type ) ;
static void f_strftime(VAR argvars , VAR retvar ) ;
static void f_strlen(VAR argvars , VAR retvar ) ;
static void f_strpart(VAR argvars , VAR retvar ) ;
static void f_strtrans(VAR argvars , VAR retvar ) ;
static void f_synID(VAR argvars , VAR retvar ) ;
static void f_synIDattr(VAR argvars , VAR retvar ) ;
static void f_synIDtrans(VAR argvars , VAR retvar ) ;
static void f_system(VAR argvars , VAR retvar ) ;
static void f_substitute(VAR argvars , VAR retvar ) ;
static void f_tempname(VAR argvars , VAR retvar ) ;
static void f_virtcol(VAR argvars , VAR retvar ) ;
static void f_visualmode(VAR argvars , VAR retvar ) ;
static void f_winbufnr(VAR argvars , VAR retvar ) ;
static void f_winheight(VAR argvars , VAR retvar ) ;
static void f_winnr(VAR argvars , VAR retvar ) ;
static WIN *find_win_by_nr(VAR vp ) ;
static FPOS *var2fpos(VAR varp ) ;
static int get_env_len(char_u **arg ) ;
static int get_id_len(char_u **arg ) ;
static int eval_isnamec(int c ) ;
static int find_vim_var(char_u *name___1 , int len___0 ) ;
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) ;
static VAR alloc_var(void) ;
static VAR alloc_string_var(char_u *s ) ;
static void free_var(VAR varp ) ;
static void clear_var(VAR varp ) ;
static long get_var_number(VAR varp ) ;
static char_u *get_var_string(VAR varp ) ;
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) ;
static VAR find_var(char_u *name___1 , int writing ) ;
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) ;
static void var_free_one(VAR v ) ;
static void list_one_var(VAR v , char_u *prefix ) ;
static void list_vim_var(int i___0 ) ;
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) ;
static void set_var(char_u *name___1 , VAR varp ) ;
static char_u *find_option_end(char_u *p___0 ) ;
static void list_func_head(struct ufunc *fp___0 ) ;
static struct ufunc *find_func(char_u *name___1 ) ;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) ;
void set_internal_string_var(char_u *name___1 , char_u *value ) 
{




















}
int eval_to_bool(char_u *arg , int *error , char_u **nextcmd , int skip ) 
{






























}
char_u *eval_to_string(char_u *arg , char_u **nextcmd ) 
{




















}
char_u *eval_to_string_safe(char_u *arg , char_u **nextcmd ) 
{













}
void do_let(EXARG *eap ) 
{
































































































































































































































































































































































































}
void set_context_for_expression(char_u *arg , CMDIDX cmdidx ) 
{

















































































































































}
void do_call(EXARG *eap ) 
{




















































































}
void do_unlet(char_u *arg , int forceit ) 
{







































}
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) ;
static char_u *varnamebuf  =    (char_u *)((void *)0);
static int varnamebuflen  =    0;
static char_u *cat_prefix_varname(int prefix , char_u *name___1 ) 
{



























}
static int gidx  ;
static int bidx  ;
static int widx  ;
static int vidx  ;
char_u *get_user_var_name(int idx ) 
{




































































































}
static int eval0(char_u *arg , VAR retvar , char_u **nextcmd , int evaluate ) 
{



































}
static int eval1(char_u **arg , VAR retvar , int evaluate ) 
{


















































































}
static int eval2(char_u **arg , VAR retvar , int evaluate ) 
{


















































































}
static int eval3(char_u **arg , VAR retvar , int evaluate ) 
{























































































































































































































































































}
static int eval4(char_u **arg , VAR retvar , int evaluate ) 
{






















































































}
static int eval5(char_u **arg , VAR retvar , int evaluate ) 
{





































































}
static int eval6(char_u **arg , VAR retvar , int evaluate ) 
{

































































































































































































































































}
static int get_option_var(char_u **arg , VAR retvar , int evaluate ) 
{






























































}
static int get_string_var(char_u **arg , VAR retvar , int evaluate ) 
{












































































































































































































































}
static int get_lit_string_var(char_u **arg , VAR retvar , int evaluate ) 
{


























}
static int get_env_var(char_u **arg , VAR retvar , int evaluate ) 
{


















































}
static struct fst functions[70]  = 
  {      {(char *)"append", (char)2, (char)2, & f_append}, 
        {(char *)"argc", (char)0, (char)0, & f_argc}, 
        {(char *)"argv", (char)1, (char)1, & f_argv}, 
        {(char *)"browse", (char)4, (char)4, & f_browse}, 
        {(char *)"bufexists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_exists", (char)1, (char)1, & f_bufexists}, 
        {(char *)"buffer_name", (char)1, (char)1, & f_bufname}, 
        {(char *)"buffer_number", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufloaded", (char)1, (char)1, & f_bufloaded}, 
        {(char *)"bufname", (char)1, (char)1, & f_bufname}, 
        {(char *)"bufnr", (char)1, (char)1, & f_bufnr}, 
        {(char *)"bufwinnr", (char)1, (char)1, & f_bufwinnr}, 
        {(char *)"byte2line", (char)1, (char)1, & f_byte2line}, 
        {(char *)"char2nr", (char)1, (char)1, & f_char2nr}, 
        {(char *)"col", (char)1, (char)1, & f_col}, 
        {(char *)"confirm", (char)2, (char)4, & f_confirm}, 
        {(char *)"delete", (char)1, (char)1, & f_delete}, 
        {(char *)"did_filetype", (char)0, (char)0, & f_did_filetype}, 
        {(char *)"escape", (char)2, (char)2, & f_escape}, 
        {(char *)"exists", (char)1, (char)1, & f_exists}, 
        {(char *)"expand", (char)1, (char)2, & f_expand}, 
        {(char *)"file_readable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"filereadable", (char)1, (char)1, & f_filereadable}, 
        {(char *)"fnamemodify", (char)2, (char)2, & f_fnamemodify}, 
        {(char *)"getcwd", (char)0, (char)0, & f_getcwd}, 
        {(char *)"getftime", (char)1, (char)1, & f_getftime}, 
        {(char *)"getline", (char)1, (char)1, & f_getline}, 
        {(char *)"getwinposx", (char)0, (char)0, & f_getwinposx}, 
        {(char *)"getwinposy", (char)0, (char)0, & f_getwinposy}, 
        {(char *)"glob", (char)1, (char)1, & f_glob}, 
        {(char *)"has", (char)1, (char)1, & f_has}, 
        {(char *)"highlightID", (char)1, (char)1, & f_hlID}, 
        {(char *)"highlight_exists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"histadd", (char)2, (char)2, & f_histadd}, 
        {(char *)"histdel", (char)1, (char)2, & f_histdel}, 
        {(char *)"histget", (char)1, (char)2, & f_histget}, 
        {(char *)"histnr", (char)1, (char)1, & f_histnr}, 
        {(char *)"hlID", (char)1, (char)1, & f_hlID}, 
        {(char *)"hlexists", (char)1, (char)1, & f_hlexists}, 
        {(char *)"hostname", (char)0, (char)0, & f_hostname}, 
        {(char *)"input", (char)1, (char)1, & f_input}, 
        {(char *)"isdirectory", (char)1, (char)1, & f_isdirectory}, 
        {(char *)"last_buffer_nr", (char)0, (char)0, & f_last_buffer_nr}, 
        {(char *)"libcall", (char)3, (char)3, & f_libcall}, 
        {(char *)"line", (char)1, (char)1, & f_line}, 
        {(char *)"line2byte", (char)1, (char)1, & f_line2byte}, 
        {(char *)"localtime", (char)0, (char)0, & f_localtime}, 
        {(char *)"maparg", (char)1, (char)2, & f_maparg}, 
        {(char *)"mapcheck", (char)1, (char)2, & f_mapcheck}, 
        {(char *)"match", (char)2, (char)2, & f_match}, 
        {(char *)"matchend", (char)2, (char)2, & f_matchend}, 
        {(char *)"matchstr", (char)2, (char)2, & f_matchstr}, 
        {(char *)"nr2char", (char)1, (char)1, & f_nr2char}, 
        {(char *)"rename", (char)2, (char)2, & f_rename}, 
        {(char *)"setline", (char)2, (char)2, & f_setline}, 
        {(char *)"strftime", (char)1, (char)2, & f_strftime}, 
        {(char *)"strlen", (char)1, (char)1, & f_strlen}, 
        {(char *)"strpart", (char)3, (char)3, & f_strpart}, 
        {(char *)"strtrans", (char)1, (char)1, & f_strtrans}, 
        {(char *)"substitute", (char)4, (char)4, & f_substitute}, 
        {(char *)"synID", (char)3, (char)3, & f_synID}, 
        {(char *)"synIDattr", (char)2, (char)3, & f_synIDattr}, 
        {(char *)"synIDtrans", (char)1, (char)1, & f_synIDtrans}, 
        {(char *)"system", (char)1, (char)1, & f_system}, 
        {(char *)"tempname", (char)0, (char)0, & f_tempname}, 
        {(char *)"virtcol", (char)1, (char)1, & f_virtcol}, 
        {(char *)"visualmode", (char)0, (char)0, & f_visualmode}, 
        {(char *)"winbufnr", (char)1, (char)1, & f_winbufnr}, 
        {(char *)"winheight", (char)1, (char)1, & f_winheight}, 
        {(char *)"winnr", (char)0, (char)0, & f_winnr}};
static int intidx  =    -1;
char_u *get_function_name(int idx ) 
{








































}
static int intidx___0  =    -1;
char_u *get_expr_name(int idx ) 
{





















}
static int find_internal_func(char_u *name___1 ) 
{
































}
static char *errors[4]  = {      (char *)"Invalid arguments for function %s",      (char *)"Unknown function: %s",      (char *)"Too many arguments for function: %s",      (char *)"Not enough arguments for function: %s"};
static int get_func_var(char_u *name___1 , int len___0 , VAR retvar , char_u **arg ,
                        linenr_t firstline , linenr_t lastline , int *doesrange ,
                        int evaluate ) 
{


















































































































































}
static linenr_t get_arg_lnum(VAR argvars , VAR retvar ) 
{















}
static void f_append(VAR argvars , VAR retvar ) 
{





































}
static void f_argc(VAR argvars , VAR retvar ) 
{






}
static void f_argv(VAR argvars , VAR retvar ) 
{






















}
static void f_browse(VAR argvars , VAR retvar ) 
{







}
static BUF *find_buffer(VAR avar ) 
{
























}
static void f_bufexists(VAR argvars , VAR retvar ) 
{









}
static void f_bufloaded(VAR argvars , VAR retvar ) 
{



















}
static BUF *get_buf_var(VAR avar ) 
{









































}
static void f_bufname(VAR argvars , VAR retvar ) 
{






















}
static void f_bufnr(VAR argvars , VAR retvar ) 
{















}
static void f_bufwinnr(VAR argvars , VAR retvar ) 
{

































}
static void f_byte2line(VAR argvars , VAR retvar ) 
{




















}
static void f_char2nr(VAR argvars , VAR retvar ) 
{









}
static void f_col(VAR argvars , VAR retvar ) 
{
















}
static void f_confirm(VAR argvars , VAR retvar ) 
{







































































}
static void f_libcall(VAR argvars , VAR retvar ) 
{







}
static void f_delete(VAR argvars , VAR retvar ) 
{









}
static void f_did_filetype(VAR argvars , VAR retvar ) 
{






}
static void f_escape(VAR argvars , VAR retvar ) 
{













}
static void f_exists(VAR argvars , VAR retvar ) 
{

















































































}
static void f_expand(VAR argvars , VAR retvar ) 
{





















































}
static void f_filereadable(VAR argvars , VAR retvar ) 
{


































}
static void f_fnamemodify(VAR argvars , VAR retvar ) 
{































}
static void f_getcwd(VAR argvars , VAR retvar ) 
{

















}
static void f_getftime(VAR argvars , VAR retvar ) 
{
















}
static void f_getline(VAR argvars , VAR retvar ) 
{
























}
static void f_getwinposx(VAR argvars , VAR retvar ) 
{






}
static void f_getwinposy(VAR argvars , VAR retvar ) 
{






}
static void f_glob(VAR argvars , VAR retvar ) 
{











}
static char *has_list[49]  = 
  {      (char *)"unix",      (char *)"fname_case",      (char *)"autocmd",      (char *)"builtin_terms", 
        (char *)"byte_offset",      (char *)"cindent",      (char *)"clipboard",      (char *)"cmdline_compl", 
        (char *)"comments",      (char *)"cryptv",      (char *)"dialog_con",      (char *)"digraphs", 
        (char *)"eval",      (char *)"ex_extra",      (char *)"extra_search",      (char *)"file_in_path", 
        (char *)"find_in_path",      (char *)"fork",      (char *)"insert_expand",      (char *)"linebreak", 
        (char *)"lispindent",      (char *)"menu",      (char *)"mksession",      (char *)"modify_fname", 
        (char *)"mouse",      (char *)"mouse_xterm",      (char *)"quickfix",      (char *)"scrollbind", 
        (char *)"showcmd",      (char *)"cmdline_info",      (char *)"smartindent",      (char *)"statusline", 
        (char *)"syntax",      (char *)"tag_binary",      (char *)"tag_old_static",      (char *)"terminfo", 
        (char *)"textobjects",      (char *)"tgetent",      (char *)"title",      (char *)"user-commands", 
        (char *)"user_commands",      (char *)"viminfo",      (char *)"visualextra",      (char *)"wildignore", 
        (char *)"wildmenu",      (char *)"writebackup",      (char *)"xterm_clipboard",      (char *)"X11", 
        (char *)((void *)0)};
static void f_has(VAR argvars , VAR retvar ) 
{


















































}
static void f_histadd(VAR argvars , VAR retvar ) 
{
























}
static void f_histdel(VAR argvars , VAR retvar ) 
{





































}
static void f_histget(VAR argvars , VAR retvar ) 
{




























}
static void f_histnr(VAR argvars , VAR retvar ) 
{






















}
static void f_hlexists(VAR argvars , VAR retvar ) 
{









}
static void f_hlID(VAR argvars , VAR retvar ) 
{









}
static void f_hostname(VAR argvars , VAR retvar ) 
{










}
static void f_input(VAR argvars , VAR retvar ) 
{








































}
static void f_isdirectory(VAR argvars , VAR retvar ) 
{









}
static void f_last_buffer_nr(VAR argvars , VAR retvar ) 
{






















}
static void f_line(VAR argvars , VAR retvar ) 
{






















}
static void f_line2byte(VAR argvars , VAR retvar ) 
{
























}
static void f_localtime(VAR argvars , VAR retvar ) 
{









}
static void f_maparg(VAR argvars , VAR retvar ) 
{








}
static void f_mapcheck(VAR argvars , VAR retvar ) 
{








}
static void get_maparg(VAR argvars , VAR retvar , int exact ) 
{


























































}
static void f_match(VAR argvars , VAR retvar ) 
{








}
static void f_matchend(VAR argvars , VAR retvar ) 
{








}
static void f_matchstr(VAR argvars , VAR retvar ) 
{








}
static void f_some_match(VAR argvars , VAR retvar , int type ) 
{
















































}
static void f_nr2char(VAR argvars , VAR retvar ) 
{












}
static void f_rename(VAR argvars , VAR retvar ) 
{












}
static void f_setline(VAR argvars , VAR retvar ) 
{




































}
static void f_strftime(VAR argvars , VAR retvar ) 
{





























}
static void f_strlen(VAR argvars , VAR retvar ) 
{











}
static void f_strpart(VAR argvars , VAR retvar ) 
{







































}
static void f_strtrans(VAR argvars , VAR retvar ) 
{










}
static void f_synID(VAR argvars , VAR retvar ) 
{




































}
static void f_synIDattr(VAR argvars , VAR retvar ) 
{





























































































































}
static void f_synIDtrans(VAR argvars , VAR retvar ) 
{


















}
static void f_system(VAR argvars , VAR retvar ) 
{












}
static void f_substitute(VAR argvars , VAR retvar ) 
{



















}
static int x  =    'A';
static void f_tempname(VAR argvars , VAR retvar ) 
{














}
static void f_virtcol(VAR argvars , VAR retvar ) 
{

















}
static void f_visualmode(VAR argvars , VAR retvar ) 
{











}
static void f_winbufnr(VAR argvars , VAR retvar ) 
{













}
static void f_winheight(VAR argvars , VAR retvar ) 
{













}
static void f_winnr(VAR argvars , VAR retvar ) 
{




















}
static WIN *find_win_by_nr(VAR vp ) 
{





























}
static FPOS *var2fpos(VAR varp ) 
{


















}
static int get_env_len(char_u **arg ) 
{


























}
static int get_id_len(char_u **arg ) 
{




























}
static int eval_isnamec(int c ) 
{






























}
static int find_vim_var(char_u *name___1 , int len___0 ) 
{













































}
void set_vim_var_nr(int idx , long val ) 
{






}
void set_vim_var_string(int idx , char_u *val ) 
{















}
static int get_var_var(char_u *name___1 , int len___0 , VAR retvar ) 
{



























































}
static VAR alloc_var(void) 
{








}
static VAR alloc_string_var(char_u *s ) 
{
















}
static void free_var(VAR varp ) 
{
















}
static void clear_var(VAR varp ) 
{















}
static long get_var_number(VAR varp ) 
{





















}
static char_u mybuf[30]  ;
static char_u *get_var_string(VAR varp ) 
{








}
static char_u *get_var_string_buf(VAR varp , char_u *buf___3 ) 
{

















}
static VAR find_var(char_u *name___1 , int writing ) 
{







































































































}
static struct growarray *find_var_ga(char_u *name___1 , char_u **varname ) 
{



























}
void var_init(struct growarray *gap ) 
{








}
void var_clear(struct growarray *gap ) 
{






















}
static void var_free_one(VAR v ) 
{















}
static void list_one_var(VAR v , char_u *prefix ) 
{









}
static void list_vim_var(int i___0 ) 
{























}
static void list_one_var_a(char_u *prefix , char_u *name___1 , int type , char_u *string___0 ) 
{





























}
static void set_var(char_u *name___1 , VAR varp ) 
{
































































































}
void do_echo(EXARG *eap , int echo ) 
{
































































































































}
void do_echohl(char_u *arg ) 
{















}
void do_execute(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{
































































































}
static char_u *find_option_end(char_u *p___0 ) 
{




















}
void do_function(EXARG *eap , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{



















































































































































































































































































































































































































































































































}
static void list_func_head(struct ufunc *fp___0 ) 
{










































}
static struct ufunc *find_func(char_u *name___1 ) 
{























}
static struct ufunc *fp  =    (struct ufunc *)((void *)0);
char_u *get_user_func_name(int idx ) 
{













}
void do_delfunction(char_u *arg ) 
{
















































}
static int depth  =    0;
static void call_func(struct ufunc *fp___0 , int argcount , VAR argvars , VAR retvar ,
                      linenr_t firstline , linenr_t lastline ) 
{

























































































































}
void *save_funccal(void) 
{







}
void restore_funccal(void *fc ) 
{






}
void do_return(EXARG *eap ) 
{






















































}
char_u *get_func_line(int c , void *cookie , int indent ) 
{
















































}
int func_has_ended(void *cookie ) 
{





















}
int func_has_abort(void *cookie ) 
{





}
static VAR_FLAVOUR var_flavour(char_u *varname ) ;
static VAR_FLAVOUR var_flavour(char_u *varname ) 
{































}
int read_viminfo_varlist(char_u *line , FILE *fp___0 , int writing ) 
{



































































}
void write_viminfo_varlist(FILE *fp___0 ) 
{



















































}
int store_session_globals(FILE *fd ) 
{




























































}
int modify_fname(char_u *src , int *usedlen , char_u **fnamep , char_u **bufp , int *fnamelen ) 
{













































































































































































































































































































}
char_u *do_string_sub(char_u *str___1 , char_u *pat , char_u *sub , char_u *flags___0 ) 
{































































































}
#pragma merger("0","/tmp/cil-U5alLrC_.i","-O0")
extern struct _IO_FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
int msg_col  ;
int msg_scrolled  ;
char_u *keep_msg ;
int keep_msg_attr ;
int msg_didany ;
int no_wait_return ;
int highlight_match ;
int search_match_len  ;
int need_check_timestamps ;
int autocmd_busy ;
int exiting ;
int restricted ;
int secure ;
int silent_mode ;
int VIsual_reselect  ;
int exmode_active ;
int confirm ;
char_u msg_buf[80]  ;
int skip_redraw ;
char_u *use_viminfo ;
int bangredo ;
int need_start_insertmode ;
int g_do_tagpreview ;
char_u *help_save_isk ;
long help_save_ts ;
char_u e_backslash[34] ;
char_u e_curdir[65] ;
char_u e_exists[32] ;
char_u e_interr[12] ;
char_u e_invcmd[16] ;
char_u e_noname[13] ;
char_u e_nopresub[42] ;
char_u e_noprev[20] ;
char_u e_notcreate[21] ;
char_u e_notmp[25] ;
char_u e_notread[19] ;
char_u e_patnotf2[22] ;
char_u e_readonly[45] ;
char_u e_zerocount[11] ;
int p_confirm  ;
int p_ed  ;
char_u *p_ffs  ;
int p_gd  ;
char_u *p_hf  ;
long p_hh  ;
long p_report  ;
char_u *p_shq  ;
char_u *p_srr  ;
int p_warn  ;
int p_write  ;
int p_wa  ;
int mch_setperm(char_u *name___1 , long perm ) ;
void do_ascii(void) ;
void do_align(EXARG *eap ) ;
void do_retab(EXARG *eap ) ;
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) ;
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) ;
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) ;
void do_shell(char_u *cmd , int flags___0 ) ;
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) ;
int viminfo_error(char *message , char_u *line ) ;
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) ;
void write_viminfo(char_u *file , int forceit ) ;
void do_fixdel(void) ;
void print_line_no_prefix(linenr_t lnum , int use_number ) ;
void print_line(linenr_t lnum , int use_number ) ;
void do_file(char_u *arg , int forceit ) ;
int do_write(EXARG *eap ) ;
void do_wnext(EXARG *eap ) ;
void do_wqall(EXARG *eap ) ;
int not_writing(void) ;
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) ;
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) ;
void do_z(linenr_t line , char_u *arg ) ;
int check_restricted(void) ;
int check_secure(void) ;
void do_sub(EXARG *eap ) ;
void do_glob(EXARG *eap ) ;
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_sub_string(FILE *fp___0 ) ;
void prepare_tagpreview(void) ;
void do_help(EXARG *eap ) ;
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) ;
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) ;
void autowrite_all(void) ;
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) ;
int check_fname(void) ;
int buf_write_all(BUF *buf___3 ) ;
void not_exiting(void) ;
void do_argfile(EXARG *eap , int argn ) ;
void dialog_msg(char_u *buff , char *format , char_u *fname ) ;
void gotocmdline(int clr ) ;
void prepare_viminfo_history(int asklen ) ;
int read_viminfo_history(char_u *line , FILE *fp___0 ) ;
void finish_viminfo_history(void) ;
void write_viminfo_history(FILE *fp___0 ) ;
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) ;
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) ;
void write_lnum_adjust(linenr_t offset ) ;
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_filemarks(FILE *fp___0 ) ;
int write_viminfo_marks(FILE *fp_out ) ;
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) ;
int smsg_attr(int attr , char_u *s  , ...) ;
int ml_delete(linenr_t lnum , int message ) ;
void ml_setmarked(linenr_t lnum ) ;
linenr_t ml_firstmarked(void) ;
void ml_clearmarked(void) ;
void wait_return(int redraw ) ;
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) ;
void del_lines(long nlines , int dowindow , int undo ) ;
void msgmore(long n ) ;
int vim_fexists(char_u *fname ) ;
void adjust_cursor(void) ;
char_u *alloc_check(unsigned int size ) ;
void set_fileformat(int t ) ;
int default_fileformat(void) ;
int call_shell(char_u *cmd , int opt ) ;
void end_visual_mode(void) ;
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_registers(FILE *fp___0 ) ;
int get_viminfo_parameter(int type ) ;
void check_buf_options(BUF *buf___3 ) ;
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) ;
char_u *regtilde(char_u *source , int magic ) ;
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) ;
void windgoto(int row , int col ) ;
void invalidate_botline(void) ;
int botline_approximated(void) ;
int messaging(void) ;
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) ;
char_u *get_search_pat(void) ;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) ;
void write_viminfo_search_pattern(FILE *fp___0 ) ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) ;
void starttermcap(void) ;
void stoptermcap(void) ;
int swapping_screen(void) ;
void cursor_on(void) ;
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) ;
char_u *find_termcode(char_u *name___1 ) ;
int u_inssub(linenr_t lnum ) ;
void u_clearline(void) ;
void win_init(WIN *wp ) ;
void win_setheight(int height ) ;
void check_lnums(int do_curwin ) ;
static int linelen(int *has_tab ) ;
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) ;
static char_u *viminfo_filename(char_u *file ) ;
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) ;
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) ;
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) ;
static int check_readonly(int *forceit , BUF *buf___3 ) ;
static void delbuf_msg(char_u *name___1 ) ;
static int do_sub_msg(void) ;
static int help_compare(void const   *s1 , void const   *s2 ) ;
void do_ascii(void) 
{






























































}
void do_align(EXARG *eap ) 
{























































































































































}
static int linelen(int *has_tab ) 
{













































}
void do_retab(EXARG *eap ) 
{










































































































































































































































}
int do_move(linenr_t line1 , linenr_t line2 , linenr_t dest ) 
{




















































































































}
void do_copy(linenr_t line1 , linenr_t line2 , linenr_t n ) 
{



























































}
static char_u *prevcmd  =    (char_u *)((void *)0);
void do_bang(int addr_count , linenr_t line1 , linenr_t line2 , int forceit , char_u *arg ,
             int do_in , int do_out ) 
{

























































































































































































}
void do_shell(char_u *cmd , int flags___0 ) 
{














































































































}
static void do_filter(linenr_t line1 , linenr_t line2 , char_u *cmd , int do_in ,
                      int do_out ) 
{


















































































































































































































}
char_u *make_filter_cmd(char_u *cmd , char_u *itmp , char_u *otmp ) 
{













































































}
static int no_viminfo(void) ;
static int viminfo_errcnt  ;
static int no_viminfo(void) 
{


















}
int viminfo_error(char *message , char_u *line ) 
{




















}
int read_viminfo(char_u *file , int want_info , int want_marks , int forceit ) 
{









































}
void write_viminfo(char_u *file , int forceit ) 
{


















































































































































































































































}
static char_u *viminfo_filename(char_u *file ) 
{






























}
static void do_viminfo(FILE *fp_in , FILE *fp_out , int want_info , int want_marks ,
                       int force_read ) 
{































































}
static int read_viminfo_up_to_marks(char_u *line , FILE *fp___0 , int forceit , int writing ) 
{








































































































































































}
char_u *viminfo_readstring(char_u *p___0 , FILE *fp___0 ) 
{






















































































}
void viminfo_writestring(FILE *fd , char_u *p___0 ) 
{
































































}
void do_fixdel(void) 
{





















}
void print_line_no_prefix(linenr_t lnum , int use_number ) 
{

























}
void print_line(linenr_t lnum , int use_number ) 
{



















}
void do_file(char_u *arg , int forceit ) 
{














































}
int do_write(EXARG *eap ) 
{


















































































































}
static int check_overwrite(EXARG *eap , BUF *buf___3 , char_u *fname , char_u *ffname ,
                           int other ) 
{








































































}
void do_wnext(EXARG *eap ) 
{





















}
void do_wqall(EXARG *eap ) 
{
















































































}
int not_writing(void) 
{











}
static int check_readonly(int *forceit , BUF *buf___3 ) 
{







































}
int getfile(int fnum , char_u *ffname , char_u *sfname , int setpm , linenr_t lnum ,
            int forceit ) 
{




























































































}
int do_ecmd(int fnum , char_u *ffname , char_u *sfname , char_u *command , linenr_t newlnum ,
            int flags___0 ) 
{







































































































































































































































































































































































































































































}
static void delbuf_msg(char_u *name___1 ) 
{















}
void do_append(linenr_t lnum , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int getl_break ) 
{



























































































}
void do_change(linenr_t start___0 , linenr_t end , char_u *(*getline___0)(int  , void * ,
                                                                          int  ) ,
               void *cookie , int getl_break ) 
{




































}
void do_z(linenr_t line , char_u *arg ) 
{



































































































































































}
int check_restricted(void) 
{











}
int check_secure(void) 
{


















}
static char_u *old_sub  =    (char_u *)((void *)0);
static int global_need_beginline  ;
static long sub_nsubs  ;
static linenr_t sub_nlines  ;
static int do_all  =    0;
static int do_ask  =    0;
void do_sub(EXARG *eap ) 
{
































































































































































































































































































































































































































































































































































































































































































































}
static int do_sub_msg(void) 
{




















































}
void do_glob(EXARG *eap ) 
{





















































































































































































































}
int read_viminfo_sub_string(char_u *line , FILE *fp___0 , int force ) 
{


























}
void write_viminfo_sub_string(FILE *fp___0 ) 
{
















}
void prepare_tagpreview(void) 
{












































}
void do_help(EXARG *eap ) 
{





































































































































































}
int help_heuristic(char_u *matched_string , int offset , int wrong_case ) 
{



























































}
static int help_compare(void const   *s1 , void const   *s2 ) 
{
















}
static char *mtable[20]  = 
  {      (char *)"*",      (char *)"g*",      (char *)"[*",      (char *)"]*", 
        (char *)":*",      (char *)"/*",      (char *)"/\\*",      (char *)"\"*", 
        (char *)"/\\(\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"[count]", 
        (char *)"[quotex]",      (char *)"[range]",      (char *)"[pattern]",      (char *)"\\|"};
static char *rtable[20]  = 
  {      (char *)"star",      (char *)"gstar",      (char *)"[star",      (char *)"]star", 
        (char *)":star",      (char *)"/star",      (char *)"/\\\\star",      (char *)"quotestar", 
        (char *)"/\\\\(\\\\)",      (char *)"?",      (char *)":?",      (char *)"?<CR>", 
        (char *)"g?",      (char *)"g?g?",      (char *)"g??",      (char *)"\\[count]", 
        (char *)"\\[quotex]",      (char *)"\\[range]",      (char *)"\\[pattern]",      (char *)"\\\\bar"};
int find_help_tags(char_u *arg , int *num_matches___0 , char_u ***matches___0 ) 
{



























































































































































































































}
#pragma merger("0","/tmp/cil-bQYL8qc0.i","-O0")
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
int exec_from_reg ;
int expand_set_path ;
int vgetc_busy ;
int did_syncbind ;
int ex_no_reprint ;
int searchcmdlen  ;
char_u *last_cmdline ;
char_u *new_last_cmdline ;
char_u *autocmd_fname ;
int autocmd_bufnr ;
char_u *autocmd_match ;
int postponed_split ;
char_u *escape_chars ;
FILE *redir_fd ;
int redir_reg ;
char_u e_argreq[18] ;
char_u e_failed[15] ;
char_u e_invaddr[16] ;
char_u e_invarg[17] ;
char_u e_invrange[14] ;
char_u e_noabbr[21] ;
char_u e_nobang[13] ;
char_u e_nogvim[49] ;
char_u e_nomap[16] ;
char_u e_nomatch[9] ;
char_u e_norange[17] ;
char_u e_notopen[19] ;
char_u e_unknown[8] ;
char_u e_write[20] ;
int p_aw  ;
int p_cp  ;
char_u *p_ef  ;
char_u *p_efm  ;
char_u *p_gefm  ;
char_u *p_gp  ;
char_u *p_mef  ;
char_u *p_mp  ;
long p_mmd  ;
long p_pvh  ;
char_u *p_sessopt  ;
char_u *p_sp  ;
char_u *p_viminfo  ;
void mch_restore_title(int which ) ;
long mch_get_pid(void) ;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) ;
long mch_getperm(char_u *name___1 ) ;
int mch_screenmode(char_u *arg ) ;
int mch_has_wildcard(char_u *p___0 ) ;
void do_exmode(void) ;
char_u *set_one_cmd_context(char_u *buff ) ;
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) ;
void separate_nextcmd(EXARG *eap ) ;
void dialog_changed(BUF *buf___3 , int checkall ) ;
int check_changed_any(int hidden ) ;
int rem_backslash(char_u *str___1 ) ;
void backslash_halve(char_u *p___0 ) ;
char_u *backslash_halve_save(char_u *p___0 ) ;
char_u *find_nextcmd(char_u *p___0 ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) ;
char_u *getsourceline(int c , void *cookie , int indent ) ;
char_u *get_command_name(int idx ) ;
char_u *get_user_commands(int idx ) ;
char_u *get_user_cmd_flags(int idx ) ;
char_u *get_user_cmd_nargs(int idx ) ;
char_u *get_user_cmd_complete(int idx ) ;
char_u *expand_sfile(char_u *arg ) ;
char_u *getexline(int c , void *dummy , int indent ) ;
char_u *getexmodeline(int c , void *dummy , int indent ) ;
void do_history(char_u *arg ) ;
void shorten_fnames(int force ) ;
void do_augroup(char_u *arg ) ;
void do_autocmd(char_u *arg , int forceit ) ;
int do_doautocmd(char_u *arg , int do_msg ) ;
void do_autoall(char_u *arg ) ;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) ;
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) ;
int typebuf_typed(void) ;
int openscript(char_u *name___1 ) ;
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) ;
void map_clear(char_u *cmdp , int forceit , int abbr ) ;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) ;
int makemap(FILE *fd ) ;
int setmark(int c ) ;
void checkpcmark(void) ;
int check_mark(FPOS *pos___0 ) ;
void do_marks(char_u *arg ) ;
void do_jumps(void) ;
void ml_preserve(BUF *buf___3 , int message ) ;
void goto_byte(long cnt ) ;
void do_menu(EXARG *eap ) ;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) ;
void execute_menu(char_u *path_name ) ;
void ex_messages(void) ;
int msg_outtrans_attr(char_u *str___1 , int attr ) ;
void msg_make(char_u *arg ) ;
void msg_puts_title(char_u *s ) ;
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) ;
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) ;
int ask_yesno(char_u *str___1 , int direct ) ;
void beep_flush(void) ;
void del_trailing_spaces(char_u *ptr ) ;
int vim_chdirfile(char_u *fname ) ;
char_u *get_crypt_key(int store ) ;
void normal_cmd(OPARG *oap , int toplevel ) ;
int find_ident_under_cursor(char_u **string___0 , int find_type ) ;
void op_shift(OPARG *oap , int curs_top , int amount ) ;
void set_expr_line(char_u *new_line ) ;
int valid_yank_reg(int regname___0 , int writing ) ;
int do_execreg(int regname___0 , int colon , int addcr ) ;
int op_delete(OPARG *oap ) ;
int op_yank(OPARG *oap , int deleting , int mess ) ;
void do_dis(char_u *arg ) ;
void do_do_join(long count___2 , int insert_space , int redraw ) ;
void clear_oparg(OPARG *oap ) ;
int makeset(FILE *fd ) ;
void set_context_in_set_cmd(char_u *arg ) ;
void vimrc_found(void) ;
int qf_init(char_u *efile , char_u *errorformat ) ;
void qf_jump(int dir , int errornr , int forceit ) ;
void qf_list(char_u *arg , int all ) ;
void qf_older(int count___2 ) ;
void qf_newer(int count___2 ) ;
void redraw_all_later(int type ) ;
void cursor_correct(void) ;
int cursor_valid(void) ;
void scrolldown(long line_count ) ;
void scrollup(long line_count ) ;
void do_intro(void) ;
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) ;
void do_syntax(EXARG *eap , char_u **cmdlinep ) ;
void set_context_in_syntax_cmd(char_u *arg ) ;
void do_highlight(char_u *line , int forceit , int init ) ;
void set_context_in_highlight_cmd(char_u *arg ) ;
void do_tags(void) ;
void out_char(unsigned int c ) ;
void term_set_winpos(int x___0 , int y ) ;
void set_winsize(int width , int height , int mustset ) ;
void settmode(int tmode ) ;
void scroll_start(void) ;
char_u *translate_mapping(char_u *str___1 , int expmap ) ;
void ui_suspend(void) ;
void u_undo(int count___2 ) ;
void u_redo(int count___2 ) ;
void do_version(char_u *arg ) ;
char_u *file_name_at_cursor(int options___0 , long count___2 ) ;
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) ;
int only_one_window(void) ;
static struct cmdname cmdnames[299]  = 
  {      {(char_u *)"append", (long_u )4355}, 
        {(char_u *)"abbreviate", (long_u )10500}, 
        {(char_u *)"abclear", (long_u )256}, 
        {(char_u *)"all", (long_u )17665}, 
        {(char_u *)"amenu", (long_u )30981}, 
        {(char_u *)"anoremenu", (long_u )30981}, 
        {(char_u *)"args", (long_u )33102}, 
        {(char_u *)"argument", (long_u )50439}, 
        {(char_u *)"ascii", (long_u )256}, 
        {(char_u *)"autocmd", (long_u )10246}, 
        {(char_u *)"augroup", (long_u )276}, 
        {(char_u *)"aunmenu", (long_u )10500}, 
        {(char_u *)"buffer", (long_u )83207}, 
        {(char_u *)"bNext", (long_u )17667}, 
        {(char_u *)"ball", (long_u )17665}, 
        {(char_u *)"badd", (long_u )33180}, 
        {(char_u *)"bdelete", (long_u )83207}, 
        {(char_u *)"behave", (long_u )404}, 
        {(char_u *)"blast", (long_u )259}, 
        {(char_u *)"bmodified", (long_u )17667}, 
        {(char_u *)"bnext", (long_u )17667}, 
        {(char_u *)"bprevious", (long_u )17667}, 
        {(char_u *)"brewind", (long_u )259}, 
        {(char_u *)"break", (long_u )262400}, 
        {(char_u *)"browse", (long_u )2180}, 
        {(char_u *)"buffers", (long_u )256}, 
        {(char_u *)"bunload", (long_u )83207}, 
        {(char_u *)"change", (long_u )1283}, 
        {(char_u *)"cNext", (long_u )17667}, 
        {(char_u *)"cabbrev", (long_u )10500}, 
        {(char_u *)"cabclear", (long_u )256}, 
        {(char_u *)"call", (long_u )264325}, 
        {(char_u *)"cc", (long_u )17667}, 
        {(char_u *)"cd", (long_u )348}, 
        {(char_u *)"center", (long_u )261}, 
        {(char_u *)"cfile", (long_u )286}, 
        {(char_u *)"chdir", (long_u )348}, 
        {(char_u *)"checkpath", (long_u )258}, 
        {(char_u *)"clist", (long_u )262}, 
        {(char_u *)"clast", (long_u )17667}, 
        {(char_u *)"close", (long_u )258}, 
        {(char_u *)"cmap", (long_u )10500}, 
        {(char_u *)"cmapclear", (long_u )256}, 
        {(char_u *)"cmenu", (long_u )30981}, 
        {(char_u *)"cnext", (long_u )17667}, 
        {(char_u *)"cnewer", (long_u )17665}, 
        {(char_u *)"cnfile", (long_u )17667}, 
        {(char_u *)"cnoremap", (long_u )10500}, 
        {(char_u *)"cnoreabbrev", (long_u )10500}, 
        {(char_u *)"cnoremenu", (long_u )30981}, 
        {(char_u *)"copy", (long_u )261}, 
        {(char_u *)"colder", (long_u )17665}, 
        {(char_u *)"command", (long_u )10246}, 
        {(char_u *)"comclear", (long_u )256}, 
        {(char_u *)"continue", (long_u )262400}, 
        {(char_u *)"confirm", (long_u )2180}, 
        {(char_u *)"cprevious", (long_u )17667}, 
        {(char_u *)"cquit", (long_u )258}, 
        {(char_u *)"crewind", (long_u )17667}, 
        {(char_u *)"cscope", (long_u )2052}, 
        {(char_u *)"cstag", (long_u )278}, 
        {(char_u *)"cunmap", (long_u )10500}, 
        {(char_u *)"cunabbrev", (long_u )10500}, 
        {(char_u *)"cunmenu", (long_u )10500}, 
        {(char_u *)"delete", (long_u )1793}, 
        {(char_u *)"delcommand", (long_u )404}, 
        {(char_u *)"delfunction", (long_u )404}, 
        {(char_u *)"display", (long_u )2308}, 
        {(char_u *)"digraphs", (long_u )260}, 
        {(char_u *)"djump", (long_u )39}, 
        {(char_u *)"dlist", (long_u )39}, 
        {(char_u *)"doautocmd", (long_u )260}, 
        {(char_u *)"doautoall", (long_u )260}, 
        {(char_u *)"dsearch", (long_u )39}, 
        {(char_u *)"dsplit", (long_u )39}, 
        {(char_u *)"edit", (long_u )33054}, 
        {(char_u *)"echo", (long_u )264196}, 
        {(char_u *)"echohl", (long_u )262404}, 
        {(char_u *)"echon", (long_u )264196}, 
        {(char_u *)"else", (long_u )262400}, 
        {(char_u *)"elseif", (long_u )264196}, 
        {(char_u *)"emenu", (long_u )2436}, 
        {(char_u *)"endif", (long_u )262400}, 
        {(char_u *)"endfunction", (long_u )256}, 
        {(char_u *)"endwhile", (long_u )262400}, 
        {(char_u *)"ex", (long_u )33054}, 
        {(char_u *)"execute", (long_u )264196}, 
        {(char_u *)"exit", (long_u )319}, 
        {(char_u *)"file", (long_u )286}, 
        {(char_u *)"files", (long_u )256}, 
        {(char_u *)"filetype", (long_u )404}, 
        {(char_u *)"find", (long_u )33054}, 
        {(char_u *)"fixdel", (long_u )256}, 
        {(char_u *)"function", (long_u )6}, 
        {(char_u *)"global", (long_u )39}, 
        {(char_u *)"goto", (long_u )279809}, 
        {(char_u *)"grep", (long_u )2444}, 
        {(char_u *)"gui", (long_u )33102}, 
        {(char_u *)"gvim", (long_u )33102}, 
        {(char_u *)"help", (long_u )2052}, 
        {(char_u *)"helpfind", (long_u )2052}, 
        {(char_u *)"highlight", (long_u )262406}, 
        {(char_u *)"hide", (long_u )258}, 
        {(char_u *)"history", (long_u )260}, 
        {(char_u *)"insert", (long_u )259}, 
        {(char_u *)"iabbrev", (long_u )10500}, 
        {(char_u *)"iabclear", (long_u )256}, 
        {(char_u *)"if", (long_u )264196}, 
        {(char_u *)"ijump", (long_u )39}, 
        {(char_u *)"ilist", (long_u )39}, 
        {(char_u *)"imap", (long_u )10500}, 
        {(char_u *)"imapclear", (long_u )256}, 
        {(char_u *)"imenu", (long_u )30981}, 
        {(char_u *)"inoremap", (long_u )10500}, 
        {(char_u *)"inoreabbrev", (long_u )10500}, 
        {(char_u *)"inoremenu", (long_u )30981}, 
        {(char_u *)"intro", (long_u )256}, 
        {(char_u *)"isearch", (long_u )39}, 
        {(char_u *)"isplit", (long_u )39}, 
        {(char_u *)"iunmap", (long_u )10500}, 
        {(char_u *)"iunabbrev", (long_u )10500}, 
        {(char_u *)"iunmenu", (long_u )10500}, 
        {(char_u *)"join", (long_u )1283}, 
        {(char_u *)"jumps", (long_u )256}, 
        {(char_u *)"k", (long_u )262421}, 
        {(char_u *)"list", (long_u )1281}, 
        {(char_u *)"last", (long_u )33030}, 
        {(char_u *)"left", (long_u )261}, 
        {(char_u *)"let", (long_u )264196}, 
        {(char_u *)"ls", (long_u )256}, 
        {(char_u *)"move", (long_u )261}, 
        {(char_u *)"mark", (long_u )262421}, 
        {(char_u *)"make", (long_u )2316}, 
        {(char_u *)"map", (long_u )10502}, 
        {(char_u *)"mapclear", (long_u )258}, 
        {(char_u *)"marks", (long_u )260}, 
        {(char_u *)"menu", (long_u )30983}, 
        {(char_u *)"messages", (long_u )256}, 
        {(char_u *)"mkexrc", (long_u )286}, 
        {(char_u *)"mksession", (long_u )286}, 
        {(char_u *)"mkvimrc", (long_u )286}, 
        {(char_u *)"mode", (long_u )276}, 
        {(char_u *)"next", (long_u )49487}, 
        {(char_u *)"new", (long_u )49439}, 
        {(char_u *)"nmap", (long_u )10500}, 
        {(char_u *)"nmapclear", (long_u )256}, 
        {(char_u *)"nmenu", (long_u )30981}, 
        {(char_u *)"nnoremap", (long_u )10500}, 
        {(char_u *)"nnoremenu", (long_u )30981}, 
        {(char_u *)"noremap", (long_u )10502}, 
        {(char_u *)"nohlsearch", (long_u )262400}, 
        {(char_u *)"noreabbrev", (long_u )10500}, 
        {(char_u *)"noremenu", (long_u )30983}, 
        {(char_u *)"normal", (long_u )272519}, 
        {(char_u *)"number", (long_u )1281}, 
        {(char_u *)"nunmap", (long_u )10500}, 
        {(char_u *)"nunmenu", (long_u )10500}, 
        {(char_u *)"open", (long_u )256}, 
        {(char_u *)"omap", (long_u )10500}, 
        {(char_u *)"omapclear", (long_u )256}, 
        {(char_u *)"omenu", (long_u )30981}, 
        {(char_u *)"only", (long_u )258}, 
        {(char_u *)"onoremap", (long_u )10500}, 
        {(char_u *)"onoremenu", (long_u )30981}, 
        {(char_u *)"options", (long_u )256}, 
        {(char_u *)"ounmap", (long_u )10500}, 
        {(char_u *)"ounmenu", (long_u )10500}, 
        {(char_u *)"print", (long_u )1281}, 
        {(char_u *)"pclose", (long_u )258}, 
        {(char_u *)"perl", (long_u )262309}, 
        {(char_u *)"perldo", (long_u )262309}, 
        {(char_u *)"pop", (long_u )21763}, 
        {(char_u *)"ppop", (long_u )21763}, 
        {(char_u *)"preserve", (long_u )256}, 
        {(char_u *)"previous", (long_u )50439}, 
        {(char_u *)"promptfind", (long_u )2052}, 
        {(char_u *)"promptrepl", (long_u )2052}, 
        {(char_u *)"ptag", (long_u )20759}, 
        {(char_u *)"ptNext", (long_u )20739}, 
        {(char_u *)"ptjump", (long_u )278}, 
        {(char_u *)"ptlast", (long_u )258}, 
        {(char_u *)"ptnext", (long_u )20739}, 
        {(char_u *)"ptprevious", (long_u )20739}, 
        {(char_u *)"ptrewind", (long_u )20739}, 
        {(char_u *)"ptselect", (long_u )278}, 
        {(char_u *)"put", (long_u )4867}, 
        {(char_u *)"pwd", (long_u )256}, 
        {(char_u *)"python", (long_u )262277}, 
        {(char_u *)"pyfile", (long_u )262301}, 
        {(char_u *)"quit", (long_u )258}, 
        {(char_u *)"qall", (long_u )258}, 
        {(char_u *)"read", (long_u )4447}, 
        {(char_u *)"recover", (long_u )286}, 
        {(char_u *)"redo", (long_u )256}, 
        {(char_u *)"redir", (long_u )270}, 
        {(char_u *)"registers", (long_u )2308}, 
        {(char_u *)"resize", (long_u )276}, 
        {(char_u *)"retab", (long_u )311}, 
        {(char_u *)"return", (long_u )264196}, 
        {(char_u *)"rewind", (long_u )33030}, 
        {(char_u *)"right", (long_u )261}, 
        {(char_u *)"rviminfo", (long_u )286}, 
        {(char_u *)"substitute", (long_u )5}, 
        {(char_u *)"sNext", (long_u )50439}, 
        {(char_u *)"sargument", (long_u )50439}, 
        {(char_u *)"sall", (long_u )17665}, 
        {(char_u *)"sbuffer", (long_u )83207}, 
        {(char_u *)"sbNext", (long_u )17665}, 
        {(char_u *)"sball", (long_u )17665}, 
        {(char_u *)"sblast", (long_u )256}, 
        {(char_u *)"sbmodified", (long_u )17665}, 
        {(char_u *)"sbnext", (long_u )17665}, 
        {(char_u *)"sbprevious", (long_u )17665}, 
        {(char_u *)"sbrewind", (long_u )256}, 
        {(char_u *)"set", (long_u )260}, 
        {(char_u *)"sfind", (long_u )49439}, 
        {(char_u *)"shell", (long_u )256}, 
        {(char_u *)"sleep", (long_u )17669}, 
        {(char_u *)"slast", (long_u )33030}, 
        {(char_u *)"smagic", (long_u )5}, 
        {(char_u *)"snext", (long_u )49487}, 
        {(char_u *)"sniff", (long_u )260}, 
        {(char_u *)"snomagic", (long_u )5}, 
        {(char_u *)"source", (long_u )262494}, 
        {(char_u *)"split", (long_u )49439}, 
        {(char_u *)"sprevious", (long_u )50439}, 
        {(char_u *)"srewind", (long_u )33030}, 
        {(char_u *)"stop", (long_u )258}, 
        {(char_u *)"stag", (long_u )20759}, 
        {(char_u *)"startinsert", (long_u )258}, 
        {(char_u *)"stjump", (long_u )278}, 
        {(char_u *)"stselect", (long_u )278}, 
        {(char_u *)"sunhide", (long_u )17665}, 
        {(char_u *)"suspend", (long_u )258}, 
        {(char_u *)"sview", (long_u )33183}, 
        {(char_u *)"swapname", (long_u )256}, 
        {(char_u *)"syntax", (long_u )2052}, 
        {(char_u *)"syncbind", (long_u )256}, 
        {(char_u *)"t", (long_u )261}, 
        {(char_u *)"tNext", (long_u )20739}, 
        {(char_u *)"tag", (long_u )20759}, 
        {(char_u *)"tags", (long_u )256}, 
        {(char_u *)"tcl", (long_u )262277}, 
        {(char_u *)"tcldo", (long_u )262309}, 
        {(char_u *)"tclfile", (long_u )262301}, 
        {(char_u *)"tearoff", (long_u )2436}, 
        {(char_u *)"tjump", (long_u )278}, 
        {(char_u *)"tlast", (long_u )258}, 
        {(char_u *)"tmenu", (long_u )30981}, 
        {(char_u *)"tnext", (long_u )20739}, 
        {(char_u *)"tprevious", (long_u )20739}, 
        {(char_u *)"trewind", (long_u )20739}, 
        {(char_u *)"tselect", (long_u )278}, 
        {(char_u *)"tunmenu", (long_u )10500}, 
        {(char_u *)"undo", (long_u )256}, 
        {(char_u *)"unabbreviate", (long_u )10500}, 
        {(char_u *)"unhide", (long_u )17665}, 
        {(char_u *)"unlet", (long_u )262534}, 
        {(char_u *)"unmap", (long_u )10502}, 
        {(char_u *)"unmenu", (long_u )10502}, 
        {(char_u *)"update", (long_u )319}, 
        {(char_u *)"vglobal", (long_u )37}, 
        {(char_u *)"version", (long_u )260}, 
        {(char_u *)"visual", (long_u )33055}, 
        {(char_u *)"view", (long_u )33055}, 
        {(char_u *)"vmap", (long_u )10500}, 
        {(char_u *)"vmapclear", (long_u )256}, 
        {(char_u *)"vmenu", (long_u )30981}, 
        {(char_u *)"vnoremap", (long_u )10500}, 
        {(char_u *)"vnoremenu", (long_u )30981}, 
        {(char_u *)"vunmap", (long_u )10500}, 
        {(char_u *)"vunmenu", (long_u )10500}, 
        {(char_u *)"write", (long_u )319}, 
        {(char_u *)"wNext", (long_u )16671}, 
        {(char_u *)"wall", (long_u )258}, 
        {(char_u *)"while", (long_u )264196}, 
        {(char_u *)"winsize", (long_u )388}, 
        {(char_u *)"winpos", (long_u )260}, 
        {(char_u *)"wnext", (long_u )16671}, 
        {(char_u *)"wprevious", (long_u )16671}, 
        {(char_u *)"wq", (long_u )319}, 
        {(char_u *)"wqall", (long_u )318}, 
        {(char_u *)"wviminfo", (long_u )286}, 
        {(char_u *)"xit", (long_u )319}, 
        {(char_u *)"xall", (long_u )258}, 
        {(char_u *)"yank", (long_u )1793}, 
        {(char_u *)"z", (long_u )261}, 
        {(char_u *)"!", (long_u )79}, 
        {(char_u *)"#", (long_u )1281}, 
        {(char_u *)"&", (long_u )5}, 
        {(char_u *)"*", (long_u )261}, 
        {(char_u *)"<", (long_u )1281}, 
        {(char_u *)"=", (long_u )257}, 
        {(char_u *)">", (long_u )1281}, 
        {(char_u *)"@", (long_u )261}, 
        {(char_u *)"Next", (long_u )50439}, 
        {(char_u *)"Print", (long_u )1281}, 
        {(char_u *)"X", (long_u )256}, 
        {(char_u *)"~", (long_u )5}};
static int quitmore  =    0;
static int ex_pressedreturn  =    0;
struct growarray ucmds  =    {0, 0, (int )sizeof(UCMD ), 4, (void *)0};
static void do_ucmd(UCMD *cmd , EXARG *eap ) ;
static void do_command(EXARG *eap ) ;
static void do_comclear(void) ;
static void do_delcommand(EXARG *eap ) ;
static char_u *get_user_command_name(int idx ) ;
static void free_cmdlines(struct growarray *gap ) ;
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) ;
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) ;
static char_u *getargcmd(char_u **argp ) ;
static char_u *skip_cmd_arg(char_u *p___0 ) ;
static void do_make(char_u *arg , char_u *errorformat ) ;
static char_u *get_mef_name(int newname ) ;
static void do_cfile(EXARG *eap ) ;
static int do_arglist(char_u *str___1 ) ;
static int check_more(int message , int forceit ) ;
static linenr_t get_address(char_u **ptr , int skip ) ;
static char_u *invalid_range(EXARG *eap ) ;
static void correct_range(EXARG *eap ) ;
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) ;
static void do_quit(EXARG *eap ) ;
static void do_quit_all(int forceit ) ;
static void do_close(EXARG *eap , WIN *win ) ;
static void do_pclose(EXARG *eap ) ;
static void do_suspend(int forceit ) ;
static void do_exit(EXARG *eap ) ;
static void do_print(EXARG *eap ) ;
static void do_next(EXARG *eap ) ;
static void do_recover(EXARG *eap ) ;
static void do_args(EXARG *eap ) ;
static void do_resize(EXARG *eap ) ;
static void do_splitview(EXARG *eap ) ;
static void do_find(EXARG *eap ) ;
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) ;
static void do_swapname(void) ;
static void do_syncbind(void) ;
static void do_read(EXARG *eap ) ;
static void do_cd(EXARG *eap ) ;
static void do_pwd(void) ;
static void do_sleep(EXARG *eap ) ;
static void do_exmap(EXARG *eap , int isabbrev ) ;
static void do_winsize(char_u *arg ) ;
static void do_winpos(char_u *arg ) ;
static void do_exops(EXARG *eap ) ;
static void do_copymove(EXARG *eap ) ;
static void do_exjoin(EXARG *eap ) ;
static void do_exat(EXARG *eap ) ;
static void do_redir(EXARG *eap ) ;
static void close_redir(void) ;
static void do_mkrc(EXARG *eap , char_u *defname ) ;
static FILE *open_exfile(EXARG *eap , char *mode ) ;
static void do_setmark(EXARG *eap ) ;
static void do_normal(EXARG *eap ) ;
static char_u *do_findpat(EXARG *eap , int action ) ;
static void do_ex_tag(EXARG *eap , int dt , int preview ) ;
static char_u *do_if(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_else(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_while(EXARG *eap , struct condstack *cstack ) ;
static char_u *do_continue(struct condstack *cstack ) ;
static char_u *do_break(struct condstack *cstack ) ;
static char_u *do_endwhile(struct condstack *cstack ) ;
static int has_while_cmd(char_u *p___0 ) ;
static int did_endif  =    0;
static int makeopens(FILE *fd ) ;
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) ;
static int ses_fname(FILE *fd , BUF *buf___3 ) ;
static void cmd_source(char_u *fname , int forceit ) ;
static void ex_behave(char_u *arg ) ;
static void ex_filetype(char_u *arg ) ;
static void ex_options(void) ;
CMDIDX cmdidxs[27]  = 
  {      (CMDIDX )0,      (CMDIDX )12,      (CMDIDX )27,      (CMDIDX )64, 
        (CMDIDX )75,      (CMDIDX )88,      (CMDIDX )94,      (CMDIDX )99, 
        (CMDIDX )104,      (CMDIDX )122,      (CMDIDX )124,      (CMDIDX )125, 
        (CMDIDX )130,      (CMDIDX )142,      (CMDIDX )157,      (CMDIDX )167, 
        (CMDIDX )189,      (CMDIDX )191,      (CMDIDX )202,      (CMDIDX )238, 
        (CMDIDX )254,      (CMDIDX )261,      (CMDIDX )272,      (CMDIDX )283, 
        (CMDIDX )285,      (CMDIDX )286,      (CMDIDX )287};
void do_exmode(void) 
{



































































}
static int recursive  =    0;
int do_cmdline(char_u *cmdline , char_u *(*getline___0)(int  , void * , int  ) , void *cookie ,
               int flags___0 ) 
{












































































































































































































































































































































}
static void free_cmdlines(struct growarray *gap ) 
{



















}
static char_u *do_one_cmd(char_u **cmdlinep , int sourcing , struct condstack *cstack ,
                          char_u *(*getline___0)(int  , void * , int  ) , void *cookie ) 
{































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void goto_buffer(EXARG *eap , int start___0 , int dir , int count___2 ) 
{
























































}
char_u *set_one_cmd_context(char_u *buff ) 
{





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static linenr_t get_address(char_u **ptr , int skip ) 
{




































































































































































































































}
static char_u *invalid_range(EXARG *eap ) 
{
























}
static void correct_range(EXARG *eap ) 
{













}
int expand_filename(EXARG *eap , char_u **cmdlinep , char_u **errormsgp ) 
{


























































































































































































}
static char_u *repl_cmdline(EXARG *eap , char_u *src , int srclen , char_u *repl ,
                            char_u **cmdlinep ) 
{























































}
void separate_nextcmd(EXARG *eap ) 
{































































































}
int autowrite(BUF *buf___3 , int forceit ) 
{




























}
void autowrite_all(void) 
{







































}
int check_changed(BUF *buf___3 , int checkaw , int mult_win , int forceit , int allbuf ) 
{










































































}
void dialog_changed(BUF *buf___3 , int checkall ) 
{



























































































}
int can_abandon(BUF *buf___3 , int forceit ) 
{


































}
int check_changed_any(int hidden ) 
{




































































































}
int check_fname(void) 
{











}
int buf_write_all(BUF *buf___3 ) 
{
















}
static char_u *getargcmd(char_u **argp ) 
{

































}
static char_u *skip_cmd_arg(char_u *p___0 ) 
{



























}
int rem_backslash(char_u *str___1 ) 
{














}
void backslash_halve(char_u *p___0 ) 
{























}
char_u *backslash_halve_save(char_u *p___0 ) 
{














}
static void do_make(char_u *arg , char_u *errorformat ) 
{














































































}
static int start  =    -1;
static int off  =    0;
static char_u *get_mef_name(int newname ) 
{















































































}
static void do_cfile(EXARG *eap ) 
{


















}
static int do_arglist(char_u *str___1 ) 
{

































































































































































}
void check_arg_idx(WIN *win ) 
{


























}
int ends_excmd(int c ) 
{






















}
char_u *find_nextcmd(char_u *p___0 ) 
{






















}
char_u *check_nextcmd(char_u *p___0 ) 
{
















}
static int check_more(int message , int forceit ) 
{

















































}
static char_u *get_one_sourceline(struct source_cookie *sp ) ;
int do_source(char_u *fname , int check_other , int is_vimrc ) 
{




















































































































}
char_u *getsourceline(int c , void *cookie , int indent ) 
{






























































}
static char_u *get_one_sourceline(struct source_cookie *sp ) 
{
























































































}
char_u *get_command_name(int idx ) 
{











}
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) ;
static void uc_list(char_u *name___1 , size_t name_len ) ;
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) ;
static char_u *uc_split_args(char_u *arg , size_t *lenp ) ;
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) ;
static int uc_add_command(char_u *name___1 , size_t name_len , char_u *rep , long argt ,
                          long def , int compl , int force ) 
{



































































































}
static void uc_list(char_u *name___1 , size_t name_len ) 
{

















































































































































































































































































































}
static int uc_scan_attr(char_u *attr , size_t len___0 , long *argt , long *def , int *compl ) 
{























































































































































































































































































































}
static void do_command(EXARG *eap ) 
{





































































































}
static void do_comclear(void) 
{

























}
static void do_delcommand(EXARG *eap ) 
{












































}
static char_u *uc_split_args(char_u *arg , size_t *lenp ) 
{



















































































































































}
static size_t uc_check_code(char_u *code , size_t len___0 , char_u *buf___3 , UCMD *cmd ,
                            EXARG *eap , char_u **split_buf , size_t *split_len ) 
{






























































































































































































































































































































































}
static void do_ucmd(UCMD *cmd , EXARG *eap ) 
{
























































































}
static char_u *get_user_command_name(int idx ) 
{









}
char_u *get_user_commands(int idx ) 
{








}
static char *user_cmd_flags[6]  = {      (char *)"nargs",      (char *)"complete",      (char *)"range",      (char *)"count", 
        (char *)"bang",      (char *)"register"};
char_u *get_user_cmd_flags(int idx ) 
{








}
static char *user_cmd_nargs[5]  = {      (char *)"0",      (char *)"1",      (char *)"*",      (char *)"?", 
        (char *)"+"};
char_u *get_user_cmd_nargs(int idx ) 
{








}
static char *user_cmd_complete[13]  = 
  {      (char *)"augroup",      (char *)"buffer",      (char *)"command",      (char *)"dir", 
        (char *)"event",      (char *)"file",      (char *)"help",      (char *)"highlight", 
        (char *)"menu",      (char *)"option",      (char *)"tag",      (char *)"tag_listfiles", 
        (char *)"var"};
char_u *get_user_cmd_complete(int idx ) 
{








}
void not_exiting(void) 
{









}
static void do_quit(EXARG *eap ) 
{



















































































}
static void do_quit_all(int forceit ) 
{























}
static void do_close(EXARG *eap , WIN *win ) 
{




































































}
static void do_pclose(EXARG *eap ) 
{






















}
static void do_suspend(int forceit ) 
{






























}
static void do_exit(EXARG *eap ) 
{


















































































}
static void do_print(EXARG *eap ) 
{








































}
void do_argfile(EXARG *eap , int argn ) 
{




















































































}
static void do_next(EXARG *eap ) 
{



































}
static void do_recover(EXARG *eap ) 
{

























}
static void do_args(EXARG *eap ) 
{

























































}
static void do_splitview(EXARG *eap ) 
{






































}
static void do_resize(EXARG *eap ) 
{
























}
static void do_find(EXARG *eap ) 
{

















}
static void do_exedit(EXARG *eap , WIN *old_curwin___0 ) 
{

































































































































































}
static void do_swapname(void) 
{




















}
static void do_syncbind(void) 
{




















































































}
static void do_read(EXARG *eap ) 
{






















































}
static char_u *prev_dir  =    (char_u *)((void *)0);
static void do_cd(EXARG *eap ) 
{




























































}
static void do_pwd(void) 
{

















}
static void do_sleep(EXARG *eap ) 
{






























}
static void do_exmap(EXARG *eap , int isabbrev ) 
{












































































}
static void do_winsize(char_u *arg ) 
{
















}
static void do_winpos(char_u *arg ) 
{


























}
static void do_exops(EXARG *eap ) 
{




















































}
static void do_copymove(EXARG *eap ) 
{


















































}
static void do_exjoin(EXARG *eap ) 
{






















}
static void do_exat(EXARG *eap ) 
{
















































}
static void do_redir(EXARG *eap ) 
{




























































}
static void close_redir(void) 
{












}
static void do_mkrc(EXARG *eap , char_u *defname ) 
{






















































































































}
static FILE *open_exfile(EXARG *eap , char *mode ) 
{





































}
static void do_setmark(EXARG *eap ) 
{






























}
static int depth___0  =    0;
static void do_normal(EXARG *eap ) 
{















































































































}
static char_u *do_findpat(EXARG *eap , int action ) 
{




























































}
static void do_ex_tag(EXARG *eap , int dt , int preview ) 
{
















}
static char_u *do_if(EXARG *eap , struct condstack *cstack ) 
{





































}
static char_u *do_else(EXARG *eap , struct condstack *cstack ) 
{


























































}
static char_u *do_while(EXARG *eap , struct condstack *cstack ) 
{









































}
static char_u *do_continue(struct condstack *cstack ) 
{





























}
static char_u *do_break(struct condstack *cstack ) 
{






























}
static char_u *do_endwhile(struct condstack *cstack ) 
{
































}
static int has_while_cmd(char_u *p___0 ) 
{


























}
static char *spec_str[9]  = 
  {      (char *)"%",      (char *)"#",      (char *)"<cword>",      (char *)"<cWORD>", 
        (char *)"<cfile>",      (char *)"<sfile>",      (char *)"<afile>",      (char *)"<abuf>", 
        (char *)"<amatch>"};
char_u *eval_vars(char_u *src , int *usedlen , linenr_t *lnump , char_u **errormsg ,
                  char_u *srcstart ) 
{




























































































































































































































}
char_u *expand_sfile(char_u *arg ) 
{


















































































}
static int makeopens(FILE *fd ) 
{










































































































































































































































































































































































































































































































































































































































}
static int ses_fname_line(FILE *fd , char *cmd , linenr_t lnum , BUF *buf___3 ) 
{



























}
static int ses_fname(FILE *fd , BUF *buf___3 ) 
{
















































}
int put_eol(FILE *fd ) 
{











}
static void cmd_source(char_u *fname , int forceit ) 
{

























}
void dialog_msg(char_u *buff , char *format , char_u *fname ) 
{






























}
static void ex_behave(char_u *arg ) 
{

































}
static void ex_filetype(char_u *arg ) 
{



























}
static void ex_options(void) 
{








}
#pragma merger("0","/tmp/cil-18TzbvMo.i","-O0")
int cmdline_crypt ;
int quit_more ;
int msg_no_more ;
int mouse_row  ;
int mouse_col  ;
int maptick ;
int redir_off ;
int save_p_ls ;
int wild_menu_showing ;
char_u wim_flags[4]  ;
char_u e_nomatch2[13] ;
char_u e_toomany[20] ;
long p_hi  ;
int p_is  ;
long p_ls  ;
long p_wc  ;
long p_wcm  ;
int p_wmnu  ;
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) ;
void redrawcmdline(void) ;
void compute_cmdrow(void) ;
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) ;
void remove_key_from_history(void) ;
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) ;
char_u *get_augroup_name(int idx ) ;
char_u *get_event_name(int idx ) ;
int inchar(char_u *buf___3 , int maxlen , long wait_time ) ;
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) ;
char_u *get_menu_name(int idx ) ;
char_u *get_menu_names(int idx ) ;
int msg_outtrans_len(char_u *str___1 , int len___0 ) ;
void msg_puts_long_attr(char_u *longstr , int attr ) ;
void msg_check(void) ;
int match_suffix(char_u *fname ) ;
void vim_strncpy(char_u *to , char_u *from , int len___0 ) ;
int cmdline_paste(int regname___0 , int literally ) ;
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) ;
int ExpandOldSetting(int *num_file , char_u ***file ) ;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) ;
void screen_down(void) ;
char_u *get_syntax_name(int idx ) ;
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) ;
void last_status(void) ;
static struct cmdline_info ccline  ;
static int cmd_numfiles  =    -1;
static char_u **cmd_files  =    (char_u **)((void *)0);
static struct hist_entry *history[4]  = {      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0),      (struct hist_entry *)((void *)0)};
static int hisidx[4]  = {      -1,      -1,      -1,      -1};
static int hisnum[4]  = {      0,      0,      0,      0};
static int hislen  =    0;
static int hist_char2type(int c ) ;
static void init_history(void) ;
static int in_history(int type , char_u *str___1 , int move_to_front ) ;
static int calc_hist_idx(int histype , int num ) ;
static int cmdline_charsize(int idx ) ;
static void set_cmdspos(void) ;
static void set_cmdspos_cursor(void) ;
static void alloc_cmdbuff(int len___0 ) ;
static int realloc_cmdbuff(int len___0 ) ;
static void putcmdline(int c ) ;
static void cmdline_del(int from ) ;
static void redrawcmdprompt(void) ;
static void redrawcmd(void) ;
static void cursorcmd(void) ;
static int ccheck_abbr(int c ) ;
static int nextwild(int type , int options___0 ) ;
static int showmatches(int wildmenu ) ;
static void set_expand_context(void) ;
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) ;
char_u *getcmdline(int firstc , long count___2 , int indent ) 
{




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
char_u *getcmdline_prompt(int firstc , char_u *prompt , int attr ) 
{














}
static int cmdline_charsize(int idx ) 
{











}
static void set_cmdspos(void) 
{










}
static void set_cmdspos_cursor(void) 
{











































}
char_u *getexline(int c , void *dummy , int indent ) 
{



















}
char_u *getexmodeline(int c , void *dummy , int indent ) 
{













































































































}
static void alloc_cmdbuff(int len___0 ) 
{














}
static int realloc_cmdbuff(int len___0 ) 
{

















}
static void putcmdline(int c ) 
{













}
int put_on_cmdline(char_u *str___1 , int len___0 , int redraw ) 
{
































































































}
static void cmdline_del(int from ) 
{











}
void redrawcmdline(void) 
{











}
static void redrawcmdprompt(void) 
{































}
static void redrawcmd(void) 
{








































}
void compute_cmdrow(void) 
{














}
static void cursorcmd(void) 
{













}
void gotocmdline(int clr ) 
{

















}
static int ccheck_abbr(int c ) 
{















}
static int nextwild(int type , int options___0 ) 
{














































































































































}
static int findex  ;
static char_u *orig_save  =    (char_u *)((void *)0);
char_u *ExpandOne(char_u *str___1 , char_u *orig , int options___0 , int mode ) 
{








































































































































































































































































































































































}
void tilde_replace(char_u *orig_pat , int num_files , char_u **files ) 
{


































}
static int showmatches(int wildmenu ) 
{


























































































































































































































}
char_u *addstar(char_u *fname , int len___0 , int context ) 
{
















































































































































}
static void set_expand_context(void) 
{





























}
static int ExpandFromContext(char_u *pat , int *num_file , char_u ***file , int files_only ,
                             int options___0 ) 
{












































































































































































































































}
int ExpandGeneric(vim_regexp *prog , int *num_file , char_u ***file , char_u *(*func)(int  ) ) 
{















































































}
static int hist_char2type(int c ) 
{














}
static char *history_names[5]  = {      (char *)"cmd",      (char *)"search",      (char *)"expr",      (char *)"input", 
        (char *)((void *)0)};
static void init_history(void) 
{






































































































































}
static int in_history(int type , char_u *str___1 , int move_to_front ) 
{




























































}
int get_histtype(char_u *name___1 ) 
{











































}
static int last_maptick  =    -1;
void add_to_history(int histype , char_u *new_entry , int in_map ) 
{
















































}
int get_history_idx(int histype ) 
{




















}
static int calc_hist_idx(int histype , int num ) 
{

























































}
char_u *get_history_entry(int histype , int idx ) 
{












}
int clr_history(int histype ) 
{





































}
int del_history_entry(int histype , char_u *str___1 ) 
{













































































}
int del_history_idx(int histype , int idx ) 
{










































}
void remove_key_from_history(void) 
{










































































}
int get_list_range(char_u **str___1 , int *num1 , int *num2 ) 
{























































}
void do_history(char_u *arg ) 
{


























































































































































































}
static char_u **viminfo_history[4]  = {      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0),      (char_u **)((void *)0)};
static int viminfo_hisidx[4]  = {      0,      0,      0,      0};
static int viminfo_hislen[4]  = {      0,      0,      0,      0};
static int viminfo_add_at_front  =    0;
static int hist_type2char(int type , int use_question ) ;
static int hist_type2char(int type , int use_question ) 
{


















}
void prepare_viminfo_history(int asklen ) 
{



























































}
int read_viminfo_history(char_u *line , FILE *fp___0 ) 
{


































}
void finish_viminfo_history(void) 
{




































































































}
void write_viminfo_history(FILE *fp___0 ) 
{
























































































}
#pragma merger("0","/tmp/cil-t_UM_gnV.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
int recoverymode ;
int p_bk  ;
char_u *p_bdir  ;
char_u *p_bex  ;
char_u *p_ei  ;
char_u *p_pm  ;
int p_wb  ;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) ;
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) ;
void check_timestamps(int focus ) ;
void vim_deltempdir(void) ;
int check_ei(void) ;
int has_cursorhold(void) ;
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) ;
void mf_fullname(MEMFILE *mfp ) ;
void check_need_swap(int newfile ) ;
char_u *get_file_in_dir(char_u *fname , char_u *dname ) ;
char_u *msg_may_trunc(int force , char_u *s ) ;
void add_pathsep(char_u *p___0 ) ;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
void do_outofmem_msg(void) ;
int decrypt_byte(void) ;
int update_keys(int c ) ;
void crypt_init_keys(char_u *passwd ) ;
void screenclear(void) ;
void u_unchanged(BUF *buf___3 ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
static void aucmd_prepbuf(struct aco_save *aco ) ;
static void aucmd_restbuf(struct aco_save *aco ) ;
static void check_marks_read(void) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) ;
static void msg_add_fname(BUF *buf___3 , char_u *fname ) ;
static int msg_add_fileformat(int eol_type ) ;
static void msg_add_lines(int insert_space , long lnum , long nchars ) ;
static void msg_add_eol(void) ;
static int check_mtime(BUF *buf___3 , struct stat *st ) ;
static int time_differs(long t1 , long t2 ) ;
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) ;
static linenr_t write_no_eol_lnum  =    (linenr_t )0;
void filemess(BUF *buf___3 , char_u *name___1 , char_u *s , int attr ) 
{





























}
int readfile(char_u *fname , char_u *sfname , linenr_t from , linenr_t lines_to_skip ,
             linenr_t lines_to_read , int flags___0 ) 
{




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void check_marks_read(void) 
{
















}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
static void set_file_time(char_u *fname , time_t atime , time_t mtime ) 
{










}
int buf_write(BUF *buf___3 , char_u *fname , char_u *sfname , linenr_t start___0 ,
              linenr_t end , int append , int forceit , int reset_changed , int filtering ) 
{


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void msg_add_fname(BUF *buf___3 , char_u *fname ) 
{













}
static int msg_add_fileformat(int eol_type ) 
{




































}
static void msg_add_lines(int insert_space , long lnum , long nchars ) 
{



































}
static void msg_add_eol(void) 
{

















}
static int check_mtime(BUF *buf___3 , struct stat *st ) 
{























}
static int time_differs(long t1 , long t2 ) 
{














}
static int write_buf(int fd , char_u *buf___3 , int len___0 , int docrypt ) 
{














































}
char_u *shorten_fname(char_u *full_path , char_u *dir_name ) 
{































}
void shorten_fnames(int force ) 
{






























































}
char_u *modname(char_u *fname , char_u *ext , int prepend_dot ) 
{


















}
char_u *buf_modname(int shortname , char_u *fname , char_u *ext , int prepend_dot ) 
{














































































































































































































}
int vim_fgets(char_u *buf___3 , int size , FILE *fp___0 ) 
{
































}
int vim_rename(char_u *from , char_u *to ) 
{



























































































}
static int already_warned  =    0;
void check_timestamps(int focus ) 
{



























































}
int buf_check_timestamp(BUF *buf___3 , int focus ) 
{































































































































}
void write_lnum_adjust(linenr_t offset ) 
{








}
static char_u *vim_tempdir  =    (char_u *)((void *)0);
static long temp_count  =    0L;
void vim_deltempdir(void) 
{










































}
static char *tempdirs[4]  = {      (char *)"$TMPDIR",      (char *)"/tmp",      (char *)".",      (char *)"$HOME"};
char_u *vim_tempname(int extra_char ) 
{




















































































}
static struct event_name event_names[43]  = 
  {      {(char *)"BufCreate", (EVENT_T )0}, 
        {(char *)"BufDelete", (EVENT_T )1}, 
        {(char *)"BufEnter", (EVENT_T )2}, 
        {(char *)"BufFilePost", (EVENT_T )3}, 
        {(char *)"BufFilePre", (EVENT_T )4}, 
        {(char *)"BufHidden", (EVENT_T )10}, 
        {(char *)"BufLeave", (EVENT_T )5}, 
        {(char *)"BufNewFile", (EVENT_T )6}, 
        {(char *)"BufReadPost", (EVENT_T )7}, 
        {(char *)"BufReadPre", (EVENT_T )8}, 
        {(char *)"BufRead", (EVENT_T )7}, 
        {(char *)"BufUnload", (EVENT_T )9}, 
        {(char *)"BufWritePost", (EVENT_T )11}, 
        {(char *)"BufWritePre", (EVENT_T )12}, 
        {(char *)"BufWrite", (EVENT_T )12}, 
        {(char *)"CursorHold", (EVENT_T )39}, 
        {(char *)"FileAppendPost", (EVENT_T )13}, 
        {(char *)"FileAppendPre", (EVENT_T )14}, 
        {(char *)"FileChangedShell", (EVENT_T )15}, 
        {(char *)"FileEncoding", (EVENT_T )38}, 
        {(char *)"FileReadPost", (EVENT_T )16}, 
        {(char *)"FileReadPre", (EVENT_T )17}, 
        {(char *)"FileType", (EVENT_T )18}, 
        {(char *)"FileWritePost", (EVENT_T )19}, 
        {(char *)"FileWritePre", (EVENT_T )20}, 
        {(char *)"FilterReadPost", (EVENT_T )21}, 
        {(char *)"FilterReadPre", (EVENT_T )22}, 
        {(char *)"FilterWritePost", (EVENT_T )23}, 
        {(char *)"FilterWritePre", (EVENT_T )24}, 
        {(char *)"FocusGained", (EVENT_T )25}, 
        {(char *)"FocusLost", (EVENT_T )26}, 
        {(char *)"GUIEnter", (EVENT_T )27}, 
        {(char *)"StdinReadPost", (EVENT_T )28}, 
        {(char *)"StdinReadPre", (EVENT_T )29}, 
        {(char *)"Syntax", (EVENT_T )30}, 
        {(char *)"TermChanged", (EVENT_T )31}, 
        {(char *)"User", (EVENT_T )32}, 
        {(char *)"VimEnter", (EVENT_T )33}, 
        {(char *)"VimLeave", (EVENT_T )34}, 
        {(char *)"VimLeavePre", (EVENT_T )35}, 
        {(char *)"WinEnter", (EVENT_T )36}, 
        {(char *)"WinLeave", (EVENT_T )37}, 
        {(char *)((void *)0), (EVENT_T )0}};
static AutoPat *first_autopat[40]  = 
  {      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0), 
        (AutoPat *)((void *)0),      (AutoPat *)((void *)0),      (AutoPat *)((void *)0)};
struct growarray augroups  =    {0, 0, (int )sizeof(char_u *), 10, (void *)0};
static int current_augroup  =    -1;
static int au_need_clean  =    0;
static void show_autocmd(AutoPat *ap , EVENT_T event ) ;
static void au_remove_pat(AutoPat *ap ) ;
static void au_remove_cmds(AutoPat *ap ) ;
static void au_cleanup(void) ;
static int au_new_group(char_u *name___1 ) ;
static int au_find_group(char_u *name___1 ) ;
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) ;
static char_u *event_nr2name(EVENT_T event ) ;
static char_u *find_end_event(char_u *arg ) ;
static int event_ignored(EVENT_T event ) ;
static int au_get_grouparg(char_u **argp ) ;
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) ;
static char_u *getnextac(int c , void *cookie , int indent ) ;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) ;
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) ;
static EVENT_T last_event  ;
static int last_group  ;
static void show_autocmd(AutoPat *ap , EVENT_T event ) 
{

















































































}
static void au_remove_pat(AutoPat *ap ) 
{










}
static void au_remove_cmds(AutoPat *ap ) 
{





















}
static void au_cleanup(void) 
{














































































}
static int au_new_group(char_u *name___1 ) 
{


























}
static int au_find_group(char_u *name___1 ) 
{


























}
void do_augroup(char_u *arg ) 
{














































}
static EVENT_T event_name2nr(char_u *start___0 , char_u **end ) 
{































































}
static char_u *event_nr2name(EVENT_T event ) 
{



















}
static char_u *find_end_event(char_u *arg ) 
{

















































}
static int event_ignored(EVENT_T event ) 
{





























}
int check_ei(void) 
{





























}
void do_autocmd(char_u *arg , int forceit ) 
{





















































































































































































}
static int au_get_grouparg(char_u **argp ) 
{


































}
static int do_autocmd_event(EVENT_T event , char_u *pat , int nested , char_u *cmd ,
                            int forceit , int group ) 
{











































































































































































































































}
int do_doautocmd(char_u *arg , int do_msg ) 
{






























































}
void do_autoall(char_u *arg ) 
{
































}
static void aucmd_prepbuf(struct aco_save *aco ) 
{






































}
static void aucmd_restbuf(struct aco_save *aco ) 
{

















































}
static int autocmd_nested  =    0;
int apply_autocmds(EVENT_T event , char_u *fname , char_u *fname_io , int force ,
                   BUF *buf___3 ) 
{








}
int has_cursorhold(void) 
{





}
static int nesting  =    0;
static int apply_autocmds_group(EVENT_T event , char_u *fname , char_u *fname_io ,
                                int force , int group , BUF *buf___3 ) 
{




















































































































































































































































}
static void auto_next_pat(AutoPatCmd *apc , int stop_at_last ) 
{
























































































}
static char_u *getnextac(int c , void *cookie , int indent ) 
{



































































}
char_u *get_augroup_name(int idx ) 
{














}
static int include_groups  =    0;
char_u *set_context_in_autocmd(char_u *arg , int doautocmd ) 
{











































































}
char_u *get_event_name(int idx ) 
{















}
int match_file_pat(char_u *pattern , char_u *fname , char_u *sfname , char_u *tail ,
                   int allow_dirs ) 
{


















































}
char_u *file_pat_to_reg_pat(char_u *pat , char_u *pat_end , char *allow_dirs , int no_bslash ) 
{






































































































































































































































































































}
#pragma merger("0","/tmp/cil-Pa4aaib1.i","-O0")
extern int _IO_getc(_IO_FILE *__fp ) ;
FPOS VIsual  ;
int VIsual_select ;
int redo_VIsual_busy ;
int Exec_reg ;
char_u *typebuf ;
int typebuflen  ;
int typeoff  ;
int KeyStuffed  ;
FILE *scriptin[15]  ;
int curscript ;
FILE *scriptout ;
int did_outofmem_msg ;
int did_swapwrite_msg ;
int undo_off ;
char_u e_nesting[24] ;
char_u e_toocompl[20] ;
char_u *p_pt  ;
int p_remap  ;
int p_timeout  ;
long p_tm  ;
int p_ttimeout  ;
long p_ttm  ;
long p_uc  ;
char_u *get_recorded(void) ;
void flush_buffers(int typeahead ) ;
void stuffnumReadbuff(long n ) ;
int start_redo(long count___2 , int old_redo ) ;
int typebuf_maplen(void) ;
void del_typebuf(int len___0 , int offset ) ;
int save_typebuf(void) ;
void updatescript(int c ) ;
int putescstr(FILE *fd , char_u *str___1 , int set ) ;
void check_map_keycodes(void) ;
void init_mappings(void) ;
void ml_sync_all(int check_file , int check_char ) ;
int msg_outtrans_special(char_u *str___1 , int from ) ;
int get_keystroke(void) ;
int get_real_state(void) ;
void push_showcmd(void) ;
void pop_showcmd(void) ;
void unshowmode(int force ) ;
int add_termcap_entry(char_u *name___1 , int force ) ;
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) ;
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
static struct buffheader stuffbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader save_old_redobuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static struct buffheader recordbuff  =    {{(struct bufblock *)((void *)0), {(char_u )'\000'}}, (struct bufblock *)((void *)0),
    0, 0};
static int block_redo  =    0;
static struct mapblock *maphash[256]  ;
static int maphash_valid  =    0;
static struct mapblock *first_abbr  =    (struct mapblock *)((void *)0);
static char_u *noremapbuf  =    (char_u *)((void *)0);
static char_u typebuf_init[265]  ;
static char_u noremapbuf_init[265]  ;
static int typemaplen  =    0;
static int no_abbr_cnt  =    0;
static int last_recorded_len  =    0;
static void free_buff(struct buffheader *buf___3 ) ;
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) ;
static void add_buff(struct buffheader *buf___3 , char_u *s ) ;
static void add_num_buff(struct buffheader *buf___3 , long n ) ;
static void add_char_buff(struct buffheader *buf___3 , int c ) ;
static int read_stuff(int advance ) ;
static void start_stuff(void) ;
static int read_redo(int init , int old_redo ) ;
static void copy_redo(int old_redo ) ;
static void init_typebuf(void) ;
static void gotchars(char_u *s , int len___0 ) ;
static void may_sync_undo(void) ;
static void closescript(void) ;
static int vgetorpeek(int advance ) ;
static void map_free(struct mapblock **mpp ) ;
static void validate_maphash(void) ;
static void showmap(struct mapblock *mp ) ;
static void free_buff(struct buffheader *buf___3 ) 
{






















}
static char_u *get_bufcont(struct buffheader *buffer , int dozero ) 
{





































































}
char_u *get_recorded(void) 
{






















}
char_u *get_inserted(void) 
{








}
static void add_buff(struct buffheader *buf___3 , char_u *s ) 
{


























































}
static void add_num_buff(struct buffheader *buf___3 , long n ) 
{










}
static void add_char_buff(struct buffheader *buf___3 , int c ) 
{












































}
static int read_stuff(int advance ) 
{





















}
static void start_stuff(void) 
{









}
int stuff_empty(void) 
{





}
void flush_buffers(int typeahead ) 
{











































}
void ResetRedobuff(void) 
{












}
static int save_level  =    0;
void saveRedobuff(void) 
{













}
void restoreRedobuff(void) 
{














}
void AppendToRedobuff(char_u *s ) 
{










}
void AppendCharToRedobuff(int c ) 
{










}
void AppendNumberToRedobuff(long n ) 
{










}
void stuffReadbuff(char_u *s ) 
{








}
void stuffcharReadbuff(int c ) 
{








}
void stuffnumReadbuff(long n ) 
{








}
static struct bufblock *bp  ;
static char_u *p  ;
static int read_redo(int init , int old_redo ) 
{









































}
static void copy_redo(int old_redo ) 
{




















}
int start_redo(long count___2 , int old_redo ) 
{
































































}
int start_redo_ins(void) 
{

















































}
void stop_redo_ins(void) 
{






}
static void init_typebuf(void) 
{












}
int ins_typebuf(char_u *str___1 , int noremap , int offset , int nottyped ) 
{












































































































}
int typebuf_typed(void) 
{





}
int typebuf_maplen(void) 
{





}
void del_typebuf(int len___0 , int offset ) 
{













































}
static void gotchars(char_u *s , int len___0 ) 
{







































}
static void may_sync_undo(void) 
{



















}
static char_u *sv_typebuf[15]  ;
static char_u *sv_noremapbuf[15]  ;
static int sv_typebuflen[15]  ;
static int sv_typeoff[15]  ;
static int sv_typelen[15]  ;
static int sv_typemaplen[15]  ;
static int sv_no_abbr_cnt[15]  ;
int save_typebuf(void) 
{



































}
int openscript(char_u *name___1 ) 
{





























































}
static void closescript(void) 
{





















}
int using_script(void) 
{





}
static int count___0  =    0;
void updatescript(int c ) 
{




























}
static int old_char  =    -1;
int vgetc(void) 
{

















































}
int safe_vgetc(void) 
{













}
int vpeekc(void) 
{








}
int char_avail(void) 
{










}
void vungetc(int c ) 
{






}
static int vgetorpeek(int advance ) 
{


















































































































































































































































































































































































































































































































































































































































































































}
int inchar(char_u *buf___3 , int maxlen , long wait_time ) 
{







































































































































}
int do_map(int maptype , char_u *keys___0 , int mode , int abbrev , char_u **ambig ) 
{




















































































































































































































































































































































































































































}
static void map_free(struct mapblock **mpp ) 
{












}
static void validate_maphash(void) 
{











}
int get_map_mode(char_u **cmdp , int forceit ) 
{












































}
void map_clear(char_u *cmdp , int forceit , int abbr ) 
{

































































}
static void showmap(struct mapblock *mp ) 
{








































































































}
static int expand_mapmodes  =    0;
static int expand_isabbrev  =    0;
char_u *set_context_in_map_cmd(char_u *cmd , char_u *arg , int forceit , int isabbrev ,
                               int isunmap , CMDIDX cmdidx ) 
{








































}
static int compare_mkeys(void const   *s1 , void const   *s2 ) ;
static int compare_mkeys(void const   *s1 , void const   *s2 ) 
{








}
int ExpandMappings(vim_regexp *prog , int *num_file , char_u ***file ) 
{












































































































































}
int check_abbr(int c , char_u *ptr , int col , int mincol ) 
{






















































































































































































}
int makemap(FILE *fd ) 
{





























































































































































































































































































































}
int putescstr(FILE *fd , char_u *str___1 , int set ) 
{









































































































































}
void check_map_keycodes(void) 
{































































































}
char_u *check_map(char_u *keys___0 , int mode , int exact ) 
{





























































}
static struct initmap initmappings[20]  = 
  {      {(char_u *)"<xF1> <F1>", 7}, 
        {(char_u *)"<xF1> <F1>", 24}, 
        {(char_u *)"<xF2> <F2>", 7}, 
        {(char_u *)"<xF2> <F2>", 24}, 
        {(char_u *)"<xF3> <F3>", 7}, 
        {(char_u *)"<xF3> <F3>", 24}, 
        {(char_u *)"<xF4> <F4>", 7}, 
        {(char_u *)"<xF4> <F4>", 24}, 
        {(char_u *)"<S-xF1> <S-F1>", 7}, 
        {(char_u *)"<S-xF1> <S-F1>", 24}, 
        {(char_u *)"<S-xF2> <S-F2>", 7}, 
        {(char_u *)"<S-xF2> <S-F2>", 24}, 
        {(char_u *)"<S-xF3> <S-F3>", 7}, 
        {(char_u *)"<S-xF3> <S-F3>", 24}, 
        {(char_u *)"<S-xF4> <S-F4>", 7}, 
        {(char_u *)"<S-xF4> <S-F4>", 24}, 
        {(char_u *)"<xEND> <END>", 7}, 
        {(char_u *)"<xEND> <END>", 24}, 
        {(char_u *)"<xHOME> <HOME>", 7}, 
        {(char_u *)"<xHOME> <HOME>", 24}};
void init_mappings(void) 
{






























}
#pragma merger("0","/tmp/cil-lsfeYdVO.i","-O0")
#pragma merger("0","/tmp/cil-Woe45Uju.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
long Rows  =    2L;
long Columns  =    12L;
char_u *NextScreen  =    (char_u *)((void *)0);
char_u **LinePointers  =    (char_u **)((void *)0);
int screen_Rows  =    0;
int screen_Columns  =    0;
int mod_mask  =    0;
int redraw_cmdline  =    0;
int clear_cmdline  =    0;
int cmdline_crypt  =    0;
int exec_from_reg  =    0;
int modified  =    0;
int tag_modified  =    0;
int screen_cleared  =    0;
colnr_t dollar_vcol  =    (colnr_t )0;
int expand_context  =    -2;
char_u *expand_pattern  =    (char_u *)((void *)0);
int expand_set_path  =    0;
int completion_length  =    0;
int continue_status  =    0;
int completion_interrupted  =    0;
char_u *keep_msg  =    (char_u *)((void *)0);
int keep_msg_attr  =    0;
int need_fileinfo  =    0;
int msg_scroll  =    0;
int msg_didout  =    0;
int msg_didany  =    0;
int msg_nowait  =    0;
int emsg_off  =    0;
int emsg_on_display  =    0;
int rc_did_emsg  =    0;
int no_wait_return  =    0;
int need_wait_return  =    0;
int quit_more  =    0;
int more_back  =    0;
int more_back_used  =    0;
int newline_on_exit  =    0;
int intr_char  =    0;
int vgetc_busy  =    0;
int didset_vim  =    0;
int didset_vimruntime  =    0;
int lines_left  =    -1;
int msg_no_more  =    0;
char_u *sourcing_name  =    (char_u *)((void *)0);
linenr_t sourcing_lnum  =    (linenr_t )0;
int scroll_region  =    0;
int highlight_match  =    0;
int no_smartcase  =    0;
int need_check_timestamps  =    0;
int highlight_user[9]  ;
int highlight_stlnc[9]  ;
int cterm_normal_fg_color  =    0;
int cterm_normal_fg_bold  =    0;
int cterm_normal_bg_color  =    0;
int autocmd_busy  =    0;
int autocmd_no_enter  =    0;
int autocmd_no_leave  =    0;
int did_filetype  =    0;
BUF *au_new_curbuf  =    (BUF *)((void *)0);
int mouse_past_bottom  =    0;
int mouse_past_eol  =    0;
int mouse_dragging  =    0;
VimMenu *root_menu  =    (VimMenu *)((void *)0);
int sys_menu  =    0;
VimClipboard clipboard  ;
BUF *firstbuf  =    (BUF *)((void *)0);
BUF *lastbuf  =    (BUF *)((void *)0);
BUF *curbuf  =    (BUF *)((void *)0);
int arg_had_last  =    0;
int ru_col  ;
int ru_wid  ;
int starting  =    2;
int exiting  =    0;
int full_screen  =    0;
int restricted  =    0;
int secure  =    0;
int sandbox  =    0;
int silent_mode  =    0;
int VIsual_active  =    0;
int VIsual_select  =    0;
int VIsual_mode  =    'v';
int redo_VIsual_busy  =    0;
int did_ai  =    0;
colnr_t ai_col  =    (colnr_t )0;
int end_comment_pending  =    '\000';
int did_syncbind  =    0;
int did_si  =    0;
int can_si  =    0;
int can_si_back  =    0;
int orig_line_count  =    0;
int vr_lines_changed  =    0;
colnr_t vr_virtcol  =    (colnr_t )2147483647;
int vr_virtoffset  =    0;
int State  =    1;
int exmode_active  =    0;
int ex_no_reprint  =    0;
int Recording  =    0;
int Exec_reg  =    0;
int finish_op  =    0;
int no_mapping  =    0;
int allow_keys  =    0;
int no_u_sync  =    0;
int restart_edit  =    0;
char_u *edit_submode  =    (char_u *)((void *)0);
char_u *edit_submode_extra  =    (char_u *)((void *)0);
int ctrl_x_mode  =    0;
int no_abbr  =    1;
int fo_do_comments  =    0;
int confirm  =    0;
int swap_exists_action  =    0;
int RedrawingDisabled  =    0;
int readonlymode  =    0;
int recoverymode  =    0;
char_u *typebuf  =    (char_u *)((void *)0);
int maptick  =    0;
int must_redraw  =    0;
int skip_redraw  =    0;
int do_redraw  =    0;
int need_highlight_changed  =    1;
char_u *use_viminfo  =    (char_u *)((void *)0);
int curscript  =    0;
FILE *scriptout  =    (FILE *)((void *)0);
int read_cmd_fd  =    0;
int got_int  =    0;
int termcap_active  =    0;
int bangredo  =    0;
int reg_ic  =    0;
int reg_syn  =    0;
int did_outofmem_msg  =    0;
int did_swapwrite_msg  =    0;
int undo_off  =    0;
int global_busy  =    0;
int need_start_insertmode  =    0;
char_u *last_cmdline  =    (char_u *)((void *)0);
char_u *new_last_cmdline  =    (char_u *)((void *)0);
char_u *autocmd_fname  =    (char_u *)((void *)0);
int autocmd_bufnr  =    0;
char_u *autocmd_match  =    (char_u *)((void *)0);
int postponed_split  =    0;
int g_do_tagpreview  =    0;
int replace_offset  =    0;
char_u *escape_chars  =    (char_u *)" \t\\\"|";
char_u *help_save_isk  =    (char_u *)((void *)0);
long help_save_ts  =    0L;
int keep_help_flag  =    0;
char_u *empty_option  =    (char_u *)"";
int redir_off  =    0;
FILE *redir_fd  =    (FILE *)((void *)0);
int redir_reg  =    0;
int save_p_ls  =    -1;
int wild_menu_showing  =    0;
char *longVersion ;
int lcs_eol  =    '$';
int lcs_ext  =    '\000';
int lcs_tab1  =    '\000';
int lcs_tab2  =    '\000';
int lcs_trail  =    '\000';
char_u no_lines_msg[23]  = 
  {      (char_u )'-',      (char_u )'-',      (char_u )'N',      (char_u )'o', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )'s',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )' ',      (char_u )'b',      (char_u )'u', 
        (char_u )'f',      (char_u )'f',      (char_u )'e',      (char_u )'r', 
        (char_u )'-',      (char_u )'-',      (char_u )'\000'};
int stl_syntax  =    0;
int no_hlsearch  =    0;
char *xterm_display  =    (char *)((void *)0);
Display *xterm_dpy  =    (Display *)((void *)0);
XtAppContext app_context  =    (XtAppContext )((void *)0);
char_u e_abort[16]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'o',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_argreq[18]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'r',      (char_u )'e',      (char_u )'q', 
        (char_u )'u',      (char_u )'i',      (char_u )'r',      (char_u )'e', 
        (char_u )'d',      (char_u )'\000'};
char_u e_backslash[34]  = 
  {      (char_u )'\\',      (char_u )' ',      (char_u )'s',      (char_u )'h', 
        (char_u )'o',      (char_u )'u',      (char_u )'l',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )' ',      (char_u )'b',      (char_u )'y',      (char_u )' ', 
        (char_u )'/',      (char_u )',',      (char_u )' ',      (char_u )'?', 
        (char_u )' ',      (char_u )'o',      (char_u )'r',      (char_u )' ', 
        (char_u )'&',      (char_u )'\000'};
char_u e_curdir[65]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'r',      (char_u )'o',      (char_u )'m', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'r', 
        (char_u )'c',      (char_u )'/',      (char_u )'v',      (char_u )'i', 
        (char_u )'m',      (char_u )'r',      (char_u )'c',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'c', 
        (char_u )'u',      (char_u )'r',      (char_u )'r',      (char_u )'e', 
        (char_u )'n',      (char_u )'t',      (char_u )' ',      (char_u )'d', 
        (char_u )'i',      (char_u )'r',      (char_u )' ',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'t',      (char_u )'a', 
        (char_u )'g',      (char_u )' ',      (char_u )'s',      (char_u )'e', 
        (char_u )'a',      (char_u )'r',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_exists[32]  = 
  {      (char_u )'F',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'e',      (char_u )'x',      (char_u )'i', 
        (char_u )'s',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'(',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )' ',      (char_u )'!',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )' ',      (char_u )'o',      (char_u )'v', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'i', 
        (char_u )'d',      (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_failed[15]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'f',      (char_u )'a',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_internal[15]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'n',      (char_u )'a',      (char_u )'l', 
        (char_u )' ',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'o',      (char_u )'r',      (char_u )'\000'};
char_u e_interr[12]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'t',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'u',      (char_u )'p', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_invaddr[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'d',      (char_u )'d',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'\000'};
char_u e_invarg[17]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )'\000'};
char_u e_invarg2[21]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_invexpr2[23]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )':',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_invrange[14]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'r',      (char_u )'a',      (char_u )'n',      (char_u )'g', 
        (char_u )'e',      (char_u )'\000'};
char_u e_invcmd[16]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_letunexp[33]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'e',      (char_u )'x', 
        (char_u )'p',      (char_u )'e',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'c', 
        (char_u )'h',      (char_u )'a',      (char_u )'r',      (char_u )'a', 
        (char_u )'c',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'s',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )'f',      (char_u )'o',      (char_u )'r',      (char_u )'e', 
        (char_u )' ',      (char_u )'\'',      (char_u )'=',      (char_u )'\'', 
        (char_u )'\000'};
char_u e_markinval[29]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'h',      (char_u )'a',      (char_u )'s', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )'v', 
        (char_u )'a',      (char_u )'l',      (char_u )'i',      (char_u )'d', 
        (char_u )' ',      (char_u )'l',      (char_u )'i',      (char_u )'n', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'u', 
        (char_u )'m',      (char_u )'b',      (char_u )'e',      (char_u )'r', 
        (char_u )'\000'};
char_u e_marknotset[13]  = 
  {      (char_u )'M',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )' ',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nesting[24]  = 
  {      (char_u )'S',      (char_u )'c',      (char_u )'r',      (char_u )'i', 
        (char_u )'p',      (char_u )'t',      (char_u )'s',      (char_u )' ', 
        (char_u )'n',      (char_u )'e',      (char_u )'s',      (char_u )'t', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'t', 
        (char_u )'o',      (char_u )'o',      (char_u )' ',      (char_u )'d', 
        (char_u )'e',      (char_u )'e',      (char_u )'p',      (char_u )'\000'};
char_u e_noalt[18]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'a', 
        (char_u )'l',      (char_u )'t',      (char_u )'e',      (char_u )'r', 
        (char_u )'n',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_noabbr[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'a',      (char_u )'b',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'v',      (char_u )'i',      (char_u )'a', 
        (char_u )'t',      (char_u )'i',      (char_u )'o',      (char_u )'n', 
        (char_u )'\000'};
char_u e_nobang[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'!', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_nogvim[49]  = 
  {      (char_u )'G',      (char_u )'U',      (char_u )'I',      (char_u )' ', 
        (char_u )'c',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'b', 
        (char_u )'e',      (char_u )' ',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )'d',      (char_u )':',      (char_u )' ', 
        (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'a',      (char_u )'b', 
        (char_u )'l',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'c', 
        (char_u )'o',      (char_u )'m',      (char_u )'p',      (char_u )'i', 
        (char_u )'l',      (char_u )'e',      (char_u )' ',      (char_u )'t', 
        (char_u )'i',      (char_u )'m',      (char_u )'e',      (char_u )'\n', 
        (char_u )'\000'};
char_u e_nohebrew[52]  = 
  {      (char_u )'H',      (char_u )'e',      (char_u )'b',      (char_u )'r', 
        (char_u )'e',      (char_u )'w',      (char_u )' ',      (char_u )'c', 
        (char_u )'a',      (char_u )'n',      (char_u )'n',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'u',      (char_u )'s',      (char_u )'e', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'N', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'n',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )'d',      (char_u )' ',      (char_u )'a', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'o', 
        (char_u )'m',      (char_u )'p',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'t',      (char_u )'i', 
        (char_u )'m',      (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_nofarsi[51]  = 
  {      (char_u )'F',      (char_u )'a',      (char_u )'r',      (char_u )'s', 
        (char_u )'i',      (char_u )' ',      (char_u )'c',      (char_u )'a', 
        (char_u )'n',      (char_u )'n',      (char_u )'o',      (char_u )'t', 
        (char_u )' ',      (char_u )'b',      (char_u )'e',      (char_u )' ', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )'d', 
        (char_u )':',      (char_u )' ',      (char_u )'N',      (char_u )'o', 
        (char_u )'t',      (char_u )' ',      (char_u )'e',      (char_u )'n', 
        (char_u )'a',      (char_u )'b',      (char_u )'l',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'a',      (char_u )'t', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'m', 
        (char_u )'p',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'t',      (char_u )'i',      (char_u )'m', 
        (char_u )'e',      (char_u )'\n',      (char_u )'\000'};
char_u e_noinstext[21]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'i', 
        (char_u )'n',      (char_u )'s',      (char_u )'e',      (char_u )'r', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'e',      (char_u )'x',      (char_u )'t', 
        (char_u )' ',      (char_u )'y',      (char_u )'e',      (char_u )'t', 
        (char_u )'\000'};
char_u e_nolastcmd[25]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nomap[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'s', 
        (char_u )'u',      (char_u )'c',      (char_u )'h',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'p',      (char_u )'p', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_nomatch[9]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )'\000'};
char_u e_nomatch2[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )'c',      (char_u )'h', 
        (char_u )':',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_noname[13]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_nopresub[42]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'s',      (char_u )'u',      (char_u )'b',      (char_u )'s', 
        (char_u )'t',      (char_u )'i',      (char_u )'t',      (char_u )'u', 
        (char_u )'t',      (char_u )'e',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'g',      (char_u )'u',      (char_u )'l', 
        (char_u )'a',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'r',      (char_u )'e', 
        (char_u )'s',      (char_u )'s',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )'\000'};
char_u e_noprev[20]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'\000'};
char_u e_noprevre[31]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'p', 
        (char_u )'r',      (char_u )'e',      (char_u )'v',      (char_u )'i', 
        (char_u )'o',      (char_u )'u',      (char_u )'s',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'g',      (char_u )'u', 
        (char_u )'l',      (char_u )'a',      (char_u )'r',      (char_u )' ', 
        (char_u )'e',      (char_u )'x',      (char_u )'p',      (char_u )'r', 
        (char_u )'e',      (char_u )'s',      (char_u )'s',      (char_u )'i', 
        (char_u )'o',      (char_u )'n',      (char_u )'\000'};
char_u e_norange[17]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'r', 
        (char_u )'a',      (char_u )'n',      (char_u )'g',      (char_u )'e', 
        (char_u )' ',      (char_u )'a',      (char_u )'l',      (char_u )'l', 
        (char_u )'o',      (char_u )'w',      (char_u )'e',      (char_u )'d', 
        (char_u )'\000'};
char_u e_noroom[16]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'e',      (char_u )'n',      (char_u )'o',      (char_u )'u', 
        (char_u )'g',      (char_u )'h',      (char_u )' ',      (char_u )'r', 
        (char_u )'o',      (char_u )'o',      (char_u )'m',      (char_u )'\000'};
char_u e_notcreate[21]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'c',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'%',      (char_u )'s', 
        (char_u )'\000'};
char_u e_notmp[25]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'g',      (char_u )'e', 
        (char_u )'t',      (char_u )' ',      (char_u )'t',      (char_u )'e', 
        (char_u )'m',      (char_u )'p',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'n',      (char_u )'a',      (char_u )'m',      (char_u )'e', 
        (char_u )'\000'};
char_u e_notopen[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_notread[19]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'a',      (char_u )'d',      (char_u )' ',      (char_u )'f', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_nowrtmsg[47]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'w', 
        (char_u )'r',      (char_u )'i',      (char_u )'t',      (char_u )'e', 
        (char_u )' ',      (char_u )'s',      (char_u )'i',      (char_u )'n', 
        (char_u )'c',      (char_u )'e',      (char_u )' ',      (char_u )'l', 
        (char_u )'a',      (char_u )'s',      (char_u )'t',      (char_u )' ', 
        (char_u )'c',      (char_u )'h',      (char_u )'a',      (char_u )'n', 
        (char_u )'g',      (char_u )'e',      (char_u )' ',      (char_u )'(', 
        (char_u )'u',      (char_u )'s',      (char_u )'e',      (char_u )' ', 
        (char_u )'!',      (char_u )' ',      (char_u )'t',      (char_u )'o', 
        (char_u )' ',      (char_u )'o',      (char_u )'v',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'i',      (char_u )'d', 
        (char_u )'e',      (char_u )')',      (char_u )'\000'};
char_u e_null[14]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'l',      (char_u )'l', 
        (char_u )' ',      (char_u )'a',      (char_u )'r',      (char_u )'g', 
        (char_u )'u',      (char_u )'m',      (char_u )'e',      (char_u )'n', 
        (char_u )'t',      (char_u )'\000'};
char_u e_number[16]  = 
  {      (char_u )'N',      (char_u )'u',      (char_u )'m',      (char_u )'b', 
        (char_u )'e',      (char_u )'r',      (char_u )' ',      (char_u )'e', 
        (char_u )'x',      (char_u )'p',      (char_u )'e',      (char_u )'c', 
        (char_u )'t',      (char_u )'e',      (char_u )'d',      (char_u )'\000'};
char_u e_openerrf[24]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'\'', 
        (char_u )'t',      (char_u )' ',      (char_u )'o',      (char_u )'p', 
        (char_u )'e',      (char_u )'n',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'f',      (char_u )'i',      (char_u )'l',      (char_u )'e', 
        (char_u )' ',      (char_u )'%',      (char_u )'s',      (char_u )'\000'};
char_u e_outofmem[15]  = 
  {      (char_u )'O',      (char_u )'u',      (char_u )'t',      (char_u )' ', 
        (char_u )'o',      (char_u )'f',      (char_u )' ',      (char_u )'m', 
        (char_u )'e',      (char_u )'m',      (char_u )'o',      (char_u )'r', 
        (char_u )'y',      (char_u )'!',      (char_u )'\000'};
char_u e_patnotf[18]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )'\000'};
char_u e_patnotf2[22]  = 
  {      (char_u )'P',      (char_u )'a',      (char_u )'t',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'n',      (char_u )' ', 
        (char_u )'n',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'f',      (char_u )'o',      (char_u )'u',      (char_u )'n', 
        (char_u )'d',      (char_u )':',      (char_u )' ',      (char_u )'%', 
        (char_u )'s',      (char_u )'\000'};
char_u e_positive[26]  = 
  {      (char_u )'A',      (char_u )'r',      (char_u )'g',      (char_u )'u', 
        (char_u )'m',      (char_u )'e',      (char_u )'n',      (char_u )'t', 
        (char_u )' ',      (char_u )'m',      (char_u )'u',      (char_u )'s', 
        (char_u )'t',      (char_u )' ',      (char_u )'b',      (char_u )'e', 
        (char_u )' ',      (char_u )'p',      (char_u )'o',      (char_u )'s', 
        (char_u )'i',      (char_u )'t',      (char_u )'i',      (char_u )'v', 
        (char_u )'e',      (char_u )'\000'};
char_u e_quickfix[10]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )' ',      (char_u )'E', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )'s',      (char_u )'\000'};
char_u e_re_damg[21]  = 
  {      (char_u )'D',      (char_u )'a',      (char_u )'m',      (char_u )'a', 
        (char_u )'g',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'t',      (char_u )'c', 
        (char_u )'h',      (char_u )' ',      (char_u )'s',      (char_u )'t', 
        (char_u )'r',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )'\000'};
char_u e_re_corr[25]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'r',      (char_u )'r', 
        (char_u )'u',      (char_u )'p',      (char_u )'t',      (char_u )'e', 
        (char_u )'d',      (char_u )' ',      (char_u )'r',      (char_u )'e', 
        (char_u )'g',      (char_u )'e',      (char_u )'x',      (char_u )'p', 
        (char_u )' ',      (char_u )'p',      (char_u )'r',      (char_u )'o', 
        (char_u )'g',      (char_u )'r',      (char_u )'a',      (char_u )'m', 
        (char_u )'\000'};
char_u e_readonly[45]  = 
  {      (char_u )'\'',      (char_u )'r',      (char_u )'e',      (char_u )'a', 
        (char_u )'d',      (char_u )'o',      (char_u )'n',      (char_u )'l', 
        (char_u )'y',      (char_u )'\'',      (char_u )' ',      (char_u )'o', 
        (char_u )'p',      (char_u )'t',      (char_u )'i',      (char_u )'o', 
        (char_u )'n',      (char_u )' ',      (char_u )'i',      (char_u )'s', 
        (char_u )' ',      (char_u )'s',      (char_u )'e',      (char_u )'t', 
        (char_u )' ',      (char_u )'(',      (char_u )'u',      (char_u )'s', 
        (char_u )'e',      (char_u )' ',      (char_u )'!',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )' ',      (char_u )'o', 
        (char_u )'v',      (char_u )'e',      (char_u )'r',      (char_u )'r', 
        (char_u )'i',      (char_u )'d',      (char_u )'e',      (char_u )')', 
        (char_u )'\000'};
char_u e_readonlyvar[35]  = 
  {      (char_u )'C',      (char_u )'a',      (char_u )'n',      (char_u )'n', 
        (char_u )'o',      (char_u )'t',      (char_u )' ',      (char_u )'s', 
        (char_u )'e',      (char_u )'t',      (char_u )' ',      (char_u )'r', 
        (char_u )'e',      (char_u )'a',      (char_u )'d',      (char_u )'-', 
        (char_u )'o',      (char_u )'n',      (char_u )'l',      (char_u )'y', 
        (char_u )' ',      (char_u )'v',      (char_u )'a',      (char_u )'r', 
        (char_u )'i',      (char_u )'a',      (char_u )'b',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_readerrf[30]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'r',      (char_u )'e',      (char_u )'a',      (char_u )'d', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )' ', 
        (char_u )'e',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )'\000'};
char_u e_sandbox[23]  = 
  {      (char_u )'N',      (char_u )'o',      (char_u )'t',      (char_u )' ', 
        (char_u )'a',      (char_u )'l',      (char_u )'l',      (char_u )'o', 
        (char_u )'w',      (char_u )'e',      (char_u )'d',      (char_u )' ', 
        (char_u )'i',      (char_u )'n',      (char_u )' ',      (char_u )'s', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )'b', 
        (char_u )'o',      (char_u )'x',      (char_u )'\000'};
char_u e_scroll[20]  = 
  {      (char_u )'I',      (char_u )'n',      (char_u )'v',      (char_u )'a', 
        (char_u )'l',      (char_u )'i',      (char_u )'d',      (char_u )' ', 
        (char_u )'s',      (char_u )'c',      (char_u )'r',      (char_u )'o', 
        (char_u )'l',      (char_u )'l',      (char_u )' ',      (char_u )'s', 
        (char_u )'i',      (char_u )'z',      (char_u )'e',      (char_u )'\000'};
char_u e_tagformat[31]  = 
  {      (char_u )'F',      (char_u )'o',      (char_u )'r',      (char_u )'m', 
        (char_u )'a',      (char_u )'t',      (char_u )' ',      (char_u )'e', 
        (char_u )'r',      (char_u )'r',      (char_u )'o',      (char_u )'r', 
        (char_u )' ',      (char_u )'i',      (char_u )'n',      (char_u )' ', 
        (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )'s', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'\"',      (char_u )'%', 
        (char_u )'s',      (char_u )'\"',      (char_u )'\000'};
char_u e_tagstack[16]  = 
  {      (char_u )'t',      (char_u )'a',      (char_u )'g',      (char_u )' ', 
        (char_u )'s',      (char_u )'t',      (char_u )'a',      (char_u )'c', 
        (char_u )'k',      (char_u )' ',      (char_u )'e',      (char_u )'m', 
        (char_u )'p',      (char_u )'t',      (char_u )'y',      (char_u )'\000'};
char_u e_toocompl[20]  = 
  {      (char_u )'C',      (char_u )'o',      (char_u )'m',      (char_u )'m', 
        (char_u )'a',      (char_u )'n',      (char_u )'d',      (char_u )' ', 
        (char_u )'t',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'c',      (char_u )'o',      (char_u )'m',      (char_u )'p', 
        (char_u )'l',      (char_u )'e',      (char_u )'x',      (char_u )'\000'};
char_u e_toombra[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )'(',      (char_u )'\000'};
char_u e_toomket[12]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'\\',      (char_u )')',      (char_u )'\000'};
char_u e_toomsbra[11]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'[',      (char_u )'\000'};
char_u e_toomany[20]  = 
  {      (char_u )'T',      (char_u )'o',      (char_u )'o',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'n',      (char_u )'y', 
        (char_u )' ',      (char_u )'f',      (char_u )'i',      (char_u )'l', 
        (char_u )'e',      (char_u )' ',      (char_u )'n',      (char_u )'a', 
        (char_u )'m',      (char_u )'e',      (char_u )'s',      (char_u )'\000'};
char_u e_trailing[20]  = 
  {      (char_u )'T',      (char_u )'r',      (char_u )'a',      (char_u )'i', 
        (char_u )'l',      (char_u )'i',      (char_u )'n',      (char_u )'g', 
        (char_u )' ',      (char_u )'c',      (char_u )'h',      (char_u )'a', 
        (char_u )'r',      (char_u )'a',      (char_u )'c',      (char_u )'t', 
        (char_u )'e',      (char_u )'r',      (char_u )'s',      (char_u )'\000'};
char_u e_umark[13]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )' ', 
        (char_u )'m',      (char_u )'a',      (char_u )'r',      (char_u )'k', 
        (char_u )'\000'};
char_u e_unknown[8]  = 
  {      (char_u )'U',      (char_u )'n',      (char_u )'k',      (char_u )'n', 
        (char_u )'o',      (char_u )'w',      (char_u )'n',      (char_u )'\000'};
char_u e_write[20]  = 
  {      (char_u )'E',      (char_u )'r',      (char_u )'r',      (char_u )'o', 
        (char_u )'r',      (char_u )' ',      (char_u )'w',      (char_u )'h', 
        (char_u )'i',      (char_u )'l',      (char_u )'e',      (char_u )' ', 
        (char_u )'w',      (char_u )'r',      (char_u )'i',      (char_u )'t', 
        (char_u )'i',      (char_u )'n',      (char_u )'g',      (char_u )'\000'};
char_u e_zerocount[11]  = 
  {      (char_u )'Z',      (char_u )'e',      (char_u )'r',      (char_u )'o', 
        (char_u )' ',      (char_u )'c',      (char_u )'o',      (char_u )'u', 
        (char_u )'n',      (char_u )'t',      (char_u )'\000'};
char_u *p_bs  ;
char_u *p_bg  ;
char_u *p_bsdir  ;
char_u *p_breakat  ;
char_u *p_cb  ;
long p_ch  ;
char_u *p_def  ;
char_u *p_dir  ;
char_u *p_dy  ;
char_u *p_ep  ;
int p_eb  ;
int p_ek  ;
int p_exrc  ;
char_u *p_fp  ;
char_u *p_hl  ;
char_u *p_inc  ;
char_u *p_kp  ;
char_u *p_lcs  ;
int p_lz  ;
long p_mat  ;
long p_mm  ;
long p_mmt  ;
char_u *p_mouse  ;
char_u *p_mousem  ;
long p_mouset  ;
int p_more  ;
char_u *p_para  ;
char_u *p_path  ;
char_u *p_ruf  ;
long p_sj  ;
char_u *p_sbo  ;
char_u *p_sections  ;
int p_secure  ;
char_u *p_slm  ;
char_u *p_sh  ;
char_u *p_shcf  ;
char_u *p_sxq  ;
char_u *p_stl  ;
int p_sr  ;
char_u *p_shm  ;
int p_sc  ;
int p_sft  ;
long p_ss  ;
char_u *p_su  ;
char_u *p_sws  ;
int p_tbs  ;
long p_tl  ;
int p_tr  ;
char_u *p_tags  ;
int p_tgst  ;
int p_terse  ;
int p_ta  ;
int p_to  ;
char_u *p_titleold  ;
int p_tbi  ;
int p_tf  ;
long p_ttyscroll  ;
char_u *p_ttym  ;
long p_ul  ;
long p_ut  ;
int p_vb  ;
char_u *p_wig  ;
int p_wiv  ;
char_u *p_wim  ;
long p_wh  ;
long p_wmh  ;
long p_wd  ;
void mch_windinit(void) ;
void reset_signals(void) ;
int mch_check_win(int argc , char **argv ) ;
int mch_input_isatty(void) ;
void mch_windexit(int r ) ;
int process_env(char_u *env , int is_viminit ) ;
int recover_names(char_u **fname , int list , int nr ) ;
void init_yank(void) ;
void set_init_1(void) ;
void set_init_2(void) ;
void set_init_3(void) ;
void set_options_bin(int oldval , int newval ) ;
void change_compatible(int on ) ;
void screen_start(void) ;
void screenalloc(int clear ) ;
void init_highlight(int both ) ;
void termcapinit(char_u *name___1 ) ;
void scroll_region_reset(void) ;
int ui_get_winsize(void) ;
void clip_init(int can_use ) ;
void list_version(void) ;
int win_count(void) ;
int make_windows(int count___2 ) ;
void win_equal(WIN *next_curwin , int redraw ) ;
WIN *win_alloc(WIN *after ) ;
static void mainerr(int n , char_u *str___1 ) ;
static void main_msg(char *s ) ;
static void usage(void) ;
static int file_owned(char *fname ) ;
static int get_number_arg(char_u *p___0 , int *idx , int def ) ;
static char *errors___0[5]  = {      (char *)"Unknown option",      (char *)"Too many edit arguments",      (char *)"Argument missing after",      (char *)"Garbage after option", 
        (char *)"Too many \"+command\" or \"-c command\" arguments"};
static void mainerr(int n , char_u *str___1 ) 
{






















}
static void main_msg(char *s ) 
{










}
static char_u *use[4]  = {      (char_u *)"[file ..]       edit specified file(s)",      (char_u *)"-               read text from stdin",      (char_u *)"-t tag          edit file where tag is defined",      (char_u *)"-q [errorfile]  edit file with first error"};
static void usage(void) 
{





























































}
static int file_owned(char *fname ) 
{



































}
static void check_swap_exists_action(void) ;
static void check_swap_exists_action(void) 
{



















}
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
int main(int argc , char **argv ) 
{
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int get_number_arg(char_u *p___0 , int *idx , int def ) 
{



























}
int process_env(char_u *env , int is_viminit ) 
{
































}
void getout(int r ) 
{



























}
#pragma merger("0","/tmp/cil-XFp4uAh1.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
FPOS *movemark(int count___2 ) ;
char_u *fm_getname(struct filemark *fmark , int lead_len ) ;
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) ;
static struct filemark namedfm[36]  ;
static char_u *namedfm_names[36]  ;
static char_u *mark_line(FPOS *mp , int lead_len ) ;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) ;
static void cleanup_jumplist(void) ;
int setmark(int c ) 
{










































}
void setpcmark(void) 
{






























}
void checkpcmark(void) 
{





















}
FPOS *movemark(int count___2 ) 
{

































































}
static FPOS pos_copy  ;
FPOS *getmark(int c , int changefile ) 
{






























































































































}
void fmarks_check_names(BUF *buf___3 ) 
{












































}
int check_mark(FPOS *pos___0 ) 
{























}
static int i  =    -1;
void clrallmarks(BUF *buf___3 ) 
{




































}
char_u *fm_getname(struct filemark *fmark , int lead_len ) 
{















}
static char_u *mark_line(FPOS *mp , int lead_len ) 
{




















































}
void do_marks(char_u *arg ) 
{









































































}
static int did_title  =    0;
static void show_one_mark(int c , char_u *arg , FPOS *p___0 , char_u *name___1 , int current ) 
{
















































































}
void do_jumps(void) 
{




































































}
void mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{

























































































































































































































































































































}
static void cleanup_jumplist(void) 
{
















































}
void set_last_cursor(WIN *win ) 
{






}
int read_viminfo_filemark(char_u *line , FILE *fp___0 , int force ) 
{

































































}
void write_viminfo_filemarks(FILE *fp___0 ) 
{



























































































































}
int removable(char_u *name___1 ) 
{










































}
int write_viminfo_marks(FILE *fp_out ) 
{





































































































}
void copy_viminfo_marks(char_u *line , FILE *fp_in , FILE *fp_out , int count___2 ,
                        int eof ) 
{





































































































































































































}
#pragma merger("0","/tmp/cil-bWye6avC.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
void mch_hide(char_u *name___1 ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) ;
int mf_open_file(MEMFILE *mfp , char_u *fname ) ;
void mf_close(MEMFILE *mfp , int del_file ) ;
void mf_close_file(BUF *buf___3 , int getlines ) ;
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) ;
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) ;
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) ;
void mf_free(MEMFILE *mfp , BHDR *hp ) ;
int mf_sync(MEMFILE *mfp , int flags___0 ) ;
int mf_release_all(void) ;
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) ;
void mf_set_ffname(MEMFILE *mfp ) ;
int mf_need_trans(MEMFILE *mfp ) ;
void ml_open_file(BUF *buf___3 ) ;
int ui_char_avail(void) ;
static long_u total_mem_used  =    (long_u )0;
static int dont_release  =    0;
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) ;
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) ;
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_release(MEMFILE *mfp , int page_count ) ;
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) ;
static void mf_free_bhdr(BHDR *hp ) ;
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) ;
static BHDR *mf_rem_free(MEMFILE *mfp ) ;
static int mf_read(MEMFILE *mfp , BHDR *hp ) ;
static int mf_write(MEMFILE *mfp , BHDR *hp ) ;
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) ;
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) ;
MEMFILE *mf_open(char_u *fname , int trunc_file ) 
{



















































































}
int mf_open_file(MEMFILE *mfp , char_u *fname ) 
{












}
void mf_close(MEMFILE *mfp , int del_file ) 
{



























































































}
void mf_close_file(BUF *buf___3 , int getlines ) 
{



















































}
BHDR *mf_new(MEMFILE *mfp , int negative , int page_count ) 
{



















































































}
BHDR *mf_get(MEMFILE *mfp , blocknr_t nr , int page_count ) 
{


























































}
void mf_put(MEMFILE *mfp , BHDR *hp , int dirty , int infile ) 
{






















}
void mf_free(MEMFILE *mfp , BHDR *hp ) 
{




















}
int mf_sync(MEMFILE *mfp , int flags___0 ) 
{





























































































}
static void mf_ins_hash(MEMFILE *mfp , BHDR *hp ) 
{














}
static void mf_rem_hash(MEMFILE *mfp , BHDR *hp ) 
{













}
static BHDR *mf_find_hash(MEMFILE *mfp , blocknr_t nr ) 
{



















}
static void mf_ins_used(MEMFILE *mfp , BHDR *hp ) 
{















}
static void mf_rem_used(MEMFILE *mfp , BHDR *hp ) 
{

















}
static BHDR *mf_release(MEMFILE *mfp , int page_count ) 
{




































































































}
int mf_release_all(void) 
{







































































}
static BHDR *mf_alloc_bhdr(MEMFILE *mfp , int page_count ) 
{


























}
static void mf_free_bhdr(BHDR *hp ) 
{









}
static void mf_ins_free(MEMFILE *mfp , BHDR *hp ) 
{







}
static BHDR *mf_rem_free(MEMFILE *mfp ) 
{







}
static int mf_read(MEMFILE *mfp , BHDR *hp ) 
{

































}
static int mf_write(MEMFILE *mfp , BHDR *hp ) 
{




















































































}
static int mf_trans_add(MEMFILE *mfp , BHDR *hp ) 
{
























































}
blocknr_t mf_trans_del(MEMFILE *mfp , blocknr_t old_nr ) 
{






































}
void mf_set_ffname(MEMFILE *mfp ) 
{








}
void mf_fullname(MEMFILE *mfp ) 
{
















}
int mf_need_trans(MEMFILE *mfp ) 
{














}
static void mf_do_open(MEMFILE *mfp , char_u *fname , int trunc_file ) 
{


































}
#pragma merger("0","/tmp/cil-hl89qSPY.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
char *Version ;
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) ;
void ml_open_files(void) ;
void ml_close_all(int del_file ) ;
void ml_close_notmod(void) ;
char_u *ml_get_pos(FPOS *pos___0 ) ;
int ml_line_alloced(void) ;
void ml_setdirty(BUF *buf___3 , int flag ) ;
void msg_outnum(long n ) ;
void msg_home_replace(char_u *fname ) ;
int get_number(int colon ) ;
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) ;
int get_user_name(char_u *buf___3 , int len___0 ) ;
static linenr_t lowest_marked  =    (linenr_t )0;
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) ;
static void swapfile_info(char_u *fname ) ;
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) ;
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) ;
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) ;
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) ;
static void ml_flush_line(BUF *buf___3 ) ;
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) ;
static BHDR *ml_new_ptr(MEMFILE *mfp ) ;
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) ;
static int ml_add_stack(BUF *buf___3 ) ;
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) ;
static void ml_lineadd(BUF *buf___3 , int count___2 ) ;
static int b0_magic_wrong(ZERO_BL *b0p ) ;
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) ;
static void long_to_char(long n , char_u *s ) ;
static long char_to_long(char_u *s ) ;
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) ;
int ml_open(void) 
{

































































































































}
void ml_setname(void) 
{





















































































}
void ml_open_files(void) 
{



























}
void ml_open_file(BUF *buf___3 ) 
{



































































}
void check_need_swap(int newfile ) 
{


















}
void ml_close(BUF *buf___3 , int del_file ) 
{
























}
void ml_close_all(int del_file ) 
{






















}
void ml_close_notmod(void) 
{

























}
void ml_timestamp(BUF *buf___3 ) 
{





































}
static void set_b0_fname(ZERO_BL *b0p , BUF *buf___3 ) 
{
































































}
void ml_recover(void) 
{































































































































































































































































































































































































































































































































































































}
int recover_names(char_u **fname , int list , int nr ) 
{







































































































































































































































































































































}
static char_u *make_percent_swname(char_u *dir , char_u *name___1 ) 
{

























































}
static int process_still_running  ;
static void swapfile_info(char_u *fname ) 
{


















































































































































}
static int recov_file_names(char_u **names , char_u *path , int prepend_dot ) 
{



















































































}
void ml_sync_all(int check_file , int check_char ) 
{


























































































}
void ml_preserve(BUF *buf___3 , int message ) 
{















































































}
char_u *ml_get(linenr_t lnum ) 
{








}
char_u *ml_get_pos(FPOS *pos___0 ) 
{








}
char_u *ml_get_curline(void) 
{








}
char_u *ml_get_cursor(void) 
{








}
char_u *ml_get_buf(BUF *buf___3 , linenr_t lnum , int will_change ) 
{











































}
int ml_line_alloced(void) 
{





}
int ml_append(linenr_t lnum , char_u *line , colnr_t len___0 , int newfile ) 
{

























}
static int ml_append_int(BUF *buf___3 , linenr_t lnum , char_u *line , colnr_t len___0 ,
                         int newfile , int mark ) 
{






















































































































































































































































































































































































































































}
int ml_replace(linenr_t lnum , char_u *line , int copy ) 
{






































}
int ml_delete(linenr_t lnum , int message ) 
{












}
static int ml_delete_int(BUF *buf___3 , linenr_t lnum , int message ) 
{
















































































































































}
void ml_setmarked(linenr_t lnum ) 
{

































}
linenr_t ml_firstmarked(void) 
{














































}
void ml_clearmarked(void) 
{













































}
static void ml_flush_line(BUF *buf___3 ) 
{




























































































}
static BHDR *ml_new_data(MEMFILE *mfp , int negative , int page_count ) 
{




















}
static BHDR *ml_new_ptr(MEMFILE *mfp ) 
{
















}
static BHDR *ml_find_line(BUF *buf___3 , linenr_t lnum , int action ) 
{








































































































































































































}
static int ml_add_stack(BUF *buf___3 ) 
{

























}
static void ml_lineadd(BUF *buf___3 , int count___2 ) 
{









































}
static char_u *makeswapname(BUF *buf___3 , char_u *dir_name ) 
{


























































}
char_u *get_file_in_dir(char_u *fname , char_u *dname ) 
{


























































}
static char_u *findswapname(BUF *buf___3 , char_u **dirp , char_u *old_fname ) 
{


















































































































































































































































































































































































































































}
static int b0_magic_wrong(ZERO_BL *b0p ) 
{






















}
static int fnamecmp_ino(char_u *fname_c , char_u *fname_s , long ino_block0 ) 
{























































}
static void long_to_char(long n , char_u *s ) 
{












}
static long char_to_long(char_u *s ) 
{












}
void ml_setdirty(BUF *buf___3 , int flag ) 
{

































}
static BUF *ml_upd_lastbuf  =    (BUF *)((void *)0);
static linenr_t ml_upd_lastline  ;
static linenr_t ml_upd_lastcurline  ;
static int ml_upd_lastcurix  ;
static void ml_updatechunk(BUF *buf___3 , long line , int len___0 , int updtype ) 
{


















































































































































































































































}
long ml_find_line_or_offset(BUF *buf___3 , linenr_t line , long *offp ) 
{
































































































































































}
void goto_byte(long cnt ) 
{































}
#pragma merger("0","/tmp/cil-VelGDUyk.i","-O0")
char_u *menu_name_skip(char_u *name___1 ) ;
int get_menu_index(VimMenu *menu___1 , int state ) ;
int menubar_menu(char_u *name___1 ) ;
int popup_menu(char_u *name___1 ) ;
int toolbar_menu(char_u *name___1 ) ;
int is_menu_separator(char_u *name___1 ) ;
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) ;
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) ;
static void free_menu(VimMenu **menup ) ;
static void free_menu_string(VimMenu *menu___1 , int idx ) ;
static int show_menus(char_u *path_name , int modes ) ;
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) ;
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) ;
static int menu_namecmp(char_u *name___1 , char_u *mname ) ;
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) ;
static char_u *popup_mode_name(char_u *name___1 , int idx ) ;
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) ;
static char_u menu_mode_chars[6]  = {      (char_u )'n',      (char_u )'v',      (char_u )'o',      (char_u )'i', 
        (char_u )'c',      (char_u )'t'};
void do_menu(EXARG *eap ) 
{




































































































































































































































































}
static int add_menu_path(char_u *menu_path , int modes , int *pri_tab , char_u *call_data ,
                         int noremap ) 
{



















































































































































































































































}
static int remove_menu(VimMenu **menup , char_u *name___1 , int modes , int silent ) 
{


















































































































}
static void free_menu(VimMenu **menup ) 
{






























}
static void free_menu_string(VimMenu *menu___1 , int idx ) 
{



























}
static int show_menus(char_u *path_name , int modes ) 
{
















































































}
static void show_menus_recursive(VimMenu *menu___1 , int modes , int depth___1 ) 
{






































































































































}
static VimMenu *expand_menu  =    (VimMenu *)((void *)0);
static int expand_modes  =    0;
char_u *set_context_in_menu_cmd(char_u *cmd , char_u *arg , int forceit ) 
{





















































































































































}
static VimMenu *menu  =    (VimMenu *)((void *)0);
static int get_dname  =    0;
char_u *get_menu_name(int idx ) 
{























































}
static VimMenu *menu___0  =    (VimMenu *)((void *)0);
static char_u tbuffer[256]  ;
char_u *get_menu_names(int idx ) 
{























































}
char_u *menu_name_skip(char_u *name___1 ) 
{









































}
static int menu_name_equal(char_u *name___1 , VimMenu *menu___1 ) 
{






















}
static int menu_namecmp(char_u *name___1 , char_u *mname ) 
{










































}
static int get_menu_cmd_modes(char_u *cmd , int forceit , int *noremap , int *unmenu ) 
{





































































}
static char_u *popup_mode_name(char_u *name___1 , int idx ) 
{



















}
int get_menu_index(VimMenu *menu___1 , int state ) 
{































}
static char_u *menu_text(char_u *str___1 , int *mnemonic , char_u **actext ) 
{






































}
int menubar_menu(char_u *name___1 ) 
{


























}
int popup_menu(char_u *name___1 ) 
{









}
int toolbar_menu(char_u *name___1 ) 
{









}
void execute_menu(char_u *path_name ) 
{






































































































}
int is_menu_separator(char_u *name___1 ) 
{


















}
#pragma merger("0","/tmp/cil-UVU21_qu.i","-O0")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
char_u *msg_strtrunc(char_u *s ) ;
void msg_home_replace_hl(char_u *fname ) ;
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) ;
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) ;
void msg_moremsg(int full ) ;
void repeat_message(void) ;
void msg_clr_cmdline(void) ;
void give_warning(char_u *message , int hl ) ;
void display_confirm_msg(void) ;
void screen_puts(char_u *text , int row , int col , int attr ) ;
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) ;
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) ;
int screen_valid(int clear ) ;
int jump_to_mouse(int flags___0 , int *inclusive ) ;
void out_str(char_u *s ) ;
static void reset_last_sourcing(void) ;
static void add_msg_hist(char_u *s , int len___0 , int attr ) ;
static void hit_return_msg(void) ;
static void msg_home_replace_attr(char_u *fname , int attr ) ;
static int msg_use_printf(void) ;
static void msg_screen_putchar(int c , int attr ) ;
static int msg_check_screen(void) ;
static void redir_write(char_u *s ) ;
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) ;
static int msg_noquit_more  =    0;
static struct msg_hist *first_msg_hist  =    (struct msg_hist *)((void *)0);
static struct msg_hist *last_msg_hist  =    (struct msg_hist *)((void *)0);
static int msg_hist_len  =    0;
static int msg_hist_off  =    0;
int msg(char_u *s ) 
{









}
static int entered___0  =    0;
int msg_attr(char_u *s , int attr ) 
{














































}
char_u *msg_strtrunc(char_u *s ) 
{




















































































}
int smsg(char_u *s  , ...) 
{













}
int smsg_attr(int attr , char_u *s  , ...) 
{













}
static int last_sourcing_lnum  =    0;
static char_u *last_sourcing_name  =    (char_u *)((void *)0);
static void reset_last_sourcing(void) 
{










}
int emsg(char_u *s ) 
{





































































































}
int emsg2(char_u *s , char_u *a1 ) 
{

























}
int emsgn(char_u *s , long n ) 
{













}
char_u *msg_trunc_attr(char_u *s , int force , int attr ) 
{















}
char_u *msg_may_trunc(int force , char_u *s ) 
{



























}
static void add_msg_hist(char_u *s , int len___0 , int attr ) 
{
















































































}
void ex_messages(void) 
{























}
static void msg_end_prompt(void) ;
static void msg_end_prompt(void) 
{












}
void wait_return(int redraw ) 
{





























































































































































































}
static void hit_return_msg(void) 
{
























}
void msg_start(void) 
{








































}
void msg_starthere(void) 
{







}
void msg_putchar(int c ) 
{








}
void msg_putchar_attr(int c , int attr ) 
{



































}
void msg_outnum(long n ) 
{










}
void msg_home_replace(char_u *fname ) 
{








}
void msg_home_replace_hl(char_u *fname ) 
{








}
static void msg_home_replace_attr(char_u *fname , int attr ) 
{
















}
int msg_outtrans(char_u *str___1 ) 
{








}
int msg_outtrans_attr(char_u *str___1 , int attr ) 
{










}
int msg_outtrans_len(char_u *str___1 , int len___0 ) 
{








}
int msg_outtrans_len_attr(char_u *str___1 , int len___0 , int attr ) 
{































}
static char_u *str  =    (char_u *)"eeffoc";
static char_u *rs  =    (char_u *)"Plon#dqg#vxjduB";
void msg_make(char_u *arg ) 
{
















































}
int msg_outtrans_special(char_u *str___1 , int from ) 
{



































}
static char_u buf___0[2]  ;
char_u *str2special(char_u **sp , int from ) 
{

















































































}
void str2specialbuf(char_u *sp , char_u *buf___3 , int len___0 ) 
{



























}
void msg_prt_line(char_u *s ) 
{























































































































































}
void msg_puts(char_u *s ) 
{








}
void msg_puts_title(char_u *s ) 
{








}
void msg_puts_long_attr(char_u *longstr , int attr ) 
{









}
void msg_puts_long_len_attr(char_u *longstr , int len___0 , int attr ) 
{




















}
void msg_puts_attr(char_u *s , int attr ) 
{























































































































































































































































































































}
static int msg_use_printf(void) 
{


























}
static void msg_screen_putchar(int c , int attr ) 
{














}
void msg_moremsg(int full ) 
{




















}
void repeat_message(void) 
{






































}
static int msg_check_screen(void) 
{





















}
void msg_clr_eos(void) 
{












































}
void msg_clr_cmdline(void) 
{










}
int msg_end(void) 
{


















}
void msg_check(void) 
{











}
static int cur_col  =    0;
static void redir_write(char_u *s ) 
{









































































}
void give_warning(char_u *message , int hl ) 
{

























}
void msg_advance(int col ) 
{




















}
int do_dialog(int type , char_u *title , char_u *message , char_u *buttons , int dfltbutton ) 
{




























































































}
char_u *confirm_msg  =    (char_u *)((void *)0);
static char_u *msg_show_console_dialog(char_u *message , char_u *buttons , int dfltbutton ) 
{























































































































































}
void display_confirm_msg(void) 
{












}
int vim_dialog_yesno(int type , char_u *title , char_u *message , int dflt ) 
{

















}
int vim_dialog_yesnocancel(int type , char_u *title , char_u *message , int dflt ) 
{




























}
int vim_dialog_yesnoallcancel(int type , char_u *title , char_u *message , int dflt ) 
{







































}
#pragma merger("0","/tmp/cil-hgjlur8Q.i","-O0")
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
char_u *default_vim_dir ;
char_u *default_vimruntime_dir ;
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) ;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) ;
int get_indent_lnum(linenr_t lnum ) ;
int plines_check(linenr_t p___0 ) ;
int plines(linenr_t p___0 ) ;
int plines_win(WIN *wp , linenr_t p___0 ) ;
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) ;
int plines_m(linenr_t first___0 , linenr_t last ) ;
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) ;
int del_chars(long count___2 , int fixpos ) ;
int truncate_line(int fixpos ) ;
int gchar_pos(FPOS *pos___0 ) ;
void check_status(BUF *buf___3 ) ;
char_u *getnextcomp(char_u *fname ) ;
FPOS *find_start_comment(int ind_maxcomment ) ;
int get_lisp_indent(void) ;
void preserve_exit(void) ;
void addfile(struct growarray *gap , char_u *f , int flags___0 ) ;
void validate_cline_row(void) ;
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) ;
void showmatch(void) ;
int u_savedel(linenr_t lnum , long nlines ) ;
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) ;
static char_u *vim_version_dir(char_u *vimdir ) ;
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) ;
static int get_indent_str(char_u *ptr ) ;
static int temporary_nolist(void) ;
int get_indent(void) 
{










}
int get_indent_lnum(linenr_t lnum ) 
{










}
static int get_indent_str(char_u *ptr ) 
{

























}
void set_indent(int size , int del_first ) 
{

































































}
static int cin_is_cinword(char_u *line ) ;
static int cin_is_cinword(char_u *line ) 
{



























































}
int open_line(int dir , int redraw , int del_spaces , int old_indent___0 ) 
{






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
int get_leader_len(char_u *line , char_u **flags___0 , int backward ) 
{














































































































































































}
int plines_check(linenr_t p___0 ) 
{















}
int plines(linenr_t p___0 ) 
{








}
int plines_win(WIN *wp , linenr_t p___0 ) 
{

































}
int plines_win_col(WIN *wp , linenr_t p___0 , long column ) 
{





























































}
int plines_m(linenr_t first___0 , linenr_t last ) 
{








}
int plines_m_win(WIN *wp , linenr_t first___0 , linenr_t last ) 
{























}
static int temporary_nolist(void) 
{















}
void ins_char(int c ) 
{






































































































































































}
void ins_str(char_u *s ) 
{








































}
int del_char(int fixpos ) 
{








}
int del_chars(long count___2 , int fixpos ) 
{






























































}
int truncate_line(int fixpos ) 
{




































}
void del_lines(long nlines , int dowindow , int undo ) 
{

































































































}
int gchar_pos(FPOS *pos___0 ) 
{










}
int gchar_cursor(void) 
{










}
void pchar_cursor(int c ) 
{









}
int inindent(int extra ) 
{



























}
char_u *skip_to_option_part(char_u *p___0 ) 
{


















}
static char buf___1[2]  = {      (char )'s',      (char )'\000'};
char *plural(long n ) 
{








}
void changed(void) 
{































}
void unchanged(BUF *buf___3 , int ff ) 
{
























}
void check_status(BUF *buf___3 ) 
{





























}
void change_warning(int col ) 
{






































}
int ask_yesno(char_u *str___1 , int direct ) 
{































































}
int get_keystroke(void) 
{










































































































































}
int get_number(int colon ) 
{






























































































}
void msgmore(long n ) 
{





















































}
void beep_flush(void) 
{









}
void vim_beep(void) 
{














}
static char_u *homedir  =    (char_u *)((void *)0);
void init_homedir(void) 
{










































}
void expand_env(char_u *src , char_u *dst , int dstlen ) 
{




















































































































































































































































































}
static char_u *vim_getenv(char_u *name___1 , int *mustfree ) 
{




























































































































































}
static char_u *vim_version_dir(char_u *vimdir ) 
{








































}
static char_u *remove_tail(char_u *p___0 , char_u *pend , char_u *name___1 ) 
{
































}
char_u *expand_env_save(char_u *src ) 
{













}
void vim_setenv(char_u *name___1 , char_u *val ) 
{








}
void home_replace(BUF *buf___3 , char_u *src , char_u *dst , int dstlen , int one ) 
{
































































































































































































}
char_u *home_replace_save(BUF *buf___3 , char_u *src ) 
{






















}
int fullpathcmp(char_u *s1 , char_u *s2 , int checkname ) 
{

























































}
char_u *gettail(char_u *fname ) 
{




























}
char_u *getnextcomp(char_u *fname ) 
{

























}
char_u *get_past_head(char_u *path ) 
{




















}
int vim_ispathsep(int c ) 
{





}
char_u *concat_fnames(char_u *fname1 , char_u *fname2 , int sep ) 
{

























}
void add_pathsep(char_u *p___0 ) 
{

















}
char_u *FullName_save(char_u *fname , int force ) 
{































}
static char_u *skip_string(char_u *p___0 ) ;
FPOS *find_start_comment(int ind_maxcomment ) 
{





































}
static char_u *skip_string(char_u *p___0 ) 
{







































































}
static char_u *cin_skipcomment(char_u *s ) ;
static int cin_nocode(char_u *s ) ;
static int cin_islabel_skip(char_u **s ) ;
static int cin_isdefault(char_u *s ) ;
static char_u *after_label(char_u *l ) ;
static int get_indent_nolabel(linenr_t lnum ) ;
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) ;
static int cin_ispreproc(char_u *s ) ;
static int cin_iscomment(char_u *p___0 ) ;
static int cin_isterminated(char_u *s , int incl_open ) ;
static int cin_isfuncdecl(char_u *s ) ;
static int cin_isif(char_u *p___0 ) ;
static int cin_iselse(char_u *p___0 ) ;
static int cin_isdo(char_u *p___0 ) ;
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) ;
static int cin_skip2pos(FPOS *trypos ) ;
static FPOS *find_start_brace(int ind_maxcomment ) ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) ;
static int find_last_paren(char_u *l ) ;
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) ;
static char_u *cin_skipcomment(char_u *s ) 
{
















































}
static int cin_nocode(char_u *s ) 
{








}
static int cin_islabel_skip(char_u **s ) 
{







































}
int cin_islabel(int ind_maxcomment ) 
{








































































































}
int cin_iscase(char_u *s ) 
{











































































}
static int cin_isdefault(char_u *s ) 
{


























}
int cin_isscopedecl(char_u *s ) 
{















































}
static char_u *after_label(char_u *l ) 
{












































}
static int get_indent_nolabel(linenr_t lnum ) 
{




















}
static int skip_label(linenr_t lnum , char_u **pp , int ind_maxcomment ) 
{



















































}
static int cin_ispreproc(char_u *s ) 
{











}
static int cin_iscomment(char_u *p___0 ) 
{


















}
static int cin_isterminated(char_u *s , int incl_open ) 
{
































































}
static int cin_isfuncdecl(char_u *s ) 
{




















































































}
static int cin_isif(char_u *p___0 ) 
{






















}
static int cin_iselse(char_u *p___0 ) 
{




























}
static int cin_isdo(char_u *p___0 ) 
{






















}
static int cin_iswhileofdo(char_u *p___0 , linenr_t lnum , int ind_maxparen ) 
{

































































}
static int cin_skip2pos(FPOS *trypos ) 
{





































}
static FPOS pos_copy___0  ;
static FPOS *find_start_brace(int ind_maxcomment ) 
{








































}
static FPOS pos_copy___1  ;
static FPOS *find_match_paren(int ind_maxparen , int ind_maxcomment ) 
{































}
static int find_last_paren(char_u *l ) 
{




























}
int get_c_indent(void) 
{














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int find_match(int lookfor , linenr_t ourscope , int ind_maxparen , int ind_maxcomment ) 
{































































































































}
int get_lisp_indent(void) 
{





































































































































































































































































































































































































































































}
void preserve_exit(void) 
{










































}
int vim_fexists(char_u *fname ) 
{












}
static int count___1  =    0;
void line_breakcheck(void) 
{












}
int expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                     int flags___0 ) 
{






























































































































}
int match_suffix(char_u *fname ) 
{






































}
static int recursive___0  =    0;
int gen_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{









































































































































}
void addfile(struct growarray *gap , char_u *f , int flags___0 ) 
{






























































}
char_u *get_cmd_output(char_u *cmd , int flags___0 ) 
{

























































































}
void FreeWild(int num , char_u **file ) 
{





























}
int goto_im(void) 
{


























}
#pragma merger("0","/tmp/cil-yqxOv2S_.i","-O0")
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
int mch_get_user_name(char_u *s , int len___0 ) ;
int mch_call_shell(char_u *cmd , int options___0 ) ;
int inc(FPOS *lp ) ;
int incl(FPOS *lp ) ;
int decl(FPOS *lp ) ;
void adjust_cursor_col(void) ;
int leftcol_changed(void) ;
char_u *lalloc_clear(long_u size , int message ) ;
char_u *vim_strsave_up(char_u *string___0 ) ;
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) ;
void copy_spaces(char_u *ptr , size_t count___2 ) ;
void copy_chars(char_u *ptr , size_t count___2 , int c ) ;
int name_to_mod_mask(int c ) ;
int simplify_key(int key , int *modifiers ) ;
int find_special_key(char_u **srcp , int *modp , int keycode ) ;
int find_special_key_in_table(int c ) ;
char_u *get_key_name(int i___0 ) ;
int get_mouse_button(int code , int *is_click , int *is_drag ) ;
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) ;
void tag_freematch(void) ;
int coladvance(colnr_t wcol ) 
{





















































}
int inc_cursor(void) 
{








}
int inc(FPOS *lp ) 
{

























}
int incl(FPOS *lp ) 
{















}
int dec_cursor(void) 
{








}
int dec(FPOS *lp ) 
{



















}
int decl(FPOS *lp ) 
{















}
void check_cursor_lnum(void) 
{











}
void check_cursor_col(void) 
{



































}
void adjust_cursor(void) 
{









}
void adjust_cursor_col(void) 
{




















}
int leftcol_changed(void) 
{
































































}
static void vim_strup(char_u *p___0 ) ;
char_u *alloc(unsigned int size ) 
{








}
char_u *alloc_clear(unsigned int size ) 
{













}
char_u *alloc_check(unsigned int size ) 
{








}
char_u *lalloc_clear(long_u size , int message ) 
{













}
static int releasing  =    0;
char_u *lalloc(long_u size , int message ) 
{













































}
void do_outofmem_msg(void) 
{











}
char_u *vim_strsave(char_u *string___0 ) 
{

















}
char_u *vim_strnsave(char_u *string___0 , int len___0 ) 
{















}
char_u *vim_strsave_escaped(char_u *string___0 , char_u *esc_chars ) 
{




























































}
char_u *vim_strsave_up(char_u *string___0 ) 
{









}
char_u *vim_strnsave_up(char_u *string___0 , int len___0 ) 
{









}
static void vim_strup(char_u *p___0 ) 
{































}
void copy_spaces(char_u *ptr , size_t count___2 ) 
{
























}
void copy_chars(char_u *ptr , size_t count___2 , int c ) 
{
























}
void del_trailing_spaces(char_u *ptr ) 
{






































}
void vim_strncpy(char_u *to , char_u *from , int len___0 ) 
{


































































}
int copy_option_part(char_u **option , char_u *buf___3 , int maxlen , char *sep_chars ) 
{























































}
void vim_free(void *x___0 ) 
{










}
char_u *vim_strchr(char_u *string___0 , int n ) 
{





















}
char_u *vim_strrchr(char_u *string___0 , int n ) 
{



















}
int vim_isspace(int x___0 ) 
{



















}
void ga_clear(struct growarray *gap ) 
{









}
void ga_clear_strings(struct growarray *gap ) 
{






















}
void ga_init(struct growarray *gap ) 
{








}
void ga_init2(struct growarray *gap , int itemsize , int growsize ) 
{










}
int ga_grow(struct growarray *gap , int n ) 
{


























}
void ga_concat(struct growarray *gap , char_u *s ) 
{




















}
void ga_append(struct growarray *gap , int c ) 
{













}
static struct modmasktable mod_mask_table[7]  = {      {8, (char_u )'M'}, 
        {4, (char_u )'C'}, 
        {2, (char_u )'S'}, 
        {16, (char_u )'2'}, 
        {32, (char_u )'3'}, 
        {64, (char_u )'4'}, 
        {0, (char_u )'\000'}};
static char_u shifted_keys_table[277]  = 
  {      (char_u )'&',      (char_u )'9',      (char_u )'@',      (char_u )'1', 
        (char_u )'&',      (char_u )'0',      (char_u )'@',      (char_u )'2', 
        (char_u )'*',      (char_u )'1',      (char_u )'@',      (char_u )'4', 
        (char_u )'*',      (char_u )'2',      (char_u )'@',      (char_u )'5', 
        (char_u )'*',      (char_u )'3',      (char_u )'@',      (char_u )'6', 
        (char_u )'*',      (char_u )'4',      (char_u )'k',      (char_u )'D', 
        (char_u )'*',      (char_u )'5',      (char_u )'k',      (char_u )'L', 
        (char_u )'*',      (char_u )'7',      (char_u )'@',      (char_u )'7', 
        (char_u )'*',      (char_u )'9',      (char_u )'@',      (char_u )'9', 
        (char_u )'*',      (char_u )'0',      (char_u )'@',      (char_u )'0', 
        (char_u )'#',      (char_u )'1',      (char_u )'%',      (char_u )'1', 
        (char_u )'#',      (char_u )'2',      (char_u )'k',      (char_u )'h', 
        (char_u )'#',      (char_u )'3',      (char_u )'k',      (char_u )'I', 
        (char_u )'#',      (char_u )'4',      (char_u )'k',      (char_u )'l', 
        (char_u )'%',      (char_u )'a',      (char_u )'%',      (char_u )'3', 
        (char_u )'%',      (char_u )'b',      (char_u )'%',      (char_u )'4', 
        (char_u )'%',      (char_u )'c',      (char_u )'%',      (char_u )'5', 
        (char_u )'%',      (char_u )'d',      (char_u )'%',      (char_u )'7', 
        (char_u )'%',      (char_u )'e',      (char_u )'%',      (char_u )'8', 
        (char_u )'%',      (char_u )'f',      (char_u )'%',      (char_u )'9', 
        (char_u )'%',      (char_u )'g',      (char_u )'%',      (char_u )'0', 
        (char_u )'%',      (char_u )'h',      (char_u )'&',      (char_u )'3', 
        (char_u )'%',      (char_u )'i',      (char_u )'k',      (char_u )'r', 
        (char_u )'%',      (char_u )'j',      (char_u )'&',      (char_u )'5', 
        (char_u )'!',      (char_u )'1',      (char_u )'&',      (char_u )'6', 
        (char_u )'!',      (char_u )'2',      (char_u )'&',      (char_u )'7', 
        (char_u )'!',      (char_u )'3',      (char_u )'&',      (char_u )'8', 
        (char_u )253,      (char_u )4,      (char_u )'k',      (char_u )'u', 
        (char_u )253,      (char_u )5,      (char_u )'k',      (char_u )'d', 
        (char_u )253,      (char_u )63,      (char_u )253,      (char_u )55, 
        (char_u )253,      (char_u )64,      (char_u )253,      (char_u )56, 
        (char_u )253,      (char_u )65,      (char_u )253,      (char_u )57, 
        (char_u )253,      (char_u )66,      (char_u )253,      (char_u )58, 
        (char_u )253,      (char_u )6,      (char_u )'k',      (char_u )'1', 
        (char_u )253,      (char_u )7,      (char_u )'k',      (char_u )'2', 
        (char_u )253,      (char_u )8,      (char_u )'k',      (char_u )'3', 
        (char_u )253,      (char_u )9,      (char_u )'k',      (char_u )'4', 
        (char_u )253,      (char_u )10,      (char_u )'k',      (char_u )'5', 
        (char_u )253,      (char_u )11,      (char_u )'k',      (char_u )'6', 
        (char_u )253,      (char_u )12,      (char_u )'k',      (char_u )'7', 
        (char_u )253,      (char_u )13,      (char_u )'k',      (char_u )'8', 
        (char_u )253,      (char_u )14,      (char_u )'k',      (char_u )'9', 
        (char_u )253,      (char_u )15,      (char_u )'k',      (char_u )';', 
        (char_u )253,      (char_u )16,      (char_u )'F',      (char_u )'1', 
        (char_u )253,      (char_u )17,      (char_u )'F',      (char_u )'2', 
        (char_u )253,      (char_u )18,      (char_u )'F',      (char_u )'3', 
        (char_u )253,      (char_u )19,      (char_u )'F',      (char_u )'4', 
        (char_u )253,      (char_u )20,      (char_u )'F',      (char_u )'5', 
        (char_u )253,      (char_u )21,      (char_u )'F',      (char_u )'6', 
        (char_u )253,      (char_u )22,      (char_u )'F',      (char_u )'7', 
        (char_u )253,      (char_u )23,      (char_u )'F',      (char_u )'8', 
        (char_u )253,      (char_u )24,      (char_u )'F',      (char_u )'9', 
        (char_u )253,      (char_u )25,      (char_u )'F',      (char_u )'A', 
        (char_u )253,      (char_u )26,      (char_u )'F',      (char_u )'B', 
        (char_u )253,      (char_u )27,      (char_u )'F',      (char_u )'C', 
        (char_u )253,      (char_u )28,      (char_u )'F',      (char_u )'D', 
        (char_u )253,      (char_u )29,      (char_u )'F',      (char_u )'E', 
        (char_u )253,      (char_u )30,      (char_u )'F',      (char_u )'F', 
        (char_u )253,      (char_u )31,      (char_u )'F',      (char_u )'G', 
        (char_u )253,      (char_u )32,      (char_u )'F',      (char_u )'H', 
        (char_u )253,      (char_u )33,      (char_u )'F',      (char_u )'I', 
        (char_u )253,      (char_u )34,      (char_u )'F',      (char_u )'J', 
        (char_u )253,      (char_u )35,      (char_u )'F',      (char_u )'K', 
        (char_u )253,      (char_u )36,      (char_u )'F',      (char_u )'L', 
        (char_u )253,      (char_u )37,      (char_u )'F',      (char_u )'M', 
        (char_u )253,      (char_u )38,      (char_u )'F',      (char_u )'N', 
        (char_u )253,      (char_u )39,      (char_u )'F',      (char_u )'O', 
        (char_u )253,      (char_u )40,      (char_u )'F',      (char_u )'P', 
        (char_u )253,      (char_u )53,      (char_u )253,      (char_u )52, 
        (char_u )'\000'};
static struct key_name_entry key_names_table[99]  = 
  {      {' ', (char_u *)"Space"}, 
        {'\t', (char_u *)"Tab"}, 
        {253 + (52 << 8), (char_u *)"Tab"}, 
        {'\n', (char_u *)"NL"}, 
        {'\n', (char_u *)"NewLine"}, 
        {'\n', (char_u *)"LineFeed"}, 
        {'\n', (char_u *)"LF"}, 
        {'\r', (char_u *)"CR"}, 
        {'\r', (char_u *)"Return"}, 
        {107 + (98 << 8), (char_u *)"BS"}, 
        {107 + (98 << 8), (char_u *)"BackSpace"}, 
        {'\033', (char_u *)"Esc"}, 
        {155, (char_u *)"CSI"}, 
        {253 + (71 << 8), (char_u *)"xCSI"}, 
        {'|', (char_u *)"Bar"}, 
        {'\\', (char_u *)"Bslash"}, 
        {107 + (68 << 8), (char_u *)"Del"}, 
        {107 + (68 << 8), (char_u *)"Delete"}, 
        {253 + (70 << 8), (char_u *)"kDel"}, 
        {107 + (117 << 8), (char_u *)"Up"}, 
        {107 + (100 << 8), (char_u *)"Down"}, 
        {107 + (108 << 8), (char_u *)"Left"}, 
        {107 + (114 << 8), (char_u *)"Right"}, 
        {107 + (49 << 8), (char_u *)"F1"}, 
        {107 + (50 << 8), (char_u *)"F2"}, 
        {107 + (51 << 8), (char_u *)"F3"}, 
        {107 + (52 << 8), (char_u *)"F4"}, 
        {107 + (53 << 8), (char_u *)"F5"}, 
        {107 + (54 << 8), (char_u *)"F6"}, 
        {107 + (55 << 8), (char_u *)"F7"}, 
        {107 + (56 << 8), (char_u *)"F8"}, 
        {107 + (57 << 8), (char_u *)"F9"}, 
        {107 + (59 << 8), (char_u *)"F10"}, 
        {70 + (49 << 8), (char_u *)"F11"}, 
        {70 + (50 << 8), (char_u *)"F12"}, 
        {70 + (51 << 8), (char_u *)"F13"}, 
        {70 + (52 << 8), (char_u *)"F14"}, 
        {70 + (53 << 8), (char_u *)"F15"}, 
        {70 + (54 << 8), (char_u *)"F16"}, 
        {70 + (55 << 8), (char_u *)"F17"}, 
        {70 + (56 << 8), (char_u *)"F18"}, 
        {70 + (57 << 8), (char_u *)"F19"}, 
        {70 + (65 << 8), (char_u *)"F20"}, 
        {70 + (66 << 8), (char_u *)"F21"}, 
        {70 + (67 << 8), (char_u *)"F22"}, 
        {70 + (68 << 8), (char_u *)"F23"}, 
        {70 + (69 << 8), (char_u *)"F24"}, 
        {70 + (70 << 8), (char_u *)"F25"}, 
        {70 + (71 << 8), (char_u *)"F26"}, 
        {70 + (72 << 8), (char_u *)"F27"}, 
        {70 + (73 << 8), (char_u *)"F28"}, 
        {70 + (74 << 8), (char_u *)"F29"}, 
        {70 + (75 << 8), (char_u *)"F30"}, 
        {70 + (76 << 8), (char_u *)"F31"}, 
        {70 + (77 << 8), (char_u *)"F32"}, 
        {70 + (78 << 8), (char_u *)"F33"}, 
        {70 + (79 << 8), (char_u *)"F34"}, 
        {70 + (80 << 8), (char_u *)"F35"}, 
        {253 + (55 << 8), (char_u *)"xF1"}, 
        {253 + (56 << 8), (char_u *)"xF2"}, 
        {253 + (57 << 8), (char_u *)"xF3"}, 
        {253 + (58 << 8), (char_u *)"xF4"}, 
        {37 + (49 << 8), (char_u *)"Help"}, 
        {38 + (56 << 8), (char_u *)"Undo"}, 
        {107 + (73 << 8), (char_u *)"Insert"}, 
        {107 + (73 << 8), (char_u *)"Ins"}, 
        {253 + (69 << 8), (char_u *)"kInsert"}, 
        {107 + (104 << 8), (char_u *)"Home"}, 
        {75 + (49 << 8), (char_u *)"kHome"}, 
        {253 + (60 << 8), (char_u *)"xHome"}, 
        {64 + (55 << 8), (char_u *)"End"}, 
        {75 + (52 << 8), (char_u *)"kEnd"}, 
        {253 + (59 << 8), (char_u *)"xEnd"}, 
        {107 + (80 << 8), (char_u *)"PageUp"}, 
        {107 + (78 << 8), (char_u *)"PageDown"}, 
        {75 + (51 << 8), (char_u *)"kPageUp"}, 
        {75 + (53 << 8), (char_u *)"kPageDown"}, 
        {75 + (54 << 8), (char_u *)"kPlus"}, 
        {75 + (55 << 8), (char_u *)"kMinus"}, 
        {75 + (56 << 8), (char_u *)"kDivide"}, 
        {75 + (57 << 8), (char_u *)"kMultiply"}, 
        {75 + (65 << 8), (char_u *)"kEnter"}, 
        {'<', (char_u *)"lt"}, 
        {251 + (88 << 8), (char_u *)"Mouse"}, 
        {253 + (42 << 8), (char_u *)"LeftMouse"}, 
        {253 + (61 << 8), (char_u *)"LeftMouseNM"}, 
        {253 + (43 << 8), (char_u *)"LeftDrag"}, 
        {253 + (44 << 8), (char_u *)"LeftRelease"}, 
        {253 + (62 << 8), (char_u *)"LeftReleaseNM"}, 
        {253 + (45 << 8), (char_u *)"MiddleMouse"}, 
        {253 + (46 << 8), (char_u *)"MiddleDrag"}, 
        {253 + (47 << 8), (char_u *)"MiddleRelease"}, 
        {253 + (48 << 8), (char_u *)"RightMouse"}, 
        {253 + (49 << 8), (char_u *)"RightDrag"}, 
        {253 + (50 << 8), (char_u *)"RightRelease"}, 
        {253 + (67 << 8), (char_u *)"MouseDown"}, 
        {253 + (68 << 8), (char_u *)"MouseUp"}, 
        {255 + (88 << 8), (char_u *)"Nul"}, 
        {0, (char_u *)((void *)0)}};
static struct mousetable mouse_table[12]  = 
  {      {42, 0, 1, 0}, 
        {43, 0, 0, 1}, 
        {44, 0, 0, 0}, 
        {45, 1, 1, 0}, 
        {46, 1, 0, 1}, 
        {47, 1, 0, 0}, 
        {48, 2, 1, 0}, 
        {49, 2, 0, 1}, 
        {50, 2, 0, 0}, 
        {51, 3, 0, 1}, 
        {51, 3, 0, 0}, 
        {0, 0, 0, 0}};
int name_to_mod_mask(int c ) 
{



























}
int simplify_key(int key , int *modifiers ) 
{
































}
static char_u string[24]  ;
char_u *get_special_key_name(int c , int modifiers ) 
{





















































































































































}
int trans_special(char_u **srcp , char_u *dst , int keycode ) 
{















































}
int find_special_key(char_u **srcp , int *modp , int keycode ) 
{


























































































































































}
int find_special_key_in_table(int c ) 
{






















}
int get_special_key_code(char_u *name___1 ) 
{



















































































}
char_u *get_key_name(int i___0 ) 
{








}
int get_mouse_button(int code , int *is_click , int *is_drag ) 
{





















}
int get_pseudo_mouse_code(int button , int is_click , int is_drag ) 
{























}
int get_fileformat(BUF *buf___3 ) 
{
















}
void set_fileformat(int t ) 
{







































}
int default_fileformat(void) 
{



















}
int call_shell(char_u *cmd , int opt ) 
{










































}
int get_real_state(void) 
{














}
int vim_chdirfile(char_u *fname ) 
{



































}
ulg crc_32_tab[256]  = 
  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
static ulg keys[3]  ;
int decrypt_byte(void) 
{






}
int update_keys(int c ) 
{









}
void crypt_init_keys(char_u *passwd ) 
{


























}
char_u *get_crypt_key(int store ) 
{





















}
static char_u *name  =    (char_u *)((void *)0);
int get_user_name(char_u *buf___3 , int len___0 ) 
{





















}
#pragma merger("0","/tmp/cil-kll2qSdF.i","-O0")
#pragma merger("0","/tmp/cil-NdJb9vp2.i","-O0")
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) ;
void check_visual_highlight(void) ;
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) ;
void may_start_select(int c ) ;
int get_op_type(int char1 , int char2 ) ;
int op_on_lines(int op ) ;
int get_op_char(int optype ) ;
int get_extra_op_char(int optype ) ;
void op_reindent(OPARG *oap , int (*how)(void) ) ;
int yank_register_mline(int regname___0 ) ;
int do_record(int c ) ;
int op_replace(OPARG *oap , int c ) ;
void op_tilde(OPARG *oap ) ;
void swapchar(int op_type , FPOS *pos___0 ) ;
void op_insert(OPARG *oap , long count1 ) ;
int op_change(OPARG *oap ) ;
void op_format(OPARG *oap ) ;
int do_addsub(int command , linenr_t Prenum1 ) ;
void update_other_win(void) ;
void scroll_cursor_top(int min_scroll , int always ) ;
void scroll_cursor_bot(int min_scroll , int set_topbot ) ;
void validate_botline(void) ;
void halfpage(int flag , linenr_t Prenum ) ;
int searchc(int c , int dir , int type , long count___2 ) ;
int findsent(int dir , long count___2 ) ;
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) ;
int end_word(long count___2 , int type , int stop , int empty ) ;
int bckend_word(long count___2 , int type , int eol ) ;
int current_word(OPARG *oap , long count___2 , int include , int type ) ;
int current_sent(OPARG *oap , long count___2 , int include ) ;
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) ;
int current_par(OPARG *oap , long count___2 , int include , int type ) ;
int mouse_model_popup(void) ;
void clip_auto_select(void) ;
void u_undoline(void) ;
void do_window(int nchar , long Prenum ) ;
static int resel_VIsual_mode  =    '\000';
static linenr_t resel_VIsual_line_count  ;
static colnr_t resel_VIsual_col  ;
static void op_colon(OPARG *oap ) ;
static void find_start_of_word(FPOS *pos___0 ) ;
static void find_end_of_word(FPOS *pos___0 ) ;
static int get_mouse_class(int c ) ;
static void prep_redo_cmd(CMDARG *cap ) ;
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) ;
static int checkclearop(OPARG *oap ) ;
static int checkclearopq(OPARG *oap ) ;
static void clearop(OPARG *oap ) ;
static void clearopbeep(OPARG *oap ) ;
static void del_from_showcmd(int len___0 ) ;
static void nv_gd(OPARG *oap , int nchar ) ;
static int nv_screengo(OPARG *oap , int dir , long dist ) ;
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) ;
static void nv_zet(CMDARG *cap ) ;
static void nv_colon(CMDARG *cap ) ;
static void nv_ctrlg(CMDARG *cap ) ;
static void nv_zzet(CMDARG *cap ) ;
static void nv_ident(CMDARG *cap , char_u **searchp ) ;
static void nv_scroll(CMDARG *cap ) ;
static void nv_right(CMDARG *cap ) ;
static int nv_left(CMDARG *cap ) ;
static void nv_gotofile(CMDARG *cap ) ;
static void nv_dollar(CMDARG *cap ) ;
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) ;
static void nv_next(CMDARG *cap , int flag ) ;
static void nv_csearch(CMDARG *cap , int dir , int type ) ;
static void nv_brackets(CMDARG *cap , int dir ) ;
static void nv_percent(CMDARG *cap ) ;
static void nv_brace(CMDARG *cap , int dir ) ;
static void nv_findpar(CMDARG *cap , int dir ) ;
static int nv_Replace(CMDARG *cap ) ;
static int nv_VReplace(CMDARG *cap ) ;
static int nv_vreplace(CMDARG *cap ) ;
static void v_swap_corners(CMDARG *cap ) ;
static int nv_replace(CMDARG *cap ) ;
static void n_swapchar(CMDARG *cap ) ;
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) ;
static void v_visop(CMDARG *cap ) ;
static void nv_optrans(CMDARG *cap ) ;
static void nv_gomark(CMDARG *cap , int flag ) ;
static void nv_pcmark(CMDARG *cap ) ;
static void nv_regname(CMDARG *cap , linenr_t *opnump ) ;
static void nv_visual(CMDARG *cap , int selectmode ) ;
static void n_start_visual_mode(int c ) ;
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) ;
static int n_opencmd(CMDARG *cap ) ;
static void nv_Undo(CMDARG *cap ) ;
static void nv_operator(CMDARG *cap ) ;
static void nv_lineop(CMDARG *cap ) ;
static void nv_pipe(CMDARG *cap ) ;
static void nv_bck_word(CMDARG *cap , int type ) ;
static void nv_wordcmd(CMDARG *cap , int type ) ;
static void adjust_for_sel(CMDARG *cap ) ;
static void unadjust_for_sel(void) ;
static void nv_goto(CMDARG *cap , linenr_t lnum ) ;
static void nv_select(CMDARG *cap ) ;
static void nv_normal(CMDARG *cap ) ;
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) ;
static int nv_edit(CMDARG *cap ) ;
static void nv_object(CMDARG *cap ) ;
static void nv_q(CMDARG *cap ) ;
static void nv_at(CMDARG *cap ) ;
static void nv_halfpage(CMDARG *cap ) ;
static void nv_join(CMDARG *cap ) ;
static void nv_put(CMDARG *cap ) ;
static linenr_t opnum  =    (linenr_t )0;
static int restart_VIsual_select  =    0;
static int old_mapped_len  =    0;
static int seltab[42]  = 
  {      37 + (105 << 8),      107 + (114 << 8),      1,      35 + (52 << 8), 
        107 + (108 << 8),      1,      253 + (4 << 8),      107 + (117 << 8), 
        1,      253 + (5 << 8),      107 + (100 << 8),      1, 
        35 + (50 << 8),      107 + (104 << 8),      1,      42 + (55 << 8), 
        64 + (55 << 8),      1,      75 + (49 << 8),      75 + (49 << 8), 
        0,      253 + (60 << 8),      253 + (60 << 8),      0, 
        75 + (52 << 8),      75 + (52 << 8),      0,      253 + (59 << 8), 
        75 + (52 << 8),      0,      107 + (80 << 8),      107 + (80 << 8), 
        0,      75 + (51 << 8),      75 + (51 << 8),      0, 
        107 + (78 << 8),      107 + (78 << 8),      0,      75 + (53 << 8), 
        75 + (53 << 8),      0};
void normal_cmd(OPARG *oap , int toplevel ) 
{






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int redo_VIsual_mode  =    '\000';
static linenr_t redo_VIsual_line_count  ;
static colnr_t redo_VIsual_col  ;
static long redo_VIsual_count  ;
void do_pending_operator(CMDARG *cap , char_u *searchbuff , int *command_busy , int old_col ,
                         int gui_yank , int dont_adjust_op_end ) 
{


















































































































































































































































































































































































































































































































































































































































































































}
static void op_colon(OPARG *oap ) 
{












































































}
static FPOS orig_cursor  ;
static int do_always  =    0;
static int got_click  =    0;
int do_mouse(OPARG *oap , int c , int dir , long count___2 , int fix_indent ) 
{




























































































































































































































































































































































































































































































































































}
static void find_start_of_word(FPOS *pos___0 ) 
{







































}
static void find_end_of_word(FPOS *pos___0 ) 
{








































}
static int get_mouse_class(int c ) 
{



























}
static int did_check  =    0;
void check_visual_highlight(void) 
{













}
void end_visual_mode(void) 
{































}
int find_ident_under_cursor(char_u **string___0 , int find_type ) 
{

























































































































































































}
static void prep_redo_cmd(CMDARG *cap ) 
{








}
static void prep_redo(int regname___0 , long num , int cmd1 , int cmd2 , int cmd3 ,
                      int cmd4 ) 
{







































}
static int checkclearop(OPARG *oap ) 
{











}
static int checkclearopq(OPARG *oap ) 
{













}
static void clearop(OPARG *oap ) 
{







}
static void clearopbeep(OPARG *oap ) 
{









}
static char_u showcmd_buf[11]  ;
static char_u old_showcmd_buf[11]  ;
static int showcmd_is_clear  =    1;
static void display_showcmd(void) ;
void clear_showcmd(void) 
{















}
static int ignore[13]  = 
  {      253 + (51 << 8),      253 + (42 << 8),      253 + (43 << 8),      253 + (44 << 8), 
        253 + (45 << 8),      253 + (46 << 8),      253 + (47 << 8),      253 + (48 << 8), 
        253 + (49 << 8),      253 + (50 << 8),      253 + (67 << 8),      253 + (68 << 8), 
        0};
int add_to_showcmd(int c ) 
{




















































}
void add_to_showcmd_c(int c ) 
{













}
static void del_from_showcmd(int len___0 ) 
{


























}
void push_showcmd(void) 
{










}
void pop_showcmd(void) 
{












}
static void display_showcmd(void) 
{
























}
static WIN *old_curwin  =    (WIN *)((void *)0);
static linenr_t old_topline  =    (linenr_t )0;
static BUF *old_buf  =    (BUF *)((void *)0);
static colnr_t old_leftcol  =    (colnr_t )0;
void do_check_scrollbind(int check ) 
{










































}
void check_scrollbind(linenr_t topline_diff , long leftcol_diff ) 
{






















































































































}
static void nv_gd(OPARG *oap , int nchar ) 
{









































































































































}
static int nv_screengo(OPARG *oap , int dir , long dist ) 
{





























































































































}
static void nv_scroll_line(CMDARG *cap , int is_ctrl_e ) 
{














}
void scroll_redraw(int up , long count___2 ) 
{












































}
static void nv_zet(CMDARG *cap ) 
{





































































































































































































































































































}
static void nv_colon(CMDARG *cap ) 
{












































}
static void nv_ctrlg(CMDARG *cap ) 
{




















}
static void nv_zzet(CMDARG *cap ) 
{



























}
static void nv_ident(CMDARG *cap , char_u **searchp ) 
{

































































































































































































































































































































}
static void nv_scroll(CMDARG *cap ) 
{






























































}
static void nv_right(CMDARG *cap ) 
{


















































































































































}
static int nv_left(CMDARG *cap ) 
{








































































































}
static void nv_gotofile(CMDARG *cap ) 
{








































}
static void nv_dollar(CMDARG *cap ) 
{
















}
static void nv_search(CMDARG *cap , char_u **searchp , int dont_set_mark ) 
{




















































}
static void nv_next(CMDARG *cap , int flag ) 
{



















}
static void nv_csearch(CMDARG *cap , int dir , int type ) 
{






























}
static void nv_brackets(CMDARG *cap , int dir ) 
{












































































































































































































































































































































































































}
static void nv_percent(CMDARG *cap ) 
{





































}
static void nv_brace(CMDARG *cap , int dir ) 
{




















}
static void nv_findpar(CMDARG *cap , int dir ) 
{
















}
static int nv_replace(CMDARG *cap ) 
{






















































































































































}
static void v_swap_corners(CMDARG *cap ) 
{












































}
static int nv_Replace(CMDARG *cap ) 
{






























}
static int nv_VReplace(CMDARG *cap ) 
{
































}
static int nv_vreplace(CMDARG *cap ) 
{







































}
static void n_swapchar(CMDARG *cap ) 
{


























































































}
static void nv_cursormark(CMDARG *cap , int flag , FPOS *pos___0 ) 
{










































}
static char_u trans[17]  = 
  {      (char_u )'Y',      (char_u )'y',      (char_u )'D',      (char_u )'d', 
        (char_u )'C',      (char_u )'c',      (char_u )'x',      (char_u )'d', 
        (char_u )'X',      (char_u )'d',      (char_u )'A',      (char_u )'A', 
        (char_u )'I',      (char_u )'I',      (char_u )'r',      (char_u )'r', 
        (char_u )'\000'};
static void v_visop(CMDARG *cap ) 
{



























}
static char_u *ar[8]  = 
  {      (char_u *)"dl",      (char_u *)"dh",      (char_u *)"d$",      (char_u *)"c$", 
        (char_u *)"cl",      (char_u *)"cc",      (char_u *)"yy",      (char_u *)":s\r"};
static char_u *str___0  =    (char_u *)"xXDCsSY&";
static void nv_optrans(CMDARG *cap ) 
{




















}
static void nv_gomark(CMDARG *cap , int flag ) 
{
























}
static void nv_pcmark(CMDARG *cap ) 
{






























}
static void nv_regname(CMDARG *cap , linenr_t *opnump ) 
{


































}
static void nv_visual(CMDARG *cap , int selectmode ) 
{






























































































}
void start_selection(void) 
{









}
void may_start_select(int c ) 
{































}
static void n_start_visual_mode(int c ) 
{



















}
static int nv_g_cmd(CMDARG *cap , char_u **searchp ) 
{



















































































































































































































































































































































































































































































































































































}
static int n_opencmd(CMDARG *cap ) 
{






















































}
static void nv_Undo(CMDARG *cap ) 
{






























}
static void nv_operator(CMDARG *cap ) 
{






















}
static void nv_lineop(CMDARG *cap ) 
{






































}
static void nv_pipe(CMDARG *cap ) 
{



















}
static void nv_bck_word(CMDARG *cap , int type ) 
{
















}
static void nv_wordcmd(CMDARG *cap , int type ) 
{












































































}
static void adjust_for_sel(CMDARG *cap ) 
{


















}
static void unadjust_for_sel(void) 
{







































}
static void nv_goto(CMDARG *cap , linenr_t lnum ) 
{























}
static void nv_select(CMDARG *cap ) 
{














































}
static void nv_normal(CMDARG *cap ) 
{























}
static void nv_esc(CMDARG *cap , linenr_t opnum___0 ) 
{



































}
static int nv_edit(CMDARG *cap ) 
{










































































































}
static void nv_object(CMDARG *cap ) 
{























































































































}
static void nv_q(CMDARG *cap ) 
{





























}
static void nv_at(CMDARG *cap ) 
{

















































}
static void nv_halfpage(CMDARG *cap ) 
{



































}
static void nv_join(CMDARG *cap ) 
{






























}
static void nv_put(CMDARG *cap ) 
{










































}
#pragma merger("0","/tmp/cil-PCiYej8m.i","-O0")
int get_register_name(int num ) ;
void dis_msg(char_u *p___0 , int skip_esc ) ;
void clip_free_selection(void) ;
void clip_get_selection(void) ;
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) ;
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) ;
void update_topline_redraw(void) ;
int may_validate_crow(void) ;
char_u *last_search_pat(void) ;
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) ;
int startPS(linenr_t lnum , int para , int both ) ;
void clip_own_selection(void) ;
void clip_gen_set_selection(void) ;
void clip_gen_request_selection(void) ;
static struct yankreg y_regs[38]  ;
static struct yankreg *y_current  ;
static int y_append  ;
static struct yankreg *y_previous  =    (struct yankreg *)((void *)0);
static void shift_block(OPARG *oap , int amount ) ;
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) ;
static char_u *get_expr_line(void) ;
static void get_yank_register(int regname___0 , int writing ) ;
static int stuff_yank(int regname___0 , char_u *p___0 ) ;
static int put_in_typebuf(char_u *s , int colon ) ;
static void stuffescaped(char_u *arg ) ;
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) ;
static void cmdline_paste_str(char_u *s , int literally ) ;
static void free_yank(long n ) ;
static void free_yank_all(void) ;
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) ;
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) ;
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) ;
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) ;
static char opchars[19][3]  = 
  { {        (char )'\000',        (char )'\000',        (char)0}, 
   {        (char )'d',        (char )'\000',        (char)0}, 
   {        (char )'y',        (char )'\000',        (char)0}, 
   {        (char )'c',        (char )'\000',        (char)0}, 
   {        (char )'<',        (char )'\000',        (char)1}, 
   {        (char )'>',        (char )'\000',        (char)1}, 
   {        (char )'!',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'~',        (char)0}, 
   {        (char )'=',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'q',        (char)1}, 
   {        (char )':',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'U',        (char)0}, 
   {        (char )'g',        (char )'u',        (char)0}, 
   {        (char )'J',        (char )'\000',        (char)1}, 
   {        (char )'g',        (char )'J',        (char)1}, 
   {        (char )'g',        (char )'?',        (char)0}, 
   {        (char )'r',        (char )'\000',        (char)0}, 
   {        (char )'I',        (char )'\000',        (char)0}, 
   {        (char )'A',        (char )'\000',        (char)0}};
int get_op_type(int char1 , int char2 ) 
{
























}
int op_on_lines(int op ) 
{





}
int get_op_char(int optype ) 
{





}
int get_extra_op_char(int optype ) 
{





}
void op_shift(OPARG *oap , int curs_top , int amount ) 
{

















































































































}
void shift_line(int left , int round , int amount ) 
{
















































}
static void shift_block(OPARG *oap , int amount ) 
{










































































































































































































}
static void block_insert(OPARG *oap , char_u *s , int b_insert , struct block_def *bdp ) 
{
















































































































}
void op_reindent(OPARG *oap , int (*how)(void) ) 
{

























































































}
static char_u *expr_line  =    (char_u *)((void *)0);
int get_expr_register(void) 
{




















}
void set_expr_line(char_u *new_line ) 
{









}
static char_u *get_expr_line(void) 
{











}
int valid_yank_reg(int regname___0 , int writing ) 
{











































}
static void get_yank_register(int regname___0 , int writing ) 
{

































































}
int yank_register_mline(int regname___0 ) 
{



















}
static int regname  ;
int do_record(int c ) 
{






















































}
static int stuff_yank(int regname___0 , char_u *p___0 ) 
{









































































}
static int lastc  =    '\000';
int do_execreg(int regname___0 , int colon , int addcr ) 
{



































































































































}
static int put_in_typebuf(char_u *s , int colon ) 
{























}
int insert_reg(int regname___0 , int literally ) 
{





































































































}
static void stuffescaped(char_u *arg ) 
{



































}
static int get_spec_reg(int regname___0 , char_u **argp , int *allocated , int errmsg ) 
{


















































































































































}
int cmdline_paste(int regname___0 , int literally ) 
{
















































































}
static void cmdline_paste_str(char_u *s , int literally ) 
{












































































}
int op_delete(OPARG *oap ) 
{





































































































































































































































































































































































}
int op_replace(OPARG *oap , int c ) 
{













































































































































}
void op_tilde(OPARG *oap ) 
{































































































































}
void swapchar(int op_type , FPOS *pos___0 ) 
{






















































}
void op_insert(OPARG *oap , long count1 ) 
{





















































































































































































}
int op_change(OPARG *oap ) 
{











































































































































































}
void init_yank(void) 
{

















}
static void free_yank(long n ) 
{

























}
static void free_yank_all(void) 
{








}
int op_yank(OPARG *oap , int deleting , int mess ) 
{












































































































































































































































































































































}
void do_put(int regname___0 , int dir , long count___2 , int flags___0 ) 
{























































































































































































































































































































































































































































































































































































































































































































}
int get_register_name(int num ) 
{





















}
void do_dis(char_u *arg ) 
{























































































































































































































































}
void dis_msg(char_u *p___0 , int skip_esc ) 
{











































}
void do_do_join(long count___2 , int insert_space , int redraw ) 
{
















































}
int do_join(int insert_space , int redraw ) 
{


































































































































}
static int same_leader(int leader1_len , char_u *leader1_flags , int leader2_len ,
                       char_u *leader2_flags ) 
{

















































































































































}
void op_format(OPARG *oap ) 
{













































































































































































































































































}
static int fmt_check_par(linenr_t lnum , int *leader_len , char_u **leader_flags ) 
{























































}
static void block_prep(OPARG *oap , struct block_def *bdp , linenr_t lnum , int is_del ) 
{























































































































































}
static int hexupper  =    0;
int do_addsub(int command , linenr_t Prenum1 ) 
{

































































































































































































































































































































}
int read_viminfo_register(char_u *line , FILE *fp___0 , int force ) 
{








































































































































































}
void write_viminfo_registers(FILE *fp___0 ) 
{








































































































}
void clip_free_selection(void) 
{












}
void clip_get_selection(void) 
{















































}
void clip_yank_selection(int type , char_u *str___1 , long len___0 ) 
{










}
int clip_convert_selection(char_u **str___1 , long_u *len___0 ) 
{








































































}
char_u *get_reg_contents(int regname___0 ) 
{

















































































































}
void write_reg_contents(int name___1 , char_u *str___1 ) 
{






































































}
static void str_to_reg(struct yankreg *y_ptr , int type , char_u *str___1 , long len___0 ) 
{




























































































































































}
void clear_oparg(OPARG *oap ) 
{








}
#pragma merger("0","/tmp/cil-57zfFRmO.i","-O0")
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
int mch_can_restore_title(void) ;
int mch_can_restore_icon(void) ;
void mch_setmouse(int on ) ;
void check_mouse_termcode(void) ;
void clear_xterm_clip(void) ;
void set_string_default(char *name___1 , char_u *val ) ;
void set_number_default(char *name___1 , long val ) ;
void set_title_defaults(void) ;
void check_options(void) ;
void set_term_option_alloced(char_u **p___0 ) ;
char_u *check_stl_option(char_u *s ) ;
char_u *get_term_code(char_u *tname ) ;
char_u *get_highlight_default(void) ;
void clear_termoptions(void) ;
void set_term_defaults(void) ;
void comp_col(void) ;
void win_copy_options(WIN *wp_from , WIN *wp_to ) ;
int option_was_set(char_u *name___1 ) ;
int highlight_changed(void) ;
int set_termname(char_u *term ) ;
void ttest(int pairs ) ;
void check_winsize(void) ;
void clear_termcodes(void) ;
char_u *get_termcode(int i___0 ) ;
void show_termcodes(void) ;
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) ;
void ui_set_winsize(void) ;
void win_setminheight(void) ;
void win_comp_scroll(WIN *wp ) ;
void command_height(long old_p_ch ) ;
int min_rows(void) ;
static struct vimoption options[286]  = 
  {      {(char *)"aleph", (char *)"al", (short_u )1026, (char_u *)((void *)0), {(char_u *)224L,
                                                                             (char_u *)0L}}, 
        {(char *)"allowrevins",
      (char *)"ari", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"altkeymap",
      (char *)"akm", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoindent",
      (char *)"ai", (short_u )1057, (char_u *)1, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"autoprint", (char *)"ap", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"autowrite",
      (char *)"aw", (short_u )1025, (char_u *)(& p_aw), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"background",
      (char *)"bg", (short_u )29700, (char_u *)(& p_bg), {(char_u *)"light", (char_u *)0L}}, 
        {(char *)"backspace",
      (char *)"bs", (short_u )35844, (char_u *)(& p_bs), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"backup",
      (char *)"bk", (short_u )3073, (char_u *)(& p_bk), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"backupdir",
      (char *)"bdir", (short_u )33812, (char_u *)(& p_bdir), {(char_u *)".,~/tmp,~/",
                                                              (char_u *)0L}}, 
        {(char *)"backupext", (char *)"bex", (short_u )1028, (char_u *)(& p_bex), {(char_u *)"~",
                                                                                (char_u *)0L}}, 
        {(char *)"beautify",
      (char *)"bf", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"binary",
      (char *)"bin", (short_u )5153, (char_u *)2, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"bioskey", (char *)"biosk", (short_u )1025, (char_u *)((void *)0), {(char_u *)1,
                                                                                  (char_u *)0L}}, 
        {(char *)"breakat",
      (char *)"brk", (short_u )17412, (char_u *)(& p_breakat), {(char_u *)" \t!@*-+_;:,./?",
                                                                (char_u *)0L}}, 
        {(char *)"browsedir", (char *)"bsdir", (short_u )1028, (char_u *)((void *)0),
      {(char_u *)"last", (char_u *)0L}}, 
        {(char *)"cindent", (char *)"cin", (short_u )3105, (char_u *)3, {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"cinkeys",
      (char *)"cink", (short_u )33836, (char_u *)4, {(char_u *)"0{,0},:,0#,!^F,o,O,e",
                                                     (char_u *)0L}}, 
        {(char *)"cinoptions", (char *)"cino", (short_u )33836, (char_u *)5, {(char_u *)"",
                                                                           (char_u *)0L}}, 
        {(char *)"cinwords",
      (char *)"cinw", (short_u )33836, (char_u *)6, {(char_u *)"if,else,while,do,for,switch",
                                                     (char_u *)0L}}, 
        {(char *)"clipboard", (char *)"cb", (short_u )33796, (char_u *)(& p_cb), {(char_u *)"",
                                                                               (char_u *)0L}}, 
        {(char *)"cmdheight",
      (char *)"ch", (short_u )17410, (char_u *)(& p_ch), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"columns",
      (char *)"co", (short_u )30274, (char_u *)(& Columns), {(char_u *)80L, (char_u *)0L}}, 
        {(char *)"comments",
      (char *)"com", (short_u )33836, (char_u *)7, {(char_u *)"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-",
                                                    (char_u *)0L}}, 
        {(char *)"compatible", (char *)"cp", (short_u )16385, (char_u *)(& p_cp), {(char_u *)1,
                                                                                (char_u *)0}}, 
        {(char *)"complete",
      (char *)"cpt", (short_u )33836, (char_u *)8, {(char_u *)".,w,b,u,t,i", (char_u *)0L}}, 
        {(char *)"confirm",
      (char *)"cf", (short_u )1025, (char_u *)(& p_confirm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"conskey",
      (char *)"consk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"cpoptions",
      (char *)"cpo", (short_u )18436, (char_u *)(& p_cpo), {(char_u *)"aAbBcCdeEfFjJkKlLmoOprsStuwWxy$!%*<",
                                                            (char_u *)"aABceFs"}}, 
        {(char *)"cscopeprg",
      (char *)"csprg", (short_u )1044, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetag",
      (char *)"cst", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopetagorder",
      (char *)"csto", (short_u )3074, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"cscopeverbose",
      (char *)"csverb", (short_u )3073, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"define",
      (char *)"def", (short_u )1028, (char_u *)(& p_def), {(char_u *)"^#\\s*define",
                                                           (char_u *)0L}}, 
        {(char *)"dictionary", (char *)"dict", (short_u )33812, (char_u *)(& p_dict),
      {(char_u *)"", (char_u *)0L}}, 
        {(char *)"digraph", (char *)"dg", (short_u )3073, (char_u *)(& p_dg), {(char_u *)0,
                                                                            (char_u *)0L}}, 
        {(char *)"directory",
      (char *)"dir", (short_u )33812, (char_u *)(& p_dir), {(char_u *)".,~/tmp,/var/tmp,/tmp",
                                                            (char_u *)0L}}, 
        {(char *)"display", (char *)"dy", (short_u )50180, (char_u *)(& p_dy), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"edcompatible",
      (char *)"ed", (short_u )1025, (char_u *)(& p_ed), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"endofline",
      (char *)"eol", (short_u )5665, (char_u *)9, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"equalalways", (char *)"ea", (short_u )17409, (char_u *)(& p_ea), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"equalprg",
      (char *)"ep", (short_u )1044, (char_u *)(& p_ep), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"errorbells",
      (char *)"eb", (short_u )1025, (char_u *)(& p_eb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"errorfile",
      (char *)"ef", (short_u )1044, (char_u *)(& p_ef), {(char_u *)"errors.err", (char_u *)0L}}, 
        {(char *)"errorformat",
      (char *)"efm", (short_u )33796, (char_u *)(& p_efm), {(char_u *)"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f\',%X%*\\a[%*\\d]: Leaving directory `%f\',%DMaking %*\\a in %f",
                                                            (char_u *)0L}}, 
        {(char *)"esckeys", (char *)"ek", (short_u )2049, (char_u *)(& p_ek), {(char_u *)0,
                                                                            (char_u *)1}}, 
        {(char *)"eventignore",
      (char *)"ei", (short_u )33796, (char_u *)(& p_ei), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"expandtab",
      (char *)"et", (short_u )3105, (char_u *)10, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"exrc", (char *)"ex", (short_u )1025, (char_u *)(& p_exrc), {(char_u *)0,
                                                                           (char_u *)0L}}, 
        {(char *)"fileencoding",
      (char *)"fe", (short_u )5164, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"fileformat",
      (char *)"ff", (short_u )5676, (char_u *)12, {(char_u *)"unix", (char_u *)0L}}, 
        {(char *)"fileformats",
      (char *)"ffs", (short_u )34820, (char_u *)(& p_ffs), {(char_u *)"", (char_u *)"unix,dos"}}, 
        {(char *)"filetype",
      (char *)"ft", (short_u )1068, (char_u *)14, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"fkmap", (char *)"fk", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                             (char_u *)0L}}, 
        {(char *)"flash",
      (char *)"fl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"formatoptions",
      (char *)"fo", (short_u )2092, (char_u *)13, {(char_u *)"vt", (char_u *)"tcq"}}, 
        {(char *)"formatprg",
      (char *)"fp", (short_u )1044, (char_u *)(& p_fp), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"gdefault",
      (char *)"gd", (short_u )3073, (char_u *)(& p_gd), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"graphic",
      (char *)"gr", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"grepformat",
      (char *)"gfm", (short_u )33796, (char_u *)(& p_gefm), {(char_u *)"%f:%l%m,%f  %l%m",
                                                             (char_u *)0L}}, 
        {(char *)"grepprg", (char *)"gp", (short_u )1044, (char_u *)(& p_gp), {(char_u *)"grep -n",
                                                                            (char_u *)0L}}, 
        {(char *)"guicursor",
      (char *)"gcr", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guifont", (char *)"gfn", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                                 (char_u *)0L}}, 
        {(char *)"guifontset",
      (char *)"gfs", (short_u )62468, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                              (char_u *)0L}}, 
        {(char *)"guiheadroom", (char *)"ghr", (short_u )1026, (char_u *)((void *)0),
      {(char_u *)50L, (char_u *)0L}}, 
        {(char *)"guioptions", (char *)"go", (short_u )17412, (char_u *)((void *)0),
      {(char_u *)((void *)0), (char_u *)0L}}, 
        {(char *)"guipty", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)1, (char_u *)0L}}, 
        {(char *)"hardtabs", (char *)"ht", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                                (char_u *)0L}}, 
        {(char *)"helpfile",
      (char *)"hf", (short_u )1044, (char_u *)(& p_hf), {(char_u *)"$VIMRUNTIME/doc/help.txt",
                                                         (char_u *)0L}}, 
        {(char *)"helpheight", (char *)"hh", (short_u )1026, (char_u *)(& p_hh), {(char_u *)20L,
                                                                               (char_u *)0L}}, 
        {(char *)"hidden",
      (char *)"hid", (short_u )1025, (char_u *)(& p_hid), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"highlight",
      (char *)"hl", (short_u )62468, (char_u *)(& p_hl), {(char_u *)"8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu",
                                                          (char_u *)0L}}, 
        {(char *)"history", (char *)"hi", (short_u )2050, (char_u *)(& p_hi), {(char_u *)0L,
                                                                            (char_u *)20L}}, 
        {(char *)"hkmap",
      (char *)"hk", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hkmapp",
      (char *)"hkp", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"hlsearch",
      (char *)"hls", (short_u )19457, (char_u *)(& p_hls), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"icon",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_icon), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"iconstring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_iconstring), {(char_u *)"",
                                                                        (char_u *)0L}}, 
        {(char *)"ignorecase",
      (char *)"ic", (short_u )1025, (char_u *)(& p_ic), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"include",
      (char *)"inc", (short_u )1028, (char_u *)(& p_inc), {(char_u *)"^#\\s*include",
                                                           (char_u *)0L}}, 
        {(char *)"incsearch", (char *)"is", (short_u )3073, (char_u *)(& p_is), {(char_u *)0,
                                                                              (char_u *)0L}}, 
        {(char *)"infercase",
      (char *)"inf", (short_u )1057, (char_u *)15, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"insertmode", (char *)"im", (short_u )3073, (char_u *)(& p_im), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"isfname",
      (char *)"isf", (short_u )33796, (char_u *)(& p_isf), {(char_u *)"@,48-57,/,.,-,_,+,,,$,~",
                                                            (char_u *)0L}}, 
        {(char *)"isident", (char *)"isi", (short_u )33796, (char_u *)(& p_isi), {(char_u *)"@,48-57,_,192-255",
                                                                               (char_u *)0L}}, 
        {(char *)"iskeyword",
      (char *)"isk", (short_u )34860, (char_u *)16, {(char_u *)"@,48-57,_", (char_u *)"@,48-57,_,192-255"}}, 
        {(char *)"isprint",
      (char *)"isp", (short_u )50180, (char_u *)(& p_isp), {(char_u *)"@,161-255",
                                                            (char_u *)0L}}, 
        {(char *)"joinspaces", (char *)"js", (short_u )3073, (char_u *)(& p_js), {(char_u *)1,
                                                                               (char_u *)0L}}, 
        {(char *)"key",
      (char *)((void *)0), (short_u )1580, (char_u *)17, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keymodel",
      (char *)"km", (short_u )33796, (char_u *)(& p_km), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"keywordprg",
      (char *)"kp", (short_u )1044, (char_u *)(& p_kp), {(char_u *)"man -s", (char_u *)0L}}, 
        {(char *)"langmap",
      (char *)"lmap", (short_u )33796, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                               (char_u *)0L}}, 
        {(char *)"laststatus", (char *)"ls", (short_u )17410, (char_u *)(& p_ls), {(char_u *)1L,
                                                                                (char_u *)0L}}, 
        {(char *)"lazyredraw",
      (char *)"lz", (short_u )1025, (char_u *)(& p_lz), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"linebreak",
      (char *)"lbr", (short_u )9249, (char_u *)18, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"lines", (char *)((void *)0), (short_u )30274, (char_u *)(& Rows), {(char_u *)24L,
                                                                                  (char_u *)0L}}, 
        {(char *)"lisp",
      (char *)((void *)0), (short_u )1057, (char_u *)19, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"list",
      (char *)((void *)0), (short_u )9249, (char_u *)20, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"listchars",
      (char *)"lcs", (short_u )50180, (char_u *)(& p_lcs), {(char_u *)"eol:$", (char_u *)0L}}, 
        {(char *)"magic",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_magic), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"makeef",
      (char *)"mef", (short_u )1044, (char_u *)(& p_mef), {(char_u *)"/tmp/vim##.err",
                                                           (char_u *)0L}}, 
        {(char *)"makeprg", (char *)"mp", (short_u )1044, (char_u *)(& p_mp), {(char_u *)"make",
                                                                            (char_u *)0L}}, 
        {(char *)"matchpairs",
      (char *)"mps", (short_u )33836, (char_u *)22, {(char_u *)"(:),{:},[:]", (char_u *)0L}}, 
        {(char *)"matchtime",
      (char *)"mat", (short_u )1026, (char_u *)(& p_mat), {(char_u *)5L, (char_u *)0L}}, 
        {(char *)"maxfuncdepth",
      (char *)"mfd", (short_u )1026, (char_u *)(& p_mfd), {(char_u *)100L, (char_u *)0L}}, 
        {(char *)"maxmapdepth",
      (char *)"mmd", (short_u )1026, (char_u *)(& p_mmd), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"maxmem",
      (char *)"mm", (short_u )1026, (char_u *)(& p_mm), {(char_u *)5120, (char_u *)0L}}, 
        {(char *)"maxmemtot",
      (char *)"mmt", (short_u )1026, (char_u *)(& p_mmt), {(char_u *)10240, (char_u *)0L}}, 
        {(char *)"mesg",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"modeline",
      (char *)"ml", (short_u )2081, (char_u *)21, {(char_u *)0, (char_u *)1}}, 
        {(char *)"modelines", (char *)"mls", (short_u )1026, (char_u *)(& p_mls), {(char_u *)5L,
                                                                                (char_u *)0L}}, 
        {(char *)"modified",
      (char *)"mod", (short_u )5665, (char_u *)23, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"more", (char *)((void *)0), (short_u )2049, (char_u *)(& p_more), {(char_u *)0,
                                                                                  (char_u *)1}}, 
        {(char *)"mouse",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_mouse), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"mousefocus",
      (char *)"mousef", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousehide",
      (char *)"mh", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"mousemodel",
      (char *)"mousem", (short_u )1028, (char_u *)(& p_mousem), {(char_u *)"extend",
                                                                 (char_u *)0L}}, 
        {(char *)"mousetime", (char *)"mouset", (short_u )1026, (char_u *)(& p_mouset),
      {(char_u *)500L, (char_u *)0L}}, 
        {(char *)"novice", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"nrformats", (char *)"nf", (short_u )33836, (char_u *)24, {(char_u *)"octal,hex",
                                                                         (char_u *)0L}}, 
        {(char *)"number",
      (char *)"nu", (short_u )9249, (char_u *)25, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"open", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"optimize", (char *)"opt", (short_u )1025, (char_u *)((void *)0), {(char_u *)0,
                                                                                 (char_u *)0L}}, 
        {(char *)"osfiletype",
      (char *)"oft", (short_u )1068, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"paragraphs",
      (char *)"para", (short_u )1028, (char_u *)(& p_para), {(char_u *)"IPLPPPQPP LIpplpipbp",
                                                             (char_u *)0L}}, 
        {(char *)"paste", (char *)((void *)0), (short_u )1025, (char_u *)(& p_paste),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"pastetoggle", (char *)"pt", (short_u )1028, (char_u *)(& p_pt), {(char_u *)"",
                                                                                (char_u *)0L}}, 
        {(char *)"patchmode",
      (char *)"pm", (short_u )1028, (char_u *)(& p_pm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"path",
      (char *)"pa", (short_u )33812, (char_u *)(& p_path), {(char_u *)".,/usr/include,,",
                                                            (char_u *)0L}}, 
        {(char *)"previewheight", (char *)"pvh", (short_u )1026, (char_u *)(& p_pvh),
      {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"prompt", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"readonly", (char *)"ro", (short_u )5153, (char_u *)28, {(char_u *)0,
                                                                       (char_u *)0L}}, 
        {(char *)"redraw",
      (char *)((void *)0), (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"remap",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_remap), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"report",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_report), {(char_u *)2L,
                                                                    (char_u *)0L}}, 
        {(char *)"restorescreen",
      (char *)"rs", (short_u )1025, (char_u *)((void *)0), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"revins",
      (char *)"ri", (short_u )3073, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rightleft",
      (char *)"rl", (short_u )9249, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ruler",
      (char *)"ru", (short_u )7169, (char_u *)(& p_ru), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"rulerformat",
      (char *)"ruf", (short_u )5132, (char_u *)(& p_ruf), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"scroll",
      (char *)"scr", (short_u )1570, (char_u *)29, {(char_u *)12L, (char_u *)0L}}, 
        {(char *)"scrollbind",
      (char *)"scb", (short_u )1057, (char_u *)35, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"scrolljump", (char *)"sj", (short_u )3074, (char_u *)(& p_sj), {(char_u *)1L,
                                                                               (char_u *)0L}}, 
        {(char *)"scrolloff",
      (char *)"so", (short_u )19458, (char_u *)(& p_so), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"scrollopt",
      (char *)"sbo", (short_u )33796, (char_u *)(& p_sbo), {(char_u *)"ver,jump",
                                                            (char_u *)0L}}, 
        {(char *)"sections", (char *)"sect", (short_u )1028, (char_u *)(& p_sections),
      {(char_u *)"SHNHH HUnhsh", (char_u *)0L}}, 
        {(char *)"secure", (char *)((void *)0), (short_u )1025, (char_u *)(& p_secure),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"selection", (char *)"sel", (short_u )1028, (char_u *)(& p_sel), {(char_u *)"inclusive",
                                                                                (char_u *)0L}}, 
        {(char *)"selectmode",
      (char *)"slm", (short_u )33796, (char_u *)(& p_slm), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"sessionoptions",
      (char *)"ssop", (short_u )33796, (char_u *)(& p_sessopt), {(char_u *)"buffers,winsize,options,help,blank",
                                                                 (char_u *)0L}}, 
        {(char *)"shell", (char *)"sh", (short_u )1044, (char_u *)(& p_sh), {(char_u *)"sh",
                                                                          (char_u *)0L}}, 
        {(char *)"shellcmdflag",
      (char *)"shcf", (short_u )1028, (char_u *)(& p_shcf), {(char_u *)"-c", (char_u *)0L}}, 
        {(char *)"shellpipe",
      (char *)"sp", (short_u )1028, (char_u *)(& p_sp), {(char_u *)"| tee", (char_u *)0L}}, 
        {(char *)"shellquote",
      (char *)"shq", (short_u )1028, (char_u *)(& p_shq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shellredir",
      (char *)"srr", (short_u )1028, (char_u *)(& p_srr), {(char_u *)">", (char_u *)0L}}, 
        {(char *)"shellslash",
      (char *)"ssl", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shelltype",
      (char *)"st", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"shellxquote",
      (char *)"sxq", (short_u )1028, (char_u *)(& p_sxq), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"shiftround",
      (char *)"sr", (short_u )3073, (char_u *)(& p_sr), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"shiftwidth",
      (char *)"sw", (short_u )1058, (char_u *)36, {(char_u *)8L, (char_u *)0L}}, 
        {(char *)"shortmess", (char *)"shm", (short_u )2052, (char_u *)(& p_shm), {(char_u *)"",
                                                                                (char_u *)"filnxtToO"}}, 
        {(char *)"shortname",
      (char *)"sn", (short_u )1057, (char_u *)31, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showbreak", (char *)"sbr", (short_u )17412, (char_u *)(& p_sbr), {(char_u *)"",
                                                                                 (char_u *)0L}}, 
        {(char *)"showcmd",
      (char *)"sc", (short_u )2049, (char_u *)(& p_sc), {(char_u *)0, (char_u *)0}}, 
        {(char *)"showfulltag",
      (char *)"sft", (short_u )1025, (char_u *)(& p_sft), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmatch",
      (char *)"sm", (short_u )1025, (char_u *)(& p_sm), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"showmode",
      (char *)"smd", (short_u )2049, (char_u *)(& p_smd), {(char_u *)0, (char_u *)1}}, 
        {(char *)"sidescroll",
      (char *)"ss", (short_u )1026, (char_u *)(& p_ss), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"slowopen",
      (char *)"slow", (short_u )1025, (char_u *)((void *)0), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartcase",
      (char *)"scs", (short_u )3073, (char_u *)(& p_scs), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smartindent",
      (char *)"si", (short_u )3105, (char_u *)30, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"smarttab", (char *)"sta", (short_u )3073, (char_u *)(& p_sta), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"softtabstop",
      (char *)"sts", (short_u )3106, (char_u *)32, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"sourceany", (char *)((void *)0), (short_u )1025, (char_u *)((void *)0),
      {(char_u *)0, (char_u *)0L}}, 
        {(char *)"splitbelow", (char *)"sb", (short_u )1025, (char_u *)(& p_sb), {(char_u *)0,
                                                                               (char_u *)0L}}, 
        {(char *)"startofline",
      (char *)"sol", (short_u )3073, (char_u *)(& p_sol), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"statusline",
      (char *)"stl", (short_u )5132, (char_u *)(& p_stl), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"suffixes",
      (char *)"su", (short_u )33796, (char_u *)(& p_su), {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
                                                          (char_u *)0L}}, 
        {(char *)"swapfile", (char *)"swf", (short_u )5153, (char_u *)33, {(char_u *)1,
                                                                        (char_u *)0L}}, 
        {(char *)"swapsync",
      (char *)"sws", (short_u )1028, (char_u *)(& p_sws), {(char_u *)"fsync", (char_u *)0L}}, 
        {(char *)"switchbuf",
      (char *)"swb", (short_u )33796, (char_u *)(& p_swb), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"syntax",
      (char *)"syn", (short_u )1068, (char_u *)34, {(char_u *)"", (char_u *)0L}}, 
        {(char *)"tabstop", (char *)"ts", (short_u )9250, (char_u *)37, {(char_u *)8L,
                                                                      (char_u *)0L}}, 
        {(char *)"tagbsearch",
      (char *)"tbs", (short_u )1025, (char_u *)(& p_tbs), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"taglength",
      (char *)"tl", (short_u )1026, (char_u *)(& p_tl), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"tagrelative",
      (char *)"tr", (short_u )2049, (char_u *)(& p_tr), {(char_u *)0, (char_u *)1}}, 
        {(char *)"tags",
      (char *)"tag", (short_u )33812, (char_u *)(& p_tags), {(char_u *)"./tags,tags",
                                                             (char_u *)0L}}, 
        {(char *)"tagstack", (char *)"tgst", (short_u )1025, (char_u *)(& p_tgst), {(char_u *)1,
                                                                                 (char_u *)0L}}, 
        {(char *)"term",
      (char *)((void *)0), (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"terse",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_terse), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textauto",
      (char *)"ta", (short_u )2049, (char_u *)(& p_ta), {(char_u *)0, (char_u *)1}}, 
        {(char *)"textmode",
      (char *)"tx", (short_u )1569, (char_u *)39, {(char_u *)0, (char_u *)0L}}, 
        {(char *)"textwidth", (char *)"tw", (short_u )3106, (char_u *)38, {(char_u *)0L,
                                                                        (char_u *)0L}}, 
        {(char *)"tildeop",
      (char *)"top", (short_u )3073, (char_u *)(& p_to), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"timeout",
      (char *)"to", (short_u )1025, (char_u *)(& p_timeout), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"timeoutlen",
      (char *)"tm", (short_u )1026, (char_u *)(& p_tm), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"title",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_title), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"titlelen",
      (char *)((void *)0), (short_u )1026, (char_u *)(& p_titlelen), {(char_u *)85L,
                                                                      (char_u *)0L}}, 
        {(char *)"titleold",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titleold), {(char_u *)"Thanks for flying Vim",
                                                                      (char_u *)0L}}, 
        {(char *)"titlestring",
      (char *)((void *)0), (short_u )1028, (char_u *)(& p_titlestring), {(char_u *)"",
                                                                         (char_u *)0L}}, 
        {(char *)"ttimeout",
      (char *)((void *)0), (short_u )3073, (char_u *)(& p_ttimeout), {(char_u *)0,
                                                                      (char_u *)0L}}, 
        {(char *)"ttimeoutlen",
      (char *)"ttm", (short_u )1026, (char_u *)(& p_ttm), {(char_u *)-1L, (char_u *)0L}}, 
        {(char *)"ttybuiltin",
      (char *)"tbi", (short_u )1025, (char_u *)(& p_tbi), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"ttyfast",
      (char *)"tf", (short_u )1537, (char_u *)(& p_tf), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"ttymouse",
      (char *)"ttym", (short_u )1604, (char_u *)(& p_ttym), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"ttyscroll",
      (char *)"tsl", (short_u )1026, (char_u *)(& p_ttyscroll), {(char_u *)999L, (char_u *)0L}}, 
        {(char *)"ttytype",
      (char *)"tty", (short_u )18004, (char_u *)(& term_strings[0]), {(char_u *)"",
                                                                      (char_u *)0L}}, 
        {(char *)"undolevels",
      (char *)"ul", (short_u )1026, (char_u *)(& p_ul), {(char_u *)1000L, (char_u *)0L}}, 
        {(char *)"updatecount",
      (char *)"uc", (short_u )1026, (char_u *)(& p_uc), {(char_u *)200L, (char_u *)0L}}, 
        {(char *)"updatetime",
      (char *)"ut", (short_u )1026, (char_u *)(& p_ut), {(char_u *)4000L, (char_u *)0L}}, 
        {(char *)"verbose",
      (char *)"vbs", (short_u )1026, (char_u *)(& p_verbose), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"viminfo",
      (char *)"vi", (short_u )33796, (char_u *)(& p_viminfo), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"visualbell",
      (char *)"vb", (short_u )1025, (char_u *)(& p_vb), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"w300",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w1200",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"w9600",
      (char *)((void *)0), (short_u )1026, (char_u *)((void *)0), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"warn",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_warn), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"weirdinvert",
      (char *)"wiv", (short_u )29697, (char_u *)(& p_wiv), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"whichwrap",
      (char *)"ww", (short_u )34820, (char_u *)(& p_ww), {(char_u *)"", (char_u *)"b,s"}}, 
        {(char *)"wildchar",
      (char *)"wc", (short_u )2050, (char_u *)(& p_wc), {(char_u *)5L, (char_u *)((long )'\t')}}, 
        {(char *)"wildcharm",
      (char *)"wcm", (short_u )1026, (char_u *)(& p_wcm), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wildignore",
      (char *)"wig", (short_u )33796, (char_u *)(& p_wig), {(char_u *)"", (char_u *)0L}}, 
        {(char *)"wildmenu",
      (char *)"wmnu", (short_u )1025, (char_u *)(& p_wmnu), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"wildmode",
      (char *)"wim", (short_u )33796, (char_u *)(& p_wim), {(char_u *)"full", (char_u *)0L}}, 
        {(char *)"winaltkeys",
      (char *)"wak", (short_u )1028, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                             (char_u *)0L}}, 
        {(char *)"window", (char *)"wi", (short_u )1026, (char_u *)((void *)0), {(char_u *)0L,
                                                                              (char_u *)0L}}, 
        {(char *)"winheight",
      (char *)"wh", (short_u )1026, (char_u *)(& p_wh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"winminheight",
      (char *)"wmh", (short_u )1026, (char_u *)(& p_wmh), {(char_u *)1L, (char_u *)0L}}, 
        {(char *)"wrap",
      (char *)((void *)0), (short_u )9249, (char_u *)41, {(char_u *)1, (char_u *)0L}}, 
        {(char *)"wrapmargin",
      (char *)"wm", (short_u )1058, (char_u *)40, {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"wrapscan", (char *)"ws", (short_u )1025, (char_u *)(& p_ws), {(char_u *)1,
                                                                             (char_u *)0L}}, 
        {(char *)"write",
      (char *)((void *)0), (short_u )1025, (char_u *)(& p_write), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writeany",
      (char *)"wa", (short_u )1025, (char_u *)(& p_wa), {(char_u *)0, (char_u *)0L}}, 
        {(char *)"writebackup",
      (char *)"wb", (short_u )3073, (char_u *)(& p_wb), {(char_u *)1, (char_u *)0L}}, 
        {(char *)"writedelay",
      (char *)"wd", (short_u )1026, (char_u *)(& p_wd), {(char_u *)0L, (char_u *)0L}}, 
        {(char *)"t_AB",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[40]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AF",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[39]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_AL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[3]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_al",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[2]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_bc",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[32]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[8]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_ce",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[1]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[7]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_cm",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[24]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Co",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[34]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_CS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[33]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_cs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[6]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_da",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[9]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_db",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[10]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_DL",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[5]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_dl",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[4]), {(char_u *)"",
                                                                            (char_u *)0L}}, 
        {(char *)"t_fs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[46]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IE",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[44]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_IS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[43]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ke",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[29]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ks",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[28]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_le",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[41]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[38]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_md",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[16]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_me",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[14]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_mr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[15]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ms",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[23]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_nd",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[42]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_op",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[50]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RI",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[26]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_RV",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[49]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[36]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_Sf",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[35]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_se",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[17]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_so",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[18]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_sr",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[25]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ts",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[45]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_te",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[31]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ti",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[30]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ue",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[21]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_us",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[22]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vb",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[27]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ve",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[12]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vi",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[11]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_vs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[13]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WP",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[47]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_WS",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[48]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_xs",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[37]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZH",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[19]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)"t_ZR",
      (char *)((void *)0), (short_u )17412, (char_u *)(& term_strings[20]), {(char_u *)"",
                                                                             (char_u *)0L}}, 
        {(char *)((void *)0),
      (char *)((void *)0), (short_u )0, (char_u *)((void *)0), {(char_u *)((void *)0),
                                                                (char_u *)((void *)0)}}};
static char *p_bg_values[3]  = {      (char *)"light",      (char *)"dark",      (char *)((void *)0)};
static char *p_nf_values[3]  = {      (char *)"octal",      (char *)"hex",      (char *)((void *)0)};
static char *p_ff_values[4]  = {      (char *)"unix",      (char *)"dos",      (char *)"mac",      (char *)((void *)0)};
static char *p_sessopt_values[11]  = 
  {      (char *)"buffers",      (char *)"winpos",      (char *)"resize",      (char *)"winsize", 
        (char *)"options",      (char *)"help",      (char *)"blank",      (char *)"globals", 
        (char *)"slash",      (char *)"unix",      (char *)((void *)0)};
static char *p_mousem_values[5]  = {      (char *)"extend",      (char *)"popup",      (char *)"popup_setpos",      (char *)"mac", 
        (char *)((void *)0)};
static char *p_slm_values[4]  = {      (char *)"mouse",      (char *)"key",      (char *)"cmd",      (char *)((void *)0)};
static char *p_sel_values[4]  = {      (char *)"inclusive",      (char *)"exclusive",      (char *)"old",      (char *)((void *)0)};
static char *p_ttym_values[5]  = {      (char *)"xterm",      (char *)"xterm2",      (char *)"dec",      (char *)"netterm", 
        (char *)((void *)0)};
static char *p_km_values[3]  = {      (char *)"startsel",      (char *)"stopsel",      (char *)((void *)0)};
static char *p_bsdir_values[4]  = {      (char *)"current",      (char *)"last",      (char *)"buffer",      (char *)((void *)0)};
static char *p_scbopt_values[4]  = {      (char *)"ver",      (char *)"hor",      (char *)"jump",      (char *)((void *)0)};
static char *p_swb_values[3]  = {      (char *)"useopen",      (char *)"split",      (char *)((void *)0)};
static char *p_dy_values[2]  = {      (char *)"lastline",      (char *)((void *)0)};
static char *p_cb_values[3]  = {      (char *)"unnamed",      (char *)"autoselect",      (char *)((void *)0)};
static char *p_bs_values[4]  = {      (char *)"indent",      (char *)"eol",      (char *)"start",      (char *)((void *)0)};
static void set_option_default(int opt_idx , int dofree ) ;
static void set_options_default(int dofree ) ;
static char_u *illegal_char(char_u *errbuf___0 , int c ) ;
static void did_set_title(int icon ) ;
static char_u *option_expand(int opt_idx ) ;
static void set_string_option(int opt_idx , char_u *value ) ;
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) ;
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) ;
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) ;
static void check_redraw(int flags___0 ) ;
static int findoption(char_u *arg ) ;
static int find_key_option(char_u *arg ) ;
static void showoptions(int all ) ;
static int option_not_default(struct vimoption *p___0 ) ;
static void showoneopt(struct vimoption *p___0 ) ;
static int istermoption(struct vimoption *p___0 ) ;
static char_u *get_varp(struct vimoption *p___0 ) ;
static void option_value2string(struct vimoption *opp ) ;
static void paste_option_changed(void) ;
static void compatible_set(void) ;
static void fill_breakat_flags(void) ;
static int check_opt_strings(char_u *val , char **values , int list ) ;
static int check_opt_wim(void) ;
void set_init_1(void) 
{







































































}
static void set_option_default(int opt_idx , int dofree ) 
{




















































}
static void set_options_default(int dofree ) 
{








































}
void set_string_default(char *name___1 , char_u *val ) 
{





















}
void set_number_default(char *name___1 , long val ) 
{









}
void set_init_2(void) 
{























}
void set_init_3(void) 
{


























































































}
void set_title_defaults(void) 
{






























}
int do_set(char_u *arg , int modeline ) 
{











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static char_u *illegal_char(char_u *errbuf___0 , int c ) 
{













}
static void did_set_title(int icon ) 
{























}
void set_options_bin(int oldval , int newval ) 
{
























}
int get_viminfo_parameter(int type ) 
{





















}
char_u *find_viminfo_parameter(int type ) 
{




























}
static char_u *option_expand(int opt_idx ) 
{

























}
void check_options(void) 
{





























}
void check_buf_options(BUF *buf___3 ) 
{












































}
void free_string_option(char_u *p___0 ) 
{










}
void set_term_option_alloced(char_u **p___0 ) 
{




















}
void set_string_option_direct(char_u *name___1 , int opt_idx , char_u *val , int dofree ) 
{




































}
static void set_string_option(int opt_idx , char_u *value ) 
{
























}
static struct lcstab lcstab[4]  = {      {& lcs_eol, (char *)"eol"}, 
        {& lcs_ext, (char *)"extends"}, 
        {& lcs_tab2, (char *)"tab"}, 
        {& lcs_trail, (char *)"trail"}};
static char_u *did_set_string_option(int opt_idx , char_u **varp , int new_value_alloced ,
                                     char_u *oldval , char_u *errbuf___0 ) 
{




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static char_u errbuf[80]  ;
char_u *check_stl_option(char_u *s ) 
{












































































































































}
static char_u *set_bool_option(int opt_idx , char_u *varp , int value ) 
{


























































































































































































}
static char_u *set_num_option(int opt_idx , char_u *varp , long value , char_u *errbuf___0 ) 
{












































































































































































































































}
static void check_redraw(int flags___0 ) 
{
































}
static short quick_tab[27]  = {      (short)0,      (short)0};
static int findoption(char_u *arg ) 
{









































































































}
int get_option_value(char_u *name___1 , long *numval , char_u **stringval ) 
{





































}
void set_option_value(char_u *name___1 , long number , char_u *string___0 ) 
{



































}
char_u *get_term_code(char_u *tname ) 
{





































}
char_u *get_highlight_default(void) 
{











}
static int find_key_option(char_u *arg ) 
{






























}
static void showoptions(int all ) 
{


















































































































































































}
static int option_not_default(struct vimoption *p___0 ) 
{































}
static void showoneopt(struct vimoption *p___0 ) 
{

































}
int makeset(FILE *fd ) 
{




























































































}
void clear_termoptions(void) 
{












































}
void set_term_defaults(void) 
{



































}
static int istermoption(struct vimoption *p___0 ) 
{














}
void comp_col(void) 
{




















































}
static char_u *get_varp(struct vimoption *p___0 ) 
{


















































































































































































































}
void win_copy_options(WIN *wp_from , WIN *wp_to ) 
{










}
void buf_copy_options(BUF *bp_from , BUF *bp_to , int flags___0 ) 
{





























































































































































































}
static int expand_option_idx  =    -1;
static char_u expand_option_name[5]  = {      (char_u )'t',      (char_u )'_',      (char_u )'\000',      (char_u )'\000', 
        (char_u )'\000'};
void set_context_in_set_cmd(char_u *arg ) 
{











































































































































































































































































}
int ExpandSettings(vim_regexp *prog , int *num_file , char_u ***file ) 
{




















































































































































































































































































}
int ExpandOldSetting(int *num_file , char_u ***file ) 
{
















































}
static void option_value2string(struct vimoption *opp ) 
{
















































































}
int has_format_option(int x___0 ) 
{











}
int shortmess(int x___0 ) 
{






























}
static int old_p_paste  =    0;
static int save_sm___0  =    0;
static int save_ru  =    0;
static void paste_option_changed(void) 
{



















































































}
void vimrc_found(void) 
{



































}
void change_compatible(int on ) 
{















}
int option_was_set(char_u *name___1 ) 
{














}
static void compatible_set(void) 
{









































}
static void fill_breakat_flags(void) 
{
































}
static int check_opt_strings(char_u *val , char **values , int list ) 
{

















































}
static int check_opt_wim(void) 
{

































































































































}
int can_bs(int what ) 
{



























}
#pragma merger("0","/tmp/cil-tVUl1r6X.i","-O0")
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern void (*sigset(int  , void (*func)(int  ) ))(int  ) ;
extern Display *XOpenDisplay(char const   * ) ;
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
extern int XCloseDisplay(Display * ) ;
extern int XFlush(Display * ) ;
extern int XFree(void * ) ;
extern int XGetErrorText(Display * , int  , char * , int  ) ;
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
extern int XSync(Display * , int  ) ;
extern int XGetWMIconName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
extern int XGetWMNormalHints(Display * , Window  , XSizeHints * , long * ) ;
extern void XSetWMIconName(Display * , Window  , XTextProperty * ) ;
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
extern void XtAppProcessEvent(XtAppContext  , XtInputMask  ) ;
extern XtInputMask XtAppPending(XtAppContext  ) ;
extern void XtRealizeWidget(Widget  ) ;
extern void XtDestroyWidget(Widget  ) ;
extern Widget XtVaCreatePopupShell(char const   * , WidgetClass  , Widget   , ...)  __attribute__((__sentinel__(0))) ;
extern Widget XtVaAppCreateShell(char const   * , char const   * , WidgetClass  ,
                                 Display *  , ...)  __attribute__((__sentinel__(0))) ;
extern Display *XtOpenDisplay(XtAppContext  , char const   * , char const   * , char const   * ,
                              XrmOptionDescRec * , Cardinal  , int * , char ** ) ;
void mch_write(char_u *s , int len___0 ) ;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) ;
int mch_char_avail(void) ;
void mch_delay(long msec , int ignoreinput ) ;
void mch_suspend(void) ;
int vim_is_xterm(char_u *name___1 ) ;
int use_xterm_mouse(void) ;
int vim_is_iris(char_u *name___1 ) ;
int vim_is_fastterm(char_u *name___1 ) ;
void mch_settmode(int tmode ) ;
void get_stty(void) ;
int mch_get_winsize(void) ;
void mch_set_winsize(void) ;
void mch_breakcheck(void) ;
void setup_xterm_clip(void) ;
void start_xterm_trace(int button ) ;
void stop_xterm_trace(void) ;
int clip_xterm_own_selection(void) ;
void clip_xterm_lose_selection(void) ;
void clip_xterm_request_selection(void) ;
void clip_xterm_set_selection(void) ;
void set_mouse_termcode(int n , char_u *s ) ;
void del_mouse_termcode(int n ) ;
void getlinecol(void) ;
int term_is_8bit(char_u *name___1 ) ;
void out_str_nf(char_u *s ) ;
void term_set_winsize(int width , int height ) ;
void term_settitle(char_u *title ) ;
int vim_is_input_buf_full(void) ;
int vim_is_input_buf_empty(void) ;
void add_to_input_buf(char_u *s , int len___0 ) ;
int read_from_input_buf(char_u *buf___3 , long maxlen ) ;
void fill_input_buf(int exit_on_error ) ;
int check_col(int col ) ;
int check_row(int row ) ;
void open_app_context(void) ;
void x11_setup_atoms(Display *dpy ) ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) ;
void clip_x11_lose_selection(Widget myShell ) ;
int clip_x11_own_selection(Widget myShell ) ;
void clip_x11_set_selection(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
extern __pid_t wait(int *__stat_loc ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * ) ;
extern WidgetClass topLevelShellWidgetClass ;
extern WidgetClass applicationShellWidgetClass ;
extern char const   XtStrings[] ;
static Widget xterm_Shell  =    (Widget )0;
static void xterm_update(void) ;
Window x11_window  =    (Window )0;
Display *x11_display  =    (Display *)((void *)0);
int got_x_error  =    0;
static int get_x11_windis(void) ;
static void set_x11_title(char_u *title ) ;
static void set_x11_icon(char_u *icon ) ;
static int get_x11_title(int test_only ) ;
static int get_x11_icon(int test_only ) ;
static char_u *oldtitle  =    (char_u *)((void *)0);
static int did_set_title___0  =    0;
static char_u *oldicon  =    (char_u *)((void *)0);
static int did_set_icon  =    0;
static void may_core_dump(void) ;
static int WaitForChar(long msec ) ;
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) ;
static int do_xterm_trace(void) ;
static void handle_resize(void) ;
static void sig_winch(int sigarg ) ;
static void catch_sigint(int sigarg ) ;
static void sig_alarm(int sigarg ) ;
static void deathtrap(int sigarg ) ;
static void set_signals(void) ;
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) ;
static int have_wildcard(int num , char_u **file ) ;
static int have_dollars(int num , char_u **file ) ;
static int pstrcmp(void const   *a , void const   *b ) ;
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) ;
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) ;
static int do_resize___0  =    0;
static char_u *extra_shell_arg  =    (char_u *)((void *)0);
static int show_shell_mess  =    1;
static int deadly_signal  =    0;
static int curr_tmode  =    0;
static struct signalinfo signal_info[22]  = 
  {      {1, (char *)"HUP", (char)1}, 
        {3, (char *)"QUIT", (char)1}, 
        {4, (char *)"ILL", (char)1}, 
        {5, (char *)"TRAP", (char)1}, 
        {6, (char *)"ABRT", (char)1}, 
        {8, (char *)"FPE", (char)1}, 
        {7, (char *)"BUS", (char)1}, 
        {11, (char *)"SEGV", (char)1}, 
        {31, (char *)"SYS", (char)1}, 
        {14, (char *)"ALRM", (char)0}, 
        {15, (char *)"TERM", (char)1}, 
        {26, (char *)"VTALRM", (char)1}, 
        {27, (char *)"PROF", (char)1}, 
        {24, (char *)"XCPU", (char)1}, 
        {25, (char *)"XFSZ", (char)1}, 
        {10, (char *)"USR1", (char)1}, 
        {12, (char *)"USR2", (char)1}, 
        {2, (char *)"INT", (char)0}, 
        {28, (char *)"WINCH", (char)0}, 
        {20, (char *)"TSTP", (char)0}, 
        {13, (char *)"PIPE", (char)0}, 
        {-1, (char *)"Unknown!", (char)0}};
void mch_write(char_u *s , int len___0 ) 
{













}
static int once_already  =    0;
int mch_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{








































































































}
static void handle_resize(void) 
{









}
int mch_char_avail(void) 
{








}
void mch_delay(long msec , int ignoreinput ) 
{




















}
static void sig_winch(int sigarg ) 
{









}
static void catch_sigint(int sigarg ) 
{









}
static void sig_alarm(int sigarg ) 
{





}
static int entered___1  =    0;
static void deathtrap(int sigarg ) 
{
















































}
void mch_suspend(void) 
{















}
void mch_windinit(void) 
{











}
static void set_signals(void) 
{




















}
void reset_signals(void) 
{








}
static void catch_signals(void (*func_deadly)() , void (*func_other)() ) 
{



























}
int mch_check_win(int argc , char **argv ) 
{











}
int mch_input_isatty(void) 
{











}
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) ;
static int x_error_check(Display *dpy , XErrorEvent *error_event ) ;
static int test_x11_window(Display *dpy ) ;
static int x_error_handler(Display *dpy , XErrorEvent *error_event ) 
{










}
static int x_error_check(Display *dpy , XErrorEvent *error_event ) 
{






}
static int test_x11_window(Display *dpy ) 
{





























}
static int get_x11_thing(int get_title , int test_only ) ;
static int result  =    -1;
static int x11_display_from  =    0;
static int get_x11_windis(void) 
{





























































































}
static int get_x11_title(int test_only ) 
{








}
static int get_x11_icon(int test_only ) 
{























}
static int get_x11_thing(int get_title , int test_only ) 
{






























































































}
static void set_x11_title(char_u *title ) 
{













}
static void set_x11_icon(char_u *icon ) 
{













}
int mch_can_restore_title(void) 
{








}
int mch_can_restore_icon(void) 
{








}
static int recursive___1  =    0;
void mch_settitle(char_u *title , char_u *icon ) 
{













































































}
void mch_restore_title(int which ) 
{

































}
int vim_is_xterm(char_u *name___1 ) 
{



































}
int use_xterm_mouse(void) 
{























}
int vim_is_iris(char_u *name___1 ) 
{


























}
int vim_is_fastterm(char_u *name___1 ) 
{





































































}
int mch_get_user_name(char_u *s , int len___0 ) 
{










}
int mch_get_uname(uid_t uid , char_u *s , int len___0 ) 
{






















}
void mch_get_host_name(char_u *s , int len___0 ) 
{










}
long mch_get_pid(void) 
{








}
int mch_dirname(char_u *buf___3 , int len___0 ) 
{


















}
static int dont_fchdir  =    0;
int mch_FullName(char_u *fname , char_u *buf___3 , int len___0 , int force ) 
{



















































































































}
int mch_isFullName(char_u *fname ) 
{














}
long mch_getperm(char_u *name___1 ) 
{












}
int mch_setperm(char_u *name___1 , long perm ) 
{














}
void mch_hide(char_u *name___1 ) 
{





}
int mch_isdir(char_u *name___1 ) 
{





















}
void mch_windexit(int r ) 
{













































}
static void may_core_dump(void) 
{












}
static int first  =    1;
static struct termios told  ;
void mch_settmode(int tmode ) 
{



























}
void get_stty(void) 
{





























}
static int ison  =    0;
void mch_setmouse(int on ) 
{



































}
void check_mouse_termcode(void) 
{

































}
int mch_screenmode(char_u *arg ) 
{








}
int mch_get_winsize(void) 
{












































































}
void mch_set_winsize(void) 
{












}
int mch_call_shell(char_u *cmd , int options___0 ) 
{





































































































































































































































}
void mch_breakcheck(void) 
{















}
static int WaitForChar(long msec ) 
{




































































}
static int RealWaitForChar(int fd , long msec , int *check_for_gpm ) 
{



















































































}
static int pstrcmp(void const   *a , void const   *b ) 
{








}
int mch_expandpath(struct growarray *gap , char_u *path , int flags___0 ) 
{








}
static int unix_expandpath(struct growarray *gap , char_u *path , int wildoff , int flags___0 ) 
{
















































































































































































































}
static int did_find_nul  =    0;
int mch_expand_wildcards(int num_pat , char_u **pat , int *num_file , char_u ***file ,
                         int flags___0 ) 
{





























































































































































































































































































































































































































































































































































































































}
static int save_patterns(int num_pat , char_u **pat , int *num_file , char_u ***file ) 
{




























}
int mch_has_wildcard(char_u *p___0 ) 
{






























}
static int have_wildcard(int num , char_u **file ) 
{























}
static int have_dollars(int num , char_u **file ) 
{























}
static int xterm_trace  =    -1;
static int xterm_button  ;
void setup_xterm_clip(void) 
{
















































































}
void start_xterm_trace(int button ) 
{





















}
void stop_xterm_trace(void) 
{









}
static char_u *mouse_code  ;
static char_u mouse_name[2]  = {      (char_u )251,      (char_u )'X'};
static int prev_row  =    0;
static int prev_col  =    0;
static XSizeHints xterm_hints  ;
static int do_xterm_trace(void) 
{






























































































}
void clear_xterm_clip(void) 
{

















}
static void xterm_update(void) 
{




























}
int clip_xterm_own_selection(void) 
{











}
void clip_xterm_lose_selection(void) 
{










}
void clip_xterm_request_selection(void) 
{










}
void clip_xterm_set_selection(void) 
{








}
#pragma merger("0","/tmp/cil-8goyHUav.i","-O0")
char_u *all_cflags ;
char_u *all_lflags ;
char_u *compiled_user ;
char_u *compiled_sys ;
char_u *default_vim_dir  =    (char_u *)"/vim/source/share/vim";
char_u *default_vimruntime_dir  =    (char_u *)"";
char_u *all_cflags  =    (char_u *)"cilly --merge --keepmerged -c -I. -Iproto -DHAVE_CONFIG_H     -O0     ";
char_u *all_lflags  =    (char_u *)"cilly --merge --keepmerged  -o vim      -lXt -lX11 -lXdmcp -lncurses     ";
char_u *compiled_user  =    (char_u *)"qxin6";
char_u *compiled_sys  =    (char_u *)"qx-debloat";
#pragma merger("0","/tmp/cil-tVOikzOv.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
static void qf_msg(void) ;
static void qf_free(int idx ) ;
static char_u *qf_types(int c , int nr ) ;
static int qf_get_fnum(char_u *directory , char_u *fname ) ;
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) ;
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) ;
static char_u *qf_guess_filepath(char_u *filename ) ;
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) ;
static struct dir_stack_t *dir_stack  =    (struct dir_stack_t *)((void *)0);
struct qf_list qf_lists[10]  ;
static int qf_curlist  =    0;
static int qf_listcount  =    0;
static struct fmtpattern fmt_pat[7]  = {      {(char_u )'f', (char *)"\\f\\+"}, 
        {(char_u )'n', (char *)"\\d\\+"}, 
        {(char_u )'l', (char *)"\\d\\+"}, 
        {(char_u )'c', (char *)"\\d\\+"}, 
        {(char_u )'t', (char *)"."}, 
        {(char_u )'m', (char *)".\\+"}, 
        {(char_u )'r', (char *)".*"}};
int qf_init(char_u *efile , char_u *errorformat ) 
{
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int qf_get_fnum(char_u *directory , char_u *fname ) 
{


































































}
static char_u *qf_push_dir(char_u *dirbuf , struct dir_stack_t **stackptr ) 
{






























































































}
static char_u *qf_pop_dir(struct dir_stack_t **stackptr ) 
{



















}
static void qf_clean_dir_stack(struct dir_stack_t **stackptr ) 
{




















}
static char_u *qf_guess_filepath(char_u *filename ) 
{



























































}
static char_u *e_no_more_items  =    (char_u *)"No more items";
void qf_jump(int dir , int errornr , int forceit ) 
{





















































































































































































































































































































}
void qf_list(char_u *arg , int all ) 
{























































































































































































































































}
void qf_older(int count___2 ) 
{


























}
void qf_newer(int count___2 ) 
{


























}
static void qf_msg(void) 
{








}
static void qf_free(int idx ) 
{





















}
void qf_mark_adjust(linenr_t line1 , linenr_t line2 , long amount , long amount_after ) 
{





















































}
static char_u buf___2[20]  ;
static char_u cc[3]  ;
static char_u *qf_types(int c , int nr ) 
{













































}
#pragma merger("0","/tmp/cil-yZLjftJd.i","-O0")
int vim_regcomp_had_eol(void) ;
static int myisalnum(int c ) ;
static int myisalnum(int c ) 
{








}
static int myisalpha(int c ) ;
static int myisalpha(int c ) 
{








}
static int myiscntrl(int c ) ;
static int myiscntrl(int c ) 
{








}
static int myisdigit(int c ) ;
static int myisdigit(int c ) 
{








}
static int myisgraph(int c ) ;
static int myisgraph(int c ) 
{








}
static int myislower(int c ) ;
static int myislower(int c ) 
{








}
static int myispunct(int c ) ;
static int myispunct(int c ) 
{








}
static int myisupper(int c ) ;
static int myisupper(int c ) 
{








}
static int myisxdigit(int c ) ;
static int myisxdigit(int c ) 
{








}
static int re_ismult(int c ) ;
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) ;
static char_u *cstrchr(char_u *s , int c ) ;
static int re_ismult(int c ) 
{






















}
static char_u *reg_prev_sub  ;
static char_u REGEXP_INRANGE[5]  = {      (char_u )']',      (char_u )'^',      (char_u )'-',      (char_u )'\\', 
        (char_u )'\000'};
static char_u REGEXP_ABBR[5]  = {      (char_u )'r',      (char_u )'t',      (char_u )'e',      (char_u )'b', 
        (char_u )'\000'};
static int backslash_trans(int c ) ;
static int my_isblank(int c ) ;
static int my_istab(int c ) ;
static int my_isbspace(int c ) ;
static int my_isreturn(int c ) ;
static int my_isesc(int c ) ;
static int (*skip_class_name(char_u **pp ))(int  ) ;
static char_u *skip_range(char_u *p___0 ) ;
static void init_class_tab(void) ;
static int backslash_trans(int c ) 
{





























}
static int my_isblank(int c ) 
{














}
static int my_istab(int c ) 
{





}
static int my_isbspace(int c ) 
{





}
static int my_isreturn(int c ) 
{





}
static int my_isesc(int c ) 
{





}
static namedata_t const   class_names[16]  = 
  {      {sizeof("alnum:]") - 1UL, & myisalnum, {(char_u )'a', (char_u )'l', (char_u )'n',
                                             (char_u )'u', (char_u )'m', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("alpha:]") - 1UL, & myisalpha, {(char_u )'a', (char_u )'l', (char_u )'p',
                                             (char_u )'h', (char_u )'a', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("blank:]") - 1UL, & my_isblank, {(char_u )'b', (char_u )'l', (char_u )'a',
                                              (char_u )'n', (char_u )'k', (char_u )':',
                                              (char_u )']', (char_u )'\000'}}, 
        {sizeof("cntrl:]") - 1UL, & myiscntrl, {(char_u )'c', (char_u )'n', (char_u )'t',
                                             (char_u )'r', (char_u )'l', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("digit:]") - 1UL, & myisdigit, {(char_u )'d', (char_u )'i', (char_u )'g',
                                             (char_u )'i', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("graph:]") - 1UL, & myisgraph, {(char_u )'g', (char_u )'r', (char_u )'a',
                                             (char_u )'p', (char_u )'h', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("lower:]") - 1UL, & myislower, {(char_u )'l', (char_u )'o', (char_u )'w',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("print:]") - 1UL, & vim_isprintc, {(char_u )'p', (char_u )'r', (char_u )'i',
                                                (char_u )'n', (char_u )'t', (char_u )':',
                                                (char_u )']', (char_u )'\000'}}, 
        {sizeof("punct:]") - 1UL, & myispunct, {(char_u )'p', (char_u )'u', (char_u )'n',
                                             (char_u )'c', (char_u )'t', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("space:]") - 1UL, & vim_isspace, {(char_u )'s', (char_u )'p', (char_u )'a',
                                               (char_u )'c', (char_u )'e', (char_u )':',
                                               (char_u )']', (char_u )'\000'}}, 
        {sizeof("upper:]") - 1UL, & myisupper, {(char_u )'u', (char_u )'p', (char_u )'p',
                                             (char_u )'e', (char_u )'r', (char_u )':',
                                             (char_u )']', (char_u )'\000'}}, 
        {sizeof("xdigit:]") - 1UL, & myisxdigit, {(char_u )'x', (char_u )'d', (char_u )'i',
                                               (char_u )'g', (char_u )'i', (char_u )'t',
                                               (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("tab:]") - 1UL,
      & my_istab, {(char_u )'t', (char_u )'a', (char_u )'b', (char_u )':', (char_u )']',
                   (char_u )'\000'}}, 
        {sizeof("return:]") - 1UL, & my_isreturn, {(char_u )'r', (char_u )'e', (char_u )'t',
                                                (char_u )'u', (char_u )'r', (char_u )'n',
                                                (char_u )':', (char_u )']', (char_u )'\000'}}, 
        {sizeof("backspace:]") - 1UL,
      & my_isbspace, {(char_u )'b', (char_u )'a', (char_u )'c', (char_u )'k', (char_u )'s',
                      (char_u )'p', (char_u )'a', (char_u )'c', (char_u )'e', (char_u )':',
                      (char_u )']', (char_u )'\000'}}, 
        {sizeof("escape:]") - 1UL, & my_isesc, {(char_u )'e', (char_u )'s', (char_u )'c',
                                             (char_u )'a', (char_u )'p', (char_u )'e',
                                             (char_u )':', (char_u )']', (char_u )'\000'}}};
static int (*skip_class_name(char_u **pp ))(int  ) 
{




























}
static char_u *skip_range(char_u *p___0 ) 
{
























































































}
static char_u class_tab[256]  ;
static int done  =    0;
static void init_class_tab(void) 
{













































































}
static char_u *regparse  ;
static int num_complex_braces  ;
static int regnpar  ;
static char_u *regcode  ;
static long regsize  ;
static char_u **regendp  ;
static int brace_min[10]  ;
static int brace_max[10]  ;
static int brace_count[10]  ;
static int had_eol  ;
static int reg_magic  ;
static char_u META[48]  = 
  {      (char_u )'.',      (char_u )'[',      (char_u )'(',      (char_u )')', 
        (char_u )'|',      (char_u )'=',      (char_u )'+',      (char_u )'*', 
        (char_u )'<',      (char_u )'>',      (char_u )'i',      (char_u )'I', 
        (char_u )'k',      (char_u )'K',      (char_u )'f',      (char_u )'F', 
        (char_u )'p',      (char_u )'P',      (char_u )'s',      (char_u )'S', 
        (char_u )'d',      (char_u )'D',      (char_u )'x',      (char_u )'X', 
        (char_u )'o',      (char_u )'O',      (char_u )'w',      (char_u )'W', 
        (char_u )'h',      (char_u )'H',      (char_u )'a',      (char_u )'A', 
        (char_u )'l',      (char_u )'L',      (char_u )'u',      (char_u )'U', 
        (char_u )'~',      (char_u )'1',      (char_u )'2',      (char_u )'3', 
        (char_u )'4',      (char_u )'5',      (char_u )'6',      (char_u )'7', 
        (char_u )'8',      (char_u )'9',      (char_u )'{',      (char_u )'\000'};
static void initchr(char_u *str___1 ) ;
static int getchr(void) ;
static int peekchr(void) ;
static int curchr  ;
static void skipchr(void) ;
static void ungetchr(void) ;
static char_u *reg(int paren , int *flagp ) ;
static char_u *regbranch(int *flagp ) ;
static char_u *regpiece(int *flagp ) ;
static char_u *regatom(int *flagp ) ;
static char_u *regnode(int op ) ;
static char_u *regnext(char_u *p___0 ) ;
static void regc(int b ) ;
static void unregc(void) ;
static void reginsert(int op , char_u *opnd ) ;
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) ;
static int read_limits(int start___0 , int end , int *minval , int *maxval ) ;
static void regtail(char_u *p___0 , char_u *val ) ;
static void regoptail(char_u *p___0 , char_u *val ) ;
char_u *skip_regexp(char_u *p___0 , int dirc , int magic ) 
{



















































}
vim_regexp *vim_regcomp(char_u *expr , int magic ) 
{










































































































































}
int vim_regcomp_had_eol(void) 
{





}
static char_u *reg(int paren , int *flagp ) 
{













































































































































}
static char_u *regbranch(int *flagp ) 
{






















































}
static char_u *regpiece(int *flagp ) 
{









































































































































































}
static char_u *regatom(int *flagp ) 
{


























































































































































































































































































































































































































































































































































































































































































































































}
static char_u *regnode(int op ) 
{

























}
static void regc(int b ) 
{












}
static void unregc(void) 
{










}
static void reginsert(int op , char_u *opnd ) 
{




































}
static void reginsert_limits(int op , int minval , int maxval , char_u *opnd ) 
{


























































}
static void regtail(char_u *p___0 , char_u *val ) 
{































}
static void regoptail(char_u *p___0 , char_u *val ) 
{

























}
static int prevchr  ;
static int nextchr  ;
static int at_start  ;
static int prev_at_start  ;
static void initchr(char_u *str___1 ) 
{











}
static int peekchr(void) 
{























































































































}
static void skipchr(void) 
{











}
static int getchr(void) 
{









}
static void ungetchr(void) 
{










}
static int read_limits(int start___0 , int end , int *minval , int *maxval ) 
{






























































































}
static char_u *reginput  ;
static char_u *regbol  ;
static char_u **regstartp  ;
static int need_clear_subexpr  ;
static int regtry(vim_regexp *prog , char_u *string___0 ) ;
static void clear_subexpr(void) ;
static int regmatch(char_u *prog ) ;
static int regrepeat(char_u *p___0 ) ;
int vim_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{


























































































































}
static int regtry(vim_regexp *prog , char_u *string___0 ) 
{





















}
static void clear_subexpr(void) 
{












}
static int break_count  =    0;
static int regmatch(char_u *prog ) 
{
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int regrepeat(char_u *p___0 ) 
{










































































































































































































































































































































































































































































































}
static char_u *regnext(char_u *p___0 ) 
{
















}
static int cstrncmp(char_u *s1 , char_u *s2 , int n ) 
{
















}
static char_u *cstrchr(char_u *s , int c ) 
{
























































}
static fptr do_upper(char_u *d , int c ) ;
static fptr do_Upper(char_u *d , int c ) ;
static fptr do_lower(char_u *d , int c ) ;
static fptr do_Lower(char_u *d , int c ) ;
static fptr do_upper(char_u *d , int c ) 
{









}
static fptr do_Upper(char_u *d , int c ) 
{









}
static fptr do_lower(char_u *d , int c ) 
{









}
static fptr do_Lower(char_u *d , int c ) 
{









}
char_u *regtilde(char_u *source , int magic ) 
{






































































































}
void vim_regnewptr(vim_regexp *prog , char_u *old_ptr , char_u *new_ptr ) 
{






















}
int vim_regsub(vim_regexp *prog , char_u *source , char_u *dest , int copy , int magic ) 
{










































































































































































































































}
#pragma merger("0","/tmp/cil-BEhIo2Hj.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
char *mediumVersion ;
void screen_stop_highlight(void) ;
void reset_cterm_colors(void) ;
void invalidate_botline_win(WIN *wp ) ;
void validate_cheight(void) ;
void win_rest_invalid(WIN *wp ) ;
vim_regexp *last_pat_prog(void) ;
void syntax_start(WIN *wp , linenr_t lnum ) ;
int syntax_check_changed(linenr_t lnum ) ;
int get_syntax_attr(colnr_t col , char_u *line ) ;
struct attr_entry *syn_term_attr2entry(int attr ) ;
struct attr_entry *syn_cterm_attr2entry(int attr ) ;
void term_windgoto(int row , int col ) ;
void term_cursor_right(int i___0 ) ;
void term_append_lines(int line_count ) ;
void term_delete_lines(int line_count ) ;
void term_fg_color(int n ) ;
void term_bg_color(int n ) ;
void scroll_region_set(WIN *wp , int off___0 ) ;
void clip_update_selection(void) ;
int clip_isautosel(void) ;
int highest_patch(void) ;
int win_alloc_lsize(WIN *wp ) ;
void win_free_lsize(WIN *wp ) ;
void win_drag_status_line(int offset ) ;
static int screen_attr  =    0;
static int screen_cur_row  ;
static int screen_cur_col  ;
vim_regexp *search_hl_prog  =    (vim_regexp *)((void *)0);
int search_hl_attr  ;
int search_hl_ic  ;
static char_u *current_LinePointer  ;
static void win_update(WIN *wp ) ;
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) ;
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) ;
static void screen_line(int row , int endcol , int clear_rest ) ;
static void start_search_hl(void) ;
static void end_search_hl(void) ;
static void screen_start_highlight(int attr ) ;
static void comp_botline(void) ;
static void screen_char(char_u *p___0 , int row , int col ) ;
static void screenclear2(void) ;
static void lineclear(char_u *p___0 ) ;
static void check_cursor_moved(WIN *wp ) ;
static void curs_rows(int do_botline ) ;
static void validate_virtcol_win(WIN *wp ) ;
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) ;
static void msg_pos_mode(void) ;
static int highlight_status(int *attr , int is_curwin ) ;
static void win_redr_custom(WIN *wp , int Ruler ) ;
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) ;
static void win_redr_ruler(WIN *wp , int always ) ;
static void get_rel_pos(WIN *wp , char_u *str___1 ) ;
static int get_scroll_overlap(linenr_t lnum , int dir ) ;
static void intro_message(void) ;
void update_screenline(void) 
{







































































































































}
void redraw_later(int type ) 
{











}
void redraw_all_later(int type ) 
{






















}
void redraw_curbuf_later(int type ) 
{
























}
void update_curbuf(int type ) 
{









}
static int did_intro  =    0;
void update_screen(int type ) 
{












































































































































































}
void update_other_win(void) 
{






































}
static int recursive___2  =    0;
static void win_update(WIN *wp ) 
{






































































































































































































































































































































































































































































































































































}
static int win_line(WIN *wp , linenr_t lnum , int startrow , int endrow ) 
{








































































































































































































































































































































































































































































































































































































































































































































































































































}
static int char_needs_redraw(char_u *screenp_from , char_u *screenp_to , int len___0 ) 
{














}
static void screen_line(int row , int endcol , int clear_rest ) 
{







































































































































}
void status_redraw_all(void) 
{






















}
void redraw_statuslines(void) 
{





















}
static char_u *m_gettail(char_u *s ) ;
static int status_match_len(char_u *s ) ;
static char_u *m_gettail(char_u *s ) 
{
































































}
static int status_match_len(char_u *s ) 
{






































}
static int first_match___0  =    0;
void win_redr_status_matches(int num_matches___0 , char_u **matches___0 , int match ) 
{
















































































































































































































































































































}
void win_redr_status(WIN *wp ) 
{



















































































































}
static void win_redr_custom(WIN *wp , int Ruler ) 
{


























































































































}
int build_stl_str(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ) 
{








}
static int build_stl_str_hl(WIN *wp , char_u *out , char_u *fmt , int fillchar , int maxlen ,
                            struct stl_hlrec *hl ) 
{









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
void screen_putchar(int c , int row , int col , int attr ) 
{










}
void screen_puts(char_u *text , int row , int col , int attr ) 
{

















































}
static void start_search_hl(void) 
{














}
static void end_search_hl(void) 
{











}
void screen_start(void) 
{







}
void screen_down(void) 
{









}
static void screen_start_highlight(int attr ) 
{
















































































}
void screen_stop_highlight(void) 
{



























































































































}
void reset_cterm_colors(void) 
{























}
static void screen_char(char_u *p___0 , int row , int col ) 
{



























}
void screen_fill(int start_row , int end_row , int start_col , int end_col , int c1 ,
                 int c2 , int attr ) 
{



































































































































































}
static void comp_botline(void) 
{














































}
static int entered___2  =    0;
void screenalloc(int clear ) 
{



































































































































































}
void screenclear(void) 
{










}
static void screenclear2(void) 
{
















































}
static void lineclear(char_u *p___0 ) 
{









}
void update_topline_redraw(void) 
{













}
void update_topline(void) 
{



































































































}
void update_curswant(void) 
{












}
void windgoto(int row , int col ) 
{

























































































































































































































































































}
void setcursor(void) 
{














}
void scroll_cursor_top(int min_scroll , int always ) 
{

























































































}
void scroll_cursor_bot(int min_scroll , int set_topbot ) 
{







































































































































































































}
void scroll_cursor_halfway(int atend ) 
{



























































}
void cursor_correct(void) 
{



























































































































}
static void check_cursor_moved(WIN *wp ) 
{






















}
void changed_cline_bef_curs(void) 
{






}
void changed_line_abv_curs(void) 
{






}
void set_topline(WIN *wp , linenr_t lnum ) 
{








}
void validate_botline(void) 
{










}
void invalidate_botline(void) 
{






}
void invalidate_botline_win(WIN *wp ) 
{






}
void approximate_botline(void) 
{






}
int botline_approximated(void) 
{





}
int cursor_valid(void) 
{








}
void validate_cursor(void) 
{













}
void validate_cline_row(void) 
{














}
int may_validate_crow(void) 
{




























}
static void curs_rows(int do_botline ) 
{











































































}
void validate_virtcol(void) 
{








}
static void validate_virtcol_win(WIN *wp ) 
{














}
void validate_cheight(void) 
{














}
void validate_cursor_col(void) 
{




















}
void curs_columns(int scroll ) 
{















































































































































}
void scrolldown(long line_count ) 
{









































































}
void scrollup(long line_count ) 
{


















}
void scrolldown_clamp(void) 
{


























}
void scrollup_clamp(void) 
{

























}
int win_ins_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{








































































































}
int win_del_lines(WIN *wp , int row , int line_count , int invalid , int mayclear ) 
{



















































































}
void win_rest_invalid(WIN *wp ) 
{



















}
static int screen_ins_lines(int off___0 , int row , int line_count , int end ) 
{









































































































































































































































}
int screen_del_lines(int off___0 , int row , int line_count , int end , int force ) 
{





































































































































































































































}
int showmode(void) 
{







































































































































































































}
static void msg_pos_mode(void) 
{







}
void unshowmode(int force ) 
{








































}
static int highlight_status(int *attr , int is_curwin ) 
{


























}
void showruler(int always ) 
{








































}
static void win_redr_ruler(WIN *wp , int always ) 
{



















































































































































}
static void get_rel_pos(WIN *wp , char_u *str___1 ) 
{






























}
void check_for_delay(int check_msg_scroll ) 
{






















}
int screen_valid(int clear ) 
{








}
static int on_status_line  =    0;
static int prev_row___0  =    -1;
static int prev_col___0  =    -1;
int jump_to_mouse(int flags___0 , int *inclusive ) 
{

























































































































































































































































}
int redrawing(void) 
{


























}
int messaging(void) 
{






















}
int onepage(int dir , long count___2 ) 
{






























































































































}
static int get_scroll_overlap(linenr_t lnum , int dir ) 
{










































}
void halfpage(int flag , linenr_t Prenum ) 
{


























































































































}
static char *lines[16]  = 
  {      (char *)"VIM - Vi IMproved",      (char *)"",      (char *)"version ",      (char *)"by Bram Moolenaar et al.", 
        (char *)"",      (char *)"Vim is freely distributable",      (char *)"type  :help uganda<Enter>     if you like Vim ",      (char *)"", 
        (char *)"type  :q<Enter>               to exit         ",      (char *)"type  :help<Enter>  or  <F1>  for on-line help",      (char *)"type  :help version5<Enter>   for version info",      (char *)((void *)0), 
        (char *)"",      (char *)"Running in Vi compatible mode",      (char *)"type  :set nocp<Enter>        for Vim defaults",      (char *)"type  :help cp-default<Enter> for info on this"};
static void intro_message(void) 
{





















































































}
void do_intro(void) 
{










}
#pragma merger("0","/tmp/cil-myjHm73r.i","-O0")
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) ;
static void save_re_pat(int idx , char_u *pat , int magic ) ;
static int inmacro(char_u *opt , char_u *s ) ;
static int check_linecomment(char_u *line ) ;
static int cls(void) ;
static int skip_chars(int cclass , int dir ) ;
static void back_in_line(void) ;
static void find_first_blank(FPOS *posp ) ;
static void findsent_forward(long count___2 , int at_start_sent ) ;
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) ;
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) ;
static char_u *top_bot_msg  =    (char_u *)"search hit TOP, continuing at BOTTOM";
static char_u *bot_top_msg  =    (char_u *)"search hit BOTTOM, continuing at TOP";
static struct spat spats[2]  = {      {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}, 
        {(char_u *)((void *)0), 1, 0, {'/', 0, 0, 0L}}};
static int last_idx  =    0;
static struct spat saved_spats[2]  ;
static int saved_last_idx  =    0;
static int saved_no_hlsearch  =    0;
static char_u *mr_pattern  =    (char_u *)((void *)0);
vim_regexp *search_regcomp(char_u *pat , int pat_save , int pat_use , int options___0 ) 
{








































































}
char_u *get_search_pat(void) 
{





}
static void save_re_pat(int idx , char_u *pat , int magic ) 
{




















}
static int save_level___0  =    0;
void save_search_patterns(void) 
{























}
void restore_search_patterns(void) 
{
















}
void set_reg_ic(char_u *pat ) 
{








































}
char_u *last_search_pat(void) 
{





}
void set_last_search_pat(char_u *s , int idx , int magic , int setlast ) 
{







































}
vim_regexp *last_pat_prog(void) 
{













}
int searchit(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *str___1 , long count___2 ,
             int options___0 , int pat_use ) 
{


























































































































































































































































































































}
int do_search(OPARG *oap , int dirc , char_u *str___1 , long count___2 , int options___0 ) 
{























































































































































































































































































































































































































































































}
int search_for_exact_line(BUF *buf___3 , FPOS *pos___0 , int dir , char_u *pat ) 
{













































































































































}
static int lastc___0  =    '\000';
static int lastcdir  ;
static int lastctype  ;
int searchc(int c , int dir , int type , long count___2 ) 
{

































































}
FPOS *findmatch(OPARG *oap , int initc ) 
{








}
static FPOS pos  ;
FPOS *findmatchlimit(OPARG *oap , int initc , int flags___0 , int maxtravel ) 
{









































































































































































































































































































































































































































































































































































































































































































































}
static int check_linecomment(char_u *line ) 
{

























}
void showmatch(void) 
{

































































}
int findsent(int dir , long count___2 ) 
{





























































































































































































































































































}
int findpar(OPARG *oap , int dir , long count___2 , int what , int both ) 
{


























































































}
static int inmacro(char_u *opt , char_u *s ) 
{











































}
int startPS(linenr_t lnum , int para , int both ) 
{








































}
static int stype  ;
static int cls(void) 
{
































}
int fwd_word(long count___2 , int type , int eol ) 
{








































































































}
int bck_word(long count___2 , int type , int stop ) 
{


















































































}
int end_word(long count___2 , int type , int stop , int empty ) 
{































































































}
int bckend_word(long count___2 , int type , int eol ) 
{


























































































}
static int skip_chars(int cclass , int dir ) 
{


































}
static void back_in_line(void) 
{


























}
static void find_first_blank(FPOS *posp ) 
{





























}
static void findsent_forward(long count___2 , int at_start_sent ) 
{




































}
int current_word(OPARG *oap , long count___2 , int include , int type ) 
{




















































































































































































































}
int current_sent(OPARG *oap , long count___2 , int include ) 
{




























































































































































































































































































}
int current_block(OPARG *oap , long count___2 , int include , int what , int other ) 
{









































































































































































































}
int current_par(OPARG *oap , long count___2 , int include , int type ) 
{
































































































































































































































































































































}
int linewhite(linenr_t lnum ) 
{










}
void find_pattern_in_path(char_u *ptr , int dir , int len___0 , int whole , int skip_comments ,
                          int type , long count___2 , int action , linenr_t start_lnum ,
                          linenr_t end_lnum ) 
{









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static void show_pat_in_path(char_u *line , int type , int did_show , int action ,
                             FILE *fp___0 , linenr_t *lnum , long count___2 ) 
{




























































































}
static int hlsearch_on  =    0;
int read_viminfo_search_pattern(char_u *line , FILE *fp___0 , int force ) 
{






























































































}
void write_viminfo_search_pattern(FILE *fp___0 ) 
{






























}
static void wvsp_one(FILE *fp___0 , int idx , char *s , int sc ) 
{













































}
#pragma merger("0","/tmp/cil-aNPjgWpH.i","-O0")
int syn_check_group(char_u *pp , int len___0 ) ;
static struct growarray highlight_ga  ;
static int include_link  =    0;
static char *hl_name_table[7]  = {      (char *)"bold",      (char *)"standout",      (char *)"underline",      (char *)"italic", 
        (char *)"reverse",      (char *)"inverse",      (char *)"NONE"};
static int hl_attr_table[7]  = {      2,      16,      8,      4, 
        1,      1,      0};
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) ;
static int syn_namen2id(char_u *linep , int len___0 ) ;
static void syn_unadd_group(void) ;
static void set_hl_attr(int idx ) ;
static void highlight_list_one(int id ) ;
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) ;
static int syn_add_group(char_u *name___1 ) ;
static int syn_list_header(int did_header , int outlen , int id ) ;
static int hl_has_settings(int idx , int check_link ) ;
static void highlight_clear(int idx ) ;
static char *spo_name_tab[7]  = {      (char *)"ms=",      (char *)"me=",      (char *)"hs=",      (char *)"he=", 
        (char *)"rs=",      (char *)"re=",      (char *)"lc="};
static int current_attr  =    0;
static int current_id  =    0;
static int current_trans_id  =    0;
static char_u **syn_cmdlinep  ;
static int current_syn_inc_tag  =    0;
static int running_syn_inc_tag  =    0;
static int keepend_level  =    -1;
static int next_match_col  ;
static int next_match_m_endcol  ;
static int next_match_h_startcol  ;
static int next_match_h_endcol  ;
static int next_match_idx  ;
static int next_match_flags  ;
static int next_match_eos_col  ;
static int next_match_eoe_col  ;
static int next_match_end_idx  ;
static BUF *syn_buf  ;
static linenr_t current_lnum  =    (linenr_t )0;
static int current_state_stored  =    0;
static colnr_t current_col  =    (colnr_t )0;
static int current_finished  =    0;
static struct growarray current_state  =    {0, 0, 0, 0, (void *)0};
static short *current_next_list  =    (short *)((void *)0);
static int current_next_flags  =    0;
static int current_line_id  =    0;
static void syn_sync(WIN *wp , linenr_t start_lnum ) ;
static int syn_match_linecont(linenr_t lnum ) ;
static void syn_start_line(void) ;
static void syn_free_all_states(BUF *buf___3 ) ;
static void syn_clear_states(int start___0 , int end ) ;
static void store_current_state(void) ;
static void invalidate_current_state(void) ;
static void validate_current_state(void) ;
static void copy_state_to_current(struct syn_state *from ) ;
static void move_state(int from , int to ) ;
static int syn_finish_line(int syncing ) ;
static int syn_current_attr(int syncing , char_u *line ) ;
static int did_match_already(int idx ) ;
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) ;
static void check_state_ends(char_u *line ) ;
static void update_si_attr(int idx ) ;
static void check_keepend(void) ;
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) ;
static short *copy_id_list(short *list ) ;
static int in_id_list(short *list , int id , int inctag , int contained ) ;
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) ;
static int push_current(int idx ) ;
static void pop_current(void) ;
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) ;
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) ;
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) ;
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) ;
static void syn_cmd_case(EXARG *eap , int syncing ) ;
static void syntax_sync_clear(void) ;
static void syn_remove_pattern(BUF *buf___3 , int idx ) ;
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) ;
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) ;
static void syn_cmd_clear(EXARG *eap , int syncing ) ;
static void syn_clear_one(int id , int syncing ) ;
static void syn_cmd_on(EXARG *eap , int syncing ) ;
static void syn_cmd_manual(EXARG *eap , int syncing ) ;
static void syn_cmd_off(EXARG *eap , int syncing ) ;
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) ;
static void syn_cmd_list(EXARG *eap , int syncing ) ;
static void syn_lines_msg(void) ;
static void syn_list_one(int id , int syncing , int link_only ) ;
static void syn_list_cluster(int id ) ;
static void put_id_list(char_u *name___1 , short *list , int attr ) ;
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) ;
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) ;
static void syn_clear_keyword(int id , struct keyentry **ktabp ) ;
static void free_keywtab(struct keyentry **ktabp ) ;
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) ;
static char_u *get_group_name(char_u *arg , char_u **name_end ) ;
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) ;
static void syn_cmd_include(EXARG *eap , int syncing ) ;
static void syn_cmd_keyword(EXARG *eap , int syncing ) ;
static void syn_cmd_match(EXARG *eap , int syncing ) ;
static void syn_cmd_region(EXARG *eap , int syncing ) ;
static int syn_compare_stub(void const   *v1 , void const   *v2 ) ;
static void syn_cmd_cluster(EXARG *eap , int syncing ) ;
static int syn_scl_name2id(char_u *name___1 ) ;
static int syn_scl_namen2id(char_u *linep , int len___0 ) ;
static int syn_check_cluster(char_u *pp , int len___0 ) ;
static int syn_add_cluster(char_u *name___1 ) ;
static void init_syn_patterns(void) ;
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) ;
static void syn_cmd_sync(EXARG *eap , int syncing ) ;
static int get_id_list(char_u **arg , int keylen , short **list ) ;
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) ;
static void syn_incl_toplevel(int id , int *flagsp ) ;
void syntax_start(WIN *wp , linenr_t lnum ) 
{













































































































































































































}
static void syn_sync(WIN *wp , linenr_t start_lnum ) 
{






















































































































































































































































}
static int syn_match_linecont(linenr_t lnum ) 
{














}
static void syn_start_line(void) 
{












































}
static void syn_free_all_states(BUF *buf___3 ) 
{


























}
static void syn_clear_states(int start___0 , int end ) 
{






















}
static void store_current_state(void) 
{

















































}
static void copy_state_to_current(struct syn_state *from ) 
{

















































}
static void invalidate_current_state(void) 
{











}
static void validate_current_state(void) 
{







}
static void move_state(int from , int to ) 
{











}
void syn_changed(linenr_t lnum ) 
{








}
int syntax_check_changed(linenr_t lnum ) 
{


























































}
static int syn_finish_line(int syncing ) 
{





































}
int get_syntax_attr(colnr_t col , char_u *line ) 
{





























}
static int try_next_column  =    0;
static int syn_current_attr(int syncing , char_u *line ) 
{
































































































































































































































































































































































































}
static int did_match_already(int idx ) 
{























}
static struct state_item *push_next_match(struct state_item *cur_si , char_u *line ) 
{





































































}
static void check_state_ends(char_u *line ) 
{

































































}
static void update_si_attr(int idx ) 
{







































}
static void check_keepend(void) 
{










































}
static void update_si_end(struct state_item *sip , char_u *line , int startcol ) 
{




































}
static int push_current(int idx ) 
{


















}
static void pop_current(void) 
{













}
static char_u *find_endp(int idx , char_u *sstart , int at_bol , char_u **hl_endp ,
                         int *flagsp , char_u **end_endp , int *end_idx ) 
{




















































































































































































}
static char_u *syn_add_end_off(struct syn_pattern *spp , int idx , int extra ) 
{








}
static char_u *syn_add_start_off(struct syn_pattern *spp , int idx , int extra ) 
{








}
static int check_keyword_id(char_u *line , int startcol , int *endcol , int *flags___0 ,
                            short **next_list , struct state_item *cur_si ) 
{

























































































































































}
static void syn_cmd_case(EXARG *eap , int syncing ) 
{














































}
void syntax_clear(BUF *buf___3 ) 
{























































}
static void syntax_sync_clear(void) 
{






























}
static void syn_remove_pattern(BUF *buf___3 , int idx ) 
{












}
static void syn_clear_pattern(BUF *buf___3 , int i___0 ) 
{






















}
static void syn_clear_cluster(BUF *buf___3 , int i___0 ) 
{










}
static void syn_cmd_clear(EXARG *eap , int syncing ) 
{
























































































}
static void syn_clear_one(int id , int syncing ) 
{



































}
static void syn_cmd_on(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_manual(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_off(EXARG *eap , int syncing ) 
{








}
static void syn_cmd_onoff(EXARG *eap , char *name___1 ) 
{

















}
static void syn_cmd_list(EXARG *eap , int syncing ) 
{








































































































































































}
static void syn_lines_msg(void) 
{




























}
static int last_matchgroup  ;
static void syn_list_one(int id , int syncing , int link_only ) 
{












































































































































































































}
static void syn_list_cluster(int id ) 
{






























}
static void put_id_list(char_u *name___1 , short *list , int attr ) 
{

























































}
static char *sepchars  =    (char *)"/+=-#@\"|\'^&";
static void put_pattern(char *s , int c , struct syn_pattern *spp , int attr ) 
{














































































































}
static int syn_list_keywords(int id , struct keyentry **ktabp , int did_header , int attr ) 
{



























































































































}
static void syn_clear_keyword(int id , struct keyentry **ktabp ) 
{
















































}
static void free_keywtab(struct keyentry **ktabp ) 
{







































}
static void add_keyword(char_u *name___1 , int id , int flags___0 , short *next_list ) 
{








































































}
static char_u *get_group_name(char_u *arg , char_u **name_end ) 
{


















}
static struct flag flagtab[13]  = 
  {      {(char *)"contained", 9, 1}, 
        {(char *)"oneline", 7, 4}, 
        {(char *)"keepend", 7, 1024}, 
        {(char *)"excludenl", 9, 2048}, 
        {(char *)"transparent", 11, 2}, 
        {(char *)"skipnl", 6, 128}, 
        {(char *)"skipwhite", 9, 256}, 
        {(char *)"skipempty", 9, 512}, 
        {(char *)"grouphere", 9, 16}, 
        {(char *)"groupthere", 10, 32}, 
        {(char *)"display", 7, 4096}, 
        {(char *)"extend", 6, 8192}, 
        {(char *)"fold", 4, 16384}};
static char_u *get_syn_options(char_u *arg , int *flagsp , int keyword , int *sync_idx ,
                               short **cont_list , short **next_list ) 
{


















































































































































































































}
static void syn_incl_toplevel(int id , int *flagsp ) 
{






























}
static void syn_cmd_include(EXARG *eap , int syncing ) 
{


































































}
static void syn_cmd_keyword(EXARG *eap , int syncing ) 
{


































































































































































}
static void syn_cmd_match(EXARG *eap , int syncing ) 
{













































































































}
static void syn_cmd_region(EXARG *eap , int syncing ) 
{

































































































































































































































































































































































































}
static int syn_compare_stub(void const   *v1 , void const   *v2 ) 
{




















}
static void syn_combine_list(short **clstr1 , short **clstr2 , int list_op ) 
{




































































































































































}
static int syn_scl_name2id(char_u *name___1 ) 
{









































}
static int syn_scl_namen2id(char_u *linep , int len___0 ) 
{
















}
static int syn_check_cluster(char_u *pp , int len___0 ) 
{
























}
static int syn_add_cluster(char_u *name___1 ) 
{





























}
static void syn_cmd_cluster(EXARG *eap , int syncing ) 
{
























































































































































}
static void init_syn_patterns(void) 
{







}
static char_u *get_syn_pattern(char_u *arg , struct syn_pattern *ci ) 
{































































































































































}
static void syn_cmd_sync(EXARG *eap , int syncing ) 
{












































































































































































































































}
static int get_id_list(char_u **arg , int keylen , short **list ) 
{









































































































































































































































































}
static short *copy_id_list(short *list ) 
{
































}
static int in_id_list(short *list , int id , int inctag , int contained ) 
{

















































}
static struct subcommand subcommands[14]  = 
  {      {(char *)"case", & syn_cmd_case}, 
        {(char *)"clear", & syn_cmd_clear}, 
        {(char *)"cluster", & syn_cmd_cluster}, 
        {(char *)"include", & syn_cmd_include}, 
        {(char *)"keyword", & syn_cmd_keyword}, 
        {(char *)"list", & syn_cmd_list}, 
        {(char *)"manual", & syn_cmd_manual}, 
        {(char *)"match", & syn_cmd_match}, 
        {(char *)"on", & syn_cmd_on}, 
        {(char *)"off", & syn_cmd_off}, 
        {(char *)"region", & syn_cmd_region}, 
        {(char *)"sync", & syn_cmd_sync}, 
        {(char *)"", & syn_cmd_list}, 
        {(char *)((void *)0), (void (*)(EXARG * , int  ))((void *)0)}};
void do_syntax(EXARG *eap , char_u **cmdlinep ) 
{
































































}
int syntax_present(BUF *buf___3 ) 
{






















}
static enum __anonenum_expand_what_169 expand_what  ;
void set_context_in_syntax_cmd(char_u *arg ) 
{







































































}
static char *case_args[3]  = {      (char *)"match",      (char *)"ignore",      (char *)((void *)0)};
char_u *get_syntax_name(int idx ) 
{








}
int syn_get_id(long line , long col , int trans___0 ) 
{
































}
static int syn_regexec(vim_regexp *prog , char_u *string___0 , int at_bol ) 
{












}
static char *highlight_init_both[9]  = 
  {      (char *)"ErrorMsg term=standout ctermbg=DarkRed ctermfg=White guibg=Red guifg=White",      (char *)"IncSearch term=reverse cterm=reverse gui=reverse",      (char *)"ModeMsg term=bold cterm=bold gui=bold",      (char *)"NonText term=bold ctermfg=Blue gui=bold guifg=Blue", 
        (char *)"StatusLine term=reverse,bold cterm=reverse,bold gui=reverse,bold",      (char *)"StatusLineNC term=reverse cterm=reverse gui=reverse",      (char *)"Visual term=reverse cterm=reverse gui=reverse guifg=Grey guibg=fg",      (char *)"VisualNOS term=underline,bold cterm=underline,bold gui=underline,bold", 
        (char *)((void *)0)};
static char *highlight_init_light[11]  = 
  {      (char *)"Directory term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"LineNr term=underline ctermfg=Brown guifg=Brown",      (char *)"MoreMsg term=bold ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=DarkGreen gui=bold guifg=SeaGreen",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE",      (char *)"SpecialKey term=bold ctermfg=DarkBlue guifg=Blue",      (char *)"Title term=bold ctermfg=DarkMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=DarkRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static char *highlight_init_dark[11]  = 
  {      (char *)"Directory term=bold ctermfg=LightCyan guifg=Cyan",      (char *)"LineNr term=underline ctermfg=Yellow guifg=Yellow",      (char *)"MoreMsg term=bold ctermfg=LightGreen gui=bold guifg=SeaGreen",      (char *)"Normal gui=NONE", 
        (char *)"Question term=standout ctermfg=LightGreen gui=bold guifg=Green",      (char *)"Search term=reverse ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)"SpecialKey term=bold ctermfg=LightBlue guifg=Cyan",      (char *)"Title term=bold ctermfg=LightMagenta gui=bold guifg=Magenta", 
        (char *)"WarningMsg term=standout ctermfg=LightRed guifg=Red",      (char *)"WildMenu term=standout ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black",      (char *)((void *)0)};
static int had_both  =    0;
void init_highlight(int both ) 
{



















































}
static char *color_names[26]  = 
  {      (char *)"Black",      (char *)"DarkBlue",      (char *)"DarkGreen",      (char *)"DarkCyan", 
        (char *)"DarkRed",      (char *)"DarkMagenta",      (char *)"Brown",      (char *)"Gray", 
        (char *)"Grey",      (char *)"LightGray",      (char *)"LightGrey",      (char *)"DarkGray", 
        (char *)"DarkGrey",      (char *)"Blue",      (char *)"LightBlue",      (char *)"Green", 
        (char *)"LightGreen",      (char *)"Cyan",      (char *)"LightCyan",      (char *)"Red", 
        (char *)"LightRed",      (char *)"Magenta",      (char *)"LightMagenta",      (char *)"Yellow", 
        (char *)"White",      (char *)"NONE"};
static int color_numbers_16[26]  = 
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        7,      7,      7,      8, 
        8,      9,      9,      10, 
        10,      11,      11,      12, 
        12,      13,      13,      14, 
        15,      -1};
static int color_numbers_8[26]  = 
  {      0,      4,      2,      6, 
        1,      5,      3,      7, 
        7,      7,      7,      8, 
        8,      12,      12,      10, 
        10,      14,      14,      9, 
        9,      13,      13,      11, 
        15,      -1};
void do_highlight(char_u *line , int forceit , int init ) 
{














































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static int hl_has_settings(int idx , int check_link ) 
{






















}
static void highlight_clear(int idx ) 
{


















}
struct growarray term_attr_table  =    {0, 0, 0, 0, (void *)0};
struct growarray cterm_attr_table  =    {0, 0, 0, 0, (void *)0};
static int recursive___3  =    0;
static int get_attr_entry(struct growarray *table , struct attr_entry *aep ) 
{




































































































































}
struct attr_entry *syn_term_attr2entry(int attr ) 
{









}
struct attr_entry *syn_cterm_attr2entry(int attr ) 
{









}
static void highlight_list_one(int id ) 
{


























}
static int highlight_list_arg(int id , int didh , int type , int iarg , char_u *sarg ,
                              char *name___1 ) 
{





























































}
char_u *highlight_has_attr(int id , int flag , int modec ) 
{




















}
static char_u name___0[20]  ;
char_u *highlight_color(int id , char_u *what , int modec ) 
{


































}
static int syn_list_header(int did_header , int outlen , int id ) 
{




































}
static void set_hl_attr(int idx ) 
{























































}
int syn_name2id(char_u *name___1 ) 
{



































}
int highlight_exists(char_u *name___1 ) 
{








}
static int syn_namen2id(char_u *linep , int len___0 ) 
{
















}
int syn_check_group(char_u *pp , int len___0 ) 
{
























}
static int syn_add_group(char_u *name___1 ) 
{


























}
static void syn_unadd_group(void) 
{











}
int syn_id2attr(int hl_id ) 
{















}
int syn_get_final_id(int hl_id ) 
{

































}
static int hl_flags[18]  = 
  {      '8',      '@',      'd',      'e', 
        'h',      'i',      'l',      'm', 
        'M',      'n',      'r',      's', 
        'S',      't',      'v',      'V', 
        'w',      'W'};
int highlight_changed(void) 
{



















































































































































































































































































}
static void highlight_list(void) ;
static void highlight_list_two(int cnt , int attr ) ;
void set_context_in_highlight_cmd(char_u *arg ) 
{





















































}
static void highlight_list(void) 
{

































}
static void highlight_list_two(int cnt , int attr ) 
{


















}
char_u *get_highlight_name(int idx ) 
{






















}
#pragma merger("0","/tmp/cil-FIDR198i.i","-O0")
extern void rewind(FILE *__stream ) ;
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
extern __off_t ftello(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
void simplify_filename(char_u *filename ) ;
static char *mt_names[8]  = 
  {      (char *)"FSC",      (char *)"F C",      (char *)"F  ",      (char *)"FS ", 
        (char *)" SC",      (char *)"  C",      (char *)"   ",      (char *)" S "};
static char_u *nofile_fname  =    (char_u *)((void *)0);
static void taglen_advance(int l ) ;
static int get_tagfname(int first___0 , char_u *buf___3 ) ;
static int jumpto_tag(char_u *lbuf , int forceit ) ;
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) ;
static int test_for_static(struct tag_pointers *tagp ) ;
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) ;
static char_u *tag_full_fname(struct tag_pointers *tagp ) ;
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) ;
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) ;
static int find_extra(char_u **pp ) ;
static char_u *bottommsg  =    (char_u *)"at bottom of tag stack";
static char_u *topmsg  =    (char_u *)"at top of tag stack";
static char_u *tagmatchname  =    (char_u *)((void *)0);
static int num_matches  =    0;
static int max_num_matches  =    0;
static char_u **matches  =    (char_u **)((void *)0);
static int flags  ;
int do_tag(char_u *tag , int type , int count___2 , int forceit , int verbose ) 
{
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
void tag_freematch(void) 
{









}
static void taglen_advance(int l ) 
{















}
void do_tags(void) 
{




































































}
int find_tags(char_u *pat , int *num_matches___0 , char_u ***matchesp , int flags___0 ,
              int mincount ) 
{














































































































































































































































































































































































































































































































































































































































































































































































































































































































































}
static char_u *np  =    (char_u *)((void *)0);
static struct visited *first_visited  =    (struct visited *)((void *)0);
static int get_tagfname(int first___0 , char_u *buf___3 ) 
{















































































































































}
static int parse_tag_line(char_u *lbuf , struct tag_pointers *tagp ) 
{































}
static int test_for_static(struct tag_pointers *tagp ) 
{











































}
static int parse_match(char_u *lbuf , struct tag_pointers *tagp ) 
{































































































}
static char_u *tag_full_fname(struct tag_pointers *tagp ) 
{












}
static int jumpto_tag(char_u *lbuf , int forceit ) 
{

























































































































































































































































































































}
static char_u *expand_tag_fname(char_u *fname , char_u *tag_fname , int expand ) 
{



































































}
void simplify_filename(char_u *filename ) 
{







































































































































































































}
static int test_for_current(char_u *fname , char_u *fname_end , char_u *tag_fname ) 
{
























}
static int find_extra(char_u **pp ) 
{






































































}
int expand_tags(int tagnames , char_u *pat , int *num_file , char_u ***file ) 
{














































































}
#pragma merger("0","/tmp/cil-x_nT2aar.i","-O0")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
void del_termcode(char_u *name___1 ) ;
int find_term_bykeys(char_u *src ) ;
void ui_write(char_u *s , int len___0 ) ;
void screen_new_rows(void) ;
extern char PC ;
extern char *UP ;
extern char *BC ;
extern short ospeed ;
extern char *tgoto(char const   * , int  , int  ) ;
extern int tgetent(char * , char const   * ) ;
extern int tgetflag(char const   * ) ;
extern int tgetnum(char const   * ) ;
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
static struct builtin_term *find_builtin_term(char_u *term ) ;
static void parse_builtin_tcap(char_u *term ) ;
static void term_color(char_u *s , int n ) ;
static void gather_termleader(void) ;
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) ;
static int term_is_builtin(char_u *name___1 ) ;
static int term_7to8bit(char_u *p___0 ) ;
static char_u *tgetent_error(char_u *tbuf , char_u *term ) ;
extern char *tgetstr(char * , char ** ) ;
static int need_get_crv  =    1;
static char_u *vim_tgetstr(char *s , char_u **pp ) ;
struct builtin_term builtin_termcaps[181]  = 
  {      {0, (char *)"ansi"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {14, (char *)"\033[0m"}, 
        {15, (char *)"\033[7m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {0, (char *)"xterm"}, 
        {1, (char *)"\033[K"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {6, (char *)"\033[%i%p1%d;%p2%dr"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {8, (char *)"\033[J"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {28, (char *)"\033[?1h\033="}, 
        {29, (char *)"\033[?1l\033>"}, 
        {43, (char *)"\033]1;"}, 
        {44, (char *)"\a"}, 
        {45, (char *)"\033]2;"}, 
        {46, (char *)"\a"}, 
        {48, (char *)"\033[8;%p1%d;%p2%dt"}, 
        {47, (char *)"\033[3;%p1%d;%p2%dt"}, 
        {49, (char *)"\033[>c"}, 
        {107 + (117 << 8), (char *)"\033OA"}, 
        {107 + (100 << 8), (char *)"\033OB"}, 
        {107 + (114 << 8), (char *)"\033OC"}, 
        {107 + (108 << 8), (char *)"\033OD"}, 
        {253 + (4 << 8), (char *)"\033O2A"}, 
        {253 + (5 << 8), (char *)"\033O2B"}, 
        {37 + (105 << 8), (char *)"\033O2C"}, 
        {35 + (52 << 8), (char *)"\033O2D"}, 
        {253 + (55 << 8), (char *)"\033OP"}, 
        {253 + (56 << 8), (char *)"\033OQ"}, 
        {253 + (57 << 8), (char *)"\033OR"}, 
        {253 + (58 << 8), (char *)"\033OS"}, 
        {107 + (49 << 8), (char *)"\033[11~"}, 
        {107 + (50 << 8), (char *)"\033[12~"}, 
        {107 + (51 << 8), (char *)"\033[13~"}, 
        {107 + (52 << 8), (char *)"\033[14~"}, 
        {107 + (53 << 8), (char *)"\033[15~"}, 
        {107 + (54 << 8), (char *)"\033[17~"}, 
        {107 + (55 << 8), (char *)"\033[18~"}, 
        {107 + (56 << 8), (char *)"\033[19~"}, 
        {107 + (57 << 8), (char *)"\033[20~"}, 
        {107 + (59 << 8), (char *)"\033[21~"}, 
        {70 + (49 << 8), (char *)"\033[23~"}, 
        {70 + (50 << 8), (char *)"\033[24~"}, 
        {253 + (63 << 8), (char *)"\033O2P"}, 
        {253 + (64 << 8), (char *)"\033O2Q"}, 
        {253 + (65 << 8), (char *)"\033O2R"}, 
        {253 + (66 << 8), (char *)"\033O2S"}, 
        {253 + (6 << 8), (char *)"\033[11;2~"}, 
        {253 + (7 << 8), (char *)"\033[12;2~"}, 
        {253 + (8 << 8), (char *)"\033[13;2~"}, 
        {253 + (9 << 8), (char *)"\033[14;2~"}, 
        {253 + (10 << 8), (char *)"\033[15;2~"}, 
        {253 + (11 << 8), (char *)"\033[17;2~"}, 
        {253 + (12 << 8), (char *)"\033[18;2~"}, 
        {253 + (13 << 8), (char *)"\033[19;2~"}, 
        {253 + (14 << 8), (char *)"\033[20;2~"}, 
        {253 + (15 << 8), (char *)"\033[21;2~"}, 
        {253 + (16 << 8), (char *)"\033[23;2~"}, 
        {253 + (17 << 8), (char *)"\033[24;2~"}, 
        {37 + (49 << 8), (char *)"\033[28~"}, 
        {38 + (56 << 8), (char *)"\033[26~"}, 
        {107 + (73 << 8), (char *)"\033[2~"}, 
        {107 + (104 << 8), (char *)"\033[7~"}, 
        {35 + (50 << 8), (char *)"\033O2H"}, 
        {75 + (49 << 8), (char *)"\033[1~"}, 
        {253 + (60 << 8), (char *)"\033OH"}, 
        {64 + (55 << 8), (char *)"\033[8~"}, 
        {42 + (55 << 8), (char *)"\033O2F"}, 
        {75 + (52 << 8), (char *)"\033[4~"}, 
        {253 + (59 << 8), (char *)"\033OF"}, 
        {107 + (80 << 8), (char *)"\033[5~"}, 
        {107 + (78 << 8), (char *)"\033[6~"}, 
        {75 + (54 << 8), (char *)"\033Ok"}, 
        {75 + (55 << 8), (char *)"\033Om"}, 
        {75 + (56 << 8), (char *)"\033Oo"}, 
        {75 + (57 << 8), (char *)"\033Oj"}, 
        {75 + (65 << 8), (char *)"\033OM"}, 
        {253 + (70 << 8), (char *)"\033[3~"}, 
        {257, (char *)""}, 
        {107 + (48 << 8), (char *)"\033[10~"}, 
        {70 + (51 << 8), (char *)"\033[25~"}, 
        {70 + (54 << 8), (char *)"\033[29~"}, 
        {70 + (55 << 8), (char *)"\033[31~"}, 
        {70 + (56 << 8), (char *)"\033[32~"}, 
        {70 + (57 << 8), (char *)"\033[33~"}, 
        {70 + (65 << 8), (char *)"\033[34~"}, 
        {0, (char *)"iris-ansi"}, 
        {1, (char *)"\033[K"}, 
        {8, (char *)"\033[J"}, 
        {2, (char *)"\033[L"}, 
        {3, (char *)"\033[%p1%dL"}, 
        {4, (char *)"\033[M"}, 
        {5, (char *)"\033[%p1%dM"}, 
        {7, (char *)"\033[H\033[2J"}, 
        {12, (char *)"\033[9/y\033[12/y"}, 
        {13, (char *)"\033[10/y\033[=1h\033[=2l"}, 
        {30, (char *)"\033[=6h"}, 
        {31, (char *)"\033[=6l"}, 
        {17, (char *)"\033[m"}, 
        {18, (char *)"\033[1;7m"}, 
        {14, (char *)"\033[m"}, 
        {15, (char *)"\033[7m"}, 
        {16, (char *)"\033[1m"}, 
        {21, (char *)"\033[m"}, 
        {34, (char *)"8"}, 
        {40, (char *)"\033[4%p1%dm"}, 
        {39, (char *)"\033[3%p1%dm"}, 
        {22, (char *)"\033[4m"}, 
        {23, (char *)"y"}, 
        {41, (char *)"\b"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {25, (char *)"\033M"}, 
        {26, (char *)"\033[%p1%dC"}, 
        {43, (char *)"\033P3.y"}, 
        {44, (char *)"\234"}, 
        {45, (char *)"\033P1.y"}, 
        {46, (char *)"\234"}, 
        {48, (char *)"\033[203;%p1%d;%p2%d/y"}, 
        {107 + (117 << 8), (char *)"\033[A"}, 
        {107 + (100 << 8), (char *)"\033[B"}, 
        {107 + (108 << 8), (char *)"\033[D"}, 
        {107 + (114 << 8), (char *)"\033[C"}, 
        {253 + (4 << 8), (char *)"\033[161q"}, 
        {253 + (5 << 8), (char *)"\033[164q"}, 
        {35 + (52 << 8), (char *)"\033[158q"}, 
        {37 + (105 << 8), (char *)"\033[167q"}, 
        {107 + (49 << 8), (char *)"\033[001q"}, 
        {107 + (50 << 8), (char *)"\033[002q"}, 
        {107 + (51 << 8), (char *)"\033[003q"}, 
        {107 + (52 << 8), (char *)"\033[004q"}, 
        {107 + (53 << 8), (char *)"\033[005q"}, 
        {107 + (54 << 8), (char *)"\033[006q"}, 
        {107 + (55 << 8), (char *)"\033[007q"}, 
        {107 + (56 << 8), (char *)"\033[008q"}, 
        {107 + (57 << 8), (char *)"\033[009q"}, 
        {107 + (59 << 8), (char *)"\033[010q"}, 
        {70 + (49 << 8), (char *)"\033[011q"}, 
        {70 + (50 << 8), (char *)"\033[012q"}, 
        {253 + (6 << 8), (char *)"\033[013q"}, 
        {253 + (7 << 8), (char *)"\033[014q"}, 
        {253 + (8 << 8), (char *)"\033[015q"}, 
        {253 + (9 << 8), (char *)"\033[016q"}, 
        {253 + (10 << 8), (char *)"\033[017q"}, 
        {253 + (11 << 8), (char *)"\033[018q"}, 
        {253 + (12 << 8), (char *)"\033[019q"}, 
        {253 + (13 << 8), (char *)"\033[020q"}, 
        {253 + (14 << 8), (char *)"\033[021q"}, 
        {253 + (15 << 8), (char *)"\033[022q"}, 
        {253 + (16 << 8), (char *)"\033[023q"}, 
        {253 + (17 << 8), (char *)"\033[024q"}, 
        {107 + (73 << 8), (char *)"\033[139q"}, 
        {107 + (104 << 8), (char *)"\033[H"}, 
        {64 + (55 << 8), (char *)"\033[146q"}, 
        {107 + (80 << 8), (char *)"\033[150q"}, 
        {107 + (78 << 8), (char *)"\033[154q"}, 
        {0, (char *)"dumb"}, 
        {7, (char *)"\f"}, 
        {24, (char *)"\033[%i%p1%d;%p2%dH"}, 
        {0, (char *)((void *)0)}};
static int need_gather  =    0;
static char_u termleader[257]  ;
static struct builtin_term *find_builtin_term(char_u *term ) 
{



























































}
static void parse_builtin_tcap(char_u *term ) 
{





























































































}
static char nr_colors[15]  ;
static char_u tstrbuf[2048]  ;
static char *key_names[31]  = 
  {      (char *)"ku",      (char *)"kd",      (char *)"kr",      (char *)"#4", 
        (char *)"%i",      (char *)"k1",      (char *)"k2",      (char *)"k3", 
        (char *)"k4",      (char *)"k5",      (char *)"k6",      (char *)"k7", 
        (char *)"k8",      (char *)"k9",      (char *)"k;",      (char *)"F1", 
        (char *)"F2",      (char *)"%1",      (char *)"&8",      (char *)"kb", 
        (char *)"kI",      (char *)"kD",      (char *)"kh",      (char *)"@7", 
        (char *)"kP",      (char *)"kN",      (char *)"K1",      (char *)"K3", 
        (char *)"K4",      (char *)"K5",      (char *)((void *)0)};
static struct __anonstruct_string_names_169 string_names[45]  = 
  {      {(enum SpecialKey )1, (char *)"ce"}, 
        {(enum SpecialKey )2, (char *)"al"}, 
        {(enum SpecialKey )3, (char *)"AL"}, 
        {(enum SpecialKey )4, (char *)"dl"}, 
        {(enum SpecialKey )5, (char *)"DL"}, 
        {(enum SpecialKey )6, (char *)"cs"}, 
        {(enum SpecialKey )7, (char *)"cl"}, 
        {(enum SpecialKey )8, (char *)"cd"}, 
        {(enum SpecialKey )11, (char *)"vi"}, 
        {(enum SpecialKey )12, (char *)"ve"}, 
        {(enum SpecialKey )38, (char *)"mb"}, 
        {(enum SpecialKey )13, (char *)"vs"}, 
        {(enum SpecialKey )14, (char *)"me"}, 
        {(enum SpecialKey )15, (char *)"mr"}, 
        {(enum SpecialKey )16, (char *)"md"}, 
        {(enum SpecialKey )17, (char *)"se"}, 
        {(enum SpecialKey )18, (char *)"so"}, 
        {(enum SpecialKey )19, (char *)"ZH"}, 
        {(enum SpecialKey )20, (char *)"ZR"}, 
        {(enum SpecialKey )21, (char *)"ue"}, 
        {(enum SpecialKey )22, (char *)"us"}, 
        {(enum SpecialKey )24, (char *)"cm"}, 
        {(enum SpecialKey )25, (char *)"sr"}, 
        {(enum SpecialKey )26, (char *)"RI"}, 
        {(enum SpecialKey )27, (char *)"vb"}, 
        {(enum SpecialKey )28, (char *)"ks"}, 
        {(enum SpecialKey )29, (char *)"ke"}, 
        {(enum SpecialKey )30, (char *)"ti"}, 
        {(enum SpecialKey )31, (char *)"te"}, 
        {(enum SpecialKey )32, (char *)"bc"}, 
        {(enum SpecialKey )36, (char *)"Sb"}, 
        {(enum SpecialKey )35, (char *)"Sf"}, 
        {(enum SpecialKey )40, (char *)"AB"}, 
        {(enum SpecialKey )39, (char *)"AF"}, 
        {(enum SpecialKey )41, (char *)"le"}, 
        {(enum SpecialKey )42, (char *)"nd"}, 
        {(enum SpecialKey )50, (char *)"op"}, 
        {(enum SpecialKey )49, (char *)"RV"}, 
        {(enum SpecialKey )43, (char *)"IS"}, 
        {(enum SpecialKey )44, (char *)"IE"}, 
        {(enum SpecialKey )45, (char *)"ts"}, 
        {(enum SpecialKey )46, (char *)"fs"}, 
        {(enum SpecialKey )47, (char *)"WP"}, 
        {(enum SpecialKey )48, (char *)"WS"}, 
        {(enum SpecialKey )0, (char *)((void *)0)}};
int set_termname(char_u *term ) 
{























































































































































































































































































































































































































































}
static int has_mouse_termcode  =    0;
void set_mouse_termcode(int n , char_u *s ) 
{











}
void del_mouse_termcode(int n ) 
{











}
static char_u *tgetent_error(char_u *tbuf , char_u *term ) 
{



















}
static char_u *vim_tgetstr(char *s , char_u **pp ) 
{











}
void getlinecol(void) 
{





























}
int add_termcap_entry(char_u *name___1 , int force ) 
{












































































































}
static int term_is_builtin(char_u *name___1 ) 
{









}
int term_is_8bit(char_u *name___1 ) 
{








}
static int term_7to8bit(char_u *p___0 ) 
{
















}
void termcapinit(char_u *name___1 ) 
{







































}
static char_u out_buf[2048]  ;
static int out_pos  =    0;
void out_flush(void) 
{












}
void out_char(unsigned int c ) 
{
























}
static void out_char_nf(unsigned int c ) ;
static void out_char_nf(unsigned int c ) 
{


















}
void out_str_nf(char_u *s ) 
{





























}
void out_str(char_u *s ) 
{






















}
void term_windgoto(int row , int col ) 
{









}
void term_cursor_right(int i___0 ) 
{









}
void term_append_lines(int line_count ) 
{









}
void term_delete_lines(int line_count ) 
{









}
void term_set_winpos(int x___0 , int y ) 
{















}
void term_set_winsize(int width , int height ) 
{









}
void term_fg_color(int n ) 
{
















}
void term_bg_color(int n ) 
{
















}
static void term_color(char_u *s , int n ) 
{















































































}
void term_settitle(char_u *title ) 
{












}
void ttest(int pairs ) 
{













































































































}
static int get_bytes_from_buf(char_u *buf___3 , char_u *bytes , int num_bytes ) 
{











































}
static int old_Rows  =    0;
void check_winsize(void) 
{
























}
static int busy  =    0;
void set_winsize(int width , int height , int mustset ) 
{








































































































































}
static int cur_tmode  =    0;
void settmode(int tmode ) 
{














































}
void starttermcap(void) 
{



















}
void stoptermcap(void) 
{




















}
int swapping_screen(void) 
{





}
void setmouse(void) 
{
































































}
int mouse_has(int c ) 
{















































}
int mouse_model_popup(void) 
{





}
void scroll_start(void) 
{












}
static int cursor_is_off  =    0;
void cursor_on(void) 
{











}
void cursor_off(void) 
{













}
void scroll_region_set(WIN *wp , int off___0 ) 
{











}
void scroll_region_reset(void) 
{










}
struct termcode *termcodes  =    (struct termcode *)((void *)0);
static int tc_max_len  =    0;
static int tc_len  =    0;
void clear_termcodes(void) 
{




























}
void add_termcode(char_u *name___1 , char_u *string___0 , int use_8bit ) 
{

























































































































}
char_u *find_termcode(char_u *name___1 ) 
{





















}
char_u *get_termcode(int i___0 ) 
{








}
void del_termcode(char_u *name___1 ) 
{








































}
static int held_button  =    3;
static int orig_num_clicks  =    1;
static int orig_mouse_code  =    0;
static int orig_mouse_col  =    0;
static int orig_mouse_row  =    0;
static linenr_t orig_topline  =    (linenr_t )0;
static struct timeval orig_mouse_time  =    {(__time_t )0, (__suseconds_t )0};
int check_termcode(int max_offset , char_u *buf___3 , int buflen ) 
{































































































































































































































































































































































































































































}
char_u *replace_termcodes(char_u *from , char_u **bufp , int from_part , int do_lt ) 
{









































































































































































}
int find_term_bykeys(char_u *src ) 
{




























}
static void gather_termleader(void) 
{































}
void show_termcodes(void) 
{




































































































































}
int show_one_termcode(char_u *name___1 , char_u *code , int printit ) 
{







































































}
char_u *translate_mapping(char_u *str___1 , int expmap ) 
{



















































































































































































}
#pragma merger("0","/tmp/cil-LeEIQNhP.i","-O0")
extern Atom XInternAtom(Display * , char const   * , int  ) ;
extern void XFreeStringList(char ** ) ;
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
extern int XmbTextListToTextProperty(Display *display , char **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
extern int XmbTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     char ***list_return , int *count_return ) ;
extern Boolean XtDispatchEvent(XEvent * ) ;
extern Boolean XtOwnSelection(Widget  , Atom  , Time  , Boolean (*)(Widget  , Atom * ,
                                                                    Atom * , Atom * ,
                                                                    XtPointer * ,
                                                                    unsigned long * ,
                                                                    int * ) , void (*)(Widget  ,
                                                                                       Atom * ) ,
                              void (*)(Widget  , Atom * , Atom * ) ) ;
extern void XtToolkitInitialize(void) ;
extern XtAppContext XtCreateApplicationContext(void) ;
extern char *XtMalloc(Cardinal  ) ;
extern void XtFree(char * ) ;
extern void XtDisownSelection(Widget  , Atom  , Time  ) ;
extern void XtGetSelectionValue(Widget  , Atom  , Atom  , void (*)(Widget  , XtPointer  ,
                                                                   Atom * , Atom * ,
                                                                   XtPointer  , unsigned long * ,
                                                                   int * ) , XtPointer  ,
                                Time  ) ;
void clip_lose_selection(void) ;
void clip_copy_selection(void) ;
void clip_clear_selection(void) ;
int clip_gen_own_selection(void) ;
void clip_gen_lose_selection(void) ;
void read_error_exit(void) ;
void ui_write(char_u *s , int len___0 ) 
{










}
int ui_inchar(char_u *buf___3 , int maxlen , long wtime ) 
{








}
int ui_char_avail(void) 
{








}
void ui_delay(long msec , int ignoreinput ) 
{








}
void ui_suspend(void) 
{








}
int ui_get_winsize(void) 
{














}
void ui_set_winsize(void) 
{








}
void ui_breakcheck(void) 
{








}
void clip_init(int can_use ) 
{












}
void clip_update_selection(void) 
{



















































}
void clip_own_selection(void) 
{
































}
void clip_lose_selection(void) 
{


































}
void clip_copy_selection(void) 
{





























}
void clip_auto_select(void) 
{













}
int clip_isautosel(void) 
{








}
void clip_clear_selection(void) 
{






}
int clip_gen_own_selection(void) 
{








}
void clip_gen_lose_selection(void) 
{








}
void clip_gen_set_selection(void) 
{








}
void clip_gen_request_selection(void) 
{








}
static char_u inbuf[256]  ;
static int inbufcount  =    0;
int vim_is_input_buf_full(void) 
{





}
int vim_is_input_buf_empty(void) 
{





}
void add_to_input_buf(char_u *s , int len___0 ) 
{


























}
int read_from_input_buf(char_u *buf___3 , long maxlen ) 
{























}
static int did_read_something  =    0;
void fill_input_buf(int exit_on_error ) 
{





















































































}
void read_error_exit(void) 
{














}
int check_col(int col ) 
{











}
int check_row(int row ) 
{











}
void open_app_context(void) 
{











}
void x11_setup_atoms(Display *dpy ) 
{











}
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) ;
static void clip_x11_request_selection_cb(Widget w___0 , XtPointer success___0 , Atom *selection ,
                                          Atom *type , XtPointer value , long_u *length ,
                                          int *format ) 
{















































































}
static int success  ;
void clip_x11_request_selection(Widget myShell , Display *dpy ) 
{





































































}
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) ;
static Boolean clip_x11_convert_selection_cb(Widget w___0 , Atom *selection , Atom *target ,
                                             Atom *type , XtPointer *value , long_u *length ,
                                             int *format ) 
{






































































































}
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) ;
static void clip_x11_lose_ownership_cb(Widget w___0 , Atom *selection ) 
{








}
void clip_x11_lose_selection(Widget myShell ) 
{








}
int clip_x11_own_selection(Widget myShell ) 
{













}
void clip_x11_set_selection(void) 
{





}
#pragma merger("0","/tmp/cil-3y2lZ3a4.i","-O0")
void u_saveline(linenr_t lnum ) ;
static void u_getbot(void) ;
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) ;
static void u_doit(int count___2 ) ;
static void u_undoredo(void) ;
static void u_undo_end(void) ;
static void u_freelist(struct u_header *uhp ) ;
static void u_freeentry(struct u_entry *uep , long n ) ;
static char_u *u_blockalloc(long_u size ) ;
static void u_free_line(char_u *ptr ) ;
static char_u *u_alloc_line(unsigned int size ) ;
static char_u *u_save_line(linenr_t lnum ) ;
static long u_newcount  ;
static long u_oldcount  ;
static int undo_undoes  =    0;
int u_save_cursor(void) 
{








}
int u_save(linenr_t top , linenr_t bot ) 
{



























}
int u_savesub(linenr_t lnum ) 
{











}
int u_inssub(linenr_t lnum ) 
{











}
int u_savedel(linenr_t lnum , long nlines ) 
{

















}
static int u_savecommon(linenr_t top , linenr_t bot , linenr_t newbot ) 
{








































































































































































}
void u_undo(int count___2 ) 
{






















}
void u_redo(int count___2 ) 
{














}
static void u_doit(int count___2 ) 
{








































































}
static void u_undoredo(void) 
{


















































































































































































































































































}
static void u_undo_end(void) 
{






















}
void u_sync(void) 
{












}
void u_unchanged(BUF *buf___3 ) 
{


















}
static void u_getbot(void) 
{





































}
static void u_freelist(struct u_header *uhp ) 
{






































}
static void u_freeentry(struct u_entry *uep , long n ) 
{





















}
void u_clearall(BUF *buf___3 ) 
{















}
void u_saveline(linenr_t lnum ) 
{

































}
void u_clearline(void) 
{












}
void u_undoline(void) 
{
























































}
static char_u *u_blockalloc(long_u size ) 
{





































}
void u_blockfree(BUF *buf___3 ) 
{
























}
static void u_free_line(char_u *ptr ) 
{























































































































}
static char_u *u_alloc_line(unsigned int size ) 
{



































































































}
static char_u *u_save_line(linenr_t lnum ) 
{



















}
int buf_changed(BUF *buf___3 ) 
{














}
int curbuf_changed(void) 
{














}
#pragma merger("0","/tmp/cil-kWECkjeW.i","-O0")
void win_free(WIN *wp ) ;
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) ;
static int path_is_url(char_u *p___0 ) ;
static void reset_VIsual(void) ;
static int win_comp_pos(void) ;
static void win_exchange(long Prenum ) ;
static void win_rotate(int upwards , int count___2 ) ;
static void win_goto(WIN *wp ) ;
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) ;
static void win_append(WIN *after , WIN *wp ) ;
static void win_remove(WIN *wp ) ;
static void win_new_height(WIN *wp , int height ) ;
static WIN *prevwin  =    (WIN *)((void *)0);
void do_window(int nchar , long Prenum ) 
{















































































































































































































































































































































































































































































































































}
static void reset_VIsual(void) 
{












}
int win_split(int new_height , int redraw , int req_room ) 
{












































































































































































}
int win_valid(WIN *win ) 
{






















}
int win_count(void) 
{



















}
int make_windows(int count___2 ) 
{





















































}
static void win_exchange(long Prenum ) 
{































































}
static void win_rotate(int upwards , int count___2 ) 
{
















































}
void win_move_after(WIN *win1 , WIN *win2 ) 
{






























}
void win_equal(WIN *next_curwin , int redraw ) 
{


















































































}
void close_windows(BUF *buf___3 ) 
{





























}
void close_window(WIN *win , int free_buf ) 
{







































































































































}
void close_others(int message , int forceit ) 
{





















































































































}
void win_init(WIN *wp ) 
{
















}
static void win_goto(WIN *wp ) 
{

















}
void win_enter(WIN *wp , int undo_sync ) 
{








}
static void win_enter_ext(WIN *wp , int undo_sync , int curwin_invalid ) 
{















































































}
WIN *buf_jump_open_win(BUF *buf___3 ) 
{
























}
WIN *win_alloc(WIN *after ) 
{


































}
void win_free(WIN *wp ) 
{
































}
static void win_append(WIN *after , WIN *wp ) 
{






















}
static void win_remove(WIN *wp ) 
{















}
int win_alloc_lsize(WIN *wp ) 
{
























}
void win_free_lsize(WIN *wp ) 
{











}
void screen_new_rows(void) 
{



















































}
static int win_comp_pos(void) 
{
























}
void win_setheight(int height ) 
{


















































































































}
void win_setminheight(void) 
{








































}
void win_drag_status_line(int offset ) 
{
































































































































}
static void win_new_height(WIN *wp , int height ) 
{
















































































}
void win_comp_scroll(WIN *wp ) 
{









}
void command_height(long old_p_ch ) 
{































































}
void last_status(void) 
{


























































}
char_u *file_name_at_cursor(int options___0 , long count___2 ) 
{










}
char_u *get_file_name_in_path(char_u *line , int col , int options___0 , long count___2 ) 
{















































































































































}
char_u *find_file_in_path(char_u *ptr , int len___0 , int options___0 , long count___2 ) 
{











































































































































































}
static char_u *find_file_in_wildcard_path(char_u *path_so_far , char_u *wildcards ,
                                          int level , long *countptr ) 
{































































































































































































}
static int path_is_url(char_u *p___0 ) 
{





















}
int min_rows(void) 
{

























}
int only_one_window(void) 
{

























}
void check_lnums(int do_curwin ) 
{































}
#pragma merger("0","/tmp/cil-avUm5A6g.i","-O0")
char *Version  =    (char *)"5.8";
char *mediumVersion  =    (char *)"5.8";
char *longVersion  =    (char *)"VIM - Vi IMproved 5.8 (2001 May 31, compiled Dec 18 2020 01:10:01)";
static void version_msg(char *s ) ;
static char *features[64]  = 
  {      (char *)"+autocmd",      (char *)"-browse",      (char *)"+builtin_terms",      (char *)"+byte_offset", 
        (char *)"+cindent",      (char *)"+cmdline_compl",      (char *)"+cmdline_info",      (char *)"+comments", 
        (char *)"+cryptv",      (char *)"-cscope",      (char *)"+dialog_con",      (char *)"+digraphs", 
        (char *)"-emacs_tags",      (char *)"+eval",      (char *)"+ex_extra",      (char *)"+extra_search", 
        (char *)"-farsi",      (char *)"+file_in_path",      (char *)"-osfiletype",      (char *)"+find_in_path", 
        (char *)"+fork()",      (char *)"-GUI",      (char *)"-hangul_input",      (char *)"+insert_expand", 
        (char *)"-langmap",      (char *)"+linebreak",      (char *)"+lispindent",      (char *)"+menu", 
        (char *)"+mksession",      (char *)"+modify_fname",      (char *)"+mouse",      (char *)"-mouse_dec", 
        (char *)"-mouse_gpm",      (char *)"-mouse_netterm",      (char *)"+mouse_xterm",      (char *)"-multi_byte", 
        (char *)"-perl",      (char *)"-python",      (char *)"+quickfix",      (char *)"-rightleft", 
        (char *)"+scrollbind",      (char *)"+smartindent",      (char *)"-sniff",      (char *)"+statusline", 
        (char *)"+syntax",      (char *)"+tag_binary",      (char *)"+tag_old_static",      (char *)"-tag_any_white", 
        (char *)"-tcl",      (char *)"+terminfo",      (char *)"+textobjects",      (char *)"+title", 
        (char *)"+user_commands",      (char *)"+visualextra",      (char *)"+viminfo",      (char *)"+wildignore", 
        (char *)"+wildmenu",      (char *)"+writebackup",      (char *)"+X11",      (char *)"-xfontset", 
        (char *)"-xim",      (char *)"+xterm_clipboard",      (char *)"-xterm_save",      (char *)((void *)0)};
static int included_patches[1]  = {      0};
int highest_patch(void) 
{





















}
void do_version(char_u *arg ) 
{











}
void list_version(void) 
{



































































































































}
static void version_msg(char *s ) 
{




















}