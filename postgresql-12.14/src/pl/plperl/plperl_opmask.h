#define PLPERL_SET_OPMASK(opmask) \
  memset(opmask, 1, MAXO);	/* disable all */ \
  /* then allow some... */                       \
  /* ALLOWED: :default :base_math !:base_io sort time require entereval caller dofile print prtf !dbmopen !setpgrp !setpriority !custom */ \
  opmask[OP_NULL        ] = 0;	/* null operation */ \
  opmask[OP_STUB        ] = 0;	/* stub */ \
  opmask[OP_SCALAR      ] = 0;	/* scalar */ \
  opmask[OP_PUSHMARK    ] = 0;	/* pushmark */ \
  opmask[OP_WANTARRAY   ] = 0;	/* wantarray */ \
  opmask[OP_CONST       ] = 0;	/* constant item */ \
  opmask[OP_GVSV        ] = 0;	/* scalar variable */ \
  opmask[OP_GV          ] = 0;	/* glob value */ \
  opmask[OP_GELEM       ] = 0;	/* glob elem */ \
  opmask[OP_PADSV       ] = 0;	/* private variable */ \
  opmask[OP_PADAV       ] = 0;	/* private array */ \
  opmask[OP_PADHV       ] = 0;	/* private hash */ \
  opmask[OP_PADANY      ] = 0;	/* private value */ \
  opmask[OP_RV2GV       ] = 0;	/* ref-to-glob cast */ \
  opmask[OP_RV2SV       ] = 0;	/* scalar dereference */ \
  opmask[OP_AV2ARYLEN   ] = 0;	/* array length */ \
  opmask[OP_RV2CV       ] = 0;	/* subroutine dereference */ \
  opmask[OP_ANONCODE    ] = 0;	/* anonymous subroutine */ \
  opmask[OP_PROTOTYPE   ] = 0;	/* subroutine prototype */ \
  opmask[OP_REFGEN      ] = 0;	/* reference constructor */ \
  opmask[OP_SREFGEN     ] = 0;	/* single ref constructor */ \
  opmask[OP_REF         ] = 0;	/* reference-type operator */ \
  opmask[OP_BLESS       ] = 0;	/* bless */ \
  opmask[OP_REGCMAYBE   ] = 0;	/* regexp internal guard */ \
  opmask[OP_REGCRESET   ] = 0;	/* regexp internal reset */ \
  opmask[OP_REGCOMP     ] = 0;	/* regexp compilation */ \
  opmask[OP_MATCH       ] = 0;	/* pattern match (m//) */ \
  opmask[OP_QR          ] = 0;	/* pattern quote (qr//) */ \
  opmask[OP_SUBST       ] = 0;	/* substitution (s///) */ \
  opmask[OP_SUBSTCONT   ] = 0;	/* substitution iterator */ \
  opmask[OP_TRANS       ] = 0;	/* transliteration (tr///) */ \
  opmask[OP_TRANSR      ] = 0;	/* transliteration (tr///) */ \
  opmask[OP_SASSIGN     ] = 0;	/* scalar assignment */ \
  opmask[OP_AASSIGN     ] = 0;	/* list assignment */ \
  opmask[OP_CHOP        ] = 0;	/* chop */ \
  opmask[OP_SCHOP       ] = 0;	/* scalar chop */ \
  opmask[OP_CHOMP       ] = 0;	/* chomp */ \
  opmask[OP_SCHOMP      ] = 0;	/* scalar chomp */ \
  opmask[OP_DEFINED     ] = 0;	/* defined operator */ \
  opmask[OP_UNDEF       ] = 0;	/* undef operator */ \
  opmask[OP_STUDY       ] = 0;	/* study */ \
  opmask[OP_POS         ] = 0;	/* match position */ \
  opmask[OP_PREINC      ] = 0;	/* preincrement (++) */ \
  opmask[OP_I_PREINC    ] = 0;	/* integer preincrement (++) */ \
  opmask[OP_PREDEC      ] = 0;	/* predecrement (--) */ \
  opmask[OP_I_PREDEC    ] = 0;	/* integer predecrement (--) */ \
  opmask[OP_POSTINC     ] = 0;	/* postincrement (++) */ \
  opmask[OP_I_POSTINC   ] = 0;	/* integer postincrement (++) */ \
  opmask[OP_POSTDEC     ] = 0;	/* postdecrement (--) */ \
  opmask[OP_I_POSTDEC   ] = 0;	/* integer postdecrement (--) */ \
  opmask[OP_POW         ] = 0;	/* exponentiation (**) */ \
  opmask[OP_MULTIPLY    ] = 0;	/* multiplication (*) */ \
  opmask[OP_I_MULTIPLY  ] = 0;	/* integer multiplication (*) */ \
  opmask[OP_DIVIDE      ] = 0;	/* division (/) */ \
  opmask[OP_I_DIVIDE    ] = 0;	/* integer division (/) */ \
  opmask[OP_MODULO      ] = 0;	/* modulus (%) */ \
  opmask[OP_I_MODULO    ] = 0;	/* integer modulus (%) */ \
  opmask[OP_REPEAT      ] = 0;	/* repeat (x) */ \
  opmask[OP_ADD         ] = 0;	/* addition (+) */ \
  opmask[OP_I_ADD       ] = 0;	/* integer addition (+) */ \
  opmask[OP_SUBTRACT    ] = 0;	/* subtraction (-) */ \
  opmask[OP_I_SUBTRACT  ] = 0;	/* integer subtraction (-) */ \
  opmask[OP_CONCAT      ] = 0;	/* concatenation (.) or string */ \
  opmask[OP_STRINGIFY   ] = 0;	/* string */ \
  opmask[OP_LEFT_SHIFT  ] = 0;	/* left bitshift (<<) */ \
  opmask[OP_RIGHT_SHIFT ] = 0;	/* right bitshift (>>) */ \
  opmask[OP_LT          ] = 0;	/* numeric lt (<) */ \
  opmask[OP_I_LT        ] = 0;	/* integer lt (<) */ \
  opmask[OP_GT          ] = 0;	/* numeric gt (>) */ \
  opmask[OP_I_GT        ] = 0;	/* integer gt (>) */ \
  opmask[OP_LE          ] = 0;	/* numeric le (<=) */ \
  opmask[OP_I_LE        ] = 0;	/* integer le (<=) */ \
  opmask[OP_GE          ] = 0;	/* numeric ge (>=) */ \
  opmask[OP_I_GE        ] = 0;	/* integer ge (>=) */ \
  opmask[OP_EQ          ] = 0;	/* numeric eq (==) */ \
  opmask[OP_I_EQ        ] = 0;	/* integer eq (==) */ \
  opmask[OP_NE          ] = 0;	/* numeric ne (!=) */ \
  opmask[OP_I_NE        ] = 0;	/* integer ne (!=) */ \
  opmask[OP_NCMP        ] = 0;	/* numeric comparison (<=>) */ \
  opmask[OP_I_NCMP      ] = 0;	/* integer comparison (<=>) */ \
  opmask[OP_SLT         ] = 0;	/* string lt */ \
  opmask[OP_SGT         ] = 0;	/* string gt */ \
  opmask[OP_SLE         ] = 0;	/* string le */ \
  opmask[OP_SGE         ] = 0;	/* string ge */ \
  opmask[OP_SEQ         ] = 0;	/* string eq */ \
  opmask[OP_SNE         ] = 0;	/* string ne */ \
  opmask[OP_SCMP        ] = 0;	/* string comparison (cmp) */ \
  opmask[OP_BIT_AND     ] = 0;	/* bitwise and (&) */ \
  opmask[OP_BIT_XOR     ] = 0;	/* bitwise xor (^) */ \
  opmask[OP_BIT_OR      ] = 0;	/* bitwise or (|) */ \
  opmask[OP_NBIT_AND    ] = 0;	/* numeric bitwise and (&) */ \
  opmask[OP_NBIT_XOR    ] = 0;	/* numeric bitwise xor (^) */ \
  opmask[OP_NBIT_OR     ] = 0;	/* numeric bitwise or (|) */ \
  opmask[OP_SBIT_AND    ] = 0;	/* string bitwise and (&.) */ \
  opmask[OP_SBIT_XOR    ] = 0;	/* string bitwise xor (^.) */ \
  opmask[OP_SBIT_OR     ] = 0;	/* string bitwise or (|.) */ \
  opmask[OP_NEGATE      ] = 0;	/* negation (-) */ \
  opmask[OP_I_NEGATE    ] = 0;	/* integer negation (-) */ \
  opmask[OP_NOT         ] = 0;	/* not */ \
  opmask[OP_COMPLEMENT  ] = 0;	/* 1's complement (~) */ \
  opmask[OP_NCOMPLEMENT ] = 0;	/* numeric 1's complement (~) */ \
  opmask[OP_SCOMPLEMENT ] = 0;	/* string 1's complement (~) */ \
  opmask[OP_SMARTMATCH  ] = 0;	/* smart match */ \
  opmask[OP_ATAN2       ] = 0;	/* atan2 */ \
  opmask[OP_SIN         ] = 0;	/* sin */ \
  opmask[OP_COS         ] = 0;	/* cos */ \
  opmask[OP_RAND        ] = 0;	/* rand */ \
  opmask[OP_SRAND       ] = 0;	/* srand */ \
  opmask[OP_EXP         ] = 0;	/* exp */ \
  opmask[OP_LOG         ] = 0;	/* log */ \
  opmask[OP_SQRT        ] = 0;	/* sqrt */ \
  opmask[OP_INT         ] = 0;	/* int */ \
  opmask[OP_HEX         ] = 0;	/* hex */ \
  opmask[OP_OCT         ] = 0;	/* oct */ \
  opmask[OP_ABS         ] = 0;	/* abs */ \
  opmask[OP_LENGTH      ] = 0;	/* length */ \
  opmask[OP_SUBSTR      ] = 0;	/* substr */ \
  opmask[OP_VEC         ] = 0;	/* vec */ \
  opmask[OP_INDEX       ] = 0;	/* index */ \
  opmask[OP_RINDEX      ] = 0;	/* rindex */ \
  opmask[OP_SPRINTF     ] = 0;	/* sprintf */ \
  opmask[OP_ORD         ] = 0;	/* ord */ \
  opmask[OP_CHR         ] = 0;	/* chr */ \
  opmask[OP_CRYPT       ] = 0;	/* crypt */ \
  opmask[OP_UCFIRST     ] = 0;	/* ucfirst */ \
  opmask[OP_LCFIRST     ] = 0;	/* lcfirst */ \
  opmask[OP_UC          ] = 0;	/* uc */ \
  opmask[OP_LC          ] = 0;	/* lc */ \
  opmask[OP_QUOTEMETA   ] = 0;	/* quotemeta */ \
  opmask[OP_RV2AV       ] = 0;	/* array dereference */ \
  opmask[OP_AELEMFAST   ] = 0;	/* constant array element */ \
  opmask[OP_AELEMFAST_LEX] = 0;	/* constant lexical array element */ \
  opmask[OP_AELEM       ] = 0;	/* array element */ \
  opmask[OP_ASLICE      ] = 0;	/* array slice */ \
  opmask[OP_KVASLICE    ] = 0;	/* index/value array slice */ \
  opmask[OP_AEACH       ] = 0;	/* each on array */ \
  opmask[OP_AVALUES     ] = 0;	/* values on array */ \
  opmask[OP_AKEYS       ] = 0;	/* keys on array */ \
  opmask[OP_EACH        ] = 0;	/* each */ \
  opmask[OP_VALUES      ] = 0;	/* values */ \
  opmask[OP_KEYS        ] = 0;	/* keys */ \
  opmask[OP_DELETE      ] = 0;	/* delete */ \
  opmask[OP_EXISTS      ] = 0;	/* exists */ \
  opmask[OP_RV2HV       ] = 0;	/* hash dereference */ \
  opmask[OP_HELEM       ] = 0;	/* hash element */ \
  opmask[OP_HSLICE      ] = 0;	/* hash slice */ \
  opmask[OP_KVHSLICE    ] = 0;	/* key/value hash slice */ \
  opmask[OP_MULTIDEREF  ] = 0;	/* array or hash lookup */ \
  opmask[OP_SPLIT       ] = 0;	/* split */ \
  opmask[OP_JOIN        ] = 0;	/* join or string */ \
  opmask[OP_LIST        ] = 0;	/* list */ \
  opmask[OP_LSLICE      ] = 0;	/* list slice */ \
  opmask[OP_ANONLIST    ] = 0;	/* anonymous array ([]) */ \
  opmask[OP_ANONHASH    ] = 0;	/* anonymous hash ({}) */ \
  opmask[OP_SPLICE      ] = 0;	/* splice */ \
  opmask[OP_PUSH        ] = 0;	/* push */ \
  opmask[OP_POP         ] = 0;	/* pop */ \
  opmask[OP_SHIFT       ] = 0;	/* shift */ \
  opmask[OP_UNSHIFT     ] = 0;	/* unshift */ \
  opmask[OP_SORT        ] = 0;	/* sort */ \
  opmask[OP_REVERSE     ] = 0;	/* reverse */ \
  opmask[OP_GREPSTART   ] = 0;	/* grep */ \
  opmask[OP_GREPWHILE   ] = 0;	/* grep iterator */ \
  opmask[OP_MAPSTART    ] = 0;	/* map */ \
  opmask[OP_MAPWHILE    ] = 0;	/* map iterator */ \
  opmask[OP_RANGE       ] = 0;	/* flipflop */ \
  opmask[OP_FLIP        ] = 0;	/* range (or flip) */ \
  opmask[OP_FLOP        ] = 0;	/* range (or flop) */ \
  opmask[OP_AND         ] = 0;	/* logical and (&&) */ \
  opmask[OP_OR          ] = 0;	/* logical or (||) */ \
  opmask[OP_XOR         ] = 0;	/* logical xor */ \
  opmask[OP_DOR         ] = 0;	/* defined or (//) */ \
  opmask[OP_COND_EXPR   ] = 0;	/* conditional expression */ \
  opmask[OP_ANDASSIGN   ] = 0;	/* logical and assignment (&&=) */ \
  opmask[OP_ORASSIGN    ] = 0;	/* logical or assignment (||=) */ \
  opmask[OP_DORASSIGN   ] = 0;	/* defined or assignment (//=) */ \
  opmask[OP_METHOD      ] = 0;	/* method lookup */ \
  opmask[OP_ENTERSUB    ] = 0;	/* subroutine entry */ \
  opmask[OP_LEAVESUB    ] = 0;	/* subroutine exit */ \
  opmask[OP_LEAVESUBLV  ] = 0;	/* lvalue subroutine return */ \
  opmask[OP_ARGCHECK    ] = 0;	/* check subroutine arguments */ \
  opmask[OP_ARGELEM     ] = 0;	/* subroutine argument */ \
  opmask[OP_ARGDEFELEM  ] = 0;	/* subroutine argument default value */ \
  opmask[OP_CALLER      ] = 0;	/* caller */ \
  opmask[OP_WARN        ] = 0;	/* warn */ \
  opmask[OP_DIE         ] = 0;	/* die */ \
  opmask[OP_LINESEQ     ] = 0;	/* line sequence */ \
  opmask[OP_NEXTSTATE   ] = 0;	/* next statement */ \
  opmask[OP_UNSTACK     ] = 0;	/* iteration finalizer */ \
  opmask[OP_ENTER       ] = 0;	/* block entry */ \
  opmask[OP_LEAVE       ] = 0;	/* block exit */ \
  opmask[OP_SCOPE       ] = 0;	/* block */ \
  opmask[OP_ENTERITER   ] = 0;	/* foreach loop entry */ \
  opmask[OP_ITER        ] = 0;	/* foreach loop iterator */ \
  opmask[OP_ENTERLOOP   ] = 0;	/* loop entry */ \
  opmask[OP_LEAVELOOP   ] = 0;	/* loop exit */ \
  opmask[OP_RETURN      ] = 0;	/* return */ \
  opmask[OP_LAST        ] = 0;	/* last */ \
  opmask[OP_NEXT        ] = 0;	/* next */ \
  opmask[OP_REDO        ] = 0;	/* redo */ \
  opmask[OP_GOTO        ] = 0;	/* goto */ \
  opmask[OP_METHOD_NAMED] = 0;	/* method with known name */ \
  opmask[OP_METHOD_SUPER] = 0;	/* super with known name */ \
  opmask[OP_METHOD_REDIR] = 0;	/* redirect method with known name */ \
  opmask[OP_METHOD_REDIR_SUPER] = 0;	/* redirect super method with known name */ \
  opmask[OP_ENTERGIVEN  ] = 0;	/* given() */ \
  opmask[OP_LEAVEGIVEN  ] = 0;	/* leave given block */ \
  opmask[OP_ENTERWHEN   ] = 0;	/* when() */ \
  opmask[OP_LEAVEWHEN   ] = 0;	/* leave when block */ \
  opmask[OP_BREAK       ] = 0;	/* break */ \
  opmask[OP_CONTINUE    ] = 0;	/* continue */ \
  opmask[OP_PIPE_OP     ] = 0;	/* pipe */ \
  opmask[OP_TIE         ] = 0;	/* tie */ \
  opmask[OP_UNTIE       ] = 0;	/* untie */ \
  opmask[OP_DBMCLOSE    ] = 0;	/* dbmclose */ \
  opmask[OP_SSELECT     ] = 0;	/* select system call */ \
  opmask[OP_SELECT      ] = 0;	/* select */ \
  opmask[OP_PRTF        ] = 0;	/* printf */ \
  opmask[OP_PRINT       ] = 0;	/* print */ \
  opmask[OP_SOCKPAIR    ] = 0;	/* socketpair */ \
  opmask[OP_GETPPID     ] = 0;	/* getppid */ \
  opmask[OP_GETPGRP     ] = 0;	/* getpgrp */ \
  opmask[OP_GETPRIORITY ] = 0;	/* getpriority */ \
  opmask[OP_TIME        ] = 0;	/* time */ \
  opmask[OP_LOCALTIME   ] = 0;	/* localtime */ \
  opmask[OP_GMTIME      ] = 0;	/* gmtime */ \
  opmask[OP_REQUIRE     ] = 0;	/* require */ \
  opmask[OP_DOFILE      ] = 0;	/* do "file" */ \
  opmask[OP_ENTEREVAL   ] = 0;	/* eval "string" */ \
  opmask[OP_LEAVEEVAL   ] = 0;	/* eval "string" exit */ \
  opmask[OP_ENTERTRY    ] = 0;	/* eval {block} */ \
  opmask[OP_LEAVETRY    ] = 0;	/* eval {block} exit */ \
  opmask[OP_LOCK        ] = 0;	/* lock */ \
  opmask[OP_ONCE        ] = 0;	/* once */ \
  opmask[OP_COREARGS    ] = 0;	/* CORE:: subroutine */ \
  opmask[OP_AVHVSWITCH  ] = 0;	/* Array/hash switch */ \
  opmask[OP_FC          ] = 0;	/* fc */ \
  opmask[OP_PADCV       ] = 0;	/* private subroutine */ \
  opmask[OP_INTROCV     ] = 0;	/* private subroutine */ \
  opmask[OP_CLONECV     ] = 0;	/* private subroutine */ \
  opmask[OP_PADRANGE    ] = 0;	/* list of private variables */ \
  opmask[OP_REFASSIGN   ] = 0;	/* lvalue ref assignment */ \
  opmask[OP_LVREF       ] = 0;	/* lvalue ref assignment */ \
  opmask[OP_LVREFSLICE  ] = 0;	/* lvalue ref assignment */ \
  opmask[OP_LVAVREF     ] = 0;	/* lvalue array reference */ \
  opmask[OP_ANONCONST   ] = 0;	/* anonymous constant */ \
  /* end */ 
