#line 2 "repl_scanner.c"

#line 4 "repl_scanner.c"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */




#define yy_scan_string replication_yy_scan_string





#define yypush_buffer_state replication_yypush_buffer_state





#define yylex replication_yylex









#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define replication_yy_create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer replication_yy_create_buffer
#endif

#ifdef yy_delete_buffer
#define replication_yy_delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer replication_yy_delete_buffer
#endif

#ifdef yy_scan_buffer
#define replication_yy_scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer replication_yy_scan_buffer
#endif

#ifdef yy_scan_string
#define replication_yy_scan_string_ALREADY_DEFINED
#else
#define yy_scan_string replication_yy_scan_string
#endif

#ifdef yy_scan_bytes
#define replication_yy_scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes replication_yy_scan_bytes
#endif

#ifdef yy_init_buffer
#define replication_yy_init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer replication_yy_init_buffer
#endif

#ifdef yy_flush_buffer
#define replication_yy_flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer replication_yy_flush_buffer
#endif

#ifdef yy_load_buffer_state
#define replication_yy_load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state replication_yy_load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define replication_yy_switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer replication_yy_switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define replication_yypush_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state replication_yypush_buffer_state
#endif

#ifdef yypop_buffer_state
#define replication_yypop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state replication_yypop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define replication_yyensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack replication_yyensure_buffer_stack
#endif

#ifdef yylex
#define replication_yylex_ALREADY_DEFINED
#else
#define yylex replication_yylex
#endif

#ifdef yyrestart
#define replication_yyrestart_ALREADY_DEFINED
#else
#define yyrestart replication_yyrestart
#endif

#ifdef yylex_init
#define replication_yylex_init_ALREADY_DEFINED
#else
#define yylex_init replication_yylex_init
#endif

#ifdef yylex_init_extra
#define replication_yylex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra replication_yylex_init_extra
#endif

#ifdef yylex_destroy
#define replication_yylex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy replication_yylex_destroy
#endif

#ifdef yyget_debug
#define replication_yyget_debug_ALREADY_DEFINED
#else
#define yyget_debug replication_yyget_debug
#endif

#ifdef yyset_debug
#define replication_yyset_debug_ALREADY_DEFINED
#else
#define yyset_debug replication_yyset_debug
#endif

#ifdef yyget_extra
#define replication_yyget_extra_ALREADY_DEFINED
#else
#define yyget_extra replication_yyget_extra
#endif

#ifdef yyset_extra
#define replication_yyset_extra_ALREADY_DEFINED
#else
#define yyset_extra replication_yyset_extra
#endif

#ifdef yyget_in
#define replication_yyget_in_ALREADY_DEFINED
#else
#define yyget_in replication_yyget_in
#endif

#ifdef yyset_in
#define replication_yyset_in_ALREADY_DEFINED
#else
#define yyset_in replication_yyset_in
#endif

#ifdef yyget_out
#define replication_yyget_out_ALREADY_DEFINED
#else
#define yyget_out replication_yyget_out
#endif

#ifdef yyset_out
#define replication_yyset_out_ALREADY_DEFINED
#else
#define yyset_out replication_yyset_out
#endif

#ifdef yyget_leng
#define replication_yyget_leng_ALREADY_DEFINED
#else
#define yyget_leng replication_yyget_leng
#endif

#ifdef yyget_text
#define replication_yyget_text_ALREADY_DEFINED
#else
#define yyget_text replication_yyget_text
#endif

#ifdef yyget_lineno
#define replication_yyget_lineno_ALREADY_DEFINED
#else
#define yyget_lineno replication_yyget_lineno
#endif

#ifdef yyset_lineno
#define replication_yyset_lineno_ALREADY_DEFINED
#else
#define yyset_lineno replication_yyset_lineno
#endif

#ifdef yywrap
#define replication_yywrap_ALREADY_DEFINED
#else
#define yywrap replication_yywrap
#endif

#ifdef yyalloc
#define replication_yyalloc_ALREADY_DEFINED
#else
#define yyalloc replication_yyalloc
#endif

#ifdef yyrealloc
#define replication_yyrealloc_ALREADY_DEFINED
#else
#define yyrealloc replication_yyrealloc
#endif

#ifdef yyfree
#define replication_yyfree_ALREADY_DEFINED
#else
#define yyfree replication_yyfree
#endif

#ifdef yytext
#define replication_yytext_ALREADY_DEFINED
#else
#define yytext replication_yytext
#endif

#ifdef yyleng
#define replication_yyleng_ALREADY_DEFINED
#else
#define yyleng replication_yyleng
#endif

#ifdef yyin
#define replication_yyin_ALREADY_DEFINED
#else
#define yyin replication_yyin
#endif

#ifdef yyout
#define replication_yyout_ALREADY_DEFINED
#else
#define yyout replication_yyout
#endif

#ifdef yy_flex_debug
#define replication_yy_flex_debug_ALREADY_DEFINED
#else
#define yy_flex_debug replication_yy_flex_debug
#endif

#ifdef yylineno
#define replication_yylineno_ALREADY_DEFINED
#else
#define yylineno replication_yylineno
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */


/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */


/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */

/* Special action meaning "start processing a new file". */



/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else

#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the
 * main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;





#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                              \









#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {
  FILE *yy_input_file;

  char *yy_ch_buf;  /* input buffer */
  char *yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;



  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */

};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE *yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER                                                      \

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void
yyrestart(FILE *input_file);
void
yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE
yy_create_buffer(FILE *file, int size);
void
yy_delete_buffer(YY_BUFFER_STATE b);
void
yy_flush_buffer(YY_BUFFER_STATE b);
void
yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void
yypop_buffer_state(void);

static void
yyensure_buffer_stack(void);
static void
yy_load_buffer_state(void);
static void
yy_init_buffer(YY_BUFFER_STATE b, FILE *file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE
yy_scan_buffer(char *base, yy_size_t size);
YY_BUFFER_STATE
yy_scan_string(const char *yy_str);
YY_BUFFER_STATE
yy_scan_bytes(const char *bytes, int len);

void *yyalloc(yy_size_t);
void *
yyrealloc(void *, yy_size_t);
void
yyfree(void *);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                     \
  {                                                                            \
    if (!YY_CURRENT_BUFFER) {                                                  \
      yyensure_buffer_stack();                                                 \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);          \
    }                                                                          \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;              \
  }
#define yy_set_bol(at_bol)                                                     \
  {                                                                            \
    if (!YY_CURRENT_BUFFER) {                                                  \
      yyensure_buffer_stack();                                                 \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);          \
    }                                                                          \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                              \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */


#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif


static yy_state_type
yy_get_previous_state(void);
static yy_state_type
yy_try_NUL_trans(yy_state_type current_state);
static int
yy_get_next_buffer(void);
static void yynoreturn
yy_fatal_error(const char *msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                    \





#define YY_NUM_RULES 38

/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info {
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static const flex_int16_t yy_accept[279] = {
    0,  0,  0,  0,  0,  0,  0,  39, 37, 26, 26, 33, 29, 27, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 35, 34, 32,
    30, 26, 0,  27, 0,  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 35, 32, 31, 28, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 36, 9,  36, 36, 36, 36, 2,  36, 36, 36, 36, 36, 36,

    36, 36, 36, 36, 4,  20, 36, 36, 36, 36, 36, 25, 36, 36, 36, 36, 36,
    5,  36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 6,  36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 19, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 8,  36, 36, 17, 7,  36, 36, 36, 36, 12, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 21, 36, 36, 36, 36, 36, 36, 36,

    36, 36, 36, 36, 36, 36, 36, 1,  36, 36, 36, 36, 36, 36, 18, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 24, 36, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 10, 36, 36, 36, 22, 3,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 16, 36, 36, 23, 36, 13, 36, 36,
    11, 36, 36, 36, 36, 36, 15, 36, 14, 0};

static const YY_CHAR yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  2,  2,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  4,  1,  5,  1,
    1,  6,  1,  1,  1,  1,  1,  1,  1,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,
    8,  1,  1,  1,  1,  1,  1,  1,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 18, 25, 26, 27, 28, 29, 30, 31, 32, 18, 1,  1,  1,  1,
    33, 1,  34, 34, 34, 34,

    34, 34, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 1,  1,  1,  1,  1,  18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18,

    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18};

static const YY_CHAR yy_meta[35] = {0, 1, 1, 1, 2, 3, 4, 5, 6, 6, 6, 6,
                                    6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6};

static const flex_int16_t yy_base[286] = {
    0,   0,   0,   574, 573, 570, 569, 574, 579, 33,  35,  579, 579, 32,  34,
    62,  40,  41,  46,  564, 565, 44,  55,  45,  56,  73,  46,  74,  75,  60,
    51,  0,   579, 0,   565, 97,  0,   95,  563, 562, 559, 78,  78,  86,  88,
    88,  98,  100, 101, 99,  106, 108, 110, 111, 115, 116, 117, 118, 113, 120,
    135, 136, 0,   0,   579, 0,   137, 122, 125, 138, 139, 140, 144, 147, 50,
    145, 152, 151, 148, 156, 160, 161, 162, 163, 165, 168, 170, 171, 172, 560,
    173, 174, 175, 177, 559, 180, 183, 186, 187, 189, 191,

    188, 193, 202, 204, 558, 557, 207, 208, 210, 211, 212, 556, 213, 215, 217,
    218, 219, 555, 223, 228, 232, 233, 234, 236, 239, 237, 241, 242, 244, 246,
    249, 250, 247, 251, 253, 258, 255, 260, 263, 269, 554, 270, 266, 271, 274,
    278, 282, 275, 286, 283, 289, 291, 293, 294, 553, 296, 297, 298, 300, 299,
    301, 303, 304, 310, 305, 314, 320, 315, 316, 322, 324, 550, 325, 326, 542,
    538, 330, 338, 335, 333, 334, 340, 336, 344, 346, 341, 345, 347, 363, 368,
    349, 342, 521, 365, 369, 354, 372, 373, 375, 376,

    379, 380, 382, 381, 383, 386, 384, 520, 387, 388, 393, 398, 402, 399, 519,
    403, 406, 408, 410, 411, 413, 414, 416, 418, 421, 422, 426, 419, 518, 429,
    432, 434, 437, 438, 440, 441, 445, 444, 446, 447, 448, 451, 449, 453, 454,
    517, 455, 459, 456, 516, 515, 467, 470, 474, 475, 476, 477, 478, 479, 480,
    514, 481, 482, 512, 485, 511, 484, 486, 509, 487, 489, 494, 488, 497, 179,
    502, 114, 579, 529, 535, 537, 541, 547, 553, 55};

static const flex_int16_t yy_def[286] = {
    0,   278, 1,   279, 279, 280, 280, 278, 278, 278, 278, 278, 278, 281, 282,
    282, 15,  15,  15,  15,  282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 283, 278, 284, 278, 278, 285, 281, 281, 282, 15,  15,  282, 282, 282,
    15,  282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 283, 284, 278, 285, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,

    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282,

    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
    282, 282, 0,   278, 278, 278, 278, 278, 278, 278};

static const flex_int16_t yy_nxt[614] = {
    0,   8,   9,   10,  11,  8,   12,  8,   13,  14,  15,  16,  17,  18,  19,
    20,  20,  21,  20,  20,  22,  23,  24,  20,  25,  26,  27,  28,  29,  20,
    30,  20,  20,  20,  14,  35,  35,  35,  35,  36,  37,  36,  40,  40,  40,
    40,  40,  40,  40,  40,  40,  278, 278, 278, 49,  40,  46,  278, 278, 53,
    61,  65,  278, 278, 47,  42,  43,  278, 40,  36,  40,  41,  40,  40,  40,
    40,  40,  44,  48,  50,  278, 278, 278, 98,  57,  278, 60,  40,  58,  51,
    54,  67,  59,  278, 55,  278, 40,  40,  52,  35,  35,

    56,  36,  37,  66,  278, 278, 278, 278, 68,  72,  71,  69,  278, 70,  278,
    73,  278, 278, 75,  278, 278, 278, 278, 278, 278, 83,  278, 84,  278, 74,
    91,  278, 79,  85,  76,  77,  80,  81,  82,  78,  86,  278, 278, 278, 278,
    278, 278, 87,  92,  90,  278, 278, 88,  278, 278, 89,  96,  278, 278, 101,
    93,  95,  278, 97,  100, 94,  278, 278, 278, 278, 103, 278, 104, 102, 278,
    99,  278, 278, 278, 278, 278, 278, 110, 278, 108, 278, 278, 107, 106, 278,
    105, 109, 278, 278, 278, 278, 119, 278, 112, 278,

    114, 116, 118, 111, 123, 113, 117, 115, 278, 124, 278, 120, 121, 278, 278,
    122, 278, 278, 278, 278, 128, 278, 132, 278, 278, 278, 125, 133, 126, 278,
    130, 137, 129, 127, 278, 136, 138, 131, 278, 278, 278, 134, 278, 278, 135,
    278, 142, 278, 278, 140, 278, 143, 278, 278, 139, 278, 278, 278, 150, 278,
    141, 278, 148, 152, 278, 144, 278, 146, 147, 278, 149, 154, 278, 145, 155,
    278, 278, 278, 159, 151, 278, 278, 158, 161, 278, 153, 156, 157, 278, 278,
    164, 160, 278, 167, 166, 278, 165, 278, 162, 278,

    278, 163, 278, 278, 278, 278, 278, 278, 172, 278, 278, 278, 179, 168, 169,
    178, 278, 181, 170, 175, 278, 278, 278, 173, 176, 171, 278, 184, 278, 174,
    278, 278, 278, 177, 180, 185, 278, 182, 183, 278, 278, 278, 278, 186, 278,
    192, 278, 278, 278, 199, 278, 278, 278, 278, 205, 278, 187, 188, 189, 190,
    278, 191, 198, 196, 193, 195, 194, 197, 204, 278, 200, 278, 201, 202, 278,
    278, 203, 208, 278, 278, 206, 278, 278, 210, 207, 278, 278, 278, 278, 278,
    278, 209, 278, 278, 278, 214, 221, 216, 211, 278,

    213, 215, 218, 220, 278, 278, 219, 212, 278, 278, 224, 225, 278, 226, 278,
    217, 278, 278, 222, 278, 278, 230, 278, 223, 278, 278, 227, 278, 278, 232,
    236, 235, 278, 228, 237, 278, 229, 239, 278, 231, 278, 234, 233, 278, 278,
    238, 278, 278, 240, 242, 278, 278, 278, 278, 278, 278, 241, 278, 244, 278,
    278, 278, 278, 243, 252, 278, 247, 245, 246, 249, 254, 251, 248, 278, 250,
    256, 278, 257, 253, 255, 278, 278, 278, 278, 278, 278, 278, 278, 278, 258,
    278, 278, 278, 278, 278, 278, 260, 259, 262, 265,

    278, 266, 267, 278, 264, 271, 261, 268, 278, 263, 269, 273, 272, 274, 275,
    278, 270, 278, 278, 276, 278, 278, 278, 278, 278, 278, 278, 278, 277, 31,
    31,  31,  31,  31,  31,  33,  33,  33,  33,  33,  33,  38,  38,  39,  278,
    39,  39,  62,  278, 62,  62,  62,  62,  63,  63,  63,  278, 63,  63,  278,
    278, 278, 278, 278, 278, 278, 278, 40,  278, 36,  64,  278, 45,  278, 34,
    34,  32,  32,  7,   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
    278, 278, 278, 278, 278, 278, 278, 278, 278, 278,

    278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278};

static const flex_int16_t yy_chk[614] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   9,   9,   10,  10,  13,  13,  14,  14,  14,  14,
    14,  14,  14,  14,  16,  17,  21,  23,  26,  23,  18,  21,  74,  30,  26,
    30,  285, 22,  24,  22,  16,  17,  29,  14,  15,  15,  15,  15,  15,  15,
    15,  15,  18,  22,  24,  25,  27,  28,  74,  28,  42,  29,  41,  28,  25,
    27,  42,  28,  43,  27,  44,  15,  45,  25,  35,  35,

    27,  37,  37,  41,  46,  49,  47,  48,  43,  47,  46,  44,  50,  45,  51,
    48,  52,  53,  50,  58,  277, 54,  55,  56,  57,  56,  59,  57,  67,  49,
    67,  68,  52,  58,  50,  50,  53,  54,  55,  51,  59,  60,  61,  66,  69,
    70,  71,  60,  68,  66,  72,  75,  61,  73,  78,  61,  72,  77,  76,  77,
    69,  71,  79,  73,  76,  70,  80,  81,  82,  83,  79,  84,  80,  78,  85,
    75,  86,  87,  88,  90,  91,  92,  86,  93,  84,  275, 95,  83,  82,  96,
    81,  85,  97,  98,  101, 99,  97,  100, 88,  102,

    91,  93,  96,  87,  101, 90,  95,  92,  103, 102, 104, 98,  99,  107, 108,
    100, 109, 110, 111, 113, 108, 114, 113, 115, 116, 117, 103, 114, 104, 119,
    110, 119, 109, 107, 120, 117, 120, 111, 121, 122, 123, 115, 124, 126, 116,
    125, 124, 127, 128, 122, 129, 125, 130, 133, 121, 131, 132, 134, 132, 135,
    123, 137, 130, 134, 136, 126, 138, 128, 129, 139, 131, 136, 143, 127, 137,
    140, 142, 144, 142, 133, 145, 148, 140, 144, 146, 135, 138, 139, 147, 150,
    147, 143, 149, 150, 149, 151, 148, 152, 145, 153,

    154, 146, 156, 157, 158, 160, 159, 161, 156, 162, 163, 165, 163, 151, 152,
    162, 164, 165, 153, 159, 166, 168, 169, 157, 160, 154, 167, 168, 170, 158,
    171, 173, 174, 161, 164, 169, 177, 166, 167, 180, 181, 179, 183, 170, 178,
    179, 182, 186, 192, 186, 184, 187, 185, 188, 192, 191, 171, 173, 174, 177,
    196, 178, 185, 183, 180, 182, 181, 184, 191, 189, 187, 194, 188, 189, 190,
    195, 190, 196, 197, 198, 194, 199, 200, 198, 195, 201, 202, 204, 203, 205,
    207, 197, 206, 209, 210, 202, 210, 204, 199, 211,

    201, 203, 206, 209, 212, 214, 207, 200, 213, 216, 213, 214, 217, 216, 218,
    205, 219, 220, 211, 221, 222, 220, 223, 212, 224, 228, 217, 225, 226, 222,
    226, 225, 227, 218, 227, 230, 219, 230, 231, 221, 232, 224, 223, 233, 234,
    228, 235, 236, 231, 233, 238, 237, 239, 240, 241, 243, 232, 242, 235, 244,
    245, 247, 249, 234, 243, 248, 238, 236, 237, 240, 245, 242, 239, 252, 241,
    248, 253, 249, 244, 247, 254, 255, 256, 257, 258, 259, 260, 262, 263, 252,
    267, 265, 268, 270, 273, 271, 254, 253, 256, 259,

    272, 260, 262, 274, 258, 268, 255, 263, 276, 257, 265, 271, 270, 272, 273,
    269, 267, 266, 264, 274, 261, 251, 250, 246, 229, 215, 208, 193, 276, 279,
    279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 281, 281, 282, 176,
    282, 282, 283, 175, 283, 283, 283, 283, 284, 284, 284, 172, 284, 284, 155,
    141, 118, 112, 106, 105, 94,  89,  40,  39,  38,  34,  20,  19,  7,   6,
    5,   4,   3,   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
    278, 278, 278, 278, 278, 278, 278, 278, 278, 278,

    278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected

#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "repl_scanner.l"
#line 2 "repl_scanner.l"
/*-------------------------------------------------------------------------
 *
 * repl_scanner.l
 *	  a lexical scanner for the replication commands
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/replication/repl_scanner.l
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "utils/builtins.h"
#include "parser/scansup.h"

/* Avoid exit() on fatal scanner errors (a bit ugly -- see yy_fatal_error) */
#undef fprintf


static void
fprintf_to_ereport(const char *fmt, const char *msg)
{

}

/* Handle to the buffer that the lexer uses internally */
static YY_BUFFER_STATE scanbufhandle;

/* Pushed-back token (we only handle one) */
static int repl_pushed_back_token;

/* Work area for collecting literals */
static StringInfoData litbuf;

static void
startlit(void);
static char *
litbufdup(void);
static void
addlit(char *ytext, int yleng);
static void
addlitchar(unsigned char ychar);

/* LCOV_EXCL_START */

#line 976 "repl_scanner.c"
#define YY_NO_INPUT 1
/*
 * Exclusive states:
 *  <xd> delimited identifiers (double-quoted identifiers)
 *  <xq> standard single-quoted strings
 */

/* Extended quote
 * xqdouble implements embedded quote, ''''
 */
/* Double quote
 * Allows embedded spaces and other special characters into identifiers.
 */
#line 990 "repl_scanner.c"





#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int
yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int
yylex_destroy(void);

int
yyget_debug(void);

void
yyset_debug(int debug_flag);

YY_EXTRA_TYPE
yyget_extra(void);

void
yyset_extra(YY_EXTRA_TYPE user_defined);

FILE *
yyget_in(void);

void
yyset_in(FILE *_in_str);

FILE *
yyget_out(void);

void
yyset_out(FILE *_out_str);

int
yyget_leng(void);

char *
yyget_text(void);

int
yyget_lineno(void);

void
yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int
yywrap(void);
#else
extern int
yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

#endif

#ifndef yytext_ptr
static void
yy_flex_strncpy(char *, const char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int
yy_flex_strlen(const char *);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int
yyinput(void);
#else
static int
input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else

#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                   \
  do {                                                                         \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout)) {                            \
    }                                                                          \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                        \























#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate

#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR

#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int
yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK

#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL








#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif






























































































































































































































































































































































































































































































































/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int
yy_get_next_buffer(void)
{





























































































































}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type
yy_get_previous_state(void)
{





















}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type
yy_try_NUL_trans(yy_state_type yy_current_state)
{


















}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int
yyinput(void)
#else
static int
input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]) {
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';
    }

    else { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer()) {
      case EOB_ACT_LAST_MATCH:
        /* This happens because yy_g_n_b()
         * sees that we've accumulated a
         * token and flags that we need to
         * try matching the token before
         * proceeding.  But for input(),
         * there's no matching to consider.
         * So convert the EOB_ACT_LAST_MATCH
         * to EOB_ACT_END_OF_FILE.
         */

        /* Reset buffer status. */
        yyrestart(yyin);

        /*FALLTHROUGH*/

      case EOB_ACT_END_OF_FILE: {
        if (yywrap()) {
          return 0;
        }

        if (!(yy_did_buffer_switch_on_eof)) {
          YY_NEW_FILE;
        }
#ifdef __cplusplus
        return yyinput();
#else
        return input();
#endif
      }

      case EOB_ACT_CONTINUE_SCAN:
        (yy_c_buf_p) = (yytext_ptr) + offset;
        break;
      }
    }
  }

  c = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';               /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void
yyrestart(FILE *input_file)











/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void
yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)






























static void
yy_load_buffer_state(void)







/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c
 * YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE
yy_create_buffer(FILE *file, int size)

























/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void
yy_delete_buffer(YY_BUFFER_STATE b)

















/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void
yy_init_buffer(YY_BUFFER_STATE b, FILE *file)























/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void
yy_flush_buffer(YY_BUFFER_STATE b)
























/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void
yypush_buffer_state(YY_BUFFER_STATE new_buffer)


























/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void
yypop_buffer_state(void)

















/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void
yyensure_buffer_stack(void)











































/** Setup the input buffer state to scan directly from a user-specified
 * character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE
yy_scan_buffer(char *base, yy_size_t size)





























/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE
yy_scan_string(const char *yystr)





/** Setup the input buffer state to scan the given bytes. The next call to
 * yylex() will scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE
yy_scan_bytes(const char *yybytes, int _yybytes_len)
































#ifndef YY_EXIT_FAILURE

#endif

static void yynoreturn
yy_fatal_error(const char *msg)
{


}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                              \
  do {                                                                         \
    /* Undo effects of setting up yytext. */                                   \
    int yyless_macro_arg = (n);                                                \
    YY_LESS_LINENO(yyless_macro_arg);                                          \
    yytext[yyleng] = (yy_hold_char);                                           \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                  \
    (yy_hold_char) = *(yy_c_buf_p);                                            \
    *(yy_c_buf_p) = '\0';                                                      \
    yyleng = yyless_macro_arg;                                                 \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int
yyget_lineno(void)




/** Get the input stream.
 *
 */
FILE *
yyget_in(void)




/** Get the output stream.
 *
 */
FILE *
yyget_out(void)




/** Get the length of the current token.
 *
 */
int
yyget_leng(void)




/** Get the current token.
 *
 */

char *
yyget_text(void)




/** Set the current line number.
 * @param _line_number line number
 *
 */
void
yyset_lineno(int _line_number)




/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void
yyset_in(FILE *_in_str)




void
yyset_out(FILE *_out_str)




int
yyget_debug(void)




void
yyset_debug(int _bdebug)




static int
yy_init_globals(void)
{
























}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int
yylex_destroy(void)




















/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void
yy_flex_strncpy(char *s1, const char *s2, int n)
{

  int i;
  for (i = 0; i < n; ++i) {
    s1[i] = s2[i];
  }
}
#endif

#ifdef YY_NEED_STRLEN
static int
yy_flex_strlen(const char *s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *
yyalloc(yy_size_t size)




void *
yyrealloc(void *ptr, yy_size_t size)












void
yyfree(void *ptr)




#define YYTABLES_NAME "yytables"

#line 211 "repl_scanner.l"

/* LCOV_EXCL_STOP */

static void
startlit(void)
{

}

static char *
litbufdup(void)
{

}

static void
addlit(char *ytext, int yleng)
{

}

static void
addlitchar(unsigned char ychar)
{

}

void
yyerror(const char *message)
{


}

void
replication_scanner_init(const char *str)
{





















}

void
replication_scanner_finish(void)
{


}

/*
 * Check to see if the first token of a command is a WalSender keyword.
 *
 * To keep repl_scanner.l minimal, we don't ask it to know every construct
 * that the core lexer knows.  Therefore, we daren't lex more than the
 * first token of a general SQL command.  That will usually look like an
 * IDENT token here, although some other cases are possible.
 */
bool
replication_scanner_is_replication_command(void)
{

















}
